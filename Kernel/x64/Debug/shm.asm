; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.21005.1 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?shm_list@@3PEAU_list_@@EA			; shm_list
PUBLIC	?shm_id@@3GA					; shm_id
PUBLIC	?shmlock@@3PEAU_spinlock_@@EA			; shmlock
_BSS	SEGMENT
?shm_list@@3PEAU_list_@@EA DQ 01H DUP (?)		; shm_list
?shm_id@@3GA DW	01H DUP (?)				; shm_id
	ALIGN	8

?shmlock@@3PEAU_spinlock_@@EA DQ 01H DUP (?)		; shmlock
_BSS	ENDS
PUBLIC	?AuInitialiseSHMMan@@YAXXZ			; AuInitialiseSHMMan
PUBLIC	?AuGetSHMByID@@YAPEAU_shm_@@G@Z			; AuGetSHMByID
PUBLIC	?AuCreateSHM@@YAHPEAU_au_proc_@@G_KE@Z		; AuCreateSHM
PUBLIC	?AuSHMObtainMem@@YAPEAXPEAU_au_proc_@@GPEAXH@Z	; AuSHMObtainMem
PUBLIC	?AuSHMUnmap@@YAXGPEAU_au_proc_@@@Z		; AuSHMUnmap
PUBLIC	?AuSHMUnmapAll@@YAXPEAU_au_proc_@@@Z		; AuSHMUnmapAll
PUBLIC	?AuSHMGetID@@YAGXZ				; AuSHMGetID
PUBLIC	?AuGetSHMSeg@@YAPEAU_shm_@@G@Z			; AuGetSHMSeg
PUBLIC	?AuSHMDelete@@YAXPEAU_shm_@@@Z			; AuSHMDelete
PUBLIC	?AuSHMProcBreak@@YA_KPEAU_au_proc_@@_K@Z	; AuSHMProcBreak
EXTRN	initialize_list:PROC
EXTRN	list_add:PROC
EXTRN	list_remove:PROC
EXTRN	list_get_at:PROC
EXTRN	AuCreateSpinlock:PROC
EXTRN	AuAcquireSpinlock:PROC
EXTRN	AuReleaseSpinlock:PROC
EXTRN	kmalloc:PROC
EXTRN	kfree:PROC
EXTRN	AuPmmngrAlloc:PROC
EXTRN	AuPmmngrFree:PROC
EXTRN	AuVmmngrGetPage:PROC
EXTRN	AuMapPage:PROC
EXTRN	flush_tlb:PROC
EXTRN	memset:PROC
pdata	SEGMENT
$pdata$?AuInitialiseSHMMan@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+47
	DD	imagerel $unwind$?AuInitialiseSHMMan@@YAXXZ
$pdata$?AuGetSHMByID@@YAPEAU_shm_@@G@Z DD imagerel $LN7
	DD	imagerel $LN7+99
	DD	imagerel $unwind$?AuGetSHMByID@@YAPEAU_shm_@@G@Z
$pdata$?AuCreateSHM@@YAHPEAU_au_proc_@@G_KE@Z DD imagerel $LN10
	DD	imagerel $LN10+375
	DD	imagerel $unwind$?AuCreateSHM@@YAHPEAU_au_proc_@@G_KE@Z
$pdata$?AuSHMObtainMem@@YAPEAXPEAU_au_proc_@@GPEAXH@Z DD imagerel $LN22
	DD	imagerel $LN22+1033
	DD	imagerel $unwind$?AuSHMObtainMem@@YAPEAXPEAU_au_proc_@@GPEAXH@Z
$pdata$?AuSHMUnmap@@YAXGPEAU_au_proc_@@@Z DD imagerel $LN12
	DD	imagerel $LN12+443
	DD	imagerel $unwind$?AuSHMUnmap@@YAXGPEAU_au_proc_@@@Z
$pdata$?AuSHMUnmapAll@@YAXPEAU_au_proc_@@@Z DD imagerel $LN9
	DD	imagerel $LN9+329
	DD	imagerel $unwind$?AuSHMUnmapAll@@YAXPEAU_au_proc_@@@Z
$pdata$?AuSHMGetID@@YAGXZ DD imagerel $LN3
	DD	imagerel $LN3+40
	DD	imagerel $unwind$?AuSHMGetID@@YAGXZ
$pdata$?AuGetSHMSeg@@YAPEAU_shm_@@G@Z DD imagerel $LN7
	DD	imagerel $LN7+98
	DD	imagerel $unwind$?AuGetSHMSeg@@YAPEAU_shm_@@G@Z
$pdata$?AuSHMDelete@@YAXPEAU_shm_@@@Z DD imagerel $LN13
	DD	imagerel $LN13+259
	DD	imagerel $unwind$?AuSHMDelete@@YAXPEAU_shm_@@@Z
$pdata$?AuSHMProcBreak@@YA_KPEAU_au_proc_@@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+72
	DD	imagerel $unwind$?AuSHMProcBreak@@YA_KPEAU_au_proc_@@_K@Z
pdata	ENDS
xdata	SEGMENT
$unwind$?AuInitialiseSHMMan@@YAXXZ DD 010401H
	DD	04204H
$unwind$?AuGetSHMByID@@YAPEAU_shm_@@G@Z DD 010901H
	DD	06209H
$unwind$?AuCreateSHM@@YAHPEAU_au_proc_@@G_KE@Z DD 011801H
	DD	06218H
$unwind$?AuSHMObtainMem@@YAPEAXPEAU_au_proc_@@GPEAXH@Z DD 021b01H
	DD	013011bH
$unwind$?AuSHMUnmap@@YAXGPEAU_au_proc_@@@Z DD 010e01H
	DD	0c20eH
$unwind$?AuSHMUnmapAll@@YAXPEAU_au_proc_@@@Z DD 010901H
	DD	08209H
$unwind$?AuSHMGetID@@YAGXZ DD 010401H
	DD	02204H
$unwind$?AuGetSHMSeg@@YAPEAU_shm_@@G@Z DD 010901H
	DD	06209H
$unwind$?AuSHMDelete@@YAXPEAU_shm_@@@Z DD 010901H
	DD	08209H
$unwind$?AuSHMProcBreak@@YA_KPEAU_au_proc_@@_K@Z DD 010e01H
	DD	0220eH
xdata	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\mm\shm.cpp
_TEXT	SEGMENT
start_addr$ = 0
proc$ = 32
num_frames$ = 40
?AuSHMProcBreak@@YA_KPEAU_au_proc_@@_K@Z PROC		; AuSHMProcBreak

; 163  : size_t AuSHMProcBreak(AuProcess* proc, size_t num_frames) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 164  : 	size_t start_addr = proc->shm_break;

	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+1079]
	mov	QWORD PTR start_addr$[rsp], rax

; 165  : 	proc->shm_break = (proc->shm_break + num_frames * PAGE_SIZE);

	imul	rax, QWORD PTR num_frames$[rsp], 4096	; 00001000H
	mov	rcx, QWORD PTR proc$[rsp]
	add	rax, QWORD PTR [rcx+1079]
	mov	rcx, QWORD PTR proc$[rsp]
	mov	QWORD PTR [rcx+1079], rax

; 166  : 	return start_addr;

	mov	rax, QWORD PTR start_addr$[rsp]

; 167  : }

	add	rsp, 24
	ret	0
?AuSHMProcBreak@@YA_KPEAU_au_proc_@@_K@Z ENDP		; AuSHMProcBreak
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\mm\shm.cpp
_TEXT	SEGMENT
j$1 = 32
i$2 = 36
phys$3 = 40
shm_$4 = 48
shm$ = 80
?AuSHMDelete@@YAXPEAU_shm_@@@Z PROC			; AuSHMDelete

; 136  : void AuSHMDelete(AuSHM* shm) {

$LN13:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 137  : 	if (!shm)

	cmp	QWORD PTR shm$[rsp], 0
	jne	SHORT $LN10@AuSHMDelet

; 138  : 		return;

	jmp	$LN11@AuSHMDelet
$LN10@AuSHMDelet:

; 139  : 	if (shm->link_count > 1)

	mov	rax, QWORD PTR shm$[rsp]
	movzx	eax, WORD PTR [rax+16]
	cmp	eax, 1
	jle	SHORT $LN9@AuSHMDelet

; 140  : 		shm->link_count--;

	mov	rax, QWORD PTR shm$[rsp]
	movzx	eax, WORD PTR [rax+16]
	dec	ax
	mov	rcx, QWORD PTR shm$[rsp]
	mov	WORD PTR [rcx+16], ax
$LN9@AuSHMDelet:

; 141  : 
; 142  : 	if (shm->link_count == 1){

	mov	rax, QWORD PTR shm$[rsp]
	movzx	eax, WORD PTR [rax+16]
	cmp	eax, 1
	jne	$LN8@AuSHMDelet

; 143  : 		for (int i = 0; i < shm->num_frames; i++) {

	mov	DWORD PTR i$2[rsp], 0
	jmp	SHORT $LN7@AuSHMDelet
$LN6@AuSHMDelet:
	mov	eax, DWORD PTR i$2[rsp]
	inc	eax
	mov	DWORD PTR i$2[rsp], eax
$LN7@AuSHMDelet:
	mov	rax, QWORD PTR shm$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cmp	DWORD PTR i$2[rsp], eax
	jae	SHORT $LN5@AuSHMDelet

; 144  : 			size_t phys = shm->frames[i];

	movsxd	rax, DWORD PTR i$2[rsp]
	mov	rcx, QWORD PTR shm$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR phys$3[rsp], rax

; 145  : 			AuPmmngrFree((void*)phys);

	mov	rcx, QWORD PTR phys$3[rsp]
	call	AuPmmngrFree

; 146  : 		}

	jmp	SHORT $LN6@AuSHMDelet
$LN5@AuSHMDelet:

; 147  : 		
; 148  : 		for (int j = 0; j <= shm_list->pointer; j++) {

	mov	DWORD PTR j$1[rsp], 0
	jmp	SHORT $LN4@AuSHMDelet
$LN3@AuSHMDelet:
	mov	eax, DWORD PTR j$1[rsp]
	inc	eax
	mov	DWORD PTR j$1[rsp], eax
$LN4@AuSHMDelet:
	mov	rax, QWORD PTR ?shm_list@@3PEAU_list_@@EA ; shm_list
	mov	eax, DWORD PTR [rax]
	cmp	DWORD PTR j$1[rsp], eax
	ja	SHORT $LN2@AuSHMDelet

; 149  : 			AuSHM *shm_ = (AuSHM*)list_get_at(shm_list, j);

	mov	edx, DWORD PTR j$1[rsp]
	mov	rcx, QWORD PTR ?shm_list@@3PEAU_list_@@EA ; shm_list
	call	list_get_at
	mov	QWORD PTR shm_$4[rsp], rax

; 150  : 			if (shm_ == shm)

	mov	rax, QWORD PTR shm$[rsp]
	cmp	QWORD PTR shm_$4[rsp], rax
	jne	SHORT $LN1@AuSHMDelet

; 151  : 				list_remove(shm_list, j);

	mov	edx, DWORD PTR j$1[rsp]
	mov	rcx, QWORD PTR ?shm_list@@3PEAU_list_@@EA ; shm_list
	call	list_remove
$LN1@AuSHMDelet:

; 152  : 		}

	jmp	SHORT $LN3@AuSHMDelet
$LN2@AuSHMDelet:

; 153  : 		kfree(shm->frames);

	mov	rax, QWORD PTR shm$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	kfree

; 154  : 		kfree(shm);

	mov	rcx, QWORD PTR shm$[rsp]
	call	kfree
$LN8@AuSHMDelet:
$LN11@AuSHMDelet:

; 155  : 	}
; 156  : }

	add	rsp, 72					; 00000048H
	ret	0
?AuSHMDelete@@YAXPEAU_shm_@@@Z ENDP			; AuSHMDelete
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\mm\shm.cpp
_TEXT	SEGMENT
i$1 = 32
shm$2 = 40
key$ = 64
?AuGetSHMSeg@@YAPEAU_shm_@@G@Z PROC			; AuGetSHMSeg

; 70   : AuSHM * AuGetSHMSeg(uint16_t key) {

$LN7:
	mov	WORD PTR [rsp+8], cx
	sub	rsp, 56					; 00000038H

; 71   : 	for (int i = 0; i < shm_list->pointer; i++) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN4@AuGetSHMSe
$LN3@AuGetSHMSe:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN4@AuGetSHMSe:
	mov	rax, QWORD PTR ?shm_list@@3PEAU_list_@@EA ; shm_list
	mov	eax, DWORD PTR [rax]
	cmp	DWORD PTR i$1[rsp], eax
	jae	SHORT $LN2@AuGetSHMSe

; 72   : 		AuSHM* shm = (AuSHM*)list_get_at(shm_list, i);

	mov	edx, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR ?shm_list@@3PEAU_list_@@EA ; shm_list
	call	list_get_at
	mov	QWORD PTR shm$2[rsp], rax

; 73   : 		if (shm->key == key)

	mov	rax, QWORD PTR shm$2[rsp]
	movzx	eax, WORD PTR [rax]
	movzx	ecx, WORD PTR key$[rsp]
	cmp	eax, ecx
	jne	SHORT $LN1@AuGetSHMSe

; 74   : 			return shm;

	mov	rax, QWORD PTR shm$2[rsp]
	jmp	SHORT $LN5@AuGetSHMSe
$LN1@AuGetSHMSe:

; 75   : 	}

	jmp	SHORT $LN3@AuGetSHMSe
$LN2@AuGetSHMSe:

; 76   : 
; 77   : 	return NULL;

	xor	eax, eax
$LN5@AuGetSHMSe:

; 78   : }

	add	rsp, 56					; 00000038H
	ret	0
?AuGetSHMSeg@@YAPEAU_shm_@@G@Z ENDP			; AuGetSHMSeg
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\mm\shm.cpp
_TEXT	SEGMENT
_id$ = 0
?AuSHMGetID@@YAGXZ PROC					; AuSHMGetID

; 59   : uint16_t AuSHMGetID() {

$LN3:
	sub	rsp, 24

; 60   : 	uint16_t _id = shm_id;

	movzx	eax, WORD PTR ?shm_id@@3GA		; shm_id
	mov	WORD PTR _id$[rsp], ax

; 61   : 	shm_id = shm_id + 1;

	movzx	eax, WORD PTR ?shm_id@@3GA		; shm_id
	inc	eax
	mov	WORD PTR ?shm_id@@3GA, ax		; shm_id

; 62   : 	return  _id;

	movzx	eax, WORD PTR _id$[rsp]

; 63   : }

	add	rsp, 24
	ret	0
?AuSHMGetID@@YAGXZ ENDP					; AuSHMGetID
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\mm\shm.cpp
_TEXT	SEGMENT
i$1 = 32
j$2 = 36
mapping$3 = 40
vpage$4 = 48
tv74 = 56
proc$ = 80
?AuSHMUnmapAll@@YAXPEAU_au_proc_@@@Z PROC		; AuSHMUnmapAll

; 302  : void AuSHMUnmapAll(AuProcess* proc) {

$LN9:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 303  : 	AuAcquireSpinlock(shmlock);

	mov	rcx, QWORD PTR ?shmlock@@3PEAU_spinlock_@@EA ; shmlock
	call	AuAcquireSpinlock

; 304  : 	for (int i = 0; i < proc->shmmaps->pointer; i++) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN6@AuSHMUnmap
$LN5@AuSHMUnmap:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN6@AuSHMUnmap:
	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+1071]
	mov	eax, DWORD PTR [rax]
	cmp	DWORD PTR i$1[rsp], eax
	jae	$LN4@AuSHMUnmap

; 305  : 		AuSHMMappings* mapping = (AuSHMMappings*)list_remove(proc->shmmaps, i);

	mov	edx, DWORD PTR i$1[rsp]
	mov	rax, QWORD PTR proc$[rsp]
	mov	rcx, QWORD PTR [rax+1071]
	call	list_remove
	mov	QWORD PTR mapping$3[rsp], rax

; 306  : 		for (int j = 0; j < mapping->length / PAGE_SIZE; j++) {

	mov	DWORD PTR j$2[rsp], 0
	jmp	SHORT $LN3@AuSHMUnmap
$LN2@AuSHMUnmap:
	mov	eax, DWORD PTR j$2[rsp]
	inc	eax
	mov	DWORD PTR j$2[rsp], eax
$LN3@AuSHMUnmap:
	movsxd	rax, DWORD PTR j$2[rsp]
	mov	QWORD PTR tv74[rsp], rax
	xor	edx, edx
	mov	rcx, QWORD PTR mapping$3[rsp]
	mov	rax, QWORD PTR [rcx+8]
	mov	ecx, 4096				; 00001000H
	div	rcx
	mov	rcx, QWORD PTR tv74[rsp]
	cmp	rcx, rax
	jae	SHORT $LN1@AuSHMUnmap

; 307  : 			AuVPage* vpage = AuVmmngrGetPage(mapping->start_addr + j * PAGE_SIZE, VIRT_GETPAGE_ONLY_RET, VIRT_GETPAGE_ONLY_RET);

	imul	eax, DWORD PTR j$2[rsp], 4096		; 00001000H
	cdqe
	mov	rcx, QWORD PTR mapping$3[rsp]
	add	rax, QWORD PTR [rcx]
	mov	r8b, 2
	mov	dl, 2
	mov	rcx, rax
	call	AuVmmngrGetPage
	mov	QWORD PTR vpage$4[rsp], rax

; 308  : 			vpage->bits.page = 0;

	mov	rax, QWORD PTR vpage$4[rsp]
	mov	rcx, -1099511623681			; ffffff0000000fffH
	mov	rax, QWORD PTR [rax]
	and	rax, rcx
	mov	rcx, QWORD PTR vpage$4[rsp]
	mov	QWORD PTR [rcx], rax

; 309  : 			vpage->bits.present = 0;

	mov	rax, QWORD PTR vpage$4[rsp]
	mov	rax, QWORD PTR [rax]
	and	rax, -2
	mov	rcx, QWORD PTR vpage$4[rsp]
	mov	QWORD PTR [rcx], rax

; 310  : 			flush_tlb((void*)(mapping->start_addr + i * PAGE_SIZE));

	imul	eax, DWORD PTR i$1[rsp], 4096		; 00001000H
	cdqe
	mov	rcx, QWORD PTR mapping$3[rsp]
	add	rax, QWORD PTR [rcx]
	mov	rcx, rax
	call	flush_tlb

; 311  : 		}

	jmp	$LN2@AuSHMUnmap
$LN1@AuSHMUnmap:

; 312  : 		AuSHMDelete(mapping->shm);

	mov	rax, QWORD PTR mapping$3[rsp]
	mov	rcx, QWORD PTR [rax+16]
	call	?AuSHMDelete@@YAXPEAU_shm_@@@Z		; AuSHMDelete

; 313  : 		kfree(mapping);

	mov	rcx, QWORD PTR mapping$3[rsp]
	call	kfree

; 314  : 	}

	jmp	$LN5@AuSHMUnmap
$LN4@AuSHMUnmap:

; 315  : 
; 316  : 	kfree(proc->shmmaps);

	mov	rax, QWORD PTR proc$[rsp]
	mov	rcx, QWORD PTR [rax+1071]
	call	kfree

; 317  : 	AuReleaseSpinlock(shmlock);

	mov	rcx, QWORD PTR ?shmlock@@3PEAU_spinlock_@@EA ; shmlock
	call	AuReleaseSpinlock

; 318  : }

	add	rsp, 72					; 00000048H
	ret	0
?AuSHMUnmapAll@@YAXPEAU_au_proc_@@@Z ENDP		; AuSHMUnmapAll
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\mm\shm.cpp
_TEXT	SEGMENT
i$1 = 32
i$2 = 36
index$ = 40
mapping$ = 48
vpage$3 = 56
shm$ = 64
maps$4 = 72
tv82 = 80
key$ = 112
proc$ = 120
?AuSHMUnmap@@YAXGPEAU_au_proc_@@@Z PROC			; AuSHMUnmap

; 258  : void AuSHMUnmap(uint16_t key, AuProcess* proc) {

$LN12:
	mov	QWORD PTR [rsp+16], rdx
	mov	WORD PTR [rsp+8], cx
	sub	rsp, 104				; 00000068H

; 259  : 	AuAcquireSpinlock(shmlock);

	mov	rcx, QWORD PTR ?shmlock@@3PEAU_spinlock_@@EA ; shmlock
	call	AuAcquireSpinlock

; 260  : 	AuSHM* shm = AuGetSHMSeg(key);

	movzx	ecx, WORD PTR key$[rsp]
	call	?AuGetSHMSeg@@YAPEAU_shm_@@G@Z		; AuGetSHMSeg
	mov	QWORD PTR shm$[rsp], rax

; 261  : 
; 262  : 	if (!shm) {

	cmp	QWORD PTR shm$[rsp], 0
	jne	SHORT $LN9@AuSHMUnmap

; 263  : 		AuReleaseSpinlock(shmlock);

	mov	rcx, QWORD PTR ?shmlock@@3PEAU_spinlock_@@EA ; shmlock
	call	AuReleaseSpinlock

; 264  : 		return;

	jmp	$LN10@AuSHMUnmap
$LN9@AuSHMUnmap:

; 265  : 	}
; 266  : 	
; 267  : 	AuSHMMappings* mapping = NULL;

	mov	QWORD PTR mapping$[rsp], 0

; 268  : 	int index = 0;

	mov	DWORD PTR index$[rsp], 0

; 269  : 	for (int i = 0; i < proc->shmmaps->pointer; i++) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN8@AuSHMUnmap
$LN7@AuSHMUnmap:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN8@AuSHMUnmap:
	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+1071]
	mov	eax, DWORD PTR [rax]
	cmp	DWORD PTR i$1[rsp], eax
	jae	SHORT $LN6@AuSHMUnmap

; 270  : 		AuSHMMappings* maps = (AuSHMMappings*)list_get_at(proc->shmmaps, i);

	mov	edx, DWORD PTR i$1[rsp]
	mov	rax, QWORD PTR proc$[rsp]
	mov	rcx, QWORD PTR [rax+1071]
	call	list_get_at
	mov	QWORD PTR maps$4[rsp], rax

; 271  : 		if (maps->shm == shm){

	mov	rax, QWORD PTR maps$4[rsp]
	mov	rcx, QWORD PTR shm$[rsp]
	cmp	QWORD PTR [rax+16], rcx
	jne	SHORT $LN5@AuSHMUnmap

; 272  : 			index = i;

	mov	eax, DWORD PTR i$1[rsp]
	mov	DWORD PTR index$[rsp], eax

; 273  : 			mapping = maps;

	mov	rax, QWORD PTR maps$4[rsp]
	mov	QWORD PTR mapping$[rsp], rax
$LN5@AuSHMUnmap:

; 274  : 		}
; 275  : 	}

	jmp	SHORT $LN7@AuSHMUnmap
$LN6@AuSHMUnmap:

; 276  : 
; 277  : 	if (!mapping) {

	cmp	QWORD PTR mapping$[rsp], 0
	jne	SHORT $LN4@AuSHMUnmap

; 278  : 		AuReleaseSpinlock(shmlock);

	mov	rcx, QWORD PTR ?shmlock@@3PEAU_spinlock_@@EA ; shmlock
	call	AuReleaseSpinlock

; 279  : 		return;

	jmp	$LN10@AuSHMUnmap
$LN4@AuSHMUnmap:

; 280  : 	}
; 281  : 
; 282  : 	for (int i = 0; i < mapping->length / PAGE_SIZE; i++) {

	mov	DWORD PTR i$2[rsp], 0
	jmp	SHORT $LN3@AuSHMUnmap
$LN2@AuSHMUnmap:
	mov	eax, DWORD PTR i$2[rsp]
	inc	eax
	mov	DWORD PTR i$2[rsp], eax
$LN3@AuSHMUnmap:
	movsxd	rax, DWORD PTR i$2[rsp]
	mov	QWORD PTR tv82[rsp], rax
	xor	edx, edx
	mov	rcx, QWORD PTR mapping$[rsp]
	mov	rax, QWORD PTR [rcx+8]
	mov	ecx, 4096				; 00001000H
	div	rcx
	mov	rcx, QWORD PTR tv82[rsp]
	cmp	rcx, rax
	jae	SHORT $LN1@AuSHMUnmap

; 283  : 		AuVPage* vpage = AuVmmngrGetPage(mapping->start_addr + i * PAGE_SIZE, VIRT_GETPAGE_ONLY_RET, VIRT_GETPAGE_ONLY_RET);

	imul	eax, DWORD PTR i$2[rsp], 4096		; 00001000H
	cdqe
	mov	rcx, QWORD PTR mapping$[rsp]
	add	rax, QWORD PTR [rcx]
	mov	r8b, 2
	mov	dl, 2
	mov	rcx, rax
	call	AuVmmngrGetPage
	mov	QWORD PTR vpage$3[rsp], rax

; 284  : 		vpage->bits.page = 0;

	mov	rax, QWORD PTR vpage$3[rsp]
	mov	rcx, -1099511623681			; ffffff0000000fffH
	mov	rax, QWORD PTR [rax]
	and	rax, rcx
	mov	rcx, QWORD PTR vpage$3[rsp]
	mov	QWORD PTR [rcx], rax

; 285  : 		vpage->bits.present = 0;

	mov	rax, QWORD PTR vpage$3[rsp]
	mov	rax, QWORD PTR [rax]
	and	rax, -2
	mov	rcx, QWORD PTR vpage$3[rsp]
	mov	QWORD PTR [rcx], rax

; 286  : 		flush_tlb((void*)(mapping->start_addr + i * PAGE_SIZE));

	imul	eax, DWORD PTR i$2[rsp], 4096		; 00001000H
	cdqe
	mov	rcx, QWORD PTR mapping$[rsp]
	add	rax, QWORD PTR [rcx]
	mov	rcx, rax
	call	flush_tlb

; 287  : 	}

	jmp	$LN2@AuSHMUnmap
$LN1@AuSHMUnmap:

; 288  : 	
; 289  : 	list_remove(proc->shmmaps, index);

	mov	edx, DWORD PTR index$[rsp]
	mov	rax, QWORD PTR proc$[rsp]
	mov	rcx, QWORD PTR [rax+1071]
	call	list_remove

; 290  : 	kfree(mapping);

	mov	rcx, QWORD PTR mapping$[rsp]
	call	kfree

; 291  : 
; 292  : 	AuSHMDelete(shm);

	mov	rcx, QWORD PTR shm$[rsp]
	call	?AuSHMDelete@@YAXPEAU_shm_@@@Z		; AuSHMDelete

; 293  : 	AuReleaseSpinlock(shmlock);

	mov	rcx, QWORD PTR ?shmlock@@3PEAU_spinlock_@@EA ; shmlock
	call	AuReleaseSpinlock
$LN10@AuSHMUnmap:

; 294  : }

	add	rsp, 104				; 00000068H
	ret	0
?AuSHMUnmap@@YAXGPEAU_au_proc_@@@Z ENDP			; AuSHMUnmap
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\mm\shm.cpp
_TEXT	SEGMENT
have_mappings$ = 32
mem$ = 40
mappings$ = 48
j$1 = 56
j$2 = 60
i$3 = 64
i$4 = 68
last_addr$ = 72
maps$5 = 80
start_addr$6 = 88
current_virt$7 = 96
gap$8 = 104
gap$9 = 112
phys$10 = 120
phys$11 = 128
phys_addr$12 = 136
proc$ = 160
id$ = 168
shmaddr$ = 176
shmflg$ = 184
?AuSHMObtainMem@@YAPEAXPEAU_au_proc_@@GPEAXH@Z PROC	; AuSHMObtainMem

; 177  : void* AuSHMObtainMem(AuProcess* proc, uint16_t id, void* shmaddr, int shmflg) {

$LN22:
	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	WORD PTR [rsp+16], dx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 152				; 00000098H

; 178  : 	AuAcquireSpinlock(shmlock);

	mov	rcx, QWORD PTR ?shmlock@@3PEAU_spinlock_@@EA ; shmlock
	call	AuAcquireSpinlock

; 179  : 	AuSHM* mem = NULL;

	mov	QWORD PTR mem$[rsp], 0

; 180  : 
; 181  : 	/* search for shm memory segment */
; 182  : 	mem = AuGetSHMByID(id);

	movzx	ecx, WORD PTR id$[rsp]
	call	?AuGetSHMByID@@YAPEAU_shm_@@G@Z		; AuGetSHMByID
	mov	QWORD PTR mem$[rsp], rax

; 183  : 
; 184  : 	if (!mem)

	cmp	QWORD PTR mem$[rsp], 0
	jne	SHORT $LN19@AuSHMObtai

; 185  : 		return NULL;

	xor	eax, eax
	jmp	$LN20@AuSHMObtai
$LN19@AuSHMObtai:

; 186  : 
; 187  : 
; 188  : 	AuSHMMappings *mappings = (AuSHMMappings*)kmalloc(sizeof(AuSHMMappings));

	mov	ecx, 24
	call	kmalloc
	mov	QWORD PTR mappings$[rsp], rax

; 189  : 	memset(mappings, 0, sizeof(AuSHMMappings));

	mov	r8d, 24
	xor	edx, edx
	mov	rcx, QWORD PTR mappings$[rsp]
	call	memset

; 190  : 
; 191  : 	mem->link_count++;

	mov	rax, QWORD PTR mem$[rsp]
	movzx	eax, WORD PTR [rax+16]
	inc	ax
	mov	rcx, QWORD PTR mem$[rsp]
	mov	WORD PTR [rcx+16], ax

; 192  : 
; 193  : 	/* look for already available address space gap
; 194  : 	 * before increasing the process shm_break
; 195  : 	 */
; 196  : 	uint64_t last_addr = USER_SHARED_MEM_START;

	mov	eax, -2147483648			; 80000000H
	mov	QWORD PTR last_addr$[rsp], rax

; 197  : 	bool have_mappings = false;

	mov	BYTE PTR have_mappings$[rsp], 0

; 198  : 	for (int i = 0; i < proc->shmmaps->pointer; i++) {

	mov	DWORD PTR i$3[rsp], 0
	jmp	SHORT $LN18@AuSHMObtai
$LN17@AuSHMObtai:
	mov	eax, DWORD PTR i$3[rsp]
	inc	eax
	mov	DWORD PTR i$3[rsp], eax
$LN18@AuSHMObtai:
	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+1071]
	mov	eax, DWORD PTR [rax]
	cmp	DWORD PTR i$3[rsp], eax
	jae	$LN16@AuSHMObtai

; 199  : 		AuSHMMappings *maps = (AuSHMMappings*)list_get_at(proc->shmmaps, i);

	mov	edx, DWORD PTR i$3[rsp]
	mov	rax, QWORD PTR proc$[rsp]
	mov	rcx, QWORD PTR [rax+1071]
	call	list_get_at
	mov	QWORD PTR maps$5[rsp], rax

; 200  : 		if (!have_mappings)

	movzx	eax, BYTE PTR have_mappings$[rsp]
	test	eax, eax
	jne	SHORT $LN15@AuSHMObtai

; 201  : 			have_mappings = true;

	mov	BYTE PTR have_mappings$[rsp], 1
$LN15@AuSHMObtai:

; 202  : 		size_t gap = maps->start_addr - last_addr; 

	mov	rax, QWORD PTR maps$5[rsp]
	mov	rcx, QWORD PTR last_addr$[rsp]
	mov	rax, QWORD PTR [rax]
	sub	rax, rcx
	mov	QWORD PTR gap$8[rsp], rax

; 203  : 		if (gap >= mem->num_frames * PAGE_SIZE){

	mov	rax, QWORD PTR mem$[rsp]
	imul	eax, DWORD PTR [rax+4], 4096		; 00001000H
	mov	eax, eax
	cmp	QWORD PTR gap$8[rsp], rax
	jb	$LN14@AuSHMObtai

; 204  : 			for (int j = 0; j < mem->num_frames; j++) {

	mov	DWORD PTR j$2[rsp], 0
	jmp	SHORT $LN13@AuSHMObtai
$LN12@AuSHMObtai:
	mov	eax, DWORD PTR j$2[rsp]
	inc	eax
	mov	DWORD PTR j$2[rsp], eax
$LN13@AuSHMObtai:
	mov	rax, QWORD PTR mem$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cmp	DWORD PTR j$2[rsp], eax
	jae	SHORT $LN11@AuSHMObtai

; 205  : 				size_t phys = mem->frames[j];

	movsxd	rax, DWORD PTR j$2[rsp]
	mov	rcx, QWORD PTR mem$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR phys$11[rsp], rax

; 206  : 				AuMapPage(phys, last_addr + j * PAGE_SIZE, X86_64_PAGING_USER);

	imul	eax, DWORD PTR j$2[rsp], 4096		; 00001000H
	cdqe
	mov	rcx, QWORD PTR last_addr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	r8b, 4
	mov	rdx, rax
	mov	rcx, QWORD PTR phys$11[rsp]
	call	AuMapPage

; 207  : 			}

	jmp	SHORT $LN12@AuSHMObtai
$LN11@AuSHMObtai:

; 208  : 			mappings->start_addr = last_addr;

	mov	rax, QWORD PTR mappings$[rsp]
	mov	rcx, QWORD PTR last_addr$[rsp]
	mov	QWORD PTR [rax], rcx

; 209  : 			mappings->length = mem->num_frames * PAGE_SIZE;

	mov	rax, QWORD PTR mem$[rsp]
	imul	eax, DWORD PTR [rax+4], 4096		; 00001000H
	mov	eax, eax
	mov	rcx, QWORD PTR mappings$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 210  : 			mappings->shm = mem;

	mov	rax, QWORD PTR mappings$[rsp]
	mov	rcx, QWORD PTR mem$[rsp]
	mov	QWORD PTR [rax+16], rcx

; 211  : 			list_add(proc->shmmaps, mappings);

	mov	rdx, QWORD PTR mappings$[rsp]
	mov	rax, QWORD PTR proc$[rsp]
	mov	rcx, QWORD PTR [rax+1071]
	call	list_add

; 212  : 			AuReleaseSpinlock(shmlock);

	mov	rcx, QWORD PTR ?shmlock@@3PEAU_spinlock_@@EA ; shmlock
	call	AuReleaseSpinlock

; 213  : 			return (void*)mappings->start_addr;

	mov	rax, QWORD PTR mappings$[rsp]
	mov	rax, QWORD PTR [rax]
	jmp	$LN20@AuSHMObtai
$LN14@AuSHMObtai:

; 214  : 		}
; 215  : 		last_addr = maps->start_addr + maps->length;

	mov	rax, QWORD PTR maps$5[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR maps$5[rsp]
	add	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR last_addr$[rsp], rax

; 216  : 	}

	jmp	$LN17@AuSHMObtai
$LN16@AuSHMObtai:

; 217  : 
; 218  : 	if (!have_mappings) {

	movzx	eax, BYTE PTR have_mappings$[rsp]
	test	eax, eax
	jne	$LN10@AuSHMObtai

; 219  : 		size_t start_addr = USER_SHARED_MEM_START;

	mov	eax, -2147483648			; 80000000H
	mov	QWORD PTR start_addr$6[rsp], rax

; 220  : 		if (proc->shm_break > start_addr) {

	mov	rax, QWORD PTR proc$[rsp]
	mov	rcx, QWORD PTR start_addr$6[rsp]
	cmp	QWORD PTR [rax+1079], rcx
	jbe	$LN9@AuSHMObtai

; 221  : 			size_t gap = proc->shm_break - start_addr;

	mov	rax, QWORD PTR proc$[rsp]
	mov	rcx, QWORD PTR start_addr$6[rsp]
	mov	rax, QWORD PTR [rax+1079]
	sub	rax, rcx
	mov	QWORD PTR gap$9[rsp], rax

; 222  : 			if (gap >= mem->num_frames * PAGE_SIZE) {

	mov	rax, QWORD PTR mem$[rsp]
	imul	eax, DWORD PTR [rax+4], 4096		; 00001000H
	mov	eax, eax
	cmp	QWORD PTR gap$9[rsp], rax
	jb	$LN8@AuSHMObtai

; 223  : 				for (int j = 0; j < mem->num_frames; j++) {

	mov	DWORD PTR j$1[rsp], 0
	jmp	SHORT $LN7@AuSHMObtai
$LN6@AuSHMObtai:
	mov	eax, DWORD PTR j$1[rsp]
	inc	eax
	mov	DWORD PTR j$1[rsp], eax
$LN7@AuSHMObtai:
	mov	rax, QWORD PTR mem$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cmp	DWORD PTR j$1[rsp], eax
	jae	SHORT $LN5@AuSHMObtai

; 224  : 					size_t phys = mem->frames[j];

	movsxd	rax, DWORD PTR j$1[rsp]
	mov	rcx, QWORD PTR mem$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR phys$10[rsp], rax

; 225  : 					AuMapPage(phys, last_addr + j * PAGE_SIZE, X86_64_PAGING_USER);

	imul	eax, DWORD PTR j$1[rsp], 4096		; 00001000H
	cdqe
	mov	rcx, QWORD PTR last_addr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	r8b, 4
	mov	rdx, rax
	mov	rcx, QWORD PTR phys$10[rsp]
	call	AuMapPage

; 226  : 				}

	jmp	SHORT $LN6@AuSHMObtai
$LN5@AuSHMObtai:

; 227  : 				mappings->start_addr = last_addr;

	mov	rax, QWORD PTR mappings$[rsp]
	mov	rcx, QWORD PTR last_addr$[rsp]
	mov	QWORD PTR [rax], rcx

; 228  : 				mappings->length = mem->num_frames * PAGE_SIZE;

	mov	rax, QWORD PTR mem$[rsp]
	imul	eax, DWORD PTR [rax+4], 4096		; 00001000H
	mov	eax, eax
	mov	rcx, QWORD PTR mappings$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 229  : 				mappings->shm = mem;

	mov	rax, QWORD PTR mappings$[rsp]
	mov	rcx, QWORD PTR mem$[rsp]
	mov	QWORD PTR [rax+16], rcx

; 230  : 				list_add(proc->shmmaps, mappings);

	mov	rdx, QWORD PTR mappings$[rsp]
	mov	rax, QWORD PTR proc$[rsp]
	mov	rcx, QWORD PTR [rax+1071]
	call	list_add

; 231  : 				AuReleaseSpinlock(shmlock);

	mov	rcx, QWORD PTR ?shmlock@@3PEAU_spinlock_@@EA ; shmlock
	call	AuReleaseSpinlock

; 232  : 				return (void*)mappings->start_addr;

	mov	rax, QWORD PTR mappings$[rsp]
	mov	rax, QWORD PTR [rax]
	jmp	$LN20@AuSHMObtai
$LN8@AuSHMObtai:
$LN9@AuSHMObtai:
$LN10@AuSHMObtai:

; 233  : 			}
; 234  : 		}
; 235  : 	}
; 236  : 
; 237  : 	/* finally, we need to increase the shm break */
; 238  : 	for (int i = 0; i < mem->num_frames; i++) {

	mov	DWORD PTR i$4[rsp], 0
	jmp	SHORT $LN4@AuSHMObtai
$LN3@AuSHMObtai:
	mov	eax, DWORD PTR i$4[rsp]
	inc	eax
	mov	DWORD PTR i$4[rsp], eax
$LN4@AuSHMObtai:
	mov	rax, QWORD PTR mem$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cmp	DWORD PTR i$4[rsp], eax
	jae	SHORT $LN2@AuSHMObtai

; 239  : 		uint64_t phys_addr = mem->frames[i];

	movsxd	rax, DWORD PTR i$4[rsp]
	mov	rcx, QWORD PTR mem$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR phys_addr$12[rsp], rax

; 240  : 		uint64_t current_virt = AuSHMProcBreak(proc, 1);

	mov	edx, 1
	mov	rcx, QWORD PTR proc$[rsp]
	call	?AuSHMProcBreak@@YA_KPEAU_au_proc_@@_K@Z ; AuSHMProcBreak
	mov	QWORD PTR current_virt$7[rsp], rax

; 241  : 		AuMapPage((uint64_t)phys_addr, current_virt, X86_64_PAGING_USER);

	mov	r8b, 4
	mov	rdx, QWORD PTR current_virt$7[rsp]
	mov	rcx, QWORD PTR phys_addr$12[rsp]
	call	AuMapPage

; 242  : 		if (mappings->start_addr == 0)

	mov	rax, QWORD PTR mappings$[rsp]
	cmp	QWORD PTR [rax], 0
	jne	SHORT $LN1@AuSHMObtai

; 243  : 			mappings->start_addr = current_virt;

	mov	rax, QWORD PTR mappings$[rsp]
	mov	rcx, QWORD PTR current_virt$7[rsp]
	mov	QWORD PTR [rax], rcx
$LN1@AuSHMObtai:

; 244  : 	}

	jmp	SHORT $LN3@AuSHMObtai
$LN2@AuSHMObtai:

; 245  : 
; 246  : 	mappings->length = mem->num_frames * PAGE_SIZE;

	mov	rax, QWORD PTR mem$[rsp]
	imul	eax, DWORD PTR [rax+4], 4096		; 00001000H
	mov	eax, eax
	mov	rcx, QWORD PTR mappings$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 247  : 	mappings->shm = mem;

	mov	rax, QWORD PTR mappings$[rsp]
	mov	rcx, QWORD PTR mem$[rsp]
	mov	QWORD PTR [rax+16], rcx

; 248  : 	list_add(proc->shmmaps, mappings);

	mov	rdx, QWORD PTR mappings$[rsp]
	mov	rax, QWORD PTR proc$[rsp]
	mov	rcx, QWORD PTR [rax+1071]
	call	list_add

; 249  : 	AuReleaseSpinlock(shmlock);

	mov	rcx, QWORD PTR ?shmlock@@3PEAU_spinlock_@@EA ; shmlock
	call	AuReleaseSpinlock

; 250  : 	return (void*)mappings->start_addr;

	mov	rax, QWORD PTR mappings$[rsp]
	mov	rax, QWORD PTR [rax]
$LN20@AuSHMObtai:

; 251  : }

	add	rsp, 152				; 00000098H
	ret	0
?AuSHMObtainMem@@YAPEAXPEAU_au_proc_@@GPEAXH@Z ENDP	; AuSHMObtainMem
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\mm\shm.cpp
_TEXT	SEGMENT
i$1 = 32
tv80 = 36
shm$ = 40
proc$ = 64
key$ = 72
sz$ = 80
flags$ = 88
?AuCreateSHM@@YAHPEAU_au_proc_@@G_KE@Z PROC		; AuCreateSHM

; 102  : int AuCreateSHM(AuProcess* proc, uint16_t key, size_t sz, uint8_t flags) {

$LN10:
	mov	BYTE PTR [rsp+32], r9b
	mov	QWORD PTR [rsp+24], r8
	mov	WORD PTR [rsp+16], dx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 103  : 	AuSHM* shm = NULL;

	mov	QWORD PTR shm$[rsp], 0

; 104  : 	AuAcquireSpinlock(shmlock);

	mov	rcx, QWORD PTR ?shmlock@@3PEAU_spinlock_@@EA ; shmlock
	call	AuAcquireSpinlock

; 105  : 	/*  search if it's already created */
; 106  : 	shm = AuGetSHMSeg(key);

	movzx	ecx, WORD PTR key$[rsp]
	call	?AuGetSHMSeg@@YAPEAU_shm_@@G@Z		; AuGetSHMSeg
	mov	QWORD PTR shm$[rsp], rax

; 107  : 	/* create a new*/
; 108  : 	if (!shm) {

	cmp	QWORD PTR shm$[rsp], 0
	jne	$LN5@AuCreateSH

; 109  : 		shm = (AuSHM*)kmalloc(sizeof(AuSHM));

	mov	ecx, 18
	call	kmalloc
	mov	QWORD PTR shm$[rsp], rax

; 110  : 		memset(shm, 0, sizeof(AuSHM));

	mov	r8d, 18
	xor	edx, edx
	mov	rcx, QWORD PTR shm$[rsp]
	call	memset

; 111  : 		shm->id = AuSHMGetID();

	call	?AuSHMGetID@@YAGXZ			; AuSHMGetID
	mov	rcx, QWORD PTR shm$[rsp]
	mov	WORD PTR [rcx+2], ax

; 112  : 		shm->key = key;

	mov	rax, QWORD PTR shm$[rsp]
	movzx	ecx, WORD PTR key$[rsp]
	mov	WORD PTR [rax], cx

; 113  : 		shm->num_frames = (sz / 0x1000) + ((sz % 0x1000) ? 1 : 0);

	xor	edx, edx
	mov	rax, QWORD PTR sz$[rsp]
	mov	ecx, 4096				; 00001000H
	div	rcx
	mov	rax, rdx
	test	rax, rax
	je	SHORT $LN8@AuCreateSH
	mov	DWORD PTR tv80[rsp], 1
	jmp	SHORT $LN9@AuCreateSH
$LN8@AuCreateSH:
	mov	DWORD PTR tv80[rsp], 0
$LN9@AuCreateSH:
	xor	edx, edx
	mov	rax, QWORD PTR sz$[rsp]
	mov	ecx, 4096				; 00001000H
	div	rcx
	movsxd	rcx, DWORD PTR tv80[rsp]
	add	rax, rcx
	mov	rcx, QWORD PTR shm$[rsp]
	mov	DWORD PTR [rcx+4], eax

; 114  : 		shm->link_count = 1;

	mov	eax, 1
	mov	rcx, QWORD PTR shm$[rsp]
	mov	WORD PTR [rcx+16], ax

; 115  : 		shm->frames = (uint64_t*)kmalloc(sizeof(uint64_t)* shm->num_frames);

	mov	rax, QWORD PTR shm$[rsp]
	mov	eax, DWORD PTR [rax+4]
	shl	rax, 3
	mov	ecx, eax
	call	kmalloc
	mov	rcx, QWORD PTR shm$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 116  : 		for (int i = 0; i < shm->num_frames; i++)  {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN4@AuCreateSH
$LN3@AuCreateSH:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN4@AuCreateSH:
	mov	rax, QWORD PTR shm$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cmp	DWORD PTR i$1[rsp], eax
	jae	SHORT $LN2@AuCreateSH

; 117  : 			shm->frames[i] = (uint64_t)AuPmmngrAlloc();

	call	AuPmmngrAlloc
	movsxd	rcx, DWORD PTR i$1[rsp]
	mov	rdx, QWORD PTR shm$[rsp]
	mov	rdx, QWORD PTR [rdx+8]
	mov	QWORD PTR [rdx+rcx*8], rax

; 118  : 		}

	jmp	SHORT $LN3@AuCreateSH
$LN2@AuCreateSH:

; 119  : 
; 120  : 		list_add(shm_list, shm);

	mov	rdx, QWORD PTR shm$[rsp]
	mov	rcx, QWORD PTR ?shm_list@@3PEAU_list_@@EA ; shm_list
	call	list_add
$LN5@AuCreateSH:

; 121  : 	}
; 122  : 
; 123  : 	if (!shm) {

	cmp	QWORD PTR shm$[rsp], 0
	jne	SHORT $LN1@AuCreateSH

; 124  : 		AuReleaseSpinlock(shmlock);

	mov	rcx, QWORD PTR ?shmlock@@3PEAU_spinlock_@@EA ; shmlock
	call	AuReleaseSpinlock

; 125  : 		return -1;

	mov	eax, -1
	jmp	SHORT $LN6@AuCreateSH
$LN1@AuCreateSH:

; 126  : 	}
; 127  : 
; 128  : 	AuReleaseSpinlock(shmlock);

	mov	rcx, QWORD PTR ?shmlock@@3PEAU_spinlock_@@EA ; shmlock
	call	AuReleaseSpinlock

; 129  : 	return shm->id;

	mov	rax, QWORD PTR shm$[rsp]
	movzx	eax, WORD PTR [rax+2]
$LN6@AuCreateSH:

; 130  : }

	add	rsp, 56					; 00000038H
	ret	0
?AuCreateSHM@@YAHPEAU_au_proc_@@G_KE@Z ENDP		; AuCreateSHM
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\mm\shm.cpp
_TEXT	SEGMENT
i$1 = 32
shm$2 = 40
id$ = 64
?AuGetSHMByID@@YAPEAU_shm_@@G@Z PROC			; AuGetSHMByID

; 85   : AuSHM * AuGetSHMByID(uint16_t id) {

$LN7:
	mov	WORD PTR [rsp+8], cx
	sub	rsp, 56					; 00000038H

; 86   : 	for (int i = 0; i < shm_list->pointer; i++) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN4@AuGetSHMBy
$LN3@AuGetSHMBy:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN4@AuGetSHMBy:
	mov	rax, QWORD PTR ?shm_list@@3PEAU_list_@@EA ; shm_list
	mov	eax, DWORD PTR [rax]
	cmp	DWORD PTR i$1[rsp], eax
	jae	SHORT $LN2@AuGetSHMBy

; 87   : 		AuSHM* shm = (AuSHM*)list_get_at(shm_list, i);

	mov	edx, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR ?shm_list@@3PEAU_list_@@EA ; shm_list
	call	list_get_at
	mov	QWORD PTR shm$2[rsp], rax

; 88   : 		if (shm->id == id)

	mov	rax, QWORD PTR shm$2[rsp]
	movzx	eax, WORD PTR [rax+2]
	movzx	ecx, WORD PTR id$[rsp]
	cmp	eax, ecx
	jne	SHORT $LN1@AuGetSHMBy

; 89   : 			return shm;

	mov	rax, QWORD PTR shm$2[rsp]
	jmp	SHORT $LN5@AuGetSHMBy
$LN1@AuGetSHMBy:

; 90   : 	}

	jmp	SHORT $LN3@AuGetSHMBy
$LN2@AuGetSHMBy:

; 91   : 
; 92   : 	return NULL;

	xor	eax, eax
$LN5@AuGetSHMBy:

; 93   : }

	add	rsp, 56					; 00000038H
	ret	0
?AuGetSHMByID@@YAPEAU_shm_@@G@Z ENDP			; AuGetSHMByID
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\mm\shm.cpp
_TEXT	SEGMENT
?AuInitialiseSHMMan@@YAXXZ PROC				; AuInitialiseSHMMan

; 49   : void AuInitialiseSHMMan() {

$LN3:
	sub	rsp, 40					; 00000028H

; 50   : 	shm_list = initialize_list();

	call	initialize_list
	mov	QWORD PTR ?shm_list@@3PEAU_list_@@EA, rax ; shm_list

; 51   : 	shm_id = 1;

	mov	eax, 1
	mov	WORD PTR ?shm_id@@3GA, ax		; shm_id

; 52   : 	shmlock = AuCreateSpinlock(false);

	xor	ecx, ecx
	call	AuCreateSpinlock
	mov	QWORD PTR ?shmlock@@3PEAU_spinlock_@@EA, rax ; shmlock

; 53   : }

	add	rsp, 40					; 00000028H
	ret	0
?AuInitialiseSHMMan@@YAXXZ ENDP				; AuInitialiseSHMMan
_TEXT	ENDS
END
