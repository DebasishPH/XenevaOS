; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30154.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?shm_list@@3PEAU_list_@@EA			; shm_list
PUBLIC	?shm_id@@3GA					; shm_id
PUBLIC	?shmlock@@3PEAU_spinlock_@@EA			; shmlock
_BSS	SEGMENT
?shm_list@@3PEAU_list_@@EA DQ 01H DUP (?)		; shm_list
?shm_id@@3GA DW	01H DUP (?)				; shm_id
	ALIGN	8

?shmlock@@3PEAU_spinlock_@@EA DQ 01H DUP (?)		; shmlock
_BSS	ENDS
msvcjmc	SEGMENT
__F9E1A23C_shm@cpp DB 01H
msvcjmc	ENDS
PUBLIC	?AuInitialiseSHMMan@@YAXXZ			; AuInitialiseSHMMan
PUBLIC	?AuGetSHMByID@@YAPEAU_shm_@@G@Z			; AuGetSHMByID
PUBLIC	?AuCreateSHM@@YAHPEAU_au_proc_@@G_KE@Z		; AuCreateSHM
PUBLIC	?AuSHMObtainMem@@YAPEAXPEAU_au_proc_@@GPEAXH@Z	; AuSHMObtainMem
PUBLIC	?AuSHMUnmap@@YAXGPEAU_au_proc_@@@Z		; AuSHMUnmap
PUBLIC	?AuSHMUnmapAll@@YAXPEAU_au_proc_@@@Z		; AuSHMUnmapAll
PUBLIC	?AuSHMGetID@@YAGXZ				; AuSHMGetID
PUBLIC	?AuGetSHMSeg@@YAPEAU_shm_@@G@Z			; AuGetSHMSeg
PUBLIC	?AuSHMDelete@@YAXPEAU_shm_@@@Z			; AuSHMDelete
PUBLIC	?AuSHMProcBreak@@YA_KPEAU_au_proc_@@_K@Z	; AuSHMProcBreak
PUBLIC	?AuSHMProcSwap@@YAXPEAU_data_@@0@Z		; AuSHMProcSwap
PUBLIC	?AuSHMProcOrderList@@YAXPEAU_au_proc_@@@Z	; AuSHMProcOrderList
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_0DB@EJAGMDND@?$FLSHM?$FN?5Creation?5failed?0?5key?5exce@ ; `string'
PUBLIC	??_C@_0BH@FKOKJMBM@Closing?5index?5?9?$DO?5?$CFd?5?$AN?6@ ; `string'
PUBLIC	??_C@_0BP@NOCMLJGN@?$CFs?5Unmapping?5shm?5?9?$DO?$CFd?5count?5?$AN?6@ ; `string'
PUBLIC	??_C@_0BH@KJKCGEJN@Unmapping?5shm?5?9?$DO?5?$CFx?5?$AN?6@ ; `string'
EXTRN	initialize_list:PROC
EXTRN	list_add:PROC
EXTRN	list_remove:PROC
EXTRN	list_get_at:PROC
EXTRN	AuCreateSpinlock:PROC
EXTRN	AuAcquireSpinlock:PROC
EXTRN	AuReleaseSpinlock:PROC
EXTRN	kmalloc:PROC
EXTRN	kfree:PROC
EXTRN	AuPmmngrAlloc:PROC
EXTRN	AuPmmngrFree:PROC
EXTRN	AuVmmngrGetPage:PROC
EXTRN	AuMapPage:PROC
EXTRN	flush_tlb:PROC
EXTRN	memset:PROC
EXTRN	SeTextOut:PROC
EXTRN	__CheckForDebuggerJustMyCode:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuInitialiseSHMMan@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+67
	DD	imagerel $unwind$?AuInitialiseSHMMan@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuGetSHMByID@@YAPEAU_shm_@@G@Z DD imagerel $LN7
	DD	imagerel $LN7+109
	DD	imagerel $unwind$?AuGetSHMByID@@YAPEAU_shm_@@G@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuCreateSHM@@YAHPEAU_au_proc_@@G_KE@Z DD imagerel $LN11
	DD	imagerel $LN11+412
	DD	imagerel $unwind$?AuCreateSHM@@YAHPEAU_au_proc_@@G_KE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuSHMObtainMem@@YAPEAXPEAU_au_proc_@@GPEAXH@Z DD imagerel $LN23
	DD	imagerel $LN23+999
	DD	imagerel $unwind$?AuSHMObtainMem@@YAPEAXPEAU_au_proc_@@GPEAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuSHMUnmap@@YAXGPEAU_au_proc_@@@Z DD imagerel $LN12
	DD	imagerel $LN12+486
	DD	imagerel $unwind$?AuSHMUnmap@@YAXGPEAU_au_proc_@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuSHMUnmapAll@@YAXPEAU_au_proc_@@@Z DD imagerel $LN9
	DD	imagerel $LN9+356
	DD	imagerel $unwind$?AuSHMUnmapAll@@YAXPEAU_au_proc_@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuSHMGetID@@YAGXZ DD imagerel $LN3
	DD	imagerel $LN3+60
	DD	imagerel $unwind$?AuSHMGetID@@YAGXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuGetSHMSeg@@YAPEAU_shm_@@G@Z DD imagerel $LN7
	DD	imagerel $LN7+108
	DD	imagerel $unwind$?AuGetSHMSeg@@YAPEAU_shm_@@G@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuSHMDelete@@YAXPEAU_shm_@@@Z DD imagerel $LN13
	DD	imagerel $LN13+256
	DD	imagerel $unwind$?AuSHMDelete@@YAXPEAU_shm_@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuSHMProcBreak@@YA_KPEAU_au_proc_@@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+87
	DD	imagerel $unwind$?AuSHMProcBreak@@YA_KPEAU_au_proc_@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuSHMProcSwap@@YAXPEAU_data_@@0@Z DD imagerel $LN3
	DD	imagerel $LN3+78
	DD	imagerel $unwind$?AuSHMProcSwap@@YAXPEAU_data_@@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuSHMProcOrderList@@YAXPEAU_au_proc_@@@Z DD imagerel $LN12
	DD	imagerel $LN12+262
	DD	imagerel $unwind$?AuSHMProcOrderList@@YAXPEAU_au_proc_@@@Z
pdata	ENDS
;	COMDAT ??_C@_0BH@KJKCGEJN@Unmapping?5shm?5?9?$DO?5?$CFx?5?$AN?6@
CONST	SEGMENT
??_C@_0BH@KJKCGEJN@Unmapping?5shm?5?9?$DO?5?$CFx?5?$AN?6@ DB 'Unmapping s'
	DB	'hm -> %x ', 0dH, 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@NOCMLJGN@?$CFs?5Unmapping?5shm?5?9?$DO?$CFd?5count?5?$AN?6@
CONST	SEGMENT
??_C@_0BP@NOCMLJGN@?$CFs?5Unmapping?5shm?5?9?$DO?$CFd?5count?5?$AN?6@ DB '%'
	DB	's Unmapping shm ->%d count ', 0dH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@FKOKJMBM@Closing?5index?5?9?$DO?5?$CFd?5?$AN?6@
CONST	SEGMENT
??_C@_0BH@FKOKJMBM@Closing?5index?5?9?$DO?5?$CFd?5?$AN?6@ DB 'Closing ind'
	DB	'ex -> %d ', 0dH, 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@EJAGMDND@?$FLSHM?$FN?5Creation?5failed?0?5key?5exce@
CONST	SEGMENT
??_C@_0DB@EJAGMDND@?$FLSHM?$FN?5Creation?5failed?0?5key?5exce@ DB '[SHM] '
	DB	'Creation failed, key exceeds limitation ', 0dH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuSHMProcOrderList@@YAXPEAU_au_proc_@@@Z DD 025041201H
	DD	010d2312H
	DD	050060012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuSHMProcSwap@@YAXPEAU_data_@@0@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuSHMProcBreak@@YA_KPEAU_au_proc_@@_K@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuSHMDelete@@YAXPEAU_shm_@@@Z DD 025031201H
	DD	0f20d2312H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuGetSHMSeg@@YAPEAU_shm_@@G@Z DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuSHMGetID@@YAGXZ DD 025030b01H
	DD	0d206230bH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuSHMUnmapAll@@YAXPEAU_au_proc_@@@Z DD 025041201H
	DD	010d2312H
	DD	050060012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuSHMUnmap@@YAXGPEAU_au_proc_@@@Z DD 025041701H
	DD	01122317H
	DD	0500b0014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuSHMObtainMem@@YAPEAXPEAU_au_proc_@@GPEAXH@Z DD 025042101H
	DD	011c2321H
	DD	05015001cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuCreateSHM@@YAHPEAU_au_proc_@@G_KE@Z DD 025031e01H
	DD	0d219231eH
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuGetSHMByID@@YAPEAU_shm_@@G@Z DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuInitialiseSHMMan@@YAXXZ DD 025030b01H
	DD	0b206230bH
	DD	05002H
xdata	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Mm\shm.cpp
;	COMDAT ?AuSHMProcOrderList@@YAXPEAU_au_proc_@@@Z
_TEXT	SEGMENT
current$ = 0
index$ = 8
i$1 = 16
mappsone$2 = 24
k$3 = 32
maptwo$4 = 40
proc$ = 128
?AuSHMProcOrderList@@YAXPEAU_au_proc_@@@Z PROC		; AuSHMProcOrderList, COMDAT

; 188  : void AuSHMProcOrderList(AuProcess* proc) {

$LN12:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 144				; 00000090H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__F9E1A23C_shm@cpp
	call	__CheckForDebuggerJustMyCode

; 189  : 	dataentry* current = proc->shmmaps->entry_current;

	mov	rax, QWORD PTR proc$[rbp]
	mov	rax, QWORD PTR [rax+1071]
	mov	rax, QWORD PTR [rax+4]
	mov	QWORD PTR current$[rbp], rax

; 190  : 	dataentry* index = NULL;

	mov	QWORD PTR index$[rbp], 0

; 191  : 	for (int i = 0; i < proc->shmmaps->pointer; i++) {

	mov	DWORD PTR i$1[rbp], 0
	jmp	SHORT $LN4@AuSHMProcO
$LN2@AuSHMProcO:
	mov	eax, DWORD PTR i$1[rbp]
	inc	eax
	mov	DWORD PTR i$1[rbp], eax
$LN4@AuSHMProcO:
	mov	rax, QWORD PTR proc$[rbp]
	mov	rax, QWORD PTR [rax+1071]
	mov	eax, DWORD PTR [rax]
	cmp	DWORD PTR i$1[rbp], eax
	jae	$LN3@AuSHMProcO

; 192  : 		if (current == NULL)

	cmp	QWORD PTR current$[rbp], 0
	jne	SHORT $LN8@AuSHMProcO

; 193  : 			break;

	jmp	$LN3@AuSHMProcO
$LN8@AuSHMProcO:

; 194  : 		AuSHMMappings* mappsone = (AuSHMMappings*)current->data;

	mov	rax, QWORD PTR current$[rbp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR mappsone$2[rbp], rax

; 195  : 		index = current->next;

	mov	rax, QWORD PTR current$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR index$[rbp], rax

; 196  : 		for (int k = 0; k < proc->shmmaps->pointer - 1; k++) {

	mov	DWORD PTR k$3[rbp], 0
	jmp	SHORT $LN7@AuSHMProcO
$LN5@AuSHMProcO:
	mov	eax, DWORD PTR k$3[rbp]
	inc	eax
	mov	DWORD PTR k$3[rbp], eax
$LN7@AuSHMProcO:
	mov	rax, QWORD PTR proc$[rbp]
	mov	rax, QWORD PTR [rax+1071]
	mov	eax, DWORD PTR [rax]
	dec	eax
	cmp	DWORD PTR k$3[rbp], eax
	jae	SHORT $LN6@AuSHMProcO

; 197  : 			if (index == NULL)

	cmp	QWORD PTR index$[rbp], 0
	jne	SHORT $LN9@AuSHMProcO

; 198  : 				break;

	jmp	SHORT $LN6@AuSHMProcO
$LN9@AuSHMProcO:

; 199  : 			AuSHMMappings* maptwo = (AuSHMMappings*)index->data;

	mov	rax, QWORD PTR index$[rbp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR maptwo$4[rbp], rax

; 200  : 			if (mappsone->start_addr > maptwo->start_addr) 

	mov	rax, QWORD PTR mappsone$2[rbp]
	mov	rcx, QWORD PTR maptwo$4[rbp]
	mov	rcx, QWORD PTR [rcx]
	cmp	QWORD PTR [rax], rcx
	jbe	SHORT $LN10@AuSHMProcO

; 201  : 				AuSHMProcSwap(current, index);

	mov	rdx, QWORD PTR index$[rbp]
	mov	rcx, QWORD PTR current$[rbp]
	call	?AuSHMProcSwap@@YAXPEAU_data_@@0@Z	; AuSHMProcSwap
$LN10@AuSHMProcO:

; 202  : 			index = index->next;

	mov	rax, QWORD PTR index$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR index$[rbp], rax

; 203  : 		}

	jmp	SHORT $LN5@AuSHMProcO
$LN6@AuSHMProcO:

; 204  : 		current = current->next;

	mov	rax, QWORD PTR current$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR current$[rbp], rax

; 205  : 	}

	jmp	$LN2@AuSHMProcO
$LN3@AuSHMProcO:

; 206  : }

	lea	rsp, QWORD PTR [rbp+112]
	pop	rbp
	ret	0
?AuSHMProcOrderList@@YAXPEAU_au_proc_@@@Z ENDP		; AuSHMProcOrderList
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Mm\shm.cpp
;	COMDAT ?AuSHMProcSwap@@YAXPEAU_data_@@0@Z
_TEXT	SEGMENT
tmp$ = 0
current$ = 96
index$ = 104
?AuSHMProcSwap@@YAXPEAU_data_@@0@Z PROC			; AuSHMProcSwap, COMDAT

; 178  : void AuSHMProcSwap(dataentry* current, dataentry* index) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__F9E1A23C_shm@cpp
	call	__CheckForDebuggerJustMyCode

; 179  : 	void* tmp = current->data;

	mov	rax, QWORD PTR current$[rbp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR tmp$[rbp], rax

; 180  : 	current->data = index->data;

	mov	rax, QWORD PTR current$[rbp]
	mov	rcx, QWORD PTR index$[rbp]
	mov	rcx, QWORD PTR [rcx+16]
	mov	QWORD PTR [rax+16], rcx

; 181  : 	index->data = tmp;

	mov	rax, QWORD PTR index$[rbp]
	mov	rcx, QWORD PTR tmp$[rbp]
	mov	QWORD PTR [rax+16], rcx

; 182  : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
?AuSHMProcSwap@@YAXPEAU_data_@@0@Z ENDP			; AuSHMProcSwap
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Mm\shm.cpp
;	COMDAT ?AuSHMProcBreak@@YA_KPEAU_au_proc_@@_K@Z
_TEXT	SEGMENT
start_addr$ = 0
proc$ = 96
num_frames$ = 104
?AuSHMProcBreak@@YA_KPEAU_au_proc_@@_K@Z PROC		; AuSHMProcBreak, COMDAT

; 169  : size_t AuSHMProcBreak(AuProcess* proc, size_t num_frames) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__F9E1A23C_shm@cpp
	call	__CheckForDebuggerJustMyCode

; 170  : 	size_t start_addr = proc->shm_break;

	mov	rax, QWORD PTR proc$[rbp]
	mov	rax, QWORD PTR [rax+1087]
	mov	QWORD PTR start_addr$[rbp], rax

; 171  : 	proc->shm_break = (proc->shm_break + num_frames * PAGE_SIZE);

	imul	rax, QWORD PTR num_frames$[rbp], 4096	; 00001000H
	mov	rcx, QWORD PTR proc$[rbp]
	add	rax, QWORD PTR [rcx+1087]
	mov	rcx, QWORD PTR proc$[rbp]
	mov	QWORD PTR [rcx+1087], rax

; 172  : 	return start_addr;

	mov	rax, QWORD PTR start_addr$[rbp]

; 173  : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
?AuSHMProcBreak@@YA_KPEAU_au_proc_@@_K@Z ENDP		; AuSHMProcBreak
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Mm\shm.cpp
;	COMDAT ?AuSHMDelete@@YAXPEAU_shm_@@@Z
_TEXT	SEGMENT
i$1 = 0
phys$2 = 8
j$3 = 16
shm_$4 = 24
shm$ = 112
?AuSHMDelete@@YAXPEAU_shm_@@@Z PROC			; AuSHMDelete, COMDAT

; 141  : void AuSHMDelete(AuSHM* shm) {

$LN13:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 128				; 00000080H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__F9E1A23C_shm@cpp
	call	__CheckForDebuggerJustMyCode

; 142  : 	if (!shm)

	cmp	QWORD PTR shm$[rbp], 0
	jne	SHORT $LN8@AuSHMDelet

; 143  : 		return;

	jmp	$LN1@AuSHMDelet
$LN8@AuSHMDelet:

; 144  : 	if (shm->link_count > 0){

	mov	rax, QWORD PTR shm$[rbp]
	movzx	eax, WORD PTR [rax+20]
	test	eax, eax
	jle	SHORT $LN9@AuSHMDelet

; 145  : 		shm->link_count--;

	mov	rax, QWORD PTR shm$[rbp]
	movzx	eax, WORD PTR [rax+20]
	dec	ax
	mov	rcx, QWORD PTR shm$[rbp]
	mov	WORD PTR [rcx+20], ax
$LN9@AuSHMDelet:

; 146  : 	}
; 147  : 
; 148  : 	if (shm->link_count == 0){

	mov	rax, QWORD PTR shm$[rbp]
	movzx	eax, WORD PTR [rax+20]
	test	eax, eax
	jne	$LN10@AuSHMDelet

; 149  : 		for (int i = 0; i < shm->num_frames; i++) {

	mov	DWORD PTR i$1[rbp], 0
	jmp	SHORT $LN4@AuSHMDelet
$LN2@AuSHMDelet:
	mov	eax, DWORD PTR i$1[rbp]
	inc	eax
	mov	DWORD PTR i$1[rbp], eax
$LN4@AuSHMDelet:
	movsxd	rax, DWORD PTR i$1[rbp]
	mov	rcx, QWORD PTR shm$[rbp]
	cmp	rax, QWORD PTR [rcx+4]
	jae	SHORT $LN3@AuSHMDelet

; 150  : 			size_t phys = shm->frames[i];

	movsxd	rax, DWORD PTR i$1[rbp]
	mov	rcx, QWORD PTR shm$[rbp]
	mov	rcx, QWORD PTR [rcx+12]
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR phys$2[rbp], rax

; 151  : 			AuPmmngrFree((void*)phys);

	mov	rcx, QWORD PTR phys$2[rbp]
	call	AuPmmngrFree

; 152  : 		}

	jmp	SHORT $LN2@AuSHMDelet
$LN3@AuSHMDelet:

; 153  : 		
; 154  : 		for (int j = 0; j <= shm_list->pointer; j++) {

	mov	DWORD PTR j$3[rbp], 0
	jmp	SHORT $LN7@AuSHMDelet
$LN5@AuSHMDelet:
	mov	eax, DWORD PTR j$3[rbp]
	inc	eax
	mov	DWORD PTR j$3[rbp], eax
$LN7@AuSHMDelet:
	mov	rax, QWORD PTR ?shm_list@@3PEAU_list_@@EA ; shm_list
	mov	eax, DWORD PTR [rax]
	cmp	DWORD PTR j$3[rbp], eax
	ja	SHORT $LN6@AuSHMDelet

; 155  : 			AuSHM *shm_ = (AuSHM*)list_get_at(shm_list, j);

	mov	edx, DWORD PTR j$3[rbp]
	mov	rcx, QWORD PTR ?shm_list@@3PEAU_list_@@EA ; shm_list
	call	list_get_at
	mov	QWORD PTR shm_$4[rbp], rax

; 156  : 			if (shm_ == shm)

	mov	rax, QWORD PTR shm$[rbp]
	cmp	QWORD PTR shm_$4[rbp], rax
	jne	SHORT $LN11@AuSHMDelet

; 157  : 				list_remove(shm_list, j);

	mov	edx, DWORD PTR j$3[rbp]
	mov	rcx, QWORD PTR ?shm_list@@3PEAU_list_@@EA ; shm_list
	call	list_remove
$LN11@AuSHMDelet:

; 158  : 		}

	jmp	SHORT $LN5@AuSHMDelet
$LN6@AuSHMDelet:

; 159  : 		kfree(shm->frames);

	mov	rax, QWORD PTR shm$[rbp]
	mov	rcx, QWORD PTR [rax+12]
	call	kfree

; 160  : 		kfree(shm);

	mov	rcx, QWORD PTR shm$[rbp]
	call	kfree
$LN10@AuSHMDelet:
$LN1@AuSHMDelet:

; 161  : 	}
; 162  : }

	lea	rsp, QWORD PTR [rbp+96]
	pop	rbp
	ret	0
?AuSHMDelete@@YAXPEAU_shm_@@@Z ENDP			; AuSHMDelete
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Mm\shm.cpp
;	COMDAT ?AuGetSHMSeg@@YAPEAU_shm_@@G@Z
_TEXT	SEGMENT
i$1 = 0
shm$2 = 8
key$ = 96
?AuGetSHMSeg@@YAPEAU_shm_@@G@Z PROC			; AuGetSHMSeg, COMDAT

; 70   : AuSHM * AuGetSHMSeg(uint16_t key) {

$LN7:
	mov	WORD PTR [rsp+8], cx
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__F9E1A23C_shm@cpp
	call	__CheckForDebuggerJustMyCode

; 71   : 	for (int i = 0; i < shm_list->pointer; i++) {

	mov	DWORD PTR i$1[rbp], 0
	jmp	SHORT $LN4@AuGetSHMSe
$LN2@AuGetSHMSe:
	mov	eax, DWORD PTR i$1[rbp]
	inc	eax
	mov	DWORD PTR i$1[rbp], eax
$LN4@AuGetSHMSe:
	mov	rax, QWORD PTR ?shm_list@@3PEAU_list_@@EA ; shm_list
	mov	eax, DWORD PTR [rax]
	cmp	DWORD PTR i$1[rbp], eax
	jae	SHORT $LN3@AuGetSHMSe

; 72   : 		AuSHM* shm = (AuSHM*)list_get_at(shm_list, i);

	mov	edx, DWORD PTR i$1[rbp]
	mov	rcx, QWORD PTR ?shm_list@@3PEAU_list_@@EA ; shm_list
	call	list_get_at
	mov	QWORD PTR shm$2[rbp], rax

; 73   : 		if (shm->key == key)

	mov	rax, QWORD PTR shm$2[rbp]
	movzx	eax, WORD PTR [rax]
	movzx	ecx, WORD PTR key$[rbp]
	cmp	eax, ecx
	jne	SHORT $LN5@AuGetSHMSe

; 74   : 			return shm;

	mov	rax, QWORD PTR shm$2[rbp]
	jmp	SHORT $LN1@AuGetSHMSe
$LN5@AuGetSHMSe:

; 75   : 	}

	jmp	SHORT $LN2@AuGetSHMSe
$LN3@AuGetSHMSe:

; 76   : 
; 77   : 	return NULL;

	xor	eax, eax
$LN1@AuGetSHMSe:

; 78   : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
?AuGetSHMSeg@@YAPEAU_shm_@@G@Z ENDP			; AuGetSHMSeg
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Mm\shm.cpp
;	COMDAT ?AuSHMGetID@@YAGXZ
_TEXT	SEGMENT
_id$ = 0
?AuSHMGetID@@YAGXZ PROC					; AuSHMGetID, COMDAT

; 59   : uint16_t AuSHMGetID() {

$LN3:
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__F9E1A23C_shm@cpp
	call	__CheckForDebuggerJustMyCode

; 60   : 	uint16_t _id = shm_id;

	movzx	eax, WORD PTR ?shm_id@@3GA		; shm_id
	mov	WORD PTR _id$[rbp], ax

; 61   : 	shm_id = shm_id + 1;

	movzx	eax, WORD PTR ?shm_id@@3GA		; shm_id
	inc	eax
	mov	WORD PTR ?shm_id@@3GA, ax		; shm_id

; 62   : 	return  _id;

	movzx	eax, WORD PTR _id$[rbp]

; 63   : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
?AuSHMGetID@@YAGXZ ENDP					; AuSHMGetID
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Mm\shm.cpp
;	COMDAT ?AuSHMUnmapAll@@YAXPEAU_au_proc_@@@Z
_TEXT	SEGMENT
i$1 = 0
mapping$2 = 8
j$3 = 16
vpage$4 = 24
tv74 = 96
proc$ = 128
?AuSHMUnmapAll@@YAXPEAU_au_proc_@@@Z PROC		; AuSHMUnmapAll, COMDAT

; 374  : void AuSHMUnmapAll(AuProcess* proc) {

$LN9:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 144				; 00000090H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__F9E1A23C_shm@cpp
	call	__CheckForDebuggerJustMyCode

; 375  : 	AuAcquireSpinlock(shmlock);

	mov	rcx, QWORD PTR ?shmlock@@3PEAU_spinlock_@@EA ; shmlock
	call	AuAcquireSpinlock

; 376  : 	for (int i = 0; i < proc->shmmaps->pointer; i++) {

	mov	DWORD PTR i$1[rbp], 0
	jmp	SHORT $LN4@AuSHMUnmap
$LN2@AuSHMUnmap:
	mov	eax, DWORD PTR i$1[rbp]
	inc	eax
	mov	DWORD PTR i$1[rbp], eax
$LN4@AuSHMUnmap:
	mov	rax, QWORD PTR proc$[rbp]
	mov	rax, QWORD PTR [rax+1071]
	mov	eax, DWORD PTR [rax]
	cmp	DWORD PTR i$1[rbp], eax
	jae	$LN3@AuSHMUnmap

; 377  : 		AuSHMMappings* mapping = (AuSHMMappings*)list_remove(proc->shmmaps, i);

	mov	edx, DWORD PTR i$1[rbp]
	mov	rax, QWORD PTR proc$[rbp]
	mov	rcx, QWORD PTR [rax+1071]
	call	list_remove
	mov	QWORD PTR mapping$2[rbp], rax

; 378  : 		for (int j = 0; j < mapping->length / PAGE_SIZE; j++) {

	mov	DWORD PTR j$3[rbp], 0
	jmp	SHORT $LN7@AuSHMUnmap
$LN5@AuSHMUnmap:
	mov	eax, DWORD PTR j$3[rbp]
	inc	eax
	mov	DWORD PTR j$3[rbp], eax
$LN7@AuSHMUnmap:
	movsxd	rax, DWORD PTR j$3[rbp]
	mov	QWORD PTR tv74[rbp], rax
	xor	edx, edx
	mov	rcx, QWORD PTR mapping$2[rbp]
	mov	rax, QWORD PTR [rcx+8]
	mov	ecx, 4096				; 00001000H
	div	rcx
	mov	rcx, QWORD PTR tv74[rbp]
	cmp	rcx, rax
	jae	SHORT $LN6@AuSHMUnmap

; 379  : 			AuVPage* vpage = AuVmmngrGetPage(mapping->start_addr + 

	movsxd	rax, DWORD PTR j$3[rbp]
	imul	rax, rax, 4096				; 00001000H
	mov	rcx, QWORD PTR mapping$2[rbp]
	add	rax, QWORD PTR [rcx]
	mov	r8b, 2
	mov	dl, 2
	mov	rcx, rax
	call	AuVmmngrGetPage
	mov	QWORD PTR vpage$4[rbp], rax

; 380  : 				static_cast<int64_t>(j) * PAGE_SIZE, VIRT_GETPAGE_ONLY_RET, VIRT_GETPAGE_ONLY_RET);
; 381  : 			vpage->bits.page = 0;

	mov	rax, QWORD PTR vpage$4[rbp]
	mov	rcx, -1099511623681			; ffffff0000000fffH
	mov	rax, QWORD PTR [rax]
	and	rax, rcx
	mov	rcx, QWORD PTR vpage$4[rbp]
	mov	QWORD PTR [rcx], rax

; 382  : 			vpage->bits.present = 0;

	mov	rax, QWORD PTR vpage$4[rbp]
	mov	rax, QWORD PTR [rax]
	and	rax, -2
	mov	rcx, QWORD PTR vpage$4[rbp]
	mov	QWORD PTR [rcx], rax

; 383  : 			flush_tlb((void*)(mapping->start_addr + 

	movsxd	rax, DWORD PTR j$3[rbp]
	imul	rax, rax, 4096				; 00001000H
	mov	rcx, QWORD PTR mapping$2[rbp]
	add	rax, QWORD PTR [rcx]
	mov	rcx, rax
	call	flush_tlb

; 384  : 				static_cast<int64_t>(j) * PAGE_SIZE));
; 385  : 		}

	jmp	$LN5@AuSHMUnmap
$LN6@AuSHMUnmap:

; 386  : 		AuSHMDelete(mapping->shm);

	mov	rax, QWORD PTR mapping$2[rbp]
	mov	rcx, QWORD PTR [rax+16]
	call	?AuSHMDelete@@YAXPEAU_shm_@@@Z		; AuSHMDelete

; 387  : 		SeTextOut("Unmapping shm -> %x \r\n", mapping->start_addr);

	mov	rax, QWORD PTR mapping$2[rbp]
	mov	rdx, QWORD PTR [rax]
	lea	rcx, OFFSET FLAT:??_C@_0BH@KJKCGEJN@Unmapping?5shm?5?9?$DO?5?$CFx?5?$AN?6@
	call	SeTextOut

; 388  : 		kfree(mapping);

	mov	rcx, QWORD PTR mapping$2[rbp]
	call	kfree

; 389  : 	}

	jmp	$LN2@AuSHMUnmap
$LN3@AuSHMUnmap:

; 390  : 	kfree(proc->shmmaps);

	mov	rax, QWORD PTR proc$[rbp]
	mov	rcx, QWORD PTR [rax+1071]
	call	kfree

; 391  : 	AuReleaseSpinlock(shmlock);

	mov	rcx, QWORD PTR ?shmlock@@3PEAU_spinlock_@@EA ; shmlock
	call	AuReleaseSpinlock

; 392  : }

	lea	rsp, QWORD PTR [rbp+112]
	pop	rbp
	ret	0
?AuSHMUnmapAll@@YAXPEAU_au_proc_@@@Z ENDP		; AuSHMUnmapAll
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Mm\shm.cpp
;	COMDAT ?AuSHMUnmap@@YAXGPEAU_au_proc_@@@Z
_TEXT	SEGMENT
shm$ = 0
mapping$ = 8
index$ = 16
i$1 = 20
maps$2 = 24
i$3 = 32
vpage$4 = 40
tv80 = 112
key$ = 144
proc$ = 152
?AuSHMUnmap@@YAXGPEAU_au_proc_@@@Z PROC			; AuSHMUnmap, COMDAT

; 332  : void AuSHMUnmap(uint16_t key, AuProcess* proc) {

$LN12:
	mov	QWORD PTR [rsp+16], rdx
	mov	WORD PTR [rsp+8], cx
	push	rbp
	sub	rsp, 160				; 000000a0H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__F9E1A23C_shm@cpp
	call	__CheckForDebuggerJustMyCode

; 333  : 	AuAcquireSpinlock(shmlock);

	mov	rcx, QWORD PTR ?shmlock@@3PEAU_spinlock_@@EA ; shmlock
	call	AuAcquireSpinlock

; 334  : 	AuSHM* shm = AuGetSHMSeg(key);

	movzx	ecx, WORD PTR key$[rbp]
	call	?AuGetSHMSeg@@YAPEAU_shm_@@G@Z		; AuGetSHMSeg
	mov	QWORD PTR shm$[rbp], rax

; 335  : 
; 336  : 	if (!shm) {

	cmp	QWORD PTR shm$[rbp], 0
	jne	SHORT $LN8@AuSHMUnmap

; 337  : 		AuReleaseSpinlock(shmlock);

	mov	rcx, QWORD PTR ?shmlock@@3PEAU_spinlock_@@EA ; shmlock
	call	AuReleaseSpinlock

; 338  : 		return;

	jmp	$LN1@AuSHMUnmap
$LN8@AuSHMUnmap:

; 339  : 	}
; 340  : 	
; 341  : 	AuSHMMappings* mapping = NULL;

	mov	QWORD PTR mapping$[rbp], 0

; 342  : 	int index = 0;

	mov	DWORD PTR index$[rbp], 0

; 343  : 	for (int i = 0; i < proc->shmmaps->pointer; i++) {

	mov	DWORD PTR i$1[rbp], 0
	jmp	SHORT $LN4@AuSHMUnmap
$LN2@AuSHMUnmap:
	mov	eax, DWORD PTR i$1[rbp]
	inc	eax
	mov	DWORD PTR i$1[rbp], eax
$LN4@AuSHMUnmap:
	mov	rax, QWORD PTR proc$[rbp]
	mov	rax, QWORD PTR [rax+1071]
	mov	eax, DWORD PTR [rax]
	cmp	DWORD PTR i$1[rbp], eax
	jae	$LN3@AuSHMUnmap

; 344  : 		AuSHMMappings* maps = (AuSHMMappings*)list_get_at(proc->shmmaps, i);

	mov	edx, DWORD PTR i$1[rbp]
	mov	rax, QWORD PTR proc$[rbp]
	mov	rcx, QWORD PTR [rax+1071]
	call	list_get_at
	mov	QWORD PTR maps$2[rbp], rax

; 345  : 		if (maps->shm == shm){

	mov	rax, QWORD PTR maps$2[rbp]
	mov	rcx, QWORD PTR shm$[rbp]
	cmp	QWORD PTR [rax+16], rcx
	jne	$LN9@AuSHMUnmap

; 346  : 			mapping = maps;

	mov	rax, QWORD PTR maps$2[rbp]
	mov	QWORD PTR mapping$[rbp], rax

; 347  : 			for (int i = 0; i < mapping->length / PAGE_SIZE; i++) {

	mov	DWORD PTR i$3[rbp], 0
	jmp	SHORT $LN7@AuSHMUnmap
$LN5@AuSHMUnmap:
	mov	eax, DWORD PTR i$3[rbp]
	inc	eax
	mov	DWORD PTR i$3[rbp], eax
$LN7@AuSHMUnmap:
	movsxd	rax, DWORD PTR i$3[rbp]
	mov	QWORD PTR tv80[rbp], rax
	xor	edx, edx
	mov	rcx, QWORD PTR mapping$[rbp]
	mov	rax, QWORD PTR [rcx+8]
	mov	ecx, 4096				; 00001000H
	div	rcx
	mov	rcx, QWORD PTR tv80[rbp]
	cmp	rcx, rax
	jae	SHORT $LN6@AuSHMUnmap

; 348  : 				AuVPage* vpage = AuVmmngrGetPage(mapping->start_addr + static_cast<int64_t>(i) * PAGE_SIZE, VIRT_GETPAGE_ONLY_RET, VIRT_GETPAGE_ONLY_RET);

	movsxd	rax, DWORD PTR i$3[rbp]
	imul	rax, rax, 4096				; 00001000H
	mov	rcx, QWORD PTR mapping$[rbp]
	add	rax, QWORD PTR [rcx]
	mov	r8b, 2
	mov	dl, 2
	mov	rcx, rax
	call	AuVmmngrGetPage
	mov	QWORD PTR vpage$4[rbp], rax

; 349  : 				if (vpage) {

	cmp	QWORD PTR vpage$4[rbp], 0
	je	SHORT $LN10@AuSHMUnmap

; 350  : 					vpage->bits.page = 0;

	mov	rax, QWORD PTR vpage$4[rbp]
	mov	rcx, -1099511623681			; ffffff0000000fffH
	mov	rax, QWORD PTR [rax]
	and	rax, rcx
	mov	rcx, QWORD PTR vpage$4[rbp]
	mov	QWORD PTR [rcx], rax

; 351  : 					vpage->bits.present = 0;

	mov	rax, QWORD PTR vpage$4[rbp]
	mov	rax, QWORD PTR [rax]
	and	rax, -2
	mov	rcx, QWORD PTR vpage$4[rbp]
	mov	QWORD PTR [rcx], rax

; 352  : 					flush_tlb((void*)(mapping->start_addr + static_cast<int64_t>(i) * PAGE_SIZE));

	movsxd	rax, DWORD PTR i$3[rbp]
	imul	rax, rax, 4096				; 00001000H
	mov	rcx, QWORD PTR mapping$[rbp]
	add	rax, QWORD PTR [rcx]
	mov	rcx, rax
	call	flush_tlb
$LN10@AuSHMUnmap:

; 353  : 				}
; 354  : 			}

	jmp	$LN5@AuSHMUnmap
$LN6@AuSHMUnmap:

; 355  : 			SeTextOut("Closing index -> %d \r\n", i);

	mov	edx, DWORD PTR i$1[rbp]
	lea	rcx, OFFSET FLAT:??_C@_0BH@FKOKJMBM@Closing?5index?5?9?$DO?5?$CFd?5?$AN?6@
	call	SeTextOut

; 356  : 			list_remove(proc->shmmaps, i);

	mov	edx, DWORD PTR i$1[rbp]
	mov	rax, QWORD PTR proc$[rbp]
	mov	rcx, QWORD PTR [rax+1071]
	call	list_remove

; 357  : 			kfree(mapping);

	mov	rcx, QWORD PTR mapping$[rbp]
	call	kfree

; 358  : 			break;

	jmp	SHORT $LN3@AuSHMUnmap
$LN9@AuSHMUnmap:

; 359  : 		}
; 360  : 	}

	jmp	$LN2@AuSHMUnmap
$LN3@AuSHMUnmap:

; 361  : 
; 362  : 
; 363  : 	AuSHMDelete(shm);

	mov	rcx, QWORD PTR shm$[rbp]
	call	?AuSHMDelete@@YAXPEAU_shm_@@@Z		; AuSHMDelete

; 364  : 	SeTextOut("%s Unmapping shm ->%d count \r\n",proc->name, shm->link_count);

	mov	rax, QWORD PTR shm$[rbp]
	movzx	eax, WORD PTR [rax+20]
	mov	rcx, QWORD PTR proc$[rbp]
	add	rcx, 4
	mov	r8d, eax
	mov	rdx, rcx
	lea	rcx, OFFSET FLAT:??_C@_0BP@NOCMLJGN@?$CFs?5Unmapping?5shm?5?9?$DO?$CFd?5count?5?$AN?6@
	call	SeTextOut

; 365  : 	AuReleaseSpinlock(shmlock);

	mov	rcx, QWORD PTR ?shmlock@@3PEAU_spinlock_@@EA ; shmlock
	call	AuReleaseSpinlock
$LN1@AuSHMUnmap:

; 366  : }

	lea	rsp, QWORD PTR [rbp+128]
	pop	rbp
	ret	0
?AuSHMUnmap@@YAXGPEAU_au_proc_@@@Z ENDP			; AuSHMUnmap
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Mm\shm.cpp
;	COMDAT ?AuSHMObtainMem@@YAPEAXPEAU_au_proc_@@GPEAXH@Z
_TEXT	SEGMENT
mem$ = 0
mappings$ = 8
last_addr$ = 16
have_mappings$ = 24
i$1 = 28
maps$2 = 32
gap$3 = 40
j$4 = 48
phys$5 = 56
start_addr$6 = 64
gap$7 = 72
j$8 = 80
phys$9 = 88
i$10 = 96
phys_addr$11 = 104
current_virt$12 = 112
proc$ = 208
id$ = 216
shmaddr$ = 224
shmflg$ = 232
?AuSHMObtainMem@@YAPEAXPEAU_au_proc_@@GPEAXH@Z PROC	; AuSHMObtainMem, COMDAT

; 216  : void* AuSHMObtainMem(AuProcess* proc, uint16_t id, void* shmaddr, int shmflg) {

$LN23:
	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	WORD PTR [rsp+16], dx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 224				; 000000e0H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__F9E1A23C_shm@cpp
	call	__CheckForDebuggerJustMyCode

; 217  : 	AuAcquireSpinlock(shmlock);

	mov	rcx, QWORD PTR ?shmlock@@3PEAU_spinlock_@@EA ; shmlock
	call	AuAcquireSpinlock

; 218  : 	AuSHM* mem = NULL;

	mov	QWORD PTR mem$[rbp], 0

; 219  : 
; 220  : 	/* search for shm memory segment */
; 221  : 	mem = AuGetSHMByID(id);

	movzx	ecx, WORD PTR id$[rbp]
	call	?AuGetSHMByID@@YAPEAU_shm_@@G@Z		; AuGetSHMByID
	mov	QWORD PTR mem$[rbp], rax

; 222  : 
; 223  : 	if (!mem)

	cmp	QWORD PTR mem$[rbp], 0
	jne	SHORT $LN14@AuSHMObtai

; 224  : 		return NULL;

	xor	eax, eax
	jmp	$LN1@AuSHMObtai
$LN14@AuSHMObtai:

; 225  : 
; 226  : 
; 227  : 	AuSHMMappings *mappings = (AuSHMMappings*)kmalloc(sizeof(AuSHMMappings));

	mov	ecx, 24
	call	kmalloc
	mov	QWORD PTR mappings$[rbp], rax

; 228  : 	memset(mappings, 0, sizeof(AuSHMMappings));

	mov	r8d, 24
	xor	edx, edx
	mov	rcx, QWORD PTR mappings$[rbp]
	call	memset

; 229  : 
; 230  : 	mem->link_count++;

	mov	rax, QWORD PTR mem$[rbp]
	movzx	eax, WORD PTR [rax+20]
	inc	ax
	mov	rcx, QWORD PTR mem$[rbp]
	mov	WORD PTR [rcx+20], ax

; 231  : 
; 232  : 	/* look for already available address space gap
; 233  : 	 * before increasing the process shm_break
; 234  : 	 */
; 235  : 	uint64_t last_addr = USER_SHARED_MEM_START;

	mov	eax, -2147483648			; 80000000H
	mov	QWORD PTR last_addr$[rbp], rax

; 236  : 	bool have_mappings = false;

	mov	BYTE PTR have_mappings$[rbp], 0

; 237  : 	for (int i = 0; i < proc->shmmaps->pointer; i++) {

	mov	DWORD PTR i$1[rbp], 0
	jmp	SHORT $LN4@AuSHMObtai
$LN2@AuSHMObtai:
	mov	eax, DWORD PTR i$1[rbp]
	inc	eax
	mov	DWORD PTR i$1[rbp], eax
$LN4@AuSHMObtai:
	mov	rax, QWORD PTR proc$[rbp]
	mov	rax, QWORD PTR [rax+1071]
	mov	eax, DWORD PTR [rax]
	cmp	DWORD PTR i$1[rbp], eax
	jae	$LN3@AuSHMObtai

; 238  : 		AuSHMMappings *maps = (AuSHMMappings*)list_get_at(proc->shmmaps, i);

	mov	edx, DWORD PTR i$1[rbp]
	mov	rax, QWORD PTR proc$[rbp]
	mov	rcx, QWORD PTR [rax+1071]
	call	list_get_at
	mov	QWORD PTR maps$2[rbp], rax

; 239  : 		if (!have_mappings)

	movzx	eax, BYTE PTR have_mappings$[rbp]
	test	eax, eax
	jne	SHORT $LN15@AuSHMObtai

; 240  : 			have_mappings = true;

	mov	BYTE PTR have_mappings$[rbp], 1
$LN15@AuSHMObtai:

; 241  : 		if (maps->start_addr > last_addr) {

	mov	rax, QWORD PTR maps$2[rbp]
	mov	rcx, QWORD PTR last_addr$[rbp]
	cmp	QWORD PTR [rax], rcx
	jbe	$LN16@AuSHMObtai

; 242  : 			size_t gap = maps->start_addr - last_addr;

	mov	rax, QWORD PTR maps$2[rbp]
	mov	rcx, QWORD PTR last_addr$[rbp]
	mov	rax, QWORD PTR [rax]
	sub	rax, rcx
	mov	QWORD PTR gap$3[rbp], rax

; 243  : 			if (gap >= static_cast<uint64_t>(mem->num_frames) * PAGE_SIZE){

	mov	rax, QWORD PTR mem$[rbp]
	imul	rax, QWORD PTR [rax+4], 4096		; 00001000H
	cmp	QWORD PTR gap$3[rbp], rax
	jb	$LN17@AuSHMObtai

; 244  : 				for (int j = 0; j < mem->num_frames; j++) {

	mov	DWORD PTR j$4[rbp], 0
	jmp	SHORT $LN7@AuSHMObtai
$LN5@AuSHMObtai:
	mov	eax, DWORD PTR j$4[rbp]
	inc	eax
	mov	DWORD PTR j$4[rbp], eax
$LN7@AuSHMObtai:
	movsxd	rax, DWORD PTR j$4[rbp]
	mov	rcx, QWORD PTR mem$[rbp]
	cmp	rax, QWORD PTR [rcx+4]
	jae	SHORT $LN6@AuSHMObtai

; 245  : 					size_t phys = mem->frames[j];

	movsxd	rax, DWORD PTR j$4[rbp]
	mov	rcx, QWORD PTR mem$[rbp]
	mov	rcx, QWORD PTR [rcx+12]
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR phys$5[rbp], rax

; 246  : 					AuMapPage(phys, last_addr + static_cast<int64_t>(j) * PAGE_SIZE, X86_64_PAGING_USER);

	movsxd	rax, DWORD PTR j$4[rbp]
	imul	rax, rax, 4096				; 00001000H
	mov	rcx, QWORD PTR last_addr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	r8b, 4
	mov	rdx, rax
	mov	rcx, QWORD PTR phys$5[rbp]
	call	AuMapPage

; 247  : 				}

	jmp	SHORT $LN5@AuSHMObtai
$LN6@AuSHMObtai:

; 248  : 				mappings->start_addr = last_addr;

	mov	rax, QWORD PTR mappings$[rbp]
	mov	rcx, QWORD PTR last_addr$[rbp]
	mov	QWORD PTR [rax], rcx

; 249  : 				mappings->length = mem->num_frames * PAGE_SIZE;

	mov	rax, QWORD PTR mem$[rbp]
	imul	rax, QWORD PTR [rax+4], 4096		; 00001000H
	mov	rcx, QWORD PTR mappings$[rbp]
	mov	QWORD PTR [rcx+8], rax

; 250  : 				mappings->shm = mem;

	mov	rax, QWORD PTR mappings$[rbp]
	mov	rcx, QWORD PTR mem$[rbp]
	mov	QWORD PTR [rax+16], rcx

; 251  : 
; 252  : 				/* Here we need some sorting algorithm to sort
; 253  : 				 * out mappings in ascending order, like Bubble-sort
; 254  : 				 * algorithm between nodes of mappings
; 255  : 				 */
; 256  : 				list_add(proc->shmmaps, mappings);

	mov	rdx, QWORD PTR mappings$[rbp]
	mov	rax, QWORD PTR proc$[rbp]
	mov	rcx, QWORD PTR [rax+1071]
	call	list_add

; 257  : 				AuReleaseSpinlock(shmlock);

	mov	rcx, QWORD PTR ?shmlock@@3PEAU_spinlock_@@EA ; shmlock
	call	AuReleaseSpinlock

; 258  : 
; 259  : #if 0
; 260  : 				/* just for debugging purpose */
; 261  : 				for (int i = 0; i < proc->shmmaps->pointer; i++) {
; 262  : 					AuSHMMappings* map = (AuSHMMappings*)list_get_at(proc->shmmaps, i);
; 263  : 					SeTextOut("M -> %x \r\n", map->start_addr);
; 264  : 				}
; 265  : #endif
; 266  : 
; 267  : 				/* Now order the list, in ascending order */
; 268  : 				AuSHMProcOrderList(proc);

	mov	rcx, QWORD PTR proc$[rbp]
	call	?AuSHMProcOrderList@@YAXPEAU_au_proc_@@@Z ; AuSHMProcOrderList

; 269  : 
; 270  : #if 0
; 271  : 				/* just for debugging purpose after sorting 
; 272  : 				 * has been done 
; 273  : 				 */
; 274  : 				SeTextOut("After ordering \r\n");
; 275  : 
; 276  : 				for (int i = 0; i < proc->shmmaps->pointer; i++) {
; 277  : 					AuSHMMappings* map = (AuSHMMappings*)list_get_at(proc->shmmaps, i);
; 278  : 					SeTextOut("M -> %x \r\n", map->start_addr);
; 279  : 				}
; 280  : #endif
; 281  : 
; 282  : 				return (void*)mappings->start_addr;

	mov	rax, QWORD PTR mappings$[rbp]
	mov	rax, QWORD PTR [rax]
	jmp	$LN1@AuSHMObtai
$LN17@AuSHMObtai:
$LN16@AuSHMObtai:

; 283  : 			}
; 284  : 		}
; 285  : 		last_addr = maps->start_addr + maps->length;

	mov	rax, QWORD PTR maps$2[rbp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR maps$2[rbp]
	add	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR last_addr$[rbp], rax

; 286  : 	}

	jmp	$LN2@AuSHMObtai
$LN3@AuSHMObtai:

; 287  : 
; 288  : 	if (!have_mappings) {

	movzx	eax, BYTE PTR have_mappings$[rbp]
	test	eax, eax
	jne	$LN18@AuSHMObtai

; 289  : 		size_t start_addr = USER_SHARED_MEM_START;

	mov	eax, -2147483648			; 80000000H
	mov	QWORD PTR start_addr$6[rbp], rax

; 290  : 		if (proc->shm_break > start_addr) {

	mov	rax, QWORD PTR proc$[rbp]
	mov	rcx, QWORD PTR start_addr$6[rbp]
	cmp	QWORD PTR [rax+1087], rcx
	jbe	$LN19@AuSHMObtai

; 291  : 			size_t gap = proc->shm_break - start_addr;

	mov	rax, QWORD PTR proc$[rbp]
	mov	rcx, QWORD PTR start_addr$6[rbp]
	mov	rax, QWORD PTR [rax+1087]
	sub	rax, rcx
	mov	QWORD PTR gap$7[rbp], rax

; 292  : 			if (gap >= mem->num_frames * PAGE_SIZE) {

	mov	rax, QWORD PTR mem$[rbp]
	imul	rax, QWORD PTR [rax+4], 4096		; 00001000H
	cmp	QWORD PTR gap$7[rbp], rax
	jb	$LN20@AuSHMObtai

; 293  : 				for (int j = 0; j < mem->num_frames; j++) {

	mov	DWORD PTR j$8[rbp], 0
	jmp	SHORT $LN10@AuSHMObtai
$LN8@AuSHMObtai:
	mov	eax, DWORD PTR j$8[rbp]
	inc	eax
	mov	DWORD PTR j$8[rbp], eax
$LN10@AuSHMObtai:
	movsxd	rax, DWORD PTR j$8[rbp]
	mov	rcx, QWORD PTR mem$[rbp]
	cmp	rax, QWORD PTR [rcx+4]
	jae	SHORT $LN9@AuSHMObtai

; 294  : 					size_t phys = mem->frames[j];

	movsxd	rax, DWORD PTR j$8[rbp]
	mov	rcx, QWORD PTR mem$[rbp]
	mov	rcx, QWORD PTR [rcx+12]
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR phys$9[rbp], rax

; 295  : 					AuMapPage(phys, last_addr + static_cast<int64_t>(j) * PAGE_SIZE, X86_64_PAGING_USER);

	movsxd	rax, DWORD PTR j$8[rbp]
	imul	rax, rax, 4096				; 00001000H
	mov	rcx, QWORD PTR last_addr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	r8b, 4
	mov	rdx, rax
	mov	rcx, QWORD PTR phys$9[rbp]
	call	AuMapPage

; 296  : 				}

	jmp	SHORT $LN8@AuSHMObtai
$LN9@AuSHMObtai:

; 297  : 				mappings->start_addr = last_addr;

	mov	rax, QWORD PTR mappings$[rbp]
	mov	rcx, QWORD PTR last_addr$[rbp]
	mov	QWORD PTR [rax], rcx

; 298  : 				mappings->length = mem->num_frames * PAGE_SIZE;

	mov	rax, QWORD PTR mem$[rbp]
	imul	rax, QWORD PTR [rax+4], 4096		; 00001000H
	mov	rcx, QWORD PTR mappings$[rbp]
	mov	QWORD PTR [rcx+8], rax

; 299  : 				mappings->shm = mem;

	mov	rax, QWORD PTR mappings$[rbp]
	mov	rcx, QWORD PTR mem$[rbp]
	mov	QWORD PTR [rax+16], rcx

; 300  : 				list_add(proc->shmmaps, mappings);

	mov	rdx, QWORD PTR mappings$[rbp]
	mov	rax, QWORD PTR proc$[rbp]
	mov	rcx, QWORD PTR [rax+1071]
	call	list_add

; 301  : 				/* Now order the list, in ascending order */
; 302  : 				AuSHMProcOrderList(proc);

	mov	rcx, QWORD PTR proc$[rbp]
	call	?AuSHMProcOrderList@@YAXPEAU_au_proc_@@@Z ; AuSHMProcOrderList

; 303  : 				AuReleaseSpinlock(shmlock);

	mov	rcx, QWORD PTR ?shmlock@@3PEAU_spinlock_@@EA ; shmlock
	call	AuReleaseSpinlock

; 304  : 				return (void*)mappings->start_addr;

	mov	rax, QWORD PTR mappings$[rbp]
	mov	rax, QWORD PTR [rax]
	jmp	$LN1@AuSHMObtai
$LN20@AuSHMObtai:
$LN19@AuSHMObtai:
$LN18@AuSHMObtai:

; 305  : 			}
; 306  : 		}
; 307  : 	}
; 308  : 
; 309  : 	/* finally, we need to increase the shm break */
; 310  : 	for (int i = 0; i < mem->num_frames; i++) {

	mov	DWORD PTR i$10[rbp], 0
	jmp	SHORT $LN13@AuSHMObtai
$LN11@AuSHMObtai:
	mov	eax, DWORD PTR i$10[rbp]
	inc	eax
	mov	DWORD PTR i$10[rbp], eax
$LN13@AuSHMObtai:
	movsxd	rax, DWORD PTR i$10[rbp]
	mov	rcx, QWORD PTR mem$[rbp]
	cmp	rax, QWORD PTR [rcx+4]
	jae	SHORT $LN12@AuSHMObtai

; 311  : 		uint64_t phys_addr = mem->frames[i];

	movsxd	rax, DWORD PTR i$10[rbp]
	mov	rcx, QWORD PTR mem$[rbp]
	mov	rcx, QWORD PTR [rcx+12]
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR phys_addr$11[rbp], rax

; 312  : 		uint64_t current_virt = AuSHMProcBreak(proc, 1);

	mov	edx, 1
	mov	rcx, QWORD PTR proc$[rbp]
	call	?AuSHMProcBreak@@YA_KPEAU_au_proc_@@_K@Z ; AuSHMProcBreak
	mov	QWORD PTR current_virt$12[rbp], rax

; 313  : 		AuMapPage((uint64_t)phys_addr, current_virt, X86_64_PAGING_USER);

	mov	r8b, 4
	mov	rdx, QWORD PTR current_virt$12[rbp]
	mov	rcx, QWORD PTR phys_addr$11[rbp]
	call	AuMapPage

; 314  : 		if (mappings->start_addr == 0)

	mov	rax, QWORD PTR mappings$[rbp]
	cmp	QWORD PTR [rax], 0
	jne	SHORT $LN21@AuSHMObtai

; 315  : 			mappings->start_addr = current_virt;

	mov	rax, QWORD PTR mappings$[rbp]
	mov	rcx, QWORD PTR current_virt$12[rbp]
	mov	QWORD PTR [rax], rcx
$LN21@AuSHMObtai:

; 316  : 	}

	jmp	SHORT $LN11@AuSHMObtai
$LN12@AuSHMObtai:

; 317  : 
; 318  : 	mappings->length = mem->num_frames * PAGE_SIZE;

	mov	rax, QWORD PTR mem$[rbp]
	imul	rax, QWORD PTR [rax+4], 4096		; 00001000H
	mov	rcx, QWORD PTR mappings$[rbp]
	mov	QWORD PTR [rcx+8], rax

; 319  : 	mappings->shm = mem;

	mov	rax, QWORD PTR mappings$[rbp]
	mov	rcx, QWORD PTR mem$[rbp]
	mov	QWORD PTR [rax+16], rcx

; 320  : 	list_add(proc->shmmaps, mappings);

	mov	rdx, QWORD PTR mappings$[rbp]
	mov	rax, QWORD PTR proc$[rbp]
	mov	rcx, QWORD PTR [rax+1071]
	call	list_add

; 321  : 	/* Now order the list, in ascending order */
; 322  : 	AuSHMProcOrderList(proc);

	mov	rcx, QWORD PTR proc$[rbp]
	call	?AuSHMProcOrderList@@YAXPEAU_au_proc_@@@Z ; AuSHMProcOrderList

; 323  : 	AuReleaseSpinlock(shmlock);

	mov	rcx, QWORD PTR ?shmlock@@3PEAU_spinlock_@@EA ; shmlock
	call	AuReleaseSpinlock

; 324  : 	return (void*)mappings->start_addr;

	mov	rax, QWORD PTR mappings$[rbp]
	mov	rax, QWORD PTR [rax]
$LN1@AuSHMObtai:

; 325  : }

	lea	rsp, QWORD PTR [rbp+192]
	pop	rbp
	ret	0
?AuSHMObtainMem@@YAPEAXPEAU_au_proc_@@GPEAXH@Z ENDP	; AuSHMObtainMem
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Mm\shm.cpp
;	COMDAT ?AuCreateSHM@@YAHPEAU_au_proc_@@G_KE@Z
_TEXT	SEGMENT
shm$ = 0
i$1 = 8
tv84 = 76
proc$ = 96
key$ = 104
sz$ = 112
flags$ = 120
?AuCreateSHM@@YAHPEAU_au_proc_@@G_KE@Z PROC		; AuCreateSHM, COMDAT

; 102  : int AuCreateSHM(AuProcess* proc, uint16_t key, size_t sz, uint8_t flags) {

$LN11:
	mov	BYTE PTR [rsp+32], r9b
	mov	QWORD PTR [rsp+24], r8
	mov	WORD PTR [rsp+16], dx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__F9E1A23C_shm@cpp
	call	__CheckForDebuggerJustMyCode

; 103  : 	AuSHM* shm = NULL;

	mov	QWORD PTR shm$[rbp], 0

; 104  : 	AuAcquireSpinlock(shmlock);

	mov	rcx, QWORD PTR ?shmlock@@3PEAU_spinlock_@@EA ; shmlock
	call	AuAcquireSpinlock

; 105  : 	if (key > UINT16_MAX){

	movzx	eax, WORD PTR key$[rbp]
	cmp	eax, 65535				; 0000ffffH
	jle	SHORT $LN5@AuCreateSH

; 106  : 		AuReleaseSpinlock(shmlock);

	mov	rcx, QWORD PTR ?shmlock@@3PEAU_spinlock_@@EA ; shmlock
	call	AuReleaseSpinlock

; 107  : 		SeTextOut("[SHM] Creation failed, key exceeds limitation \r\n");

	lea	rcx, OFFSET FLAT:??_C@_0DB@EJAGMDND@?$FLSHM?$FN?5Creation?5failed?0?5key?5exce@
	call	SeTextOut

; 108  : 		return -1;

	mov	eax, -1
	jmp	$LN1@AuCreateSH
$LN5@AuCreateSH:

; 109  : 	}
; 110  : 	/*  search if it's already created */
; 111  : 	shm = AuGetSHMSeg(key);

	movzx	ecx, WORD PTR key$[rbp]
	call	?AuGetSHMSeg@@YAPEAU_shm_@@G@Z		; AuGetSHMSeg
	mov	QWORD PTR shm$[rbp], rax

; 112  : 	/* create a new*/
; 113  : 	if (!shm) {

	cmp	QWORD PTR shm$[rbp], 0
	jne	$LN6@AuCreateSH

; 114  : 		shm = (AuSHM*)kmalloc(sizeof(AuSHM));

	mov	ecx, 22
	call	kmalloc
	mov	QWORD PTR shm$[rbp], rax

; 115  : 		memset(shm, 0, sizeof(AuSHM));

	mov	r8d, 22
	xor	edx, edx
	mov	rcx, QWORD PTR shm$[rbp]
	call	memset

; 116  : 		shm->id = AuSHMGetID();

	call	?AuSHMGetID@@YAGXZ			; AuSHMGetID
	mov	rcx, QWORD PTR shm$[rbp]
	mov	WORD PTR [rcx+2], ax

; 117  : 		shm->key = key;

	mov	rax, QWORD PTR shm$[rbp]
	movzx	ecx, WORD PTR key$[rbp]
	mov	WORD PTR [rax], cx

; 118  : 		shm->num_frames = (sz / 0x1000) + ((sz % 0x1000) ? 1 : 0);

	xor	edx, edx
	mov	rax, QWORD PTR sz$[rbp]
	mov	ecx, 4096				; 00001000H
	div	rcx
	mov	rax, rdx
	test	rax, rax
	je	SHORT $LN9@AuCreateSH
	mov	DWORD PTR tv84[rbp], 1
	jmp	SHORT $LN10@AuCreateSH
$LN9@AuCreateSH:
	mov	DWORD PTR tv84[rbp], 0
$LN10@AuCreateSH:
	xor	edx, edx
	mov	rax, QWORD PTR sz$[rbp]
	mov	ecx, 4096				; 00001000H
	div	rcx
	movsxd	rcx, DWORD PTR tv84[rbp]
	add	rax, rcx
	mov	rcx, QWORD PTR shm$[rbp]
	mov	QWORD PTR [rcx+4], rax

; 119  : 		shm->link_count = 0;

	xor	eax, eax
	mov	rcx, QWORD PTR shm$[rbp]
	mov	WORD PTR [rcx+20], ax

; 120  : 		shm->frames = (uint64_t*)kmalloc(sizeof(uint64_t)* shm->num_frames);

	mov	rax, QWORD PTR shm$[rbp]
	mov	rax, QWORD PTR [rax+4]
	shl	rax, 3
	mov	ecx, eax
	call	kmalloc
	mov	rcx, QWORD PTR shm$[rbp]
	mov	QWORD PTR [rcx+12], rax

; 121  : 		for (int i = 0; i < shm->num_frames; i++)  {

	mov	DWORD PTR i$1[rbp], 0
	jmp	SHORT $LN4@AuCreateSH
$LN2@AuCreateSH:
	mov	eax, DWORD PTR i$1[rbp]
	inc	eax
	mov	DWORD PTR i$1[rbp], eax
$LN4@AuCreateSH:
	movsxd	rax, DWORD PTR i$1[rbp]
	mov	rcx, QWORD PTR shm$[rbp]
	cmp	rax, QWORD PTR [rcx+4]
	jae	SHORT $LN3@AuCreateSH

; 122  : 			shm->frames[i] = (uint64_t)AuPmmngrAlloc();

	call	AuPmmngrAlloc
	movsxd	rcx, DWORD PTR i$1[rbp]
	mov	rdx, QWORD PTR shm$[rbp]
	mov	rdx, QWORD PTR [rdx+12]
	mov	QWORD PTR [rdx+rcx*8], rax

; 123  : 		}

	jmp	SHORT $LN2@AuCreateSH
$LN3@AuCreateSH:

; 124  : 
; 125  : 		list_add(shm_list, shm);

	mov	rdx, QWORD PTR shm$[rbp]
	mov	rcx, QWORD PTR ?shm_list@@3PEAU_list_@@EA ; shm_list
	call	list_add
$LN6@AuCreateSH:

; 126  : 	}
; 127  : 
; 128  : 	if (!shm) {

	cmp	QWORD PTR shm$[rbp], 0
	jne	SHORT $LN7@AuCreateSH

; 129  : 		AuReleaseSpinlock(shmlock);

	mov	rcx, QWORD PTR ?shmlock@@3PEAU_spinlock_@@EA ; shmlock
	call	AuReleaseSpinlock

; 130  : 		return -1;

	mov	eax, -1
	jmp	SHORT $LN1@AuCreateSH
$LN7@AuCreateSH:

; 131  : 	}
; 132  : 
; 133  : 	AuReleaseSpinlock(shmlock);

	mov	rcx, QWORD PTR ?shmlock@@3PEAU_spinlock_@@EA ; shmlock
	call	AuReleaseSpinlock

; 134  : 	return shm->id;

	mov	rax, QWORD PTR shm$[rbp]
	movzx	eax, WORD PTR [rax+2]
$LN1@AuCreateSH:

; 135  : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
?AuCreateSHM@@YAHPEAU_au_proc_@@G_KE@Z ENDP		; AuCreateSHM
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Mm\shm.cpp
;	COMDAT ?AuGetSHMByID@@YAPEAU_shm_@@G@Z
_TEXT	SEGMENT
i$1 = 0
shm$2 = 8
id$ = 96
?AuGetSHMByID@@YAPEAU_shm_@@G@Z PROC			; AuGetSHMByID, COMDAT

; 85   : AuSHM * AuGetSHMByID(uint16_t id) {

$LN7:
	mov	WORD PTR [rsp+8], cx
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__F9E1A23C_shm@cpp
	call	__CheckForDebuggerJustMyCode

; 86   : 	for (int i = 0; i < shm_list->pointer; i++) {

	mov	DWORD PTR i$1[rbp], 0
	jmp	SHORT $LN4@AuGetSHMBy
$LN2@AuGetSHMBy:
	mov	eax, DWORD PTR i$1[rbp]
	inc	eax
	mov	DWORD PTR i$1[rbp], eax
$LN4@AuGetSHMBy:
	mov	rax, QWORD PTR ?shm_list@@3PEAU_list_@@EA ; shm_list
	mov	eax, DWORD PTR [rax]
	cmp	DWORD PTR i$1[rbp], eax
	jae	SHORT $LN3@AuGetSHMBy

; 87   : 		AuSHM* shm = (AuSHM*)list_get_at(shm_list, i);

	mov	edx, DWORD PTR i$1[rbp]
	mov	rcx, QWORD PTR ?shm_list@@3PEAU_list_@@EA ; shm_list
	call	list_get_at
	mov	QWORD PTR shm$2[rbp], rax

; 88   : 		if (shm->id == id)

	mov	rax, QWORD PTR shm$2[rbp]
	movzx	eax, WORD PTR [rax+2]
	movzx	ecx, WORD PTR id$[rbp]
	cmp	eax, ecx
	jne	SHORT $LN5@AuGetSHMBy

; 89   : 			return shm;

	mov	rax, QWORD PTR shm$2[rbp]
	jmp	SHORT $LN1@AuGetSHMBy
$LN5@AuGetSHMBy:

; 90   : 	}

	jmp	SHORT $LN2@AuGetSHMBy
$LN3@AuGetSHMBy:

; 91   : 
; 92   : 	return NULL;

	xor	eax, eax
$LN1@AuGetSHMBy:

; 93   : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
?AuGetSHMByID@@YAPEAU_shm_@@G@Z ENDP			; AuGetSHMByID
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Mm\shm.cpp
;	COMDAT ?AuInitialiseSHMMan@@YAXXZ
_TEXT	SEGMENT
?AuInitialiseSHMMan@@YAXXZ PROC				; AuInitialiseSHMMan, COMDAT

; 49   : void AuInitialiseSHMMan() {

$LN3:
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__F9E1A23C_shm@cpp
	call	__CheckForDebuggerJustMyCode

; 50   : 	shm_list = initialize_list();

	call	initialize_list
	mov	QWORD PTR ?shm_list@@3PEAU_list_@@EA, rax ; shm_list

; 51   : 	shm_id = 1;

	mov	eax, 1
	mov	WORD PTR ?shm_id@@3GA, ax		; shm_id

; 52   : 	shmlock = AuCreateSpinlock(false);

	xor	ecx, ecx
	call	AuCreateSpinlock
	mov	QWORD PTR ?shmlock@@3PEAU_spinlock_@@EA, rax ; shmlock

; 53   : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
?AuInitialiseSHMMan@@YAXXZ ENDP				; AuInitialiseSHMMan
_TEXT	ENDS
END
