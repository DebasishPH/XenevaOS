; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30154.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

msvcjmc	SEGMENT
__B24D1420_clean@cpp DB 01H
msvcjmc	ENDS
PUBLIC	?AuProcessClean@@YAXPEAU_au_proc_@@0@Z		; AuProcessClean
PUBLIC	?FreeUserStack@@YAXPEA_KPEAX@Z			; FreeUserStack
PUBLIC	?FreeImage@@YAXPEAU_au_proc_@@@Z		; FreeImage
PUBLIC	?AuThreadFree@@YAXPEAU_au_proc_@@PEAU_au_thread_@@@Z ; AuThreadFree
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_0BD@HPPMPBCK@KStack?5freed?5?$CFs?5?$AN?6@ ; `string'
PUBLIC	??_C@_0BD@FIJNGMLN@T?9?$DOUentry?5?9?$DO?5?$CFx?5?$AN?6@ ; `string'
PUBLIC	??_C@_0BK@CDKBMGGB@cleaning?5thread?5?9?$DO?5?$CFx?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0BL@ENIMOCKM@Stack_?5?9?$DO?5?$CFx?5stack?5?9?$DO?5?$CFx?$AN?6@ ; `string'
PUBLIC	??_C@_0BL@DBDDHKKG@Thread?5user?5stack?5freed?5?$AN?6@ ; `string'
PUBLIC	??_C@_0BA@PIONPHIH@Thread?5freed?5?$AN?6@	; `string'
PUBLIC	??_C@_0P@GEKFLCGN@Uenty?5?9?$DO?5?$CFx?5?$AN?6@	; `string'
PUBLIC	??_C@_0CF@IJHMLGCN@Used?5RAM?5?9?$DO?5?$CFd?5GB?5?5Avail?5?9?$DO?5?$CFd?5@ ; `string'
PUBLIC	??_C@_0BD@FPAIDJKB@Process?5cleaned?5?$AN?6@	; `string'
EXTRN	list_remove:PROC
EXTRN	?AuThreadCleanTrash@@YAXPEAU_au_thread_@@@Z:PROC ; AuThreadCleanTrash
EXTRN	?AuRemoveProcess@@YAXPEAU_au_proc_@@0@Z:PROC	; AuRemoveProcess
EXTRN	?KernelStackFree@@YAXPEAU_au_proc_@@PEAXPEA_K@Z:PROC ; KernelStackFree
EXTRN	AuGetPhysicalAddressEx:PROC
EXTRN	AuPmmngrFree:PROC
EXTRN	P2V:PROC
EXTRN	V2P:PROC
EXTRN	?AuPmmngrGetFreeMem@@YA_KXZ:PROC		; AuPmmngrGetFreeMem
EXTRN	?AuPmmngrGetTotalMem@@YA_KXZ:PROC		; AuPmmngrGetTotalMem
EXTRN	?AuRemoveVMArea@@YAXPEAU_au_proc_@@PEAU_vm_area_@@@Z:PROC ; AuRemoveVMArea
EXTRN	?AuVMAreaGet@@YAPEAU_vm_area_@@PEAU_au_proc_@@_K@Z:PROC ; AuVMAreaGet
EXTRN	kfree:PROC
EXTRN	SeTextOut:PROC
EXTRN	__CheckForDebuggerJustMyCode:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuProcessClean@@YAXPEAU_au_proc_@@0@Z DD imagerel $LN14
	DD	imagerel $LN14+774
	DD	imagerel $unwind$?AuProcessClean@@YAXPEAU_au_proc_@@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?FreeUserStack@@YAXPEA_KPEAX@Z DD imagerel $LN7
	DD	imagerel $LN7+133
	DD	imagerel $unwind$?FreeUserStack@@YAXPEA_KPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?FreeImage@@YAXPEAU_au_proc_@@@Z DD imagerel $LN7
	DD	imagerel $LN7+211
	DD	imagerel $unwind$?FreeImage@@YAXPEAU_au_proc_@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuThreadFree@@YAXPEAU_au_proc_@@PEAU_au_thread_@@@Z DD imagerel $LN6
	DD	imagerel $LN6+280
	DD	imagerel $unwind$?AuThreadFree@@YAXPEAU_au_proc_@@PEAU_au_thread_@@@Z
pdata	ENDS
;	COMDAT ??_C@_0BD@FPAIDJKB@Process?5cleaned?5?$AN?6@
CONST	SEGMENT
??_C@_0BD@FPAIDJKB@Process?5cleaned?5?$AN?6@ DB 'Process cleaned ', 0dH, 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@IJHMLGCN@Used?5RAM?5?9?$DO?5?$CFd?5GB?5?5Avail?5?9?$DO?5?$CFd?5@
CONST	SEGMENT
??_C@_0CF@IJHMLGCN@Used?5RAM?5?9?$DO?5?$CFd?5GB?5?5Avail?5?9?$DO?5?$CFd?5@ DB 'U'
	DB	'sed RAM -> %d GB  Avail -> %d GB ', 0dH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@GEKFLCGN@Uenty?5?9?$DO?5?$CFx?5?$AN?6@
CONST	SEGMENT
??_C@_0P@GEKFLCGN@Uenty?5?9?$DO?5?$CFx?5?$AN?6@ DB 'Uenty -> %x ', 0dH, 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@PIONPHIH@Thread?5freed?5?$AN?6@
CONST	SEGMENT
??_C@_0BA@PIONPHIH@Thread?5freed?5?$AN?6@ DB 'Thread freed ', 0dH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@DBDDHKKG@Thread?5user?5stack?5freed?5?$AN?6@
CONST	SEGMENT
??_C@_0BL@DBDDHKKG@Thread?5user?5stack?5freed?5?$AN?6@ DB 'Thread user st'
	DB	'ack freed ', 0dH, 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@ENIMOCKM@Stack_?5?9?$DO?5?$CFx?5stack?5?9?$DO?5?$CFx?$AN?6@
CONST	SEGMENT
??_C@_0BL@ENIMOCKM@Stack_?5?9?$DO?5?$CFx?5stack?5?9?$DO?5?$CFx?$AN?6@ DB 'S'
	DB	'tack_ -> %x stack -> %x', 0dH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@CDKBMGGB@cleaning?5thread?5?9?$DO?5?$CFx?5?$CFs?6@
CONST	SEGMENT
??_C@_0BK@CDKBMGGB@cleaning?5thread?5?9?$DO?5?$CFx?5?$CFs?6@ DB 'cleaning'
	DB	' thread -> %x %s', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@FIJNGMLN@T?9?$DOUentry?5?9?$DO?5?$CFx?5?$AN?6@
CONST	SEGMENT
??_C@_0BD@FIJNGMLN@T?9?$DOUentry?5?9?$DO?5?$CFx?5?$AN?6@ DB 'T->Uentry ->'
	DB	' %x ', 0dH, 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@HPPMPBCK@KStack?5freed?5?$CFs?5?$AN?6@
CONST	SEGMENT
??_C@_0BD@HPPMPBCK@KStack?5freed?5?$CFs?5?$AN?6@ DB 'KStack freed %s ', 0dH
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuThreadFree@@YAXPEAU_au_proc_@@PEAU_au_thread_@@@Z DD 025031701H
	DD	0f2122317H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?FreeImage@@YAXPEAU_au_proc_@@@Z DD 025041201H
	DD	010d2312H
	DD	050060012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?FreeUserStack@@YAXPEA_KPEAX@Z DD 025031701H
	DD	0f2122317H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuProcessClean@@YAXPEAU_au_proc_@@0@Z DD 025041701H
	DD	01122317H
	DD	0500b0018H
xdata	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\clean.cpp
;	COMDAT ?AuThreadFree@@YAXPEAU_au_proc_@@PEAU_au_thread_@@@Z
_TEXT	SEGMENT
k_stack$1 = 0
k_stack_$2 = 8
k_stack$3 = 16
k_stack_$4 = 24
proc$ = 112
t$ = 120
?AuThreadFree@@YAXPEAU_au_proc_@@PEAU_au_thread_@@@Z PROC ; AuThreadFree, COMDAT

; 82   : void AuThreadFree(AuProcess* proc,AuThread* t) {

$LN6:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 128				; 00000080H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__B24D1420_clean@cpp
	call	__CheckForDebuggerJustMyCode

; 83   : 	kfree(t->fx_state);

	mov	rax, QWORD PTR t$[rbp]
	mov	rcx, QWORD PTR [rax+272]
	call	kfree

; 84   : 	/* free up the kernel stack */
; 85   : 
; 86   : 	/* if the thread is main thread, the kernel
; 87   : 	 * stack is directly allocated over physical
; 88   : 	 * memory
; 89   : 	 */
; 90   : 	if (t->priviledge & THREAD_LEVEL_MAIN_THREAD){

	mov	rax, QWORD PTR t$[rbp]
	movzx	eax, BYTE PTR [rax+311]
	and	eax, 8
	test	eax, eax
	je	SHORT $LN2@AuThreadFr

; 91   : 		/* increase k_stack by 32 bytes because, 32 bytes
; 92   : 		 * being decresed at AuLoadExecToProc function 
; 93   : 		 */
; 94   : 		uint64_t k_stack = t->frame.kern_esp + 32;

	mov	rax, QWORD PTR t$[rbp]
	mov	rax, QWORD PTR [rax+200]
	add	rax, 32					; 00000020H
	mov	QWORD PTR k_stack$1[rbp], rax

; 95   : 		uint64_t k_stack_ = k_stack - PAGE_SIZE;

	mov	rax, QWORD PTR k_stack$1[rbp]
	sub	rax, 4096				; 00001000H
	mov	QWORD PTR k_stack_$2[rbp], rax

; 96   : 		AuPmmngrFree((void*)V2P((size_t)k_stack_));

	mov	rcx, QWORD PTR k_stack_$2[rbp]
	call	V2P
	mov	rcx, rax
	call	AuPmmngrFree
$LN2@AuThreadFr:

; 97   : 	}
; 98   : 	/* if its a sub thread, kstack is allocated over
; 99   : 	 * virtual memory with an index so free it
; 100  : 	 */
; 101  : 	if (t->priviledge & THREAD_LEVEL_SUBTHREAD) {

	mov	rax, QWORD PTR t$[rbp]
	movzx	eax, BYTE PTR [rax+311]
	and	eax, 4
	test	eax, eax
	je	SHORT $LN3@AuThreadFr

; 102  : 		uint64_t k_stack = t->frame.kern_esp;

	mov	rax, QWORD PTR t$[rbp]
	mov	rax, QWORD PTR [rax+200]
	mov	QWORD PTR k_stack$3[rbp], rax

; 103  : 		uint64_t k_stack_ = k_stack - 8192;

	mov	rax, QWORD PTR k_stack$3[rbp]
	sub	rax, 8192				; 00002000H
	mov	QWORD PTR k_stack_$4[rbp], rax

; 104  : 		KernelStackFree(proc, (void*)k_stack_, proc->cr3);

	mov	rax, QWORD PTR proc$[rbp]
	mov	r8, QWORD PTR [rax+22]
	mov	rdx, QWORD PTR k_stack_$4[rbp]
	mov	rcx, QWORD PTR proc$[rbp]
	call	?KernelStackFree@@YAXPEAU_au_proc_@@PEAXPEA_K@Z ; KernelStackFree

; 105  : 		SeTextOut("KStack freed %s \r\n", t->name);

	mov	rax, QWORD PTR t$[rbp]
	add	rax, 284				; 0000011cH
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:??_C@_0BD@HPPMPBCK@KStack?5freed?5?$CFs?5?$AN?6@
	call	SeTextOut
$LN3@AuThreadFr:

; 106  : 		
; 107  : 	}
; 108  : 	if (t->uentry){

	mov	rax, QWORD PTR t$[rbp]
	cmp	QWORD PTR [rax+641], 0
	je	SHORT $LN4@AuThreadFr

; 109  : 		SeTextOut("T->Uentry -> %x \r\n", t->uentry);

	mov	rax, QWORD PTR t$[rbp]
	mov	rdx, QWORD PTR [rax+641]
	lea	rcx, OFFSET FLAT:??_C@_0BD@FIJNGMLN@T?9?$DOUentry?5?9?$DO?5?$CFx?5?$AN?6@
	call	SeTextOut

; 110  : 		kfree(t->uentry);

	mov	rax, QWORD PTR t$[rbp]
	mov	rcx, QWORD PTR [rax+641]
	call	kfree
$LN4@AuThreadFr:

; 111  : 	}
; 112  : 	kfree(t);

	mov	rcx, QWORD PTR t$[rbp]
	call	kfree

; 113  : }

	lea	rsp, QWORD PTR [rbp+96]
	pop	rbp
	ret	0
?AuThreadFree@@YAXPEAU_au_proc_@@PEAU_au_thread_@@@Z ENDP ; AuThreadFree
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\clean.cpp
;	COMDAT ?FreeImage@@YAXPEAU_au_proc_@@@Z
_TEXT	SEGMENT
i$1 = 0
phys$2 = 8
physical_address$3 = 16
image_area$ = 24
tv65 = 96
proc$ = 128
?FreeImage@@YAXPEAU_au_proc_@@@Z PROC			; FreeImage, COMDAT

; 64   : void FreeImage(AuProcess* proc) {

$LN7:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 144				; 00000090H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__B24D1420_clean@cpp
	call	__CheckForDebuggerJustMyCode

; 65   : 	/* Unmap the process image */
; 66   : 	for (uint32_t i = 0; i < proc->_image_size_ / 4096 + 1; i++) {

	mov	DWORD PTR i$1[rbp], 0
	jmp	SHORT $LN4@FreeImage
$LN2@FreeImage:
	mov	eax, DWORD PTR i$1[rbp]
	inc	eax
	mov	DWORD PTR i$1[rbp], eax
$LN4@FreeImage:
	mov	eax, DWORD PTR i$1[rbp]
	mov	QWORD PTR tv65[rbp], rax
	xor	edx, edx
	mov	rcx, QWORD PTR proc$[rbp]
	mov	rax, QWORD PTR [rcx+30]
	mov	ecx, 4096				; 00001000H
	div	rcx
	inc	rax
	mov	rcx, QWORD PTR tv65[rbp]
	cmp	rcx, rax
	jae	SHORT $LN3@FreeImage

; 67   : 		void* phys = AuGetPhysicalAddressEx(proc->cr3, proc->_image_base_ + static_cast<uint64_t>(i) * 4096);

	mov	eax, DWORD PTR i$1[rbp]
	imul	rax, rax, 4096				; 00001000H
	mov	rcx, QWORD PTR proc$[rbp]
	add	rax, QWORD PTR [rcx+38]
	mov	rdx, rax
	mov	rax, QWORD PTR proc$[rbp]
	mov	rcx, QWORD PTR [rax+22]
	call	AuGetPhysicalAddressEx
	mov	QWORD PTR phys$2[rbp], rax

; 68   : 		uint64_t physical_address = (uint64_t)V2P((uint64_t)phys);

	mov	rcx, QWORD PTR phys$2[rbp]
	call	V2P
	mov	QWORD PTR physical_address$3[rbp], rax

; 69   : 		if (physical_address != 0)

	cmp	QWORD PTR physical_address$3[rbp], 0
	je	SHORT $LN5@FreeImage

; 70   : 			AuPmmngrFree((void*)physical_address);

	mov	rcx, QWORD PTR physical_address$3[rbp]
	call	AuPmmngrFree
$LN5@FreeImage:

; 71   : 	}

	jmp	SHORT $LN2@FreeImage
$LN3@FreeImage:

; 72   : 
; 73   : 	AuVMArea *image_area = AuVMAreaGet(proc, proc->_image_base_);

	mov	rax, QWORD PTR proc$[rbp]
	mov	rdx, QWORD PTR [rax+38]
	mov	rcx, QWORD PTR proc$[rbp]
	call	?AuVMAreaGet@@YAPEAU_vm_area_@@PEAU_au_proc_@@_K@Z ; AuVMAreaGet
	mov	QWORD PTR image_area$[rbp], rax

; 74   : 	AuRemoveVMArea(proc, image_area);

	mov	rdx, QWORD PTR image_area$[rbp]
	mov	rcx, QWORD PTR proc$[rbp]
	call	?AuRemoveVMArea@@YAXPEAU_au_proc_@@PEAU_vm_area_@@@Z ; AuRemoveVMArea

; 75   : }

	lea	rsp, QWORD PTR [rbp+112]
	pop	rbp
	ret	0
?FreeImage@@YAXPEAU_au_proc_@@@Z ENDP			; FreeImage
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\clean.cpp
;	COMDAT ?FreeUserStack@@YAXPEA_KPEAX@Z
_TEXT	SEGMENT
location$ = 0
i$1 = 8
addr$2 = 16
physaddr$3 = 24
cr3$ = 112
ptr$ = 120
?FreeUserStack@@YAXPEA_KPEAX@Z PROC			; FreeUserStack, COMDAT

; 48   : void FreeUserStack(uint64_t* cr3, void* ptr) {

$LN7:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 128				; 00000080H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__B24D1420_clean@cpp
	call	__CheckForDebuggerJustMyCode

; 49   : 	uint64_t location = (uint64_t)ptr;

	mov	rax, QWORD PTR ptr$[rbp]
	mov	QWORD PTR location$[rbp], rax

; 50   : 
; 51   : 	for (int i = 0; i < PROCESS_USER_STACK_SZ / 4096; i++) {

	mov	DWORD PTR i$1[rbp], 0
	jmp	SHORT $LN4@FreeUserSt
$LN2@FreeUserSt:
	mov	eax, DWORD PTR i$1[rbp]
	inc	eax
	mov	DWORD PTR i$1[rbp], eax
$LN4@FreeUserSt:
	cmp	DWORD PTR i$1[rbp], 128			; 00000080H
	jge	SHORT $LN3@FreeUserSt

; 52   : 		void* addr = AuGetPhysicalAddressEx(cr3, + static_cast<uint64_t>(i) * 4096);

	movsxd	rax, DWORD PTR i$1[rbp]
	imul	rax, rax, 4096				; 00001000H
	mov	rdx, rax
	mov	rcx, QWORD PTR cr3$[rbp]
	call	AuGetPhysicalAddressEx
	mov	QWORD PTR addr$2[rbp], rax

; 53   : 		uint64_t physaddr = (uint64_t)V2P((uint64_t)addr);

	mov	rcx, QWORD PTR addr$2[rbp]
	call	V2P
	mov	QWORD PTR physaddr$3[rbp], rax

; 54   : 		if (physaddr != 0)

	cmp	QWORD PTR physaddr$3[rbp], 0
	je	SHORT $LN5@FreeUserSt

; 55   : 			AuPmmngrFree((void*)physaddr);

	mov	rcx, QWORD PTR physaddr$3[rbp]
	call	AuPmmngrFree
$LN5@FreeUserSt:

; 56   : 	}

	jmp	SHORT $LN2@FreeUserSt
$LN3@FreeUserSt:

; 57   : }

	lea	rsp, QWORD PTR [rbp+96]
	pop	rbp
	ret	0
?FreeUserStack@@YAXPEA_KPEAX@Z ENDP			; FreeUserStack
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\clean.cpp
;	COMDAT ?AuProcessClean@@YAXPEAU_au_proc_@@0@Z
_TEXT	SEGMENT
id$ = 0
stack_$ = 8
i$1 = 16
area$2 = 24
i$3 = 32
t_$4 = 40
entry$5 = 48
stack$6 = 56
stack_$7 = 64
uentry$ = 72
phys$8 = 80
tv174 = 152
parent$ = 176
killable$ = 184
?AuProcessClean@@YAXPEAU_au_proc_@@0@Z PROC		; AuProcessClean, COMDAT

; 121  : void AuProcessClean(AuProcess* parent, AuProcess* killable) {

$LN14:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 192				; 000000c0H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__B24D1420_clean@cpp
	call	__CheckForDebuggerJustMyCode

; 122  : 	int id = killable->proc_id;

	mov	rax, QWORD PTR killable$[rbp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR id$[rbp], eax

; 123  : 	
; 124  : 	uint64_t stack_ = killable->_main_stack_ - PROCESS_USER_STACK_SZ;

	mov	rax, QWORD PTR killable$[rbp]
	mov	rax, QWORD PTR [rax+46]
	sub	rax, 524288				; 00080000H
	mov	QWORD PTR stack_$[rbp], rax

; 125  : 	FreeUserStack(killable->cr3,(void*)stack_);

	mov	rdx, QWORD PTR stack_$[rbp]
	mov	rax, QWORD PTR killable$[rbp]
	mov	rcx, QWORD PTR [rax+22]
	call	?FreeUserStack@@YAXPEA_KPEAX@Z		; FreeUserStack

; 126  : 	/* free up shm mappings */
; 127  : 
; 128  : 	/* free up image base + image size*/
; 129  : 	FreeImage(killable);

	mov	rcx, QWORD PTR killable$[rbp]
	call	?FreeImage@@YAXPEAU_au_proc_@@@Z	; FreeImage

; 130  : 
; 131  : 	/* free up vmareas */
; 132  : 	for (int i = 0; i < killable->vmareas->pointer; i++) {

	mov	DWORD PTR i$1[rbp], 0
	jmp	SHORT $LN4@AuProcessC
$LN2@AuProcessC:
	mov	eax, DWORD PTR i$1[rbp]
	inc	eax
	mov	DWORD PTR i$1[rbp], eax
$LN4@AuProcessC:
	mov	rax, QWORD PTR killable$[rbp]
	mov	rax, QWORD PTR [rax+1063]
	mov	eax, DWORD PTR [rax]
	cmp	DWORD PTR i$1[rbp], eax
	jae	SHORT $LN3@AuProcessC

; 133  : 		AuVMArea* area = (AuVMArea*)list_remove(killable->vmareas, i);

	mov	edx, DWORD PTR i$1[rbp]
	mov	rax, QWORD PTR killable$[rbp]
	mov	rcx, QWORD PTR [rax+1063]
	call	list_remove
	mov	QWORD PTR area$2[rbp], rax

; 134  : 		if (area)

	cmp	QWORD PTR area$2[rbp], 0
	je	SHORT $LN8@AuProcessC

; 135  : 			kfree(area);

	mov	rcx, QWORD PTR area$2[rbp]
	call	kfree
$LN8@AuProcessC:

; 136  : 	}

	jmp	SHORT $LN2@AuProcessC
$LN3@AuProcessC:

; 137  : 	kfree(killable->vmareas);

	mov	rax, QWORD PTR killable$[rbp]
	mov	rcx, QWORD PTR [rax+1063]
	call	kfree

; 138  : 
; 139  : 
; 140  : 	/* finally free up all threads */
; 141  : 	for (int i = 1; i < MAX_THREADS_PER_PROCESS -1 ; i++) {

	mov	DWORD PTR i$3[rbp], 1
	jmp	SHORT $LN7@AuProcessC
$LN5@AuProcessC:
	mov	eax, DWORD PTR i$3[rbp]
	inc	eax
	mov	DWORD PTR i$3[rbp], eax
$LN7@AuProcessC:
	cmp	DWORD PTR i$3[rbp], 59			; 0000003bH
	jge	$LN6@AuProcessC

; 142  : 		AuThread *t_ = killable->threads[i];

	movsxd	rax, DWORD PTR i$3[rbp]
	mov	rcx, QWORD PTR killable$[rbp]
	mov	rax, QWORD PTR [rcx+rax*8+87]
	mov	QWORD PTR t_$4[rbp], rax

; 143  : 		if (t_) {

	cmp	QWORD PTR t_$4[rbp], 0
	je	$LN9@AuProcessC

; 144  : 			SeTextOut("cleaning thread -> %x %s\n", t_, t_->name);

	mov	rax, QWORD PTR t_$4[rbp]
	add	rax, 284				; 0000011cH
	mov	r8, rax
	mov	rdx, QWORD PTR t_$4[rbp]
	lea	rcx, OFFSET FLAT:??_C@_0BK@CDKBMGGB@cleaning?5thread?5?9?$DO?5?$CFx?5?$CFs?6@
	call	SeTextOut

; 145  : 			AuThreadCleanTrash(t_);

	mov	rcx, QWORD PTR t_$4[rbp]
	call	?AuThreadCleanTrash@@YAXPEAU_au_thread_@@@Z ; AuThreadCleanTrash

; 146  : 			AuUserEntry* entry = t_->uentry;

	mov	rax, QWORD PTR t_$4[rbp]
	mov	rax, QWORD PTR [rax+641]
	mov	QWORD PTR entry$5[rbp], rax

; 147  : 			if (entry) {

	cmp	QWORD PTR entry$5[rbp], 0
	je	SHORT $LN10@AuProcessC

; 148  : 				uint64_t stack = entry->stackBase + 32;

	mov	rax, QWORD PTR entry$5[rbp]
	mov	rax, QWORD PTR [rax+52]
	add	rax, 32					; 00000020H
	mov	QWORD PTR stack$6[rbp], rax

; 149  : 				uint64_t stack_ = stack - PROCESS_USER_STACK_SZ;

	mov	rax, QWORD PTR stack$6[rbp]
	sub	rax, 524288				; 00080000H
	mov	QWORD PTR stack_$7[rbp], rax

; 150  : 				SeTextOut("Stack_ -> %x stack -> %x\r\n", stack_, stack);

	mov	r8, QWORD PTR stack$6[rbp]
	mov	rdx, QWORD PTR stack_$7[rbp]
	lea	rcx, OFFSET FLAT:??_C@_0BL@ENIMOCKM@Stack_?5?9?$DO?5?$CFx?5stack?5?9?$DO?5?$CFx?$AN?6@
	call	SeTextOut

; 151  : 				FreeUserStack(killable->cr3, (void*)stack_);

	mov	rdx, QWORD PTR stack_$7[rbp]
	mov	rax, QWORD PTR killable$[rbp]
	mov	rcx, QWORD PTR [rax+22]
	call	?FreeUserStack@@YAXPEA_KPEAX@Z		; FreeUserStack

; 152  : 				killable->_user_stack_index_ -= PROCESS_USER_STACK_SZ;

	mov	rax, QWORD PTR killable$[rbp]
	mov	rax, QWORD PTR [rax+54]
	sub	rax, 524288				; 00080000H
	mov	rcx, QWORD PTR killable$[rbp]
	mov	QWORD PTR [rcx+54], rax
$LN10@AuProcessC:

; 153  : 			}
; 154  : 			SeTextOut("Thread user stack freed \r\n");

	lea	rcx, OFFSET FLAT:??_C@_0BL@DBDDHKKG@Thread?5user?5stack?5freed?5?$AN?6@
	call	SeTextOut

; 155  : 			AuThreadFree(killable, t_);

	mov	rdx, QWORD PTR t_$4[rbp]
	mov	rcx, QWORD PTR killable$[rbp]
	call	?AuThreadFree@@YAXPEAU_au_proc_@@PEAU_au_thread_@@@Z ; AuThreadFree

; 156  : 			SeTextOut("Thread freed \r\n");

	lea	rcx, OFFSET FLAT:??_C@_0BA@PIONPHIH@Thread?5freed?5?$AN?6@
	call	SeTextOut
$LN9@AuProcessC:

; 157  : 		}
; 158  : 	}

	jmp	$LN5@AuProcessC
$LN6@AuProcessC:

; 159  : 
; 160  : 	AuUserEntry* uentry = killable->main_thread->uentry;

	mov	rax, QWORD PTR killable$[rbp]
	mov	rax, QWORD PTR [rax+70]
	mov	rax, QWORD PTR [rax+641]
	mov	QWORD PTR uentry$[rbp], rax

; 161  : 	SeTextOut("Uenty -> %x \r\n", uentry);

	mov	rdx, QWORD PTR uentry$[rbp]
	lea	rcx, OFFSET FLAT:??_C@_0P@GEKFLCGN@Uenty?5?9?$DO?5?$CFx?5?$AN?6@
	call	SeTextOut

; 162  : 	if (uentry->argvaddr != 0) {

	mov	rax, QWORD PTR uentry$[rbp]
	cmp	QWORD PTR [rax+36], 0
	je	SHORT $LN11@AuProcessC

; 163  : 		void* phys = AuGetPhysicalAddressEx(killable->cr3, 0x4000);

	mov	edx, 16384				; 00004000H
	mov	rax, QWORD PTR killable$[rbp]
	mov	rcx, QWORD PTR [rax+22]
	call	AuGetPhysicalAddressEx
	mov	QWORD PTR phys$8[rbp], rax

; 164  : 		if (phys) {

	cmp	QWORD PTR phys$8[rbp], 0
	je	SHORT $LN12@AuProcessC

; 165  : 			AuPmmngrFree((void*)P2V((size_t)phys));

	mov	rcx, QWORD PTR phys$8[rbp]
	call	P2V
	mov	rcx, rax
	call	AuPmmngrFree
$LN12@AuProcessC:
$LN11@AuProcessC:

; 166  : 		}
; 167  : 	}
; 168  : 
; 169  : 	/* clean the main thread externally*/
; 170  : 	AuThreadCleanTrash(killable->main_thread);

	mov	rax, QWORD PTR killable$[rbp]
	mov	rcx, QWORD PTR [rax+70]
	call	?AuThreadCleanTrash@@YAXPEAU_au_thread_@@@Z ; AuThreadCleanTrash

; 171  : 	AuThreadFree(killable, killable->main_thread);

	mov	rax, QWORD PTR killable$[rbp]
	mov	rdx, QWORD PTR [rax+70]
	mov	rcx, QWORD PTR killable$[rbp]
	call	?AuThreadFree@@YAXPEAU_au_proc_@@PEAU_au_thread_@@@Z ; AuThreadFree

; 172  : 
; 173  : 	/* release the process slot */
; 174  : 
; 175  : 	AuPmmngrFree((void*)V2P((size_t)killable->cr3));

	mov	rax, QWORD PTR killable$[rbp]
	mov	rcx, QWORD PTR [rax+22]
	call	V2P
	mov	rcx, rax
	call	AuPmmngrFree

; 176  : 	AuRemoveProcess(0, killable);

	mov	rdx, QWORD PTR killable$[rbp]
	xor	ecx, ecx
	call	?AuRemoveProcess@@YAXPEAU_au_proc_@@0@Z	; AuRemoveProcess

; 177  : 	SeTextOut("Used RAM -> %d GB \ Avail -> %d GB \r\n", ((AuPmmngrGetFreeMem() * PAGE_SIZE) / 1024 / 1024 / 1024),

	call	?AuPmmngrGetTotalMem@@YA_KXZ		; AuPmmngrGetTotalMem
	imul	rax, rax, 4096				; 00001000H
	xor	edx, edx
	mov	ecx, 1024				; 00000400H
	div	rcx
	xor	edx, edx
	mov	ecx, 1024				; 00000400H
	div	rcx
	xor	edx, edx
	mov	ecx, 1024				; 00000400H
	div	rcx
	mov	QWORD PTR tv174[rbp], rax
	call	?AuPmmngrGetFreeMem@@YA_KXZ		; AuPmmngrGetFreeMem
	imul	rax, rax, 4096				; 00001000H
	xor	edx, edx
	mov	ecx, 1024				; 00000400H
	div	rcx
	xor	edx, edx
	mov	ecx, 1024				; 00000400H
	div	rcx
	xor	edx, edx
	mov	ecx, 1024				; 00000400H
	div	rcx
	mov	rcx, QWORD PTR tv174[rbp]
	mov	r8, rcx
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:??_C@_0CF@IJHMLGCN@Used?5RAM?5?9?$DO?5?$CFd?5GB?5?5Avail?5?9?$DO?5?$CFd?5@
	call	SeTextOut

; 178  : 		(AuPmmngrGetTotalMem() * PAGE_SIZE / 1024 / 1024 / 1024));
; 179  : 	SeTextOut("Process cleaned \r\n");

	lea	rcx, OFFSET FLAT:??_C@_0BD@FPAIDJKB@Process?5cleaned?5?$AN?6@
	call	SeTextOut

; 180  : }

	lea	rsp, QWORD PTR [rbp+160]
	pop	rbp
	ret	0
?AuProcessClean@@YAXPEAU_au_proc_@@0@Z ENDP		; AuProcessClean
_TEXT	ENDS
END
