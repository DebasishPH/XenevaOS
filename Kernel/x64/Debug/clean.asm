; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.21005.1 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG3859	DB	'Kernel Panic!! ', 0aH, 00H
	ORG $+7
$SG3860	DB	'Root process returned null ', 0aH, 00H
	ORG $+3
$SG3881	DB	'Process cleaned ', 0dH, 0aH, 00H
CONST	ENDS
PUBLIC	?AuProcessClean@@YAXPEAU_au_proc_@@0@Z		; AuProcessClean
PUBLIC	?FreeUserStack@@YAXPEA_K@Z			; FreeUserStack
PUBLIC	?FreeImage@@YAXPEAU_au_proc_@@@Z		; FreeImage
PUBLIC	?AuThreadFree@@YAXPEAU_au_thread_@@@Z		; AuThreadFree
EXTRN	list_remove:PROC
EXTRN	list_get_at:PROC
EXTRN	?AuThreadCleanTrash@@YAXPEAU_au_thread_@@@Z:PROC ; AuThreadCleanTrash
EXTRN	?AuAddProcess@@YAXPEAU_au_proc_@@0@Z:PROC	; AuAddProcess
EXTRN	?AuGetRootProcess@@YAPEAU_au_proc_@@XZ:PROC	; AuGetRootProcess
EXTRN	AuGetPhysicalAddressEx:PROC
EXTRN	AuPmmngrFree:PROC
EXTRN	P2V:PROC
EXTRN	V2P:PROC
EXTRN	?AuRemoveVMArea@@YAXPEAU_au_proc_@@PEAU_vm_area_@@@Z:PROC ; AuRemoveVMArea
EXTRN	?AuVMAreaGet@@YAPEAU_vm_area_@@PEAU_au_proc_@@_K@Z:PROC ; AuVMAreaGet
EXTRN	kfree:PROC
EXTRN	AuTextOut:PROC
EXTRN	SeTextOut:PROC
EXTRN	AuAcquireMutex:PROC
EXTRN	AuReleaseMutex:PROC
EXTRN	?AuLoaderGetMutex@@YAPEAU_mutex_@@XZ:PROC	; AuLoaderGetMutex
pdata	SEGMENT
$pdata$?AuProcessClean@@YAXPEAU_au_proc_@@0@Z DD imagerel $LN28
	DD	imagerel $LN28+940
	DD	imagerel $unwind$?AuProcessClean@@YAXPEAU_au_proc_@@0@Z
$pdata$?FreeUserStack@@YAXPEA_K@Z DD imagerel $LN6
	DD	imagerel $LN6+104
	DD	imagerel $unwind$?FreeUserStack@@YAXPEA_K@Z
$pdata$?FreeImage@@YAXPEAU_au_proc_@@@Z DD imagerel $LN7
	DD	imagerel $LN7+190
	DD	imagerel $unwind$?FreeImage@@YAXPEAU_au_proc_@@@Z
$pdata$?AuThreadFree@@YAXPEAU_au_thread_@@@Z DD imagerel $LN3
	DD	imagerel $LN3+106
	DD	imagerel $unwind$?AuThreadFree@@YAXPEAU_au_thread_@@@Z
pdata	ENDS
xdata	SEGMENT
$unwind$?AuProcessClean@@YAXPEAU_au_proc_@@0@Z DD 021101H
	DD	0110111H
$unwind$?FreeUserStack@@YAXPEA_K@Z DD 010901H
	DD	08209H
$unwind$?FreeImage@@YAXPEAU_au_proc_@@@Z DD 010901H
	DD	0a209H
$unwind$?AuThreadFree@@YAXPEAU_au_thread_@@@Z DD 010901H
	DD	06209H
xdata	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\clean.cpp
_TEXT	SEGMENT
k_stack$ = 32
k_stack_$ = 40
t$ = 64
?AuThreadFree@@YAXPEAU_au_thread_@@@Z PROC		; AuThreadFree

; 80   : void AuThreadFree(AuThread* t) {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 81   : 	kfree(t->fx_state);

	mov	rax, QWORD PTR t$[rsp]
	mov	rcx, QWORD PTR [rax+272]
	call	kfree

; 82   : 
; 83   : 	/* free up the kernel stack */
; 84   : 	uint64_t k_stack = t->frame.rsp;

	mov	rax, QWORD PTR t$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR k_stack$[rsp], rax

; 85   : 	uint64_t k_stack_ = k_stack - PAGE_SIZE;

	mov	rax, QWORD PTR k_stack$[rsp]
	sub	rax, 4096				; 00001000H
	mov	QWORD PTR k_stack_$[rsp], rax

; 86   : 	AuPmmngrFree((void*)V2P((size_t)k_stack_));

	mov	rcx, QWORD PTR k_stack_$[rsp]
	call	V2P
	mov	rcx, rax
	call	AuPmmngrFree

; 87   : 
; 88   : 	kfree(t->uentry);

	mov	rax, QWORD PTR t$[rsp]
	mov	rcx, QWORD PTR [rax+306]
	call	kfree

; 89   : 	kfree(t);

	mov	rcx, QWORD PTR t$[rsp]
	call	kfree

; 90   : }

	add	rsp, 56					; 00000038H
	ret	0
?AuThreadFree@@YAXPEAU_au_thread_@@@Z ENDP		; AuThreadFree
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\clean.cpp
_TEXT	SEGMENT
i$1 = 32
physical_address$2 = 40
tv65 = 48
phys$3 = 56
image_area$ = 64
proc$ = 96
?FreeImage@@YAXPEAU_au_proc_@@@Z PROC			; FreeImage

; 62   : void FreeImage(AuProcess* proc) {

$LN7:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 63   : 	/* Unmap the process image */
; 64   : 	for (uint32_t i = 0; i < proc->_image_size_ / 4096 + 1; i++) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN4@FreeImage
$LN3@FreeImage:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN4@FreeImage:
	mov	eax, DWORD PTR i$1[rsp]
	mov	QWORD PTR tv65[rsp], rax
	xor	edx, edx
	mov	rcx, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rcx+22]
	mov	ecx, 4096				; 00001000H
	div	rcx
	inc	rax
	mov	rcx, QWORD PTR tv65[rsp]
	cmp	rcx, rax
	jae	SHORT $LN2@FreeImage

; 65   : 		void* phys = AuGetPhysicalAddressEx(proc->cr3, proc->_image_base_ + i * 4096);

	imul	eax, DWORD PTR i$1[rsp], 4096		; 00001000H
	mov	eax, eax
	mov	rcx, QWORD PTR proc$[rsp]
	add	rax, QWORD PTR [rcx+30]
	mov	rdx, rax
	mov	rax, QWORD PTR proc$[rsp]
	mov	rcx, QWORD PTR [rax+14]
	call	AuGetPhysicalAddressEx
	mov	QWORD PTR phys$3[rsp], rax

; 66   : 		uint64_t physical_address = (uint64_t)V2P((uint64_t)phys);

	mov	rcx, QWORD PTR phys$3[rsp]
	call	V2P
	mov	QWORD PTR physical_address$2[rsp], rax

; 67   : 		if (physical_address != 0)

	cmp	QWORD PTR physical_address$2[rsp], 0
	je	SHORT $LN1@FreeImage

; 68   : 			AuPmmngrFree((void*)physical_address);

	mov	rcx, QWORD PTR physical_address$2[rsp]
	call	AuPmmngrFree
$LN1@FreeImage:

; 69   : 	}

	jmp	SHORT $LN3@FreeImage
$LN2@FreeImage:

; 70   : 
; 71   : 	AuVMArea *image_area = AuVMAreaGet(proc, proc->_image_base_);

	mov	rax, QWORD PTR proc$[rsp]
	mov	rdx, QWORD PTR [rax+30]
	mov	rcx, QWORD PTR proc$[rsp]
	call	?AuVMAreaGet@@YAPEAU_vm_area_@@PEAU_au_proc_@@_K@Z ; AuVMAreaGet
	mov	QWORD PTR image_area$[rsp], rax

; 72   : 	AuRemoveVMArea(proc, image_area);

	mov	rdx, QWORD PTR image_area$[rsp]
	mov	rcx, QWORD PTR proc$[rsp]
	call	?AuRemoveVMArea@@YAXPEAU_au_proc_@@PEAU_vm_area_@@@Z ; AuRemoveVMArea

; 73   : }

	add	rsp, 88					; 00000058H
	ret	0
?FreeImage@@YAXPEAU_au_proc_@@@Z ENDP			; FreeImage
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\clean.cpp
_TEXT	SEGMENT
i$1 = 32
addr$2 = 40
location$ = 48
cr3$ = 80
?FreeUserStack@@YAXPEA_K@Z PROC				; FreeUserStack

; 47   : void FreeUserStack(uint64_t* cr3) {

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 48   : #define USER_STACK 0x0000700000000000 
; 49   : 	uint64_t location = USER_STACK;

	mov	rax, 123145302310912			; 0000700000000000H
	mov	QWORD PTR location$[rsp], rax

; 50   : 
; 51   : 	for (int i = 0; i < PROCESS_USER_STACK_SZ / 4096; i++) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN3@FreeUserSt
$LN2@FreeUserSt:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN3@FreeUserSt:
	cmp	DWORD PTR i$1[rsp], 64			; 00000040H
	jge	SHORT $LN1@FreeUserSt

; 52   : 		void* addr = AuGetPhysicalAddressEx(cr3, + i * 4096);

	imul	eax, DWORD PTR i$1[rsp], 4096		; 00001000H
	cdqe
	mov	rdx, rax
	mov	rcx, QWORD PTR cr3$[rsp]
	call	AuGetPhysicalAddressEx
	mov	QWORD PTR addr$2[rsp], rax

; 53   : 		AuPmmngrFree((void*)V2P((size_t)addr));

	mov	rcx, QWORD PTR addr$2[rsp]
	call	V2P
	mov	rcx, rax
	call	AuPmmngrFree

; 54   : 	}

	jmp	SHORT $LN2@FreeUserSt
$LN1@FreeUserSt:

; 55   : }

	add	rsp, 72					; 00000048H
	ret	0
?FreeUserStack@@YAXPEA_K@Z ENDP				; FreeUserStack
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\clean.cpp
_TEXT	SEGMENT
i$1 = 32
i$2 = 36
i$3 = 40
i$4 = 44
i$5 = 48
proc_$6 = 56
t_$7 = 64
root_proc$ = 72
mut$ = 80
phys$8 = 88
area$9 = 96
num_pages$10 = 104
phys$ = 112
proc_$11 = 120
parent$ = 144
killable$ = 152
?AuProcessClean@@YAXPEAU_au_proc_@@0@Z PROC		; AuProcessClean

; 98   : void AuProcessClean(AuProcess* parent, AuProcess* killable) {

$LN28:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 136				; 00000088H

; 99   : 	AuMutex *mut = AuLoaderGetMutex();

	call	?AuLoaderGetMutex@@YAPEAU_mutex_@@XZ	; AuLoaderGetMutex
	mov	QWORD PTR mut$[rsp], rax

; 100  : 	AuAcquireMutex(mut);

	mov	rcx, QWORD PTR mut$[rsp]
	call	AuAcquireMutex

; 101  : 
; 102  : 	FreeUserStack(killable->cr3);

	mov	rax, QWORD PTR killable$[rsp]
	mov	rcx, QWORD PTR [rax+14]
	call	?FreeUserStack@@YAXPEA_K@Z		; FreeUserStack

; 103  : 	/* free up shm mappings */
; 104  : 
; 105  : 	/* free up image base + image size*/
; 106  : 	FreeImage(killable);

	mov	rcx, QWORD PTR killable$[rsp]
	call	?FreeImage@@YAXPEAU_au_proc_@@@Z	; FreeImage

; 107  : 
; 108  : 	/* free up vmareas */
; 109  : 	for (int i = 0; i < killable->vmareas->pointer; i++) {

	mov	DWORD PTR i$5[rsp], 0
	jmp	SHORT $LN25@AuProcessC
$LN24@AuProcessC:
	mov	eax, DWORD PTR i$5[rsp]
	inc	eax
	mov	DWORD PTR i$5[rsp], eax
$LN25@AuProcessC:
	mov	rax, QWORD PTR killable$[rsp]
	mov	rax, QWORD PTR [rax+1055]
	mov	eax, DWORD PTR [rax]
	cmp	DWORD PTR i$5[rsp], eax
	jae	SHORT $LN23@AuProcessC

; 110  : 		AuVMArea* area = (AuVMArea*)list_get_at(killable->vmareas, i);

	mov	edx, DWORD PTR i$5[rsp]
	mov	rax, QWORD PTR killable$[rsp]
	mov	rcx, QWORD PTR [rax+1055]
	call	list_get_at
	mov	QWORD PTR area$9[rsp], rax

; 111  : 		if (!area)

	cmp	QWORD PTR area$9[rsp], 0
	jne	SHORT $LN22@AuProcessC

; 112  : 			kfree(area);

	mov	rcx, QWORD PTR area$9[rsp]
	call	kfree
$LN22@AuProcessC:

; 113  : 	}

	jmp	SHORT $LN24@AuProcessC
$LN23@AuProcessC:

; 114  : 	kfree(killable->vmareas);

	mov	rax, QWORD PTR killable$[rsp]
	mov	rcx, QWORD PTR [rax+1055]
	call	kfree

; 115  : 
; 116  : 	/* free up process heap memory */
; 117  : 	if (killable->proc_mem_heap > PROCESS_BREAK_ADDRESS) {

	mov	rax, QWORD PTR killable$[rsp]
	cmp	QWORD PTR [rax+1079], 805306368		; 30000000H
	jbe	$LN21@AuProcessC

; 118  : 		size_t num_pages = (killable->proc_mem_heap - PROCESS_BREAK_ADDRESS) / PAGE_SIZE;

	mov	rax, QWORD PTR killable$[rsp]
	mov	rax, QWORD PTR [rax+1079]
	sub	rax, 805306368				; 30000000H
	xor	edx, edx
	mov	ecx, 4096				; 00001000H
	div	rcx
	mov	QWORD PTR num_pages$10[rsp], rax

; 119  : 		for (int i = 0; i < num_pages; i++) {

	mov	DWORD PTR i$2[rsp], 0
	jmp	SHORT $LN20@AuProcessC
$LN19@AuProcessC:
	mov	eax, DWORD PTR i$2[rsp]
	inc	eax
	mov	DWORD PTR i$2[rsp], eax
$LN20@AuProcessC:
	movsxd	rax, DWORD PTR i$2[rsp]
	cmp	rax, QWORD PTR num_pages$10[rsp]
	jae	SHORT $LN18@AuProcessC

; 120  : 			void* phys = AuGetPhysicalAddressEx(killable->cr3, PROCESS_BREAK_ADDRESS + i * PAGE_SIZE);

	imul	eax, DWORD PTR i$2[rsp], 4096		; 00001000H
	add	eax, 805306368				; 30000000H
	cdqe
	mov	rdx, rax
	mov	rax, QWORD PTR killable$[rsp]
	mov	rcx, QWORD PTR [rax+14]
	call	AuGetPhysicalAddressEx
	mov	QWORD PTR phys$8[rsp], rax

; 121  : 			if (phys)

	cmp	QWORD PTR phys$8[rsp], 0
	je	SHORT $LN17@AuProcessC

; 122  : 				AuPmmngrFree((void*)V2P((uint64_t)phys));

	mov	rcx, QWORD PTR phys$8[rsp]
	call	V2P
	mov	rcx, rax
	call	AuPmmngrFree
$LN17@AuProcessC:

; 123  : 		}

	jmp	SHORT $LN19@AuProcessC
$LN18@AuProcessC:
$LN21@AuProcessC:

; 124  : 	}
; 125  : 
; 126  : 	/* finally free up all threads */
; 127  : 	for (int i = 1; i < MAX_THREADS_PER_PROCESS -1 ; i++) {

	mov	DWORD PTR i$3[rsp], 1
	jmp	SHORT $LN16@AuProcessC
$LN15@AuProcessC:
	mov	eax, DWORD PTR i$3[rsp]
	inc	eax
	mov	DWORD PTR i$3[rsp], eax
$LN16@AuProcessC:
	cmp	DWORD PTR i$3[rsp], 59			; 0000003bH
	jge	SHORT $LN14@AuProcessC

; 128  : 		AuThread *t_ = killable->threads[i];

	movsxd	rax, DWORD PTR i$3[rsp]
	mov	rcx, QWORD PTR killable$[rsp]
	mov	rax, QWORD PTR [rcx+rax*8+63]
	mov	QWORD PTR t_$7[rsp], rax

; 129  : 		if (t_) {

	cmp	QWORD PTR t_$7[rsp], 0
	je	SHORT $LN13@AuProcessC

; 130  : 			AuThreadCleanTrash(t_);

	mov	rcx, QWORD PTR t_$7[rsp]
	call	?AuThreadCleanTrash@@YAXPEAU_au_thread_@@@Z ; AuThreadCleanTrash

; 131  : 			AuThreadFree(t_);

	mov	rcx, QWORD PTR t_$7[rsp]
	call	?AuThreadFree@@YAXPEAU_au_thread_@@@Z	; AuThreadFree
$LN13@AuProcessC:

; 132  : 		}
; 133  : 	}

	jmp	SHORT $LN15@AuProcessC
$LN14@AuProcessC:

; 134  : 
; 135  : 	void* phys = AuGetPhysicalAddressEx(killable->cr3, 0x4000);

	mov	edx, 16384				; 00004000H
	mov	rax, QWORD PTR killable$[rsp]
	mov	rcx, QWORD PTR [rax+14]
	call	AuGetPhysicalAddressEx
	mov	QWORD PTR phys$[rsp], rax

; 136  : 	AuPmmngrFree((void*)P2V((size_t)phys));

	mov	rcx, QWORD PTR phys$[rsp]
	call	P2V
	mov	rcx, rax
	call	AuPmmngrFree

; 137  : 
; 138  : 	/* clean the main thread externally*/
; 139  : 	AuThreadCleanTrash(killable->main_thread);

	mov	rax, QWORD PTR killable$[rsp]
	mov	rcx, QWORD PTR [rax+46]
	call	?AuThreadCleanTrash@@YAXPEAU_au_thread_@@@Z ; AuThreadCleanTrash

; 140  : 	AuThreadFree(killable->main_thread);

	mov	rax, QWORD PTR killable$[rsp]
	mov	rcx, QWORD PTR [rax+46]
	call	?AuThreadFree@@YAXPEAU_au_thread_@@@Z	; AuThreadFree

; 141  : 
; 142  : 
; 143  : 	AuProcess* root_proc = AuGetRootProcess();

	call	?AuGetRootProcess@@YAPEAU_au_proc_@@XZ	; AuGetRootProcess
	mov	QWORD PTR root_proc$[rsp], rax

; 144  : 	if (!root_proc) {

	cmp	QWORD PTR root_proc$[rsp], 0
	jne	SHORT $LN12@AuProcessC

; 145  : 		AuTextOut("Kernel Panic!! \n");

	lea	rcx, OFFSET FLAT:$SG3859
	call	AuTextOut

; 146  : 		AuTextOut("Root process returned null \n");

	lea	rcx, OFFSET FLAT:$SG3860
	call	AuTextOut
$LN11@AuProcessC:

; 147  : 		for (;;);

	jmp	SHORT $LN11@AuProcessC
$LN12@AuProcessC:

; 148  : 	}
; 149  : 	/* make all child process's orphan process 
; 150  : 	 * it will be owned by root process
; 151  : 	 */
; 152  : 	for (int i = 0; i < killable->childs->pointer; i++) {

	mov	DWORD PTR i$4[rsp], 0
	jmp	SHORT $LN9@AuProcessC
$LN8@AuProcessC:
	mov	eax, DWORD PTR i$4[rsp]
	inc	eax
	mov	DWORD PTR i$4[rsp], eax
$LN9@AuProcessC:
	mov	rax, QWORD PTR killable$[rsp]
	mov	rax, QWORD PTR [rax+1047]
	mov	eax, DWORD PTR [rax]
	cmp	DWORD PTR i$4[rsp], eax
	jae	SHORT $LN7@AuProcessC

; 153  : 		AuProcess* proc_ = (AuProcess*)list_get_at(killable->childs, i);

	mov	edx, DWORD PTR i$4[rsp]
	mov	rax, QWORD PTR killable$[rsp]
	mov	rcx, QWORD PTR [rax+1047]
	call	list_get_at
	mov	QWORD PTR proc_$6[rsp], rax

; 154  : 		if (proc_) {

	cmp	QWORD PTR proc_$6[rsp], 0
	je	SHORT $LN6@AuProcessC

; 155  : 			proc_->state |= PROCESS_STATE_ORPHAN;

	mov	rax, QWORD PTR proc_$6[rsp]
	movzx	eax, BYTE PTR [rax+12]
	or	eax, 6
	mov	rcx, QWORD PTR proc_$6[rsp]
	mov	BYTE PTR [rcx+12], al

; 156  : 			proc_->parent = NULL;

	mov	rax, QWORD PTR proc_$6[rsp]
	mov	QWORD PTR [rax+1087], 0

; 157  : 			AuAddProcess(root_proc, proc_);

	mov	rdx, QWORD PTR proc_$6[rsp]
	mov	rcx, QWORD PTR root_proc$[rsp]
	call	?AuAddProcess@@YAXPEAU_au_proc_@@0@Z	; AuAddProcess

; 158  : 			proc_->parent = root_proc;

	mov	rax, QWORD PTR proc_$6[rsp]
	mov	rcx, QWORD PTR root_proc$[rsp]
	mov	QWORD PTR [rax+1087], rcx
$LN6@AuProcessC:

; 159  : 		}
; 160  : 	}

	jmp	$LN8@AuProcessC
$LN7@AuProcessC:

; 161  : 
; 162  : 	kfree(killable->childs);

	mov	rax, QWORD PTR killable$[rsp]
	mov	rcx, QWORD PTR [rax+1047]
	call	kfree

; 163  : 	
; 164  : 	/* release the process slot */
; 165  : 	if (killable->parent) {

	mov	rax, QWORD PTR killable$[rsp]
	cmp	QWORD PTR [rax+1087], 0
	je	$LN5@AuProcessC

; 166  : 		for (int i = 0; i < killable->parent->childs->pointer; i++) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN4@AuProcessC
$LN3@AuProcessC:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN4@AuProcessC:
	mov	rax, QWORD PTR killable$[rsp]
	mov	rax, QWORD PTR [rax+1087]
	mov	rax, QWORD PTR [rax+1047]
	mov	eax, DWORD PTR [rax]
	cmp	DWORD PTR i$1[rsp], eax
	jae	SHORT $LN2@AuProcessC

; 167  : 			AuProcess* proc_ = (AuProcess*)list_get_at(killable->parent->childs, i);

	mov	rax, QWORD PTR killable$[rsp]
	mov	rax, QWORD PTR [rax+1087]
	mov	edx, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR [rax+1047]
	call	list_get_at
	mov	QWORD PTR proc_$11[rsp], rax

; 168  : 			if (proc_ == killable) {

	mov	rax, QWORD PTR killable$[rsp]
	cmp	QWORD PTR proc_$11[rsp], rax
	jne	SHORT $LN1@AuProcessC

; 169  : 				list_remove(killable->parent->childs, i);

	mov	rax, QWORD PTR killable$[rsp]
	mov	rax, QWORD PTR [rax+1087]
	mov	edx, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR [rax+1047]
	call	list_remove
$LN1@AuProcessC:

; 170  : 			}
; 171  : 		}

	jmp	SHORT $LN3@AuProcessC
$LN2@AuProcessC:
$LN5@AuProcessC:

; 172  : 	}
; 173  : 
; 174  : 	AuPmmngrFree((void*)V2P((size_t)killable->cr3));

	mov	rax, QWORD PTR killable$[rsp]
	mov	rcx, QWORD PTR [rax+14]
	call	V2P
	mov	rcx, rax
	call	AuPmmngrFree

; 175  : 	kfree(killable);

	mov	rcx, QWORD PTR killable$[rsp]
	call	kfree

; 176  : 	SeTextOut("Process cleaned \r\n");

	lea	rcx, OFFSET FLAT:$SG3881
	call	SeTextOut

; 177  : 	AuReleaseMutex(mut);

	mov	rcx, QWORD PTR mut$[rsp]
	call	AuReleaseMutex

; 178  : }

	add	rsp, 136				; 00000088H
	ret	0
?AuProcessClean@@YAXPEAU_au_proc_@@0@Z ENDP		; AuProcessClean
_TEXT	ENDS
END
