; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30154.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

msvcjmc	SEGMENT
__A4122DEF_x86_64_gdt@cpp DB 01H
msvcjmc	ENDS
PUBLIC	x86_64_hal_init_gdt
PUBLIC	?x86_64_hal_init_gdt_ap@@YAXXZ			; x86_64_hal_init_gdt_ap
PUBLIC	?set_gdt_entry@@YAXAEAU_gdt@@_K1EE@Z		; set_gdt_entry
PUBLIC	load_default_sregs
PUBLIC	?save_sregs@@YAXXZ				; save_sregs
PUBLIC	__JustMyCode_Default
EXTRN	??2@YAPEAX_K@Z:PROC				; operator new
EXTRN	??_U@YAPEAX_K@Z:PROC				; operator new[]
EXTRN	x64_lgdt:PROC
EXTRN	x64_sgdt:PROC
EXTRN	x64_get_segment_register:PROC
EXTRN	x64_set_segment_register:PROC
EXTRN	__CheckForDebuggerJustMyCode:PROC
_BSS	SEGMENT
?gdt@@3PAU_gdt@@A DQ 09H DUP (?)			; gdt
?the_gdtr@@3U_gdtr@@A DB 0aH DUP (?)			; the_gdtr
	ALIGN	4

?old_gdtr@@3U_gdtr@@A DB 0aH DUP (?)			; old_gdtr
	ALIGN	4

?oldsregs@@3PAGA DW 08H DUP (?)				; oldsregs
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$x86_64_hal_init_gdt DD imagerel $LN3
	DD	imagerel $LN3+101
	DD	imagerel $unwind$x86_64_hal_init_gdt
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?x86_64_hal_init_gdt_ap@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+118
	DD	imagerel $unwind$?x86_64_hal_init_gdt_ap@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?set_gdt_entry@@YAXAEAU_gdt@@_K1EE@Z DD imagerel $LN3
	DD	imagerel $LN3+167
	DD	imagerel $unwind$?set_gdt_entry@@YAXAEAU_gdt@@_K1EE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$load_default_sregs DD imagerel $LN3
	DD	imagerel $LN3+110
	DD	imagerel $unwind$load_default_sregs
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?set_gdt_entry@@YAXAEAU_gdt@@EE@Z DD imagerel ?set_gdt_entry@@YAXAEAU_gdt@@EE@Z
	DD	imagerel ?set_gdt_entry@@YAXAEAU_gdt@@EE@Z+94
	DD	imagerel $unwind$?set_gdt_entry@@YAXAEAU_gdt@@EE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?fill_gdt@@YAXPEAU_gdt@@@Z DD imagerel ?fill_gdt@@YAXPEAU_gdt@@@Z
	DD	imagerel ?fill_gdt@@YAXPEAU_gdt@@@Z+265
	DD	imagerel $unwind$?fill_gdt@@YAXPEAU_gdt@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?save_sregs@@YAXXZ DD imagerel $LN6
	DD	imagerel $LN6+81
	DD	imagerel $unwind$?save_sregs@@YAXXZ
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?save_sregs@@YAXXZ DD 025030b01H
	DD	0d206230bH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?fill_gdt@@YAXPEAU_gdt@@@Z DD 035030f01H
	DD	0d20a330fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?set_gdt_entry@@YAXAEAU_gdt@@EE@Z DD 035031801H
	DD	0d2133318H
	DD	0500fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$load_default_sregs DD 025030b01H
	DD	0b206230bH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?set_gdt_entry@@YAXAEAU_gdt@@_K1EE@Z DD 025031e01H
	DD	0b219231eH
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?x86_64_hal_init_gdt_ap@@YAXXZ DD 025030e01H
	DD	0f209230eH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$x86_64_hal_init_gdt DD 025030b01H
	DD	0b206230bH
	DD	05002H
xdata	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\x86_64_gdt.cpp
;	COMDAT ?save_sregs@@YAXXZ
_TEXT	SEGMENT
reg$1 = 0
?save_sregs@@YAXXZ PROC					; save_sregs, COMDAT

; 90   : {

$LN6:
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__A4122DEF_x86_64_gdt@cpp
	call	__CheckForDebuggerJustMyCode

; 91   : 	for (uint_fast8_t reg = 0; reg < 8; ++reg)

	mov	BYTE PTR reg$1[rbp], 0
	jmp	SHORT $LN4@save_sregs
$LN2@save_sregs:
	movzx	eax, BYTE PTR reg$1[rbp]
	inc	al
	mov	BYTE PTR reg$1[rbp], al
$LN4@save_sregs:
	movzx	eax, BYTE PTR reg$1[rbp]
	cmp	eax, 8
	jge	SHORT $LN3@save_sregs

; 92   : 		oldsregs[reg] = x64_get_segment_register(reg);

	movzx	eax, BYTE PTR reg$1[rbp]
	mov	ecx, eax
	call	x64_get_segment_register
	movzx	ecx, BYTE PTR reg$1[rbp]
	lea	rdx, OFFSET FLAT:?oldsregs@@3PAGA
	mov	WORD PTR [rdx+rcx*2], ax
	jmp	SHORT $LN2@save_sregs
$LN3@save_sregs:

; 93   : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
?save_sregs@@YAXXZ ENDP					; save_sregs
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\x86_64_gdt.cpp
;	COMDAT ?fill_gdt@@YAXPEAU_gdt@@@Z
_TEXT	SEGMENT
thegdt$ = 80
?fill_gdt@@YAXPEAU_gdt@@@Z PROC				; fill_gdt, COMDAT

; 73   : {

	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+48]
	lea	rcx, OFFSET FLAT:__A4122DEF_x86_64_gdt@cpp
	call	__CheckForDebuggerJustMyCode

; 74   : 	set_gdt_entry(thegdt[GDT_ENTRY_NULL], 0, 0, 0, 0);    //0x00

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR thegdt$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	BYTE PTR [rsp+32], 0
	xor	r9d, r9d
	xor	r8d, r8d
	xor	edx, edx
	mov	rcx, rax
	call	?set_gdt_entry@@YAXAEAU_gdt@@_K1EE@Z	; set_gdt_entry

; 75   : 	//Kernel Code segment: STAR.SYSCALL_CS
; 76   : 	set_gdt_entry(thegdt[GDT_ENTRY_KERNEL_CODE], GDT_ACCESS_PRIVL(0) | GDT_ACCESS_RW | GDT_ACCESS_EX, GDT_FLAG_64BT);  //0x08

	mov	eax, 8
	imul	rax, rax, 1
	mov	rcx, QWORD PTR thegdt$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	r8b, 2
	mov	dl, 10
	mov	rcx, rax
	call	?set_gdt_entry@@YAXAEAU_gdt@@EE@Z	; set_gdt_entry

; 77   : 	//Kernel Data segment
; 78   : 	set_gdt_entry(thegdt[GDT_ENTRY_KERNEL_DATA], GDT_ACCESS_PRIVL(0) | GDT_ACCESS_RW, GDT_FLAG_32BT);    //0x10

	mov	eax, 8
	imul	rax, rax, 2
	mov	rcx, QWORD PTR thegdt$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	r8b, 4
	mov	dl, 2
	mov	rcx, rax
	call	?set_gdt_entry@@YAXAEAU_gdt@@EE@Z	; set_gdt_entry

; 79   : 	//User Code segment (32 bit): STAR.SYSRET_CS
; 80   : 	set_gdt_entry(thegdt[GDT_ENTRY_USER_CODE32], GDT_ACCESS_PRIVL(3) | GDT_ACCESS_RW | GDT_ACCESS_EX, GDT_FLAG_32BT);  //0x18

	mov	eax, 8
	imul	rax, rax, 3
	mov	rcx, QWORD PTR thegdt$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	r8b, 4
	mov	dl, 106					; 0000006aH
	mov	rcx, rax
	call	?set_gdt_entry@@YAXAEAU_gdt@@EE@Z	; set_gdt_entry

; 81   : 	//User Data segment
; 82   : 	set_gdt_entry(thegdt[GDT_ENTRY_USER_DATA], GDT_ACCESS_PRIVL(3) | GDT_ACCESS_RW, GDT_FLAG_32BT);    //0x20

	mov	eax, 8
	imul	rax, rax, 4
	mov	rcx, QWORD PTR thegdt$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	r8b, 4
	mov	dl, 98					; 00000062H
	mov	rcx, rax
	call	?set_gdt_entry@@YAXAEAU_gdt@@EE@Z	; set_gdt_entry

; 83   : 	//User Code segment (64 bit)
; 84   : 	set_gdt_entry(thegdt[GDT_ENTRY_USER_CODE], GDT_ACCESS_PRIVL(3) | GDT_ACCESS_RW | GDT_ACCESS_EX, GDT_FLAG_64BT);   //0x28  | 3 -- 0x2B

	mov	eax, 8
	imul	rax, rax, 5
	mov	rcx, QWORD PTR thegdt$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	r8b, 2
	mov	dl, 106					; 0000006aH
	mov	rcx, rax
	call	?set_gdt_entry@@YAXAEAU_gdt@@EE@Z	; set_gdt_entry

; 85   : 	//Kernel Code segment (32 bit)
; 86   : 	set_gdt_entry(thegdt[GDT_ENTRY_KERNEL_CODE32], GDT_ACCESS_PRIVL(3) | GDT_ACCESS_RW | GDT_ACCESS_EX, GDT_FLAG_32BT);  //0x30

	mov	eax, 8
	imul	rax, rax, 6
	mov	rcx, QWORD PTR thegdt$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	r8b, 4
	mov	dl, 106					; 0000006aH
	mov	rcx, rax
	call	?set_gdt_entry@@YAXAEAU_gdt@@EE@Z	; set_gdt_entry

; 87   : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
?fill_gdt@@YAXPEAU_gdt@@@Z ENDP				; fill_gdt
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\x86_64_gdt.cpp
;	COMDAT ?set_gdt_entry@@YAXAEAU_gdt@@EE@Z
_TEXT	SEGMENT
entry$ = 80
access$ = 88
flags$ = 96
?set_gdt_entry@@YAXAEAU_gdt@@EE@Z PROC			; set_gdt_entry, COMDAT

; 66   : {

	mov	BYTE PTR [rsp+24], r8b
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+48]
	lea	rcx, OFFSET FLAT:__A4122DEF_x86_64_gdt@cpp
	call	__CheckForDebuggerJustMyCode

; 67   : 	access |= GDT_ACCESS_PRESENT | GDT_ACCESS_TYPE;

	movzx	eax, BYTE PTR access$[rbp]
	or	eax, 144				; 00000090H
	mov	BYTE PTR access$[rbp], al

; 68   : 	flags |= GDT_FLAG_GRAN;

	movzx	eax, BYTE PTR flags$[rbp]
	or	eax, 8
	mov	BYTE PTR flags$[rbp], al

; 69   : 	set_gdt_entry(entry, 0, SIZE_MAX, access, flags);

	movzx	eax, BYTE PTR flags$[rbp]
	mov	BYTE PTR [rsp+32], al
	movzx	r9d, BYTE PTR access$[rbp]
	mov	r8d, 1048575				; 000fffffH
	xor	edx, edx
	mov	rcx, QWORD PTR entry$[rbp]
	call	?set_gdt_entry@@YAXAEAU_gdt@@_K1EE@Z	; set_gdt_entry

; 70   : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
?set_gdt_entry@@YAXAEAU_gdt@@EE@Z ENDP			; set_gdt_entry
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\x86_64_gdt.cpp
;	COMDAT load_default_sregs
_TEXT	SEGMENT
load_default_sregs PROC					; COMDAT

; 96   : {

$LN3:
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__A4122DEF_x86_64_gdt@cpp
	call	__CheckForDebuggerJustMyCode

; 97   : 	x64_set_segment_register(SREG_CS, SEGVAL(GDT_ENTRY_KERNEL_CODE, 0));

	mov	dx, 8
	xor	ecx, ecx
	call	x64_set_segment_register

; 98   : 	x64_set_segment_register(SREG_DS, SEGVAL(GDT_ENTRY_KERNEL_DATA, 0));

	mov	dx, 16
	mov	ecx, 1
	call	x64_set_segment_register

; 99   : 	x64_set_segment_register(SREG_ES, SEGVAL(GDT_ENTRY_KERNEL_DATA, 0));

	mov	dx, 16
	mov	ecx, 2
	call	x64_set_segment_register

; 100  : 	x64_set_segment_register(SREG_SS, SEGVAL(GDT_ENTRY_KERNEL_DATA, 0));

	mov	dx, 16
	mov	ecx, 5
	call	x64_set_segment_register

; 101  : 	//Per CPU data
; 102  : 	x64_set_segment_register(SREG_FS, SEGVAL(GDT_ENTRY_KERNEL_DATA, 0));

	mov	dx, 16
	mov	ecx, 3
	call	x64_set_segment_register

; 103  : 	x64_set_segment_register(SREG_GS, SEGVAL(GDT_ENTRY_KERNEL_DATA, 0));

	mov	dx, 16
	mov	ecx, 4
	call	x64_set_segment_register

; 104  : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
load_default_sregs ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\x86_64_gdt.cpp
;	COMDAT ?set_gdt_entry@@YAXAEAU_gdt@@_K1EE@Z
_TEXT	SEGMENT
entry$ = 80
base$ = 88
limit$ = 96
access$ = 104
flags$ = 112
?set_gdt_entry@@YAXAEAU_gdt@@_K1EE@Z PROC		; set_gdt_entry, COMDAT

; 56   : {

$LN3:
	mov	BYTE PTR [rsp+32], r9b
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__A4122DEF_x86_64_gdt@cpp
	call	__CheckForDebuggerJustMyCode

; 57   : 	entry.base_low = base & 0xFFFF;

	mov	rax, QWORD PTR base$[rbp]
	and	rax, 65535				; 0000ffffH
	mov	rcx, QWORD PTR entry$[rbp]
	mov	WORD PTR [rcx+2], ax

; 58   : 	entry.base_mid = (base >> 16) & 0xFF;

	mov	rax, QWORD PTR base$[rbp]
	shr	rax, 16
	and	rax, 255				; 000000ffH
	mov	rcx, QWORD PTR entry$[rbp]
	mov	BYTE PTR [rcx+4], al

; 59   : 	entry.base_high = (base >> 24) & 0xFF;

	mov	rax, QWORD PTR base$[rbp]
	shr	rax, 24
	and	rax, 255				; 000000ffH
	mov	rcx, QWORD PTR entry$[rbp]
	mov	BYTE PTR [rcx+7], al

; 60   : 	entry.limit_low = limit & 0xFFFF;

	mov	rax, QWORD PTR limit$[rbp]
	and	rax, 65535				; 0000ffffH
	mov	rcx, QWORD PTR entry$[rbp]
	mov	WORD PTR [rcx], ax

; 61   : 	entry.access = access;

	mov	rax, QWORD PTR entry$[rbp]
	movzx	ecx, BYTE PTR access$[rbp]
	mov	BYTE PTR [rax+5], cl

; 62   : 	entry.flags_limit = (flags << 4) | ((limit >> 16) & 0xF);

	movzx	eax, BYTE PTR flags$[rbp]
	shl	eax, 4
	cdqe
	mov	rcx, QWORD PTR limit$[rbp]
	shr	rcx, 16
	and	rcx, 15
	or	rax, rcx
	mov	rcx, QWORD PTR entry$[rbp]
	mov	BYTE PTR [rcx+6], al

; 63   : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
?set_gdt_entry@@YAXAEAU_gdt@@_K1EE@Z ENDP		; set_gdt_entry
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\x86_64_gdt.cpp
;	COMDAT ?x86_64_hal_init_gdt_ap@@YAXXZ
_TEXT	SEGMENT
new_gdtr$ = 0
new_gdt$ = 8
$T1 = 80
$T2 = 88
?x86_64_hal_init_gdt_ap@@YAXXZ PROC			; x86_64_hal_init_gdt_ap, COMDAT

; 121  : void x86_64_hal_init_gdt_ap() {

$LN3:
	push	rbp
	sub	rsp, 128				; 00000080H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__A4122DEF_x86_64_gdt@cpp
	call	__CheckForDebuggerJustMyCode

; 122  : 	gdtr* new_gdtr = new gdtr;

	mov	ecx, 10
	call	??2@YAPEAX_K@Z				; operator new
	mov	QWORD PTR $T1[rbp], rax
	mov	rax, QWORD PTR $T1[rbp]
	mov	QWORD PTR new_gdtr$[rbp], rax

; 123  : 	gdt_entry* new_gdt = new gdt_entry[GDT_ENTRIES];

	mov	ecx, 72					; 00000048H
	call	??_U@YAPEAX_K@Z				; operator new[]
	mov	QWORD PTR $T2[rbp], rax
	mov	rax, QWORD PTR $T2[rbp]
	mov	QWORD PTR new_gdt$[rbp], rax

; 124  : 	fill_gdt(new_gdt);

	mov	rcx, QWORD PTR new_gdt$[rbp]
	call	?fill_gdt@@YAXPEAU_gdt@@@Z		; fill_gdt

; 125  : 	new_gdtr->gdtaddr = new_gdt;

	mov	rax, QWORD PTR new_gdtr$[rbp]
	mov	rcx, QWORD PTR new_gdt$[rbp]
	mov	QWORD PTR [rax+2], rcx

; 126  : 	new_gdtr->size = GDT_ENTRIES * sizeof(gdt_entry)-1;

	mov	eax, 71					; 00000047H
	mov	rcx, QWORD PTR new_gdtr$[rbp]
	mov	WORD PTR [rcx], ax

; 127  : 	x64_lgdt(new_gdtr);

	mov	rcx, QWORD PTR new_gdtr$[rbp]
	call	x64_lgdt

; 128  : }

	lea	rsp, QWORD PTR [rbp+96]
	pop	rbp
	ret	0
?x86_64_hal_init_gdt_ap@@YAXXZ ENDP			; x86_64_hal_init_gdt_ap
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\x86_64_gdt.cpp
;	COMDAT x86_64_hal_init_gdt
_TEXT	SEGMENT
x86_64_hal_init_gdt PROC				; COMDAT

; 107  : extern "C" void x86_64_hal_init_gdt(){

$LN3:
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__A4122DEF_x86_64_gdt@cpp
	call	__CheckForDebuggerJustMyCode

; 108  : 	x64_sgdt(&old_gdtr);

	lea	rcx, OFFSET FLAT:?old_gdtr@@3U_gdtr@@A
	call	x64_sgdt

; 109  : 	save_sregs();

	call	?save_sregs@@YAXXZ			; save_sregs

; 110  : 	fill_gdt(gdt);

	lea	rcx, OFFSET FLAT:?gdt@@3PAU_gdt@@A
	call	?fill_gdt@@YAXPEAU_gdt@@@Z		; fill_gdt

; 111  : 	the_gdtr.gdtaddr = gdt;

	lea	rax, OFFSET FLAT:?gdt@@3PAU_gdt@@A
	mov	QWORD PTR ?the_gdtr@@3U_gdtr@@A+2, rax

; 112  : 	the_gdtr.size = GDT_ENTRIES * sizeof(gdt_entry)-1;

	mov	eax, 71					; 00000047H
	mov	WORD PTR ?the_gdtr@@3U_gdtr@@A, ax

; 113  : 	x64_lgdt(&the_gdtr);

	lea	rcx, OFFSET FLAT:?the_gdtr@@3U_gdtr@@A
	call	x64_lgdt

; 114  : 	load_default_sregs();

	call	load_default_sregs

; 115  : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
x86_64_hal_init_gdt ENDP
_TEXT	ENDS
END
