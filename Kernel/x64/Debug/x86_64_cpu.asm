; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30154.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?_tss@@3PEAU0@EA				; _tss
PUBLIC	?_fxsave@@3_NA					; _fxsave
PUBLIC	?cpuMhz@@3_KA					; cpuMhz
PUBLIC	?tscBasisTiming@@3_KA				; tscBasisTiming
PUBLIC	?bootTime@@3_KA					; bootTime
PUBLIC	?__ApStarted@@3_NA				; __ApStarted
_BSS	SEGMENT
?_tss@@3PEAU0@EA DQ 01H DUP (?)				; _tss
?_fxsave@@3_NA DB 01H DUP (?)				; _fxsave
	ALIGN	8

?cpuMhz@@3_KA DQ 01H DUP (?)				; cpuMhz
?tscBasisTiming@@3_KA DQ 01H DUP (?)			; tscBasisTiming
?bootTime@@3_KA DQ 01H DUP (?)				; bootTime
?__ApStarted@@3_NA DB 01H DUP (?)			; __ApStarted
_BSS	ENDS
msvcjmc	SEGMENT
__F57A60C1_x86_64_cpu@cpp DB 01H
msvcjmc	ENDS
PUBLIC	?x86_64_enable_syscall_ext@@YAXXZ		; x86_64_enable_syscall_ext
PUBLIC	?x86_64_init_user@@YAX_K@Z			; x86_64_init_user
PUBLIC	?x86_64_init_user_ap@@YAX_K@Z			; x86_64_init_user_ap
PUBLIC	?x86_64_get_tss@@YAPEAU_tss@@XZ			; x86_64_get_tss
PUBLIC	?x86_64_hal_cpu_feature_enable@@YAXXZ		; x86_64_hal_cpu_feature_enable
PUBLIC	?x86_64_is_cpu_fxsave_supported@@YA_NXZ		; x86_64_is_cpu_fxsave_supported
PUBLIC	?x86_64_cpu_msi_address@@YA_KPEA_K_KIEE@Z	; x86_64_cpu_msi_address
PUBLIC	?x86_64_cpu_initialize@@YAXE@Z			; x86_64_cpu_initialize
PUBLIC	?x86_64_set_ap_start_bit@@YAX_N@Z		; x86_64_set_ap_start_bit
PUBLIC	?x86_64_initialise_syscall@@YAXXZ		; x86_64_initialise_syscall
PUBLIC	?cpu_read_tsc@@YA_KXZ				; cpu_read_tsc
PUBLIC	?x86_64_measure_cpu_speed@@YAXXZ		; x86_64_measure_cpu_speed
PUBLIC	?x86_64_cpu_get_mhz@@YA_KXZ			; x86_64_cpu_get_mhz
PUBLIC	?x86_64_gettimeofday@@YAHPEAU_timeval_@@@Z	; x86_64_gettimeofday
PUBLIC	?_ICRDest@@YA_KI@Z				; _ICRDest
PUBLIC	?_ICRBusy@@YA_NXZ				; _ICRBusy
PUBLIC	?CMOSDump@@YAXPEAG@Z				; CMOSDump
PUBLIC	?isUpdateInProgress@@YAHXZ			; isUpdateInProgress
PUBLIC	?secs_of_years@@YA_KH@Z				; secs_of_years
PUBLIC	?readCMOS@@YA_KXZ				; readCMOS
PUBLIC	?updateTicks@@YAX_KPEA_K1@Z			; updateTicks
PUBLIC	__JustMyCode_Default
EXTRN	?AuPerCPUSetKernelTSS@@YAXPEAU_tss@@@Z:PROC	; AuPerCPUSetKernelTSS
EXTRN	x64_cli:PROC
EXTRN	x64_inportb:PROC
EXTRN	x64_outportb:PROC
EXTRN	x64_read_msr:PROC
EXTRN	x64_write_msr:PROC
EXTRN	x64_pause:PROC
EXTRN	x64_cpuid:PROC
EXTRN	x64_read_cr0:PROC
EXTRN	x64_read_cr4:PROC
EXTRN	x64_write_cr0:PROC
EXTRN	x64_write_cr4:PROC
EXTRN	x64_sgdt:PROC
EXTRN	x64_rdtsc:PROC
EXTRN	?ReadAPICRegister@@YA_KG@Z:PROC			; ReadAPICRegister
EXTRN	?WriteAPICRegister@@YAXG_K@Z:PROC		; WriteAPICRegister
EXTRN	?X2APICSupported@@YA_NXZ:PROC			; X2APICSupported
EXTRN	?x86_64_ap_init@@YAXPEAX@Z:PROC			; x86_64_ap_init
EXTRN	AuPmmngrAlloc:PROC
EXTRN	P2V:PROC
EXTRN	AuGetRootPageTable:PROC
EXTRN	memcpy:PROC
EXTRN	syscall_entry:PROC
EXTRN	x64_syscall_entry_compat:PROC
EXTRN	__CheckForDebuggerJustMyCode:PROC
EXTRN	__ImageBase:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$?x86_64_enable_syscall_ext@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+82
	DD	imagerel $unwind$?x86_64_enable_syscall_ext@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?x86_64_init_user@@YAX_K@Z DD imagerel $LN8
	DD	imagerel $LN8+200
	DD	imagerel $unwind$?x86_64_init_user@@YAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?x86_64_init_user_ap@@YAX_K@Z DD imagerel $LN8
	DD	imagerel $LN8+206
	DD	imagerel $unwind$?x86_64_init_user_ap@@YAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?x86_64_get_tss@@YAPEAU_tss@@XZ DD imagerel $LN3
	DD	imagerel $LN3+36
	DD	imagerel $unwind$?x86_64_get_tss@@YAPEAU_tss@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?x86_64_hal_cpu_feature_enable@@YAXXZ DD imagerel $LN10
	DD	imagerel $LN10+271
	DD	imagerel $unwind$?x86_64_hal_cpu_feature_enable@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?x86_64_is_cpu_fxsave_supported@@YA_NXZ DD imagerel $LN3
	DD	imagerel $LN3+36
	DD	imagerel $unwind$?x86_64_is_cpu_fxsave_supported@@YA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?x86_64_cpu_msi_address@@YA_KPEA_K_KIEE@Z DD imagerel $LN7
	DD	imagerel $LN7+145
	DD	imagerel $unwind$?x86_64_cpu_msi_address@@YA_KPEA_K_KIEE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?x86_64_cpu_initialize@@YAXE@Z DD imagerel $LN23
	DD	imagerel $LN23+478
	DD	imagerel $unwind$?x86_64_cpu_initialize@@YAXE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?x86_64_set_ap_start_bit@@YAX_N@Z DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$?x86_64_set_ap_start_bit@@YAX_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?x86_64_initialise_syscall@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+126
	DD	imagerel $unwind$?x86_64_initialise_syscall@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?cpu_read_tsc@@YA_KXZ DD imagerel $LN3
	DD	imagerel $LN3+77
	DD	imagerel $unwind$?cpu_read_tsc@@YA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?x86_64_measure_cpu_speed@@YAXXZ DD imagerel $LN8
	DD	imagerel $LN8+441
	DD	imagerel $unwind$?x86_64_measure_cpu_speed@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?x86_64_cpu_get_mhz@@YA_KXZ DD imagerel $LN3
	DD	imagerel $LN3+36
	DD	imagerel $unwind$?x86_64_cpu_get_mhz@@YA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?x86_64_gettimeofday@@YAHPEAU_timeval_@@@Z DD imagerel $LN3
	DD	imagerel $LN3+109
	DD	imagerel $unwind$?x86_64_gettimeofday@@YAHPEAU_timeval_@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_ICRDest@@YA_KI@Z DD imagerel $LN5
	DD	imagerel $LN5+62
	DD	imagerel $unwind$?_ICRDest@@YA_KI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_ICRBusy@@YA_NXZ DD imagerel $LN5
	DD	imagerel $LN5+69
	DD	imagerel $unwind$?_ICRBusy@@YA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?CMOSDump@@YAXPEAG@Z DD imagerel $LN6
	DD	imagerel $LN6+102
	DD	imagerel $unwind$?CMOSDump@@YAXPEAG@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?isUpdateInProgress@@YAHXZ DD imagerel $LN3
	DD	imagerel $LN3+57
	DD	imagerel $unwind$?isUpdateInProgress@@YAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?secs_of_years@@YA_KH@Z DD imagerel $LN9
	DD	imagerel $LN9+168
	DD	imagerel $unwind$?secs_of_years@@YA_KH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?secs_of_month@@YA_KHH@Z DD imagerel ?secs_of_month@@YA_KHH@Z
	DD	imagerel ?secs_of_month@@YA_KHH@Z+352
	DD	imagerel $unwind$?secs_of_month@@YA_KHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?readCMOS@@YA_KXZ DD imagerel $LN15
	DD	imagerel $LN15+821
	DD	imagerel $unwind$?readCMOS@@YA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?updateTicks@@YAX_KPEA_K1@Z DD imagerel $LN3
	DD	imagerel $LN3+118
	DD	imagerel $unwind$?updateTicks@@YAX_KPEA_K1@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?updateTicks@@YAX_KPEA_K1@Z DD 025031901H
	DD	0b2142319H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?readCMOS@@YA_KXZ DD 025040e01H
	DD	0109230eH
	DD	05002005cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?secs_of_month@@YA_KHH@Z DD 025031201H
	DD	0d20d2312H
	DD	05009H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?secs_of_years@@YA_KH@Z DD 025030e01H
	DD	0d209230eH
	DD	05005H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?isUpdateInProgress@@YAHXZ DD 025030b01H
	DD	0b206230bH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?CMOSDump@@YAXPEAG@Z DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_ICRBusy@@YA_NXZ DD 025030b01H
	DD	0d206230bH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_ICRDest@@YA_KI@Z DD 025030e01H
	DD	0b209230eH
	DD	05005H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?x86_64_gettimeofday@@YAHPEAU_timeval_@@@Z DD 025031201H
	DD	0f20d2312H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?x86_64_cpu_get_mhz@@YA_KXZ DD 025030b01H
	DD	0b206230bH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?x86_64_measure_cpu_speed@@YAXXZ DD 025030e01H
	DD	0f209230eH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?cpu_read_tsc@@YA_KXZ DD 025030b01H
	DD	0d206230bH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?x86_64_initialise_syscall@@YAXXZ DD 025030b01H
	DD	0d206230bH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?x86_64_set_ap_start_bit@@YAX_N@Z DD 025030e01H
	DD	0b209230eH
	DD	05005H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?x86_64_cpu_initialize@@YAXE@Z DD 025041101H
	DD	010c2311H
	DD	050050016H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?x86_64_cpu_msi_address@@YA_KPEA_K_KIEE@Z DD 025031e01H
	DD	0d219231eH
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?x86_64_is_cpu_fxsave_supported@@YA_NXZ DD 025030b01H
	DD	0b206230bH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?x86_64_hal_cpu_feature_enable@@YAXXZ DD 035040e01H
	DD	0109330eH
	DD	050020016H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?x86_64_get_tss@@YAPEAU_tss@@XZ DD 025030b01H
	DD	0b206230bH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?x86_64_init_user_ap@@YAX_K@Z DD 025041201H
	DD	010d2312H
	DD	050060012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?x86_64_init_user@@YAX_K@Z DD 025041201H
	DD	010d2312H
	DD	050060012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?x86_64_enable_syscall_ext@@YAXXZ DD 025030b01H
	DD	0d206230bH
	DD	05002H
xdata	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\x86_64_cpu.cpp
;	COMDAT ?updateTicks@@YAX_KPEA_K1@Z
_TEXT	SEGMENT
ticks$ = 80
timerTick$ = 88
timerSubticks$ = 96
?updateTicks@@YAX_KPEA_K1@Z PROC			; updateTicks, COMDAT

; 408  : void updateTicks(uint64_t ticks, uint64_t *timerTick, uint64_t *timerSubticks) {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__F57A60C1_x86_64_cpu@cpp
	call	__CheckForDebuggerJustMyCode

; 409  : 	*timerSubticks = ticks - tscBasisTiming;

	mov	rax, QWORD PTR ?tscBasisTiming@@3_KA	; tscBasisTiming
	mov	rcx, QWORD PTR ticks$[rbp]
	sub	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR timerSubticks$[rbp]
	mov	QWORD PTR [rcx], rax

; 410  : 	*timerTick = *timerSubticks / SUBSECONDS_PER_SECOND;

	xor	edx, edx
	mov	rax, QWORD PTR timerSubticks$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	ecx, 1000000				; 000f4240H
	div	rcx
	mov	rcx, QWORD PTR timerTick$[rbp]
	mov	QWORD PTR [rcx], rax

; 411  : 	*timerSubticks = *timerSubticks % SUBSECONDS_PER_SECOND;

	xor	edx, edx
	mov	rax, QWORD PTR timerSubticks$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	ecx, 1000000				; 000f4240H
	div	rcx
	mov	rax, rdx
	mov	rcx, QWORD PTR timerSubticks$[rbp]
	mov	QWORD PTR [rcx], rax

; 412  : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
?updateTicks@@YAX_KPEA_K1@Z ENDP			; updateTicks
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\x86_64_cpu.cpp
;	COMDAT ?readCMOS@@YA_KXZ
_TEXT	SEGMENT
values$ = 0
old_values$ = 256
time$ = 512
tv147 = 648
tv170 = 656
tv184 = 664
tv198 = 672
tv211 = 680
tv224 = 688
?readCMOS@@YA_KXZ PROC					; readCMOS, COMDAT

; 375  : uint64_t readCMOS(void) {

$LN15:
	push	rbp
	sub	rsp, 736				; 000002e0H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__F57A60C1_x86_64_cpu@cpp
	call	__CheckForDebuggerJustMyCode
$LN2@readCMOS:

; 376  : 	uint16_t values[128];
; 377  : 	uint16_t old_values[128];
; 378  : 
; 379  : 	while (isUpdateInProgress());

	call	?isUpdateInProgress@@YAHXZ		; isUpdateInProgress
	test	eax, eax
	je	SHORT $LN3@readCMOS
	jmp	SHORT $LN2@readCMOS
$LN3@readCMOS:

; 380  : 	CMOSDump(values);

	lea	rcx, QWORD PTR values$[rbp]
	call	?CMOSDump@@YAXPEAG@Z			; CMOSDump
$LN14@readCMOS:
$LN13@readCMOS:
$LN12@readCMOS:
$LN11@readCMOS:
$LN10@readCMOS:
$LN6@readCMOS:

; 381  : 
; 382  : 	do {
; 383  : 		memcpy(old_values, values, 128);

	mov	r8d, 128				; 00000080H
	lea	rdx, QWORD PTR values$[rbp]
	lea	rcx, QWORD PTR old_values$[rbp]
	call	memcpy
$LN7@readCMOS:

; 384  : 		while (isUpdateInProgress());

	call	?isUpdateInProgress@@YAHXZ		; isUpdateInProgress
	test	eax, eax
	je	SHORT $LN8@readCMOS
	jmp	SHORT $LN7@readCMOS
$LN8@readCMOS:

; 385  : 		CMOSDump(values);

	lea	rcx, QWORD PTR values$[rbp]
	call	?CMOSDump@@YAXPEAG@Z			; CMOSDump

; 386  : 	} while ((old_values[CMOS_SECOND] != values[CMOS_SECOND]) ||
; 387  : 		(old_values[CMOS_MINUTE] != values[CMOS_MINUTE]) ||
; 388  : 		(old_values[CMOS_HOUR] != values[CMOS_HOUR]) ||
; 389  : 		(old_values[CMOS_DAY] != values[CMOS_DAY]) ||
; 390  : 		(old_values[CMOS_MONTH] != values[CMOS_MONTH]) ||

	mov	eax, 2
	imul	rax, rax, 0
	movzx	eax, WORD PTR old_values$[rbp+rax]
	mov	ecx, 2
	imul	rcx, rcx, 0
	movzx	ecx, WORD PTR values$[rbp+rcx]
	cmp	eax, ecx
	jne	SHORT $LN6@readCMOS
	mov	eax, 2
	imul	rax, rax, 2
	movzx	eax, WORD PTR old_values$[rbp+rax]
	mov	ecx, 2
	imul	rcx, rcx, 2
	movzx	ecx, WORD PTR values$[rbp+rcx]
	cmp	eax, ecx
	jne	SHORT $LN10@readCMOS
	mov	eax, 2
	imul	rax, rax, 4
	movzx	eax, WORD PTR old_values$[rbp+rax]
	mov	ecx, 2
	imul	rcx, rcx, 4
	movzx	ecx, WORD PTR values$[rbp+rcx]
	cmp	eax, ecx
	jne	$LN11@readCMOS
	mov	eax, 2
	imul	rax, rax, 7
	movzx	eax, WORD PTR old_values$[rbp+rax]
	mov	ecx, 2
	imul	rcx, rcx, 7
	movzx	ecx, WORD PTR values$[rbp+rcx]
	cmp	eax, ecx
	jne	$LN12@readCMOS
	mov	eax, 2
	imul	rax, rax, 8
	movzx	eax, WORD PTR old_values$[rbp+rax]
	mov	ecx, 2
	imul	rcx, rcx, 8
	movzx	ecx, WORD PTR values$[rbp+rcx]
	cmp	eax, ecx
	jne	$LN13@readCMOS
	mov	eax, 2
	imul	rax, rax, 9
	movzx	eax, WORD PTR old_values$[rbp+rax]
	mov	ecx, 2
	imul	rcx, rcx, 9
	movzx	ecx, WORD PTR values$[rbp+rcx]
	cmp	eax, ecx
	jne	$LN14@readCMOS

; 391  : 		(old_values[CMOS_YEAR] != values[CMOS_YEAR]));
; 392  : 
; 393  : 	/* Math Time */
; 394  : 	uint64_t time =

	mov	eax, 2
	imul	rax, rax, 9
	movzx	eax, WORD PTR values$[rbp+rax]
	cdq
	and	edx, 15
	add	eax, edx
	sar	eax, 4
	imul	eax, eax, 10
	mov	ecx, 2
	imul	rcx, rcx, 9
	movzx	ecx, WORD PTR values$[rbp+rcx]
	and	ecx, 15
	lea	eax, DWORD PTR [rax+rcx-1]
	mov	ecx, eax
	call	?secs_of_years@@YA_KH@Z			; secs_of_years
	mov	QWORD PTR tv147[rbp], rax
	mov	ecx, 2
	imul	rcx, rcx, 9
	movzx	ecx, WORD PTR values$[rbp+rcx]
	mov	eax, ecx
	cdq
	and	edx, 15
	add	eax, edx
	sar	eax, 4
	imul	eax, eax, 10
	mov	ecx, 2
	imul	rcx, rcx, 9
	movzx	ecx, WORD PTR values$[rbp+rcx]
	and	ecx, 15
	add	eax, ecx
	mov	DWORD PTR tv170[rbp], eax
	mov	ecx, 2
	imul	rcx, rcx, 8
	movzx	ecx, WORD PTR values$[rbp+rcx]
	mov	eax, ecx
	cdq
	and	edx, 15
	add	eax, edx
	sar	eax, 4
	imul	eax, eax, 10
	mov	ecx, 2
	imul	rcx, rcx, 8
	movzx	ecx, WORD PTR values$[rbp+rcx]
	and	ecx, 15
	lea	eax, DWORD PTR [rax+rcx-1]
	mov	ecx, DWORD PTR tv170[rbp]
	mov	edx, ecx
	mov	ecx, eax
	call	?secs_of_month@@YA_KHH@Z		; secs_of_month
	mov	rcx, QWORD PTR tv147[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR tv184[rbp], rax
	mov	ecx, 2
	imul	rcx, rcx, 7
	movzx	ecx, WORD PTR values$[rbp+rcx]
	mov	eax, ecx
	cdq
	and	edx, 15
	add	eax, edx
	sar	eax, 4
	imul	eax, eax, 10
	mov	ecx, 2
	imul	rcx, rcx, 7
	movzx	ecx, WORD PTR values$[rbp+rcx]
	and	ecx, 15
	lea	eax, DWORD PTR [rax+rcx-1]
	imul	eax, eax, 86400				; 00015180H
	cdqe
	mov	rcx, QWORD PTR tv184[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR tv198[rbp], rax
	mov	ecx, 2
	imul	rcx, rcx, 4
	movzx	ecx, WORD PTR values$[rbp+rcx]
	mov	eax, ecx
	cdq
	and	edx, 15
	add	eax, edx
	sar	eax, 4
	imul	eax, eax, 10
	mov	ecx, 2
	imul	rcx, rcx, 4
	movzx	ecx, WORD PTR values$[rbp+rcx]
	and	ecx, 15
	add	eax, ecx
	imul	eax, eax, 3600				; 00000e10H
	cdqe
	mov	rcx, QWORD PTR tv198[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR tv211[rbp], rax
	mov	ecx, 2
	imul	rcx, rcx, 2
	movzx	ecx, WORD PTR values$[rbp+rcx]
	mov	eax, ecx
	cdq
	and	edx, 15
	add	eax, edx
	sar	eax, 4
	imul	eax, eax, 10
	mov	ecx, 2
	imul	rcx, rcx, 2
	movzx	ecx, WORD PTR values$[rbp+rcx]
	and	ecx, 15
	add	eax, ecx
	imul	eax, eax, 60				; 0000003cH
	cdqe
	mov	rcx, QWORD PTR tv211[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR tv224[rbp], rax
	mov	ecx, 2
	imul	rcx, rcx, 0
	movzx	ecx, WORD PTR values$[rbp+rcx]
	mov	eax, ecx
	cdq
	and	edx, 15
	add	eax, edx
	sar	eax, 4
	imul	eax, eax, 10
	mov	ecx, 2
	imul	rcx, rcx, 0
	movzx	ecx, WORD PTR values$[rbp+rcx]
	and	ecx, 15
	add	eax, ecx
	cdqe
	mov	rcx, QWORD PTR tv224[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR time$[rbp], rax

; 395  : 		secs_of_years(fromBCD(values[CMOS_YEAR]) - 1) +
; 396  : 		secs_of_month(fromBCD(values[CMOS_MONTH]) - 1,
; 397  : 		fromBCD(values[CMOS_YEAR])) +
; 398  : 		(fromBCD(values[CMOS_DAY]) - 1) * 86400 +
; 399  : 		(fromBCD(values[CMOS_HOUR])) * 3600 +
; 400  : 		(fromBCD(values[CMOS_MINUTE])) * 60 +
; 401  : 		fromBCD(values[CMOS_SECOND]) + 0;
; 402  : 
; 403  : 	return time;

	mov	rax, QWORD PTR time$[rbp]

; 404  : }

	lea	rsp, QWORD PTR [rbp+704]
	pop	rbp
	ret	0
?readCMOS@@YA_KXZ ENDP					; readCMOS
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\x86_64_cpu.cpp
;	COMDAT ?secs_of_month@@YA_KHH@Z
_TEXT	SEGMENT
days$ = 0
tv65 = 72
months$ = 96
year$ = 104
?secs_of_month@@YA_KHH@Z PROC				; secs_of_month, COMDAT

; 339  : static uint64_t secs_of_month(int months, int year) {

	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__F57A60C1_x86_64_cpu@cpp
	call	__CheckForDebuggerJustMyCode

; 340  : 	year += 2000;

	mov	eax, DWORD PTR year$[rbp]
	add	eax, 2000				; 000007d0H
	mov	DWORD PTR year$[rbp], eax

; 341  : 
; 342  : 	uint64_t days = 0;

	mov	QWORD PTR days$[rbp], 0

; 343  : 	switch (months) {

	mov	eax, DWORD PTR months$[rbp]
	mov	DWORD PTR tv65[rbp], eax
	mov	eax, DWORD PTR tv65[rbp]
	dec	eax
	mov	DWORD PTR tv65[rbp], eax
	cmp	DWORD PTR tv65[rbp], 10
	ja	$LN17@secs_of_mo
	movsxd	rax, DWORD PTR tv65[rbp]
	lea	rcx, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN19@secs_of_mo[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN4@secs_of_mo:

; 344  : 	case 11:
; 345  : 		days += 30; /* fallthrough */

	mov	rax, QWORD PTR days$[rbp]
	add	rax, 30
	mov	QWORD PTR days$[rbp], rax
$LN5@secs_of_mo:

; 346  : 	case 10:
; 347  : 		days += 31; /* fallthrough */

	mov	rax, QWORD PTR days$[rbp]
	add	rax, 31
	mov	QWORD PTR days$[rbp], rax
$LN6@secs_of_mo:

; 348  : 	case 9:
; 349  : 		days += 30; /* fallthrough */

	mov	rax, QWORD PTR days$[rbp]
	add	rax, 30
	mov	QWORD PTR days$[rbp], rax
$LN7@secs_of_mo:

; 350  : 	case 8:
; 351  : 		days += 31; /* fallthrough */

	mov	rax, QWORD PTR days$[rbp]
	add	rax, 31
	mov	QWORD PTR days$[rbp], rax
$LN8@secs_of_mo:

; 352  : 	case 7:
; 353  : 		days += 31; /* fallthrough */

	mov	rax, QWORD PTR days$[rbp]
	add	rax, 31
	mov	QWORD PTR days$[rbp], rax
$LN9@secs_of_mo:

; 354  : 	case 6:
; 355  : 		days += 30; /* fallthrough */

	mov	rax, QWORD PTR days$[rbp]
	add	rax, 30
	mov	QWORD PTR days$[rbp], rax
$LN10@secs_of_mo:

; 356  : 	case 5:
; 357  : 		days += 31; /* fallthrough */

	mov	rax, QWORD PTR days$[rbp]
	add	rax, 31
	mov	QWORD PTR days$[rbp], rax
$LN11@secs_of_mo:

; 358  : 	case 4:
; 359  : 		days += 30; /* fallthrough */

	mov	rax, QWORD PTR days$[rbp]
	add	rax, 30
	mov	QWORD PTR days$[rbp], rax
$LN12@secs_of_mo:

; 360  : 	case 3:
; 361  : 		days += 31; /* fallthrough */

	mov	rax, QWORD PTR days$[rbp]
	add	rax, 31
	mov	QWORD PTR days$[rbp], rax
$LN13@secs_of_mo:

; 362  : 	case 2:
; 363  : 		days += 28;

	mov	rax, QWORD PTR days$[rbp]
	add	rax, 28
	mov	QWORD PTR days$[rbp], rax

; 364  : 		if ((year % 4 == 0) && ((year % 100 != 0) || (year % 400 == 0))) {

	mov	eax, DWORD PTR year$[rbp]
	cdq
	and	edx, 3
	add	eax, edx
	and	eax, 3
	sub	eax, edx
	test	eax, eax
	jne	SHORT $LN14@secs_of_mo
	mov	eax, DWORD PTR year$[rbp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	eax, edx
	test	eax, eax
	jne	SHORT $LN15@secs_of_mo
	mov	eax, DWORD PTR year$[rbp]
	cdq
	mov	ecx, 400				; 00000190H
	idiv	ecx
	mov	eax, edx
	test	eax, eax
	jne	SHORT $LN14@secs_of_mo
$LN15@secs_of_mo:

; 365  : 			days++;

	mov	rax, QWORD PTR days$[rbp]
	inc	rax
	mov	QWORD PTR days$[rbp], rax
$LN14@secs_of_mo:
$LN16@secs_of_mo:

; 366  : 		} /* fallthrough */
; 367  : 	case 1:
; 368  : 		days += 31; /* fallthrough */

	mov	rax, QWORD PTR days$[rbp]
	add	rax, 31
	mov	QWORD PTR days$[rbp], rax
$LN17@secs_of_mo:

; 369  : 	default:
; 370  : 		break;
; 371  : 	}
; 372  : 	return days * 86400;

	imul	rax, QWORD PTR days$[rbp], 86400	; 00015180H

; 373  : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
	npad	3
$LN19@secs_of_mo:
	DD	$LN16@secs_of_mo
	DD	$LN13@secs_of_mo
	DD	$LN12@secs_of_mo
	DD	$LN11@secs_of_mo
	DD	$LN10@secs_of_mo
	DD	$LN9@secs_of_mo
	DD	$LN8@secs_of_mo
	DD	$LN7@secs_of_mo
	DD	$LN6@secs_of_mo
	DD	$LN5@secs_of_mo
	DD	$LN4@secs_of_mo
?secs_of_month@@YA_KHH@Z ENDP				; secs_of_month
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\x86_64_cpu.cpp
;	COMDAT ?secs_of_years@@YA_KH@Z
_TEXT	SEGMENT
days$ = 0
years$ = 96
?secs_of_years@@YA_KH@Z PROC				; secs_of_years, COMDAT

; 319  : uint64_t secs_of_years(int years) {

$LN9:
	mov	DWORD PTR [rsp+8], ecx
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__F57A60C1_x86_64_cpu@cpp
	call	__CheckForDebuggerJustMyCode

; 320  : 	uint64_t days = 0;

	mov	QWORD PTR days$[rbp], 0

; 321  : 	years += 2000;

	mov	eax, DWORD PTR years$[rbp]
	add	eax, 2000				; 000007d0H
	mov	DWORD PTR years$[rbp], eax
$LN2@secs_of_ye:

; 322  : 	while (years > 1969) {

	cmp	DWORD PTR years$[rbp], 1969		; 000007b1H
	jle	SHORT $LN3@secs_of_ye

; 323  : 		days += 365;

	mov	rax, QWORD PTR days$[rbp]
	add	rax, 365				; 0000016dH
	mov	QWORD PTR days$[rbp], rax

; 324  : 		if (years % 4 == 0) {

	mov	eax, DWORD PTR years$[rbp]
	cdq
	and	edx, 3
	add	eax, edx
	and	eax, 3
	sub	eax, edx
	test	eax, eax
	jne	SHORT $LN4@secs_of_ye

; 325  : 			if (years % 100 == 0) {

	mov	eax, DWORD PTR years$[rbp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	eax, edx
	test	eax, eax
	jne	SHORT $LN5@secs_of_ye

; 326  : 				if (years % 400 == 0) {

	mov	eax, DWORD PTR years$[rbp]
	cdq
	mov	ecx, 400				; 00000190H
	idiv	ecx
	mov	eax, edx
	test	eax, eax
	jne	SHORT $LN7@secs_of_ye

; 327  : 					days++;

	mov	rax, QWORD PTR days$[rbp]
	inc	rax
	mov	QWORD PTR days$[rbp], rax
$LN7@secs_of_ye:

; 328  : 				}
; 329  : 			}

	jmp	SHORT $LN6@secs_of_ye
$LN5@secs_of_ye:

; 330  : 			else {
; 331  : 				days++;

	mov	rax, QWORD PTR days$[rbp]
	inc	rax
	mov	QWORD PTR days$[rbp], rax
$LN6@secs_of_ye:
$LN4@secs_of_ye:

; 332  : 			}
; 333  : 		}
; 334  : 		years--;

	mov	eax, DWORD PTR years$[rbp]
	dec	eax
	mov	DWORD PTR years$[rbp], eax

; 335  : 	}

	jmp	SHORT $LN2@secs_of_ye
$LN3@secs_of_ye:

; 336  : 	return days * 86400;

	imul	rax, QWORD PTR days$[rbp], 86400	; 00015180H

; 337  : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
?secs_of_years@@YA_KH@Z ENDP				; secs_of_years
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\x86_64_cpu.cpp
;	COMDAT ?isUpdateInProgress@@YAHXZ
_TEXT	SEGMENT
?isUpdateInProgress@@YAHXZ PROC				; isUpdateInProgress, COMDAT

; 314  : int isUpdateInProgress(void) {

$LN3:
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__F57A60C1_x86_64_cpu@cpp
	call	__CheckForDebuggerJustMyCode

; 315  : 	x64_outportb(CMOS_ADDRESS, 0x0a);

	mov	dl, 10
	mov	cx, 112					; 00000070H
	call	x64_outportb

; 316  : 	return x64_inportb(CMOS_DATA) & 0x80;

	mov	cx, 113					; 00000071H
	call	x64_inportb
	movzx	eax, al
	and	eax, 128				; 00000080H

; 317  : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
?isUpdateInProgress@@YAHXZ ENDP				; isUpdateInProgress
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\x86_64_cpu.cpp
;	COMDAT ?CMOSDump@@YAXPEAG@Z
_TEXT	SEGMENT
i$1 = 0
val$ = 96
?CMOSDump@@YAXPEAG@Z PROC				; CMOSDump, COMDAT

; 307  : void CMOSDump(uint16_t *val) {

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__F57A60C1_x86_64_cpu@cpp
	call	__CheckForDebuggerJustMyCode

; 308  : 	for (uint16_t i = 0; i < 128; ++i) {

	xor	eax, eax
	mov	WORD PTR i$1[rbp], ax
	jmp	SHORT $LN4@CMOSDump
$LN2@CMOSDump:
	movzx	eax, WORD PTR i$1[rbp]
	inc	ax
	mov	WORD PTR i$1[rbp], ax
$LN4@CMOSDump:
	movzx	eax, WORD PTR i$1[rbp]
	cmp	eax, 128				; 00000080H
	jge	SHORT $LN3@CMOSDump

; 309  : 		x64_outportb(CMOS_ADDRESS, i);

	movzx	edx, BYTE PTR i$1[rbp]
	mov	cx, 112					; 00000070H
	call	x64_outportb

; 310  : 		val[i] = x64_inportb(CMOS_DATA);

	mov	cx, 113					; 00000071H
	call	x64_inportb
	movzx	eax, al
	movzx	ecx, WORD PTR i$1[rbp]
	mov	rdx, QWORD PTR val$[rbp]
	mov	WORD PTR [rdx+rcx*2], ax

; 311  : 	}

	jmp	SHORT $LN2@CMOSDump
$LN3@CMOSDump:

; 312  : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
?CMOSDump@@YAXPEAG@Z ENDP				; CMOSDump
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\x86_64_cpu.cpp
;	COMDAT ?_ICRBusy@@YA_NXZ
_TEXT	SEGMENT
tv68 = 64
?_ICRBusy@@YA_NXZ PROC					; _ICRBusy, COMDAT

; 190  : bool _ICRBusy() {

$LN5:
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__F57A60C1_x86_64_cpu@cpp
	call	__CheckForDebuggerJustMyCode

; 191  : 	return (ReadAPICRegister(LAPIC_REGISTER_ICR) & (1 << 12)) != 0;

	mov	cx, 48					; 00000030H
	call	?ReadAPICRegister@@YA_KG@Z		; ReadAPICRegister
	and	rax, 4096				; 00001000H
	test	rax, rax
	je	SHORT $LN3@ICRBusy
	mov	DWORD PTR tv68[rbp], 1
	jmp	SHORT $LN4@ICRBusy
$LN3@ICRBusy:
	mov	DWORD PTR tv68[rbp], 0
$LN4@ICRBusy:
	movzx	eax, BYTE PTR tv68[rbp]

; 192  : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
?_ICRBusy@@YA_NXZ ENDP					; _ICRBusy
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\x86_64_cpu.cpp
;	COMDAT ?_ICRDest@@YA_KI@Z
_TEXT	SEGMENT
processor$ = 80
?_ICRDest@@YA_KI@Z PROC					; _ICRDest, COMDAT

; 183  : uint64_t _ICRDest(uint32_t processor) {

$LN5:
	mov	DWORD PTR [rsp+8], ecx
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__F57A60C1_x86_64_cpu@cpp
	call	__CheckForDebuggerJustMyCode

; 184  : 	if (X2APICSupported())

	call	?X2APICSupported@@YA_NXZ		; X2APICSupported
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@ICRDest

; 185  : 		return ((uint64_t)processor << 32);

	mov	eax, DWORD PTR processor$[rbp]
	shl	rax, 32					; 00000020H
	jmp	SHORT $LN1@ICRDest
	jmp	SHORT $LN3@ICRDest
$LN2@ICRDest:

; 186  : 	else
; 187  : 		return ((uint64_t)processor << 56);

	mov	eax, DWORD PTR processor$[rbp]
	shl	rax, 56					; 00000038H
$LN3@ICRDest:
$LN1@ICRDest:

; 188  : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
?_ICRDest@@YA_KI@Z ENDP					; _ICRDest
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\x86_64_cpu.cpp
;	COMDAT ?x86_64_gettimeofday@@YAHPEAU_timeval_@@@Z
_TEXT	SEGMENT
tsc$ = 0
timer_ticks$ = 8
timer_subticks$ = 16
t$ = 112
?x86_64_gettimeofday@@YAHPEAU_timeval_@@@Z PROC		; x86_64_gettimeofday, COMDAT

; 467  : int x86_64_gettimeofday(timeval *t){

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 128				; 00000080H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__F57A60C1_x86_64_cpu@cpp
	call	__CheckForDebuggerJustMyCode

; 468  : 	uint64_t tsc = cpu_read_tsc();

	call	?cpu_read_tsc@@YA_KXZ			; cpu_read_tsc
	mov	QWORD PTR tsc$[rbp], rax

; 469  : 	uint64_t timer_ticks, timer_subticks;
; 470  : 	updateTicks(tsc / cpuMhz, &timer_ticks, &timer_subticks);

	xor	edx, edx
	mov	rax, QWORD PTR tsc$[rbp]
	div	QWORD PTR ?cpuMhz@@3_KA			; cpuMhz
	lea	r8, QWORD PTR timer_subticks$[rbp]
	lea	rdx, QWORD PTR timer_ticks$[rbp]
	mov	rcx, rax
	call	?updateTicks@@YAX_KPEA_K1@Z		; updateTicks

; 471  : 	t->tv_sec = bootTime + timer_ticks;

	mov	rax, QWORD PTR timer_ticks$[rbp]
	mov	rcx, QWORD PTR ?bootTime@@3_KA		; bootTime
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR t$[rbp]
	mov	DWORD PTR [rcx], eax

; 472  : 	t->tv_usec = timer_subticks;

	mov	rax, QWORD PTR t$[rbp]
	mov	ecx, DWORD PTR timer_subticks$[rbp]
	mov	DWORD PTR [rax+4], ecx

; 473  : 	return 0;

	xor	eax, eax

; 474  : }

	lea	rsp, QWORD PTR [rbp+96]
	pop	rbp
	ret	0
?x86_64_gettimeofday@@YAHPEAU_timeval_@@@Z ENDP		; x86_64_gettimeofday
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\x86_64_cpu.cpp
;	COMDAT ?x86_64_cpu_get_mhz@@YA_KXZ
_TEXT	SEGMENT
?x86_64_cpu_get_mhz@@YA_KXZ PROC			; x86_64_cpu_get_mhz, COMDAT

; 463  : uint64_t x86_64_cpu_get_mhz() {

$LN3:
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__F57A60C1_x86_64_cpu@cpp
	call	__CheckForDebuggerJustMyCode

; 464  : 	return cpuMhz;

	mov	rax, QWORD PTR ?cpuMhz@@3_KA		; cpuMhz

; 465  : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
?x86_64_cpu_get_mhz@@YA_KXZ ENDP			; x86_64_cpu_get_mhz
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\x86_64_cpu.cpp
;	COMDAT ?x86_64_measure_cpu_speed@@YAXXZ
_TEXT	SEGMENT
al$ = 0
stsc$ = 4
count_lo$ = 8
count_hi$ = 9
etsc$ = 12
cpu_hz$ = 16
?x86_64_measure_cpu_speed@@YAXXZ PROC			; x86_64_measure_cpu_speed, COMDAT

; 415  : void x86_64_measure_cpu_speed() {

$LN8:
	push	rbp
	sub	rsp, 128				; 00000080H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__F57A60C1_x86_64_cpu@cpp
	call	__CheckForDebuggerJustMyCode

; 416  : 	x64_cli();

	call	x64_cli

; 417  : 	bootTime = 0;

	mov	QWORD PTR ?bootTime@@3_KA, 0		; bootTime

; 418  : 	bootTime = readCMOS();

	call	?readCMOS@@YA_KXZ			; readCMOS
	mov	QWORD PTR ?bootTime@@3_KA, rax		; bootTime

; 419  : 	uint8_t al = x64_inportb(0x61);

	mov	cx, 97					; 00000061H
	call	x64_inportb
	mov	BYTE PTR al$[rbp], al

; 420  : 	al &= 0xDD;

	movzx	eax, BYTE PTR al$[rbp]
	and	eax, 221				; 000000ddH
	mov	BYTE PTR al$[rbp], al

; 421  : 	al |= 0x1;

	movzx	eax, BYTE PTR al$[rbp]
	or	eax, 1
	mov	BYTE PTR al$[rbp], al

; 422  : 	x64_outportb(0x61, al);

	movzx	edx, BYTE PTR al$[rbp]
	mov	cx, 97					; 00000061H
	call	x64_outportb

; 423  : 
; 424  : 	x64_outportb(0x43, 0xB2);

	mov	dl, 178					; 000000b2H
	mov	cx, 67					; 00000043H
	call	x64_outportb

; 425  : 	x64_outportb(0x42, 0x9B);

	mov	dl, 155					; 0000009bH
	mov	cx, 66					; 00000042H
	call	x64_outportb

; 426  : 	al = x64_inportb(0x60);

	mov	cx, 96					; 00000060H
	call	x64_inportb
	mov	BYTE PTR al$[rbp], al

; 427  : 
; 428  : 	x64_outportb(0x42, 0x2E);

	mov	dl, 46					; 0000002eH
	mov	cx, 66					; 00000042H
	call	x64_outportb

; 429  : 
; 430  : 	al = x64_inportb(0x61);

	mov	cx, 97					; 00000061H
	call	x64_inportb
	mov	BYTE PTR al$[rbp], al

; 431  : 	al &= 0xDE;

	movzx	eax, BYTE PTR al$[rbp]
	and	eax, 222				; 000000deH
	mov	BYTE PTR al$[rbp], al

; 432  : 	x64_outportb(0x61, al);

	movzx	edx, BYTE PTR al$[rbp]
	mov	cx, 97					; 00000061H
	call	x64_outportb

; 433  : 
; 434  : 	al |= 0x01;

	movzx	eax, BYTE PTR al$[rbp]
	or	eax, 1
	mov	BYTE PTR al$[rbp], al

; 435  : 	x64_outportb(0x61, al);

	movzx	edx, BYTE PTR al$[rbp]
	mov	cx, 97					; 00000061H
	call	x64_outportb

; 436  : 	long stsc = cpu_read_tsc();

	call	?cpu_read_tsc@@YA_KXZ			; cpu_read_tsc
	mov	DWORD PTR stsc$[rbp], eax

; 437  : 	
; 438  : 	uint8_t count_lo = x64_inportb(0x61);

	mov	cx, 97					; 00000061H
	call	x64_inportb
	mov	BYTE PTR count_lo$[rbp], al

; 439  : 	count_lo &= 0x20;

	movzx	eax, BYTE PTR count_lo$[rbp]
	and	eax, 32					; 00000020H
	mov	BYTE PTR count_lo$[rbp], al
$LN2@x86_64_mea:

; 440  : 	while (count_lo) {

	movzx	eax, BYTE PTR count_lo$[rbp]
	test	eax, eax
	je	SHORT $LN3@x86_64_mea

; 441  : 		count_lo = x64_inportb(0x61);

	mov	cx, 97					; 00000061H
	call	x64_inportb
	mov	BYTE PTR count_lo$[rbp], al

; 442  : 		count_lo &= 0x20;

	movzx	eax, BYTE PTR count_lo$[rbp]
	and	eax, 32					; 00000020H
	mov	BYTE PTR count_lo$[rbp], al

; 443  : 	}

	jmp	SHORT $LN2@x86_64_mea
$LN3@x86_64_mea:

; 444  : 
; 445  : 	uint8_t count_hi = x64_inportb(0x61);

	mov	cx, 97					; 00000061H
	call	x64_inportb
	mov	BYTE PTR count_hi$[rbp], al

; 446  : 	count_hi &= 0x20;

	movzx	eax, BYTE PTR count_hi$[rbp]
	and	eax, 32					; 00000020H
	mov	BYTE PTR count_hi$[rbp], al

; 447  : 	long etsc = cpu_read_tsc();

	call	?cpu_read_tsc@@YA_KXZ			; cpu_read_tsc
	mov	DWORD PTR etsc$[rbp], eax

; 448  : 	uint64_t cpu_hz = (etsc - stsc) / 10000;

	mov	eax, DWORD PTR stsc$[rbp]
	mov	ecx, DWORD PTR etsc$[rbp]
	sub	ecx, eax
	mov	eax, ecx
	cdq
	mov	ecx, 10000				; 00002710H
	idiv	ecx
	cdqe
	mov	QWORD PTR cpu_hz$[rbp], rax

; 449  : 
; 450  : 	if (cpu_hz == 0){

	cmp	QWORD PTR cpu_hz$[rbp], 0
	jne	SHORT $LN6@x86_64_mea

; 451  : 		x64_outportb(0x43, 0x04);

	mov	dl, 4
	mov	cx, 67					; 00000043H
	call	x64_outportb
$LN4@x86_64_mea:

; 452  : 		while (count_hi == 0){

	movzx	eax, BYTE PTR count_hi$[rbp]
	test	eax, eax
	jne	SHORT $LN5@x86_64_mea

; 453  : 			count_hi = x64_inportb(0x61);

	mov	cx, 97					; 00000061H
	call	x64_inportb
	mov	BYTE PTR count_hi$[rbp], al

; 454  : 			count_hi &= 0x20;

	movzx	eax, BYTE PTR count_hi$[rbp]
	and	eax, 32					; 00000020H
	mov	BYTE PTR count_hi$[rbp], al

; 455  : 		}

	jmp	SHORT $LN4@x86_64_mea
$LN5@x86_64_mea:

; 456  : 		etsc = cpu_read_tsc();

	call	?cpu_read_tsc@@YA_KXZ			; cpu_read_tsc
	mov	DWORD PTR etsc$[rbp], eax
$LN6@x86_64_mea:

; 457  : 	}
; 458  : 	cpu_hz = (etsc - stsc) / 10000;

	mov	eax, DWORD PTR stsc$[rbp]
	mov	ecx, DWORD PTR etsc$[rbp]
	sub	ecx, eax
	mov	eax, ecx
	cdq
	mov	ecx, 10000				; 00002710H
	idiv	ecx
	cdqe
	mov	QWORD PTR cpu_hz$[rbp], rax

; 459  : 	cpuMhz = cpu_hz;

	mov	rax, QWORD PTR cpu_hz$[rbp]
	mov	QWORD PTR ?cpuMhz@@3_KA, rax		; cpuMhz

; 460  : 	tscBasisTiming = stsc / cpuMhz;

	movsxd	rax, DWORD PTR stsc$[rbp]
	xor	edx, edx
	div	QWORD PTR ?cpuMhz@@3_KA			; cpuMhz
	mov	QWORD PTR ?tscBasisTiming@@3_KA, rax	; tscBasisTiming

; 461  : }

	lea	rsp, QWORD PTR [rbp+96]
	pop	rbp
	ret	0
?x86_64_measure_cpu_speed@@YAXXZ ENDP			; x86_64_measure_cpu_speed
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\x86_64_cpu.cpp
;	COMDAT ?cpu_read_tsc@@YA_KXZ
_TEXT	SEGMENT
hi$ = 0
lo$ = 4
count$ = 8
?cpu_read_tsc@@YA_KXZ PROC				; cpu_read_tsc, COMDAT

; 280  : uint64_t cpu_read_tsc(){

$LN3:
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__F57A60C1_x86_64_cpu@cpp
	call	__CheckForDebuggerJustMyCode

; 281  : 	uint32_t hi = 0;

	mov	DWORD PTR hi$[rbp], 0

; 282  : 	uint32_t lo = 0;

	mov	DWORD PTR lo$[rbp], 0

; 283  : 	x64_rdtsc(&hi, &lo);

	lea	rdx, QWORD PTR lo$[rbp]
	lea	rcx, QWORD PTR hi$[rbp]
	call	x64_rdtsc

; 284  : 	uint64_t count = (((uint64_t)hi << 32UL) | (uint64_t)lo);

	mov	eax, DWORD PTR hi$[rbp]
	shl	rax, 32					; 00000020H
	mov	ecx, DWORD PTR lo$[rbp]
	or	rax, rcx
	mov	QWORD PTR count$[rbp], rax

; 285  : 	return count;

	mov	rax, QWORD PTR count$[rbp]

; 286  : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
?cpu_read_tsc@@YA_KXZ ENDP				; cpu_read_tsc
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\x86_64_cpu.cpp
;	COMDAT ?x86_64_initialise_syscall@@YAXXZ
_TEXT	SEGMENT
syscall_sel$ = 0
sysret_sel$ = 8
?x86_64_initialise_syscall@@YAXXZ PROC			; x86_64_initialise_syscall, COMDAT

; 267  : void x86_64_initialise_syscall() {

$LN3:
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__F57A60C1_x86_64_cpu@cpp
	call	__CheckForDebuggerJustMyCode

; 268  : 	uint64_t syscall_sel = SEGVAL(GDT_ENTRY_KERNEL_CODE, 0);

	mov	QWORD PTR syscall_sel$[rbp], 8

; 269  : 	uint64_t sysret_sel = SEGVAL(GDT_ENTRY_USER_CODE32, 3);

	mov	QWORD PTR sysret_sel$[rbp], 27

; 270  : 
; 271  : 	x64_write_msr(IA32_STAR, (sysret_sel << 48) | (syscall_sel << 32));

	mov	rax, QWORD PTR sysret_sel$[rbp]
	shl	rax, 48					; 00000030H
	mov	rcx, QWORD PTR syscall_sel$[rbp]
	shl	rcx, 32					; 00000020H
	or	rax, rcx
	mov	rdx, rax
	mov	ecx, -1073741695			; c0000081H
	call	x64_write_msr

; 272  : 	x64_write_msr(IA32_LSTAR, (size_t)&syscall_entry);

	lea	rdx, OFFSET FLAT:syscall_entry
	mov	ecx, -1073741694			; c0000082H
	call	x64_write_msr

; 273  : 	x64_write_msr(IA32_SFMASK, IA32_EFLAGS_INTR | IA32_EFLAGS_DIRF);

	mov	edx, 1536				; 00000600H
	mov	ecx, -1073741692			; c0000084H
	call	x64_write_msr

; 274  : 	x64_write_msr(IA32_CSTAR, (size_t)&x64_syscall_entry_compat);

	lea	rdx, OFFSET FLAT:x64_syscall_entry_compat
	mov	ecx, -1073741693			; c0000083H
	call	x64_write_msr

; 275  : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
?x86_64_initialise_syscall@@YAXXZ ENDP			; x86_64_initialise_syscall
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\x86_64_cpu.cpp
;	COMDAT ?x86_64_set_ap_start_bit@@YAX_N@Z
_TEXT	SEGMENT
value$ = 80
?x86_64_set_ap_start_bit@@YAX_N@Z PROC			; x86_64_set_ap_start_bit, COMDAT

; 257  : void x86_64_set_ap_start_bit(bool value) {

$LN3:
	mov	BYTE PTR [rsp+8], cl
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__F57A60C1_x86_64_cpu@cpp
	call	__CheckForDebuggerJustMyCode

; 258  : 	__ApStarted = value;

	movzx	eax, BYTE PTR value$[rbp]
	mov	BYTE PTR ?__ApStarted@@3_NA, al		; __ApStarted

; 259  : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
?x86_64_set_ap_start_bit@@YAX_N@Z ENDP			; x86_64_set_ap_start_bit
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\x86_64_cpu.cpp
;	COMDAT ?x86_64_cpu_initialize@@YAXE@Z
_TEXT	SEGMENT
apdata$ = 0
ap_init_address$ = 8
ap_aligned_address$ = 16
pml4$ = 24
i$1 = 32
stack_address$2 = 40
cpu_struc$3 = 48
cpu$4 = 56
startup_ipi$5 = 64
i$6 = 72
i$7 = 76
num_cpu$ = 160
?x86_64_cpu_initialize@@YAXE@Z PROC			; x86_64_cpu_initialize, COMDAT

; 200  : void x86_64_cpu_initialize(uint8_t num_cpu) {

$LN23:
	mov	BYTE PTR [rsp+8], cl
	push	rbp
	sub	rsp, 176				; 000000b0H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__F57A60C1_x86_64_cpu@cpp
	call	__CheckForDebuggerJustMyCode

; 201  : 	if (num_cpu == 0)

	movzx	eax, BYTE PTR num_cpu$[rbp]
	test	eax, eax
	jne	SHORT $LN20@x86_64_cpu

; 202  : 		return;

	jmp	$LN1@x86_64_cpu
$LN20@x86_64_cpu:

; 203  : 
; 204  : 	//! fixed address
; 205  : 	uint64_t *apdata = (uint64_t*)0xA000;

	mov	QWORD PTR apdata$[rbp], 40960		; 0000a000H

; 206  : 	uint64_t ap_init_address = (uint64_t)x86_64_ap_init;

	lea	rax, OFFSET FLAT:?x86_64_ap_init@@YAXPEAX@Z ; x86_64_ap_init
	mov	QWORD PTR ap_init_address$[rbp], rax

; 207  : 	uint64_t ap_aligned_address = (uint64_t)apdata;

	mov	rax, QWORD PTR apdata$[rbp]
	mov	QWORD PTR ap_aligned_address$[rbp], rax

; 208  : 
; 209  : 	uint64_t *pml4 = (uint64_t*)AuGetRootPageTable();

	call	AuGetRootPageTable
	mov	QWORD PTR pml4$[rbp], rax

; 210  : 	
; 211  : 	for (int i = 1; i <= num_cpu; i++) {

	mov	DWORD PTR i$1[rbp], 1
	jmp	SHORT $LN4@x86_64_cpu
$LN2@x86_64_cpu:
	mov	eax, DWORD PTR i$1[rbp]
	inc	eax
	mov	DWORD PTR i$1[rbp], eax
$LN4@x86_64_cpu:
	movzx	eax, BYTE PTR num_cpu$[rbp]
	cmp	DWORD PTR i$1[rbp], eax
	jg	$LN3@x86_64_cpu

; 212  : 
; 213  : 		/* In SMP Mode : no more than 8 cpus */
; 214  : 		if (i == 8)

	cmp	DWORD PTR i$1[rbp], 8
	jne	SHORT $LN21@x86_64_cpu

; 215  : 			break;

	jmp	$LN3@x86_64_cpu
$LN21@x86_64_cpu:

; 216  : 	
; 217  : 		__ApStarted = false;

	mov	BYTE PTR ?__ApStarted@@3_NA, 0		; __ApStarted

; 218  : 
; 219  : 
; 220  : 		void *stack_address = AuPmmngrAlloc();

	call	AuPmmngrAlloc
	mov	QWORD PTR stack_address$2[rbp], rax

; 221  : 		*(uint64_t*)(ap_aligned_address + 8) = (uint64_t)pml4;

	mov	rax, QWORD PTR ap_aligned_address$[rbp]
	mov	rcx, QWORD PTR pml4$[rbp]
	mov	QWORD PTR [rax+8], rcx

; 222  : 		*(uint64_t*)(ap_aligned_address + 16) = (uint64_t)stack_address;

	mov	rax, QWORD PTR ap_aligned_address$[rbp]
	mov	rcx, QWORD PTR stack_address$2[rbp]
	mov	QWORD PTR [rax+16], rcx

; 223  : 		*(uint64_t*)(ap_aligned_address + 24) = ap_init_address;

	mov	rax, QWORD PTR ap_aligned_address$[rbp]
	mov	rcx, QWORD PTR ap_init_address$[rbp]
	mov	QWORD PTR [rax+24], rcx

; 224  : 		*(uint64_t*)(ap_aligned_address + 32) = (uint64_t)P2V((size_t)AuPmmngrAlloc());

	call	AuPmmngrAlloc
	mov	rcx, rax
	call	P2V
	mov	rcx, QWORD PTR ap_aligned_address$[rbp]
	mov	QWORD PTR [rcx+32], rax

; 225  : 		void* cpu_struc = (void*)P2V((uint64_t)AuPmmngrAlloc());

	call	AuPmmngrAlloc
	mov	rcx, rax
	call	P2V
	mov	QWORD PTR cpu_struc$3[rbp], rax

; 226  : 		CPUStruc *cpu = (CPUStruc*)cpu_struc;

	mov	rax, QWORD PTR cpu_struc$3[rbp]
	mov	QWORD PTR cpu$4[rbp], rax

; 227  : 		cpu->cpu_id = i;

	mov	rax, QWORD PTR cpu$4[rbp]
	movzx	ecx, BYTE PTR i$1[rbp]
	mov	BYTE PTR [rax], cl

; 228  : 		cpu->au_current_thread = 0;

	mov	rax, QWORD PTR cpu$4[rbp]
	mov	QWORD PTR [rax+1], 0

; 229  : 		cpu->kernel_tss = 0;

	mov	rax, QWORD PTR cpu$4[rbp]
	mov	QWORD PTR [rax+9], 0

; 230  : 		*(uint64_t*)(ap_aligned_address + 40) = (uint64_t)cpu_struc;

	mov	rax, QWORD PTR ap_aligned_address$[rbp]
	mov	rcx, QWORD PTR cpu_struc$3[rbp]
	mov	QWORD PTR [rax+40], rcx

; 231  : 
; 232  : 
; 233  : 		WriteAPICRegister(LAPIC_REGISTER_ICR, _ICRDest(i) | 0x4500);

	mov	ecx, DWORD PTR i$1[rbp]
	call	?_ICRDest@@YA_KI@Z			; _ICRDest
	or	rax, 17664				; 00004500H
	mov	rdx, rax
	mov	cx, 48					; 00000030H
	call	?WriteAPICRegister@@YAXG_K@Z		; WriteAPICRegister
$LN5@x86_64_cpu:

; 234  : 		while (_ICRBusy());

	call	?_ICRBusy@@YA_NXZ			; _ICRBusy
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN6@x86_64_cpu
	jmp	SHORT $LN5@x86_64_cpu
$LN6@x86_64_cpu:

; 235  : 
; 236  : 
; 237  : 		size_t startup_ipi = _ICRDest(i) | 0x4600 | ((size_t)apdata >> 12);

	mov	ecx, DWORD PTR i$1[rbp]
	call	?_ICRDest@@YA_KI@Z			; _ICRDest
	or	rax, 17920				; 00004600H
	mov	rcx, QWORD PTR apdata$[rbp]
	shr	rcx, 12
	or	rax, rcx
	mov	QWORD PTR startup_ipi$5[rbp], rax

; 238  : 		WriteAPICRegister(LAPIC_REGISTER_ICR, startup_ipi);

	mov	rdx, QWORD PTR startup_ipi$5[rbp]
	mov	cx, 48					; 00000030H
	call	?WriteAPICRegister@@YAXG_K@Z		; WriteAPICRegister
$LN7@x86_64_cpu:

; 239  : 		while (_ICRBusy());

	call	?_ICRBusy@@YA_NXZ			; _ICRBusy
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN8@x86_64_cpu
	jmp	SHORT $LN7@x86_64_cpu
$LN8@x86_64_cpu:

; 240  : 		for (int i = 0; i < 10000000; i++)

	mov	DWORD PTR i$6[rbp], 0
	jmp	SHORT $LN11@x86_64_cpu
$LN9@x86_64_cpu:
	mov	eax, DWORD PTR i$6[rbp]
	inc	eax
	mov	DWORD PTR i$6[rbp], eax
$LN11@x86_64_cpu:
	cmp	DWORD PTR i$6[rbp], 10000000		; 00989680H
	jge	SHORT $LN10@x86_64_cpu

; 241  : 			;

	jmp	SHORT $LN9@x86_64_cpu
$LN10@x86_64_cpu:

; 242  : 		WriteAPICRegister(LAPIC_REGISTER_ICR, startup_ipi);

	mov	rdx, QWORD PTR startup_ipi$5[rbp]
	mov	cx, 48					; 00000030H
	call	?WriteAPICRegister@@YAXG_K@Z		; WriteAPICRegister
$LN12@x86_64_cpu:

; 243  : 		while (_ICRBusy());

	call	?_ICRBusy@@YA_NXZ			; _ICRBusy
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN13@x86_64_cpu
	jmp	SHORT $LN12@x86_64_cpu
$LN13@x86_64_cpu:

; 244  : 
; 245  : 		for (int i = 0; i < 10000000; i++)

	mov	DWORD PTR i$7[rbp], 0
	jmp	SHORT $LN16@x86_64_cpu
$LN14@x86_64_cpu:
	mov	eax, DWORD PTR i$7[rbp]
	inc	eax
	mov	DWORD PTR i$7[rbp], eax
$LN16@x86_64_cpu:
	cmp	DWORD PTR i$7[rbp], 10000000		; 00989680H
	jge	SHORT $LN15@x86_64_cpu

; 246  : 			;

	jmp	SHORT $LN14@x86_64_cpu
$LN15@x86_64_cpu:
$LN19@x86_64_cpu:

; 247  : 		do {
; 248  : 			x64_pause();

	call	x64_pause

; 249  : 		} while (!__ApStarted);

	movzx	eax, BYTE PTR ?__ApStarted@@3_NA	; __ApStarted
	test	eax, eax
	je	SHORT $LN19@x86_64_cpu

; 250  : 	}

	jmp	$LN2@x86_64_cpu
$LN3@x86_64_cpu:
$LN1@x86_64_cpu:

; 251  : }

	lea	rsp, QWORD PTR [rbp+144]
	pop	rbp
	ret	0
?x86_64_cpu_initialize@@YAXE@Z ENDP			; x86_64_cpu_initialize
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\x86_64_cpu.cpp
;	COMDAT ?x86_64_cpu_msi_address@@YA_KPEA_K_KIEE@Z
_TEXT	SEGMENT
tv67 = 64
tv72 = 68
data$ = 96
vector$ = 104
processor$ = 112
edge$ = 120
deassert$ = 128
?x86_64_cpu_msi_address@@YA_KPEA_K_KIEE@Z PROC		; x86_64_cpu_msi_address, COMDAT

; 174  : uint64_t x86_64_cpu_msi_address(uint64_t* data, size_t vector, uint32_t processor, uint8_t edge, uint8_t deassert) {

$LN7:
	mov	BYTE PTR [rsp+32], r9b
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__F57A60C1_x86_64_cpu@cpp
	call	__CheckForDebuggerJustMyCode

; 175  : 	*data = (vector & 0xFF) | (edge == 1 ? 0 : (1 << 15)) | (deassert == 1 ? 0 : (1 << 14));

	movzx	eax, BYTE PTR edge$[rbp]
	cmp	eax, 1
	jne	SHORT $LN3@x86_64_cpu
	mov	DWORD PTR tv67[rbp], 0
	jmp	SHORT $LN4@x86_64_cpu
$LN3@x86_64_cpu:
	mov	DWORD PTR tv67[rbp], 32768		; 00008000H
$LN4@x86_64_cpu:
	movzx	eax, BYTE PTR deassert$[rbp]
	cmp	eax, 1
	jne	SHORT $LN5@x86_64_cpu
	mov	DWORD PTR tv72[rbp], 0
	jmp	SHORT $LN6@x86_64_cpu
$LN5@x86_64_cpu:
	mov	DWORD PTR tv72[rbp], 16384		; 00004000H
$LN6@x86_64_cpu:
	mov	rax, QWORD PTR vector$[rbp]
	and	rax, 255				; 000000ffH
	movsxd	rcx, DWORD PTR tv67[rbp]
	or	rax, rcx
	movsxd	rcx, DWORD PTR tv72[rbp]
	or	rax, rcx
	mov	rcx, QWORD PTR data$[rbp]
	mov	QWORD PTR [rcx], rax

; 176  : 	//*data = low;
; 177  : 	return (0xFEE00000 | (processor << 12));

	mov	eax, DWORD PTR processor$[rbp]
	shl	eax, 12
	or	eax, -18874368				; fee00000H
	mov	eax, eax

; 178  : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
?x86_64_cpu_msi_address@@YA_KPEA_K_KIEE@Z ENDP		; x86_64_cpu_msi_address
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\x86_64_cpu.cpp
;	COMDAT ?x86_64_is_cpu_fxsave_supported@@YA_NXZ
_TEXT	SEGMENT
?x86_64_is_cpu_fxsave_supported@@YA_NXZ PROC		; x86_64_is_cpu_fxsave_supported, COMDAT

; 162  : bool x86_64_is_cpu_fxsave_supported() {

$LN3:
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__F57A60C1_x86_64_cpu@cpp
	call	__CheckForDebuggerJustMyCode

; 163  : 	return _fxsave;

	movzx	eax, BYTE PTR ?_fxsave@@3_NA		; _fxsave

; 164  : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
?x86_64_is_cpu_fxsave_supported@@YA_NXZ ENDP		; x86_64_is_cpu_fxsave_supported
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\x86_64_cpu.cpp
;	COMDAT ?x86_64_hal_cpu_feature_enable@@YAXXZ
_TEXT	SEGMENT
cr0$ = 0
a$ = 8
b$ = 16
c$ = 24
d$ = 32
cr4$1 = 40
cr4$2 = 48
?x86_64_hal_cpu_feature_enable@@YAXXZ PROC		; x86_64_hal_cpu_feature_enable, COMDAT

; 126  : void x86_64_hal_cpu_feature_enable() {

$LN10:
	push	rbp
	sub	rsp, 176				; 000000b0H
	lea	rbp, QWORD PTR [rsp+48]
	lea	rcx, OFFSET FLAT:__F57A60C1_x86_64_cpu@cpp
	call	__CheckForDebuggerJustMyCode

; 127  : 	uint64_t cr0 = x64_read_cr0();

	call	x64_read_cr0
	mov	QWORD PTR cr0$[rbp], rax

; 128  : 	cr0 &= ~(1 << 2);

	mov	rax, QWORD PTR cr0$[rbp]
	and	rax, -5
	mov	QWORD PTR cr0$[rbp], rax

; 129  : 	cr0 |= (1 << 1);

	mov	rax, QWORD PTR cr0$[rbp]
	or	rax, 2
	mov	QWORD PTR cr0$[rbp], rax

; 130  : 	x64_write_cr0(cr0);

	mov	rcx, QWORD PTR cr0$[rbp]
	call	x64_write_cr0

; 131  : 
; 132  : 	size_t a, b, c, d;
; 133  : 	x64_cpuid(1, &a, &b, &c, &d, 0);

	mov	QWORD PTR [rsp+40], 0
	lea	rax, QWORD PTR d$[rbp]
	mov	QWORD PTR [rsp+32], rax
	lea	r9, QWORD PTR c$[rbp]
	lea	r8, QWORD PTR b$[rbp]
	lea	rdx, QWORD PTR a$[rbp]
	mov	ecx, 1
	call	x64_cpuid

; 134  : 	if ((c & (1 << 26)) != 0) {

	mov	rax, QWORD PTR c$[rbp]
	and	rax, 67108864				; 04000000H
	test	rax, rax
	je	SHORT $LN2@x86_64_hal

; 135  : 		uint64_t cr4 = x64_read_cr4();

	call	x64_read_cr4
	mov	QWORD PTR cr4$1[rbp], rax

; 136  : 		cr4 |= (1 << 18);

	mov	rax, QWORD PTR cr4$1[rbp]
	bts	rax, 18
	mov	QWORD PTR cr4$1[rbp], rax

; 137  : 		x64_write_cr4(cr4);

	mov	rcx, QWORD PTR cr4$1[rbp]
	call	x64_write_cr4
$LN2@x86_64_hal:

; 138  : 	}
; 139  : 
; 140  : 	if ((d & (1 << 25)) != 0) {

	mov	rax, QWORD PTR d$[rbp]
	and	rax, 33554432				; 02000000H
	test	rax, rax
	je	SHORT $LN3@x86_64_hal

; 141  : 		size_t cr4 = x64_read_cr4();

	call	x64_read_cr4
	mov	QWORD PTR cr4$2[rbp], rax

; 142  : 
; 143  : 		if ((d & (1 << 24)) != 0) {

	mov	rax, QWORD PTR d$[rbp]
	and	rax, 16777216				; 01000000H
	test	rax, rax
	je	SHORT $LN5@x86_64_hal

; 144  : 			cr4 |= (1 << 9);

	mov	rax, QWORD PTR cr4$2[rbp]
	bts	rax, 9
	mov	QWORD PTR cr4$2[rbp], rax

; 145  : 			_fxsave = true;

	mov	BYTE PTR ?_fxsave@@3_NA, 1		; _fxsave
$LN5@x86_64_hal:

; 146  : 		}
; 147  : 
; 148  : 		cr4 |= (1 << 10);

	mov	rax, QWORD PTR cr4$2[rbp]
	bts	rax, 10
	mov	QWORD PTR cr4$2[rbp], rax

; 149  : 		x64_write_cr4(cr4);

	mov	rcx, QWORD PTR cr4$2[rbp]
	call	x64_write_cr4

; 150  : 	}

	jmp	SHORT $LN4@x86_64_hal
$LN3@x86_64_hal:

; 151  : 
; 152  : 	else if ((d & (1 << 26)) != 0) {

	mov	rax, QWORD PTR d$[rbp]
	and	rax, 67108864				; 04000000H
	test	rax, rax
	je	SHORT $LN6@x86_64_hal

; 153  : 		//supported SSE2
; 154  : 	}

	jmp	SHORT $LN7@x86_64_hal
$LN6@x86_64_hal:

; 155  : 
; 156  : 	else if ((c & (1 << 0)) != 0) {

	mov	rax, QWORD PTR c$[rbp]
	and	rax, 1
$LN7@x86_64_hal:
$LN4@x86_64_hal:

; 157  : 		//supported SSE3
; 158  : 	}
; 159  : }

	lea	rsp, QWORD PTR [rbp+128]
	pop	rbp
	ret	0
?x86_64_hal_cpu_feature_enable@@YAXXZ ENDP		; x86_64_hal_cpu_feature_enable
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\x86_64_cpu.cpp
;	COMDAT ?x86_64_get_tss@@YAPEAU_tss@@XZ
_TEXT	SEGMENT
?x86_64_get_tss@@YAPEAU_tss@@XZ PROC			; x86_64_get_tss, COMDAT

; 119  : TSS* x86_64_get_tss() {

$LN3:
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__F57A60C1_x86_64_cpu@cpp
	call	__CheckForDebuggerJustMyCode

; 120  : 	return _tss;

	mov	rax, QWORD PTR ?_tss@@3PEAU0@EA		; _tss

; 121  : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
?x86_64_get_tss@@YAPEAU_tss@@XZ ENDP			; x86_64_get_tss
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\x86_64_cpu.cpp
;	COMDAT ?x86_64_init_user_ap@@YAX_K@Z
_TEXT	SEGMENT
data_sel$ = 0
code_sel$ = 4
peek_gdt$ = 8
tss_entry$ = 24
tss_$ = 32
tv64 = 104
bit$ = 128
?x86_64_init_user_ap@@YAX_K@Z PROC			; x86_64_init_user_ap, COMDAT

; 92   : void x86_64_init_user_ap(size_t bit) {

$LN8:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 144				; 00000090H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__F57A60C1_x86_64_cpu@cpp
	call	__CheckForDebuggerJustMyCode

; 93   : 
; 94   : 	uint16_t data_sel = SEGVAL(GDT_ENTRY_USER_DATA, 3);

	mov	eax, 35					; 00000023H
	mov	WORD PTR data_sel$[rbp], ax

; 95   : 	uint16_t code_sel = 0;

	xor	eax, eax
	mov	WORD PTR code_sel$[rbp], ax

; 96   : 	switch (bit) {

	mov	rax, QWORD PTR bit$[rbp]
	mov	QWORD PTR tv64[rbp], rax
	cmp	QWORD PTR tv64[rbp], 32			; 00000020H
	je	SHORT $LN5@x86_64_ini
	cmp	QWORD PTR tv64[rbp], 64			; 00000040H
	je	SHORT $LN4@x86_64_ini
	jmp	SHORT $LN6@x86_64_ini
$LN4@x86_64_ini:

; 97   : 	case 64:
; 98   : 		code_sel = SEGVAL(GDT_ENTRY_USER_CODE, 3);

	mov	eax, 43					; 0000002bH
	mov	WORD PTR code_sel$[rbp], ax

; 99   : 		break;

	jmp	SHORT $LN2@x86_64_ini
$LN5@x86_64_ini:

; 100  : 	case 32:
; 101  : 		code_sel = SEGVAL(GDT_ENTRY_USER_CODE32, 3);

	mov	eax, 27
	mov	WORD PTR code_sel$[rbp], ax

; 102  : 		break;

	jmp	SHORT $LN2@x86_64_ini
$LN6@x86_64_ini:

; 103  : 	default:
; 104  : 		return;

	jmp	SHORT $LN1@x86_64_ini
$LN2@x86_64_ini:

; 105  : 	}
; 106  : 
; 107  : 	gdtr peek_gdt;
; 108  : 	x64_sgdt(&peek_gdt);

	lea	rcx, QWORD PTR peek_gdt$[rbp]
	call	x64_sgdt

; 109  : 	gdt_entry& tss_entry = peek_gdt.gdtaddr[GDT_ENTRY_TSS];

	mov	eax, 8
	imul	rax, rax, 7
	mov	rcx, QWORD PTR peek_gdt$[rbp+2]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR tss_entry$[rbp], rax

; 110  : 
; 111  : 	TSS *tss_ = (TSS*)(tss_entry.base_low + (tss_entry.base_mid << 16) + (tss_entry.base_high << 24) + ((uint64_t)*(uint32_t*)&peek_gdt.gdtaddr[GDT_ENTRY_TSS + 1] << 32));

	mov	rax, QWORD PTR tss_entry$[rbp]
	movzx	eax, WORD PTR [rax+2]
	mov	rcx, QWORD PTR tss_entry$[rbp]
	movzx	ecx, BYTE PTR [rcx+4]
	shl	ecx, 16
	add	eax, ecx
	mov	rcx, QWORD PTR tss_entry$[rbp]
	movzx	ecx, BYTE PTR [rcx+7]
	shl	ecx, 24
	add	eax, ecx
	cdqe
	mov	ecx, 8
	imul	rcx, rcx, 8
	mov	rdx, QWORD PTR peek_gdt$[rbp+2]
	mov	ecx, DWORD PTR [rdx+rcx]
	shl	rcx, 32					; 00000020H
	add	rax, rcx
	mov	QWORD PTR tss_$[rbp], rax

; 112  : 
; 113  : 	AuPerCPUSetKernelTSS(tss_);

	mov	rcx, QWORD PTR tss_$[rbp]
	call	?AuPerCPUSetKernelTSS@@YAXPEAU_tss@@@Z	; AuPerCPUSetKernelTSS
$LN1@x86_64_ini:

; 114  : }

	lea	rsp, QWORD PTR [rbp+112]
	pop	rbp
	ret	0
?x86_64_init_user_ap@@YAX_K@Z ENDP			; x86_64_init_user_ap
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\x86_64_cpu.cpp
;	COMDAT ?x86_64_init_user@@YAX_K@Z
_TEXT	SEGMENT
data_sel$ = 0
code_sel$ = 4
peek_gdt$ = 8
tss_entry$ = 24
tv64 = 96
bit$ = 128
?x86_64_init_user@@YAX_K@Z PROC				; x86_64_init_user, COMDAT

; 64   : void x86_64_init_user(size_t bit) {

$LN8:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 144				; 00000090H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__F57A60C1_x86_64_cpu@cpp
	call	__CheckForDebuggerJustMyCode

; 65   : 	uint16_t data_sel = SEGVAL(GDT_ENTRY_USER_DATA, 3);

	mov	eax, 35					; 00000023H
	mov	WORD PTR data_sel$[rbp], ax

; 66   : 	uint16_t code_sel = 0;

	xor	eax, eax
	mov	WORD PTR code_sel$[rbp], ax

; 67   : 	switch (bit) {

	mov	rax, QWORD PTR bit$[rbp]
	mov	QWORD PTR tv64[rbp], rax
	cmp	QWORD PTR tv64[rbp], 32			; 00000020H
	je	SHORT $LN5@x86_64_ini
	cmp	QWORD PTR tv64[rbp], 64			; 00000040H
	je	SHORT $LN4@x86_64_ini
	jmp	SHORT $LN6@x86_64_ini
$LN4@x86_64_ini:

; 68   : 	case 64:
; 69   : 		code_sel = SEGVAL(GDT_ENTRY_USER_CODE, 3);

	mov	eax, 43					; 0000002bH
	mov	WORD PTR code_sel$[rbp], ax

; 70   : 		break;

	jmp	SHORT $LN2@x86_64_ini
$LN5@x86_64_ini:

; 71   : 	case 32:
; 72   : 		code_sel = SEGVAL(GDT_ENTRY_USER_CODE32, 3);

	mov	eax, 27
	mov	WORD PTR code_sel$[rbp], ax

; 73   : 		break;

	jmp	SHORT $LN2@x86_64_ini
$LN6@x86_64_ini:

; 74   : 	default:
; 75   : 		return;

	jmp	SHORT $LN1@x86_64_ini
$LN2@x86_64_ini:

; 76   : 	}
; 77   : 
; 78   : 	gdtr peek_gdt;
; 79   : 	x64_sgdt(&peek_gdt);

	lea	rcx, QWORD PTR peek_gdt$[rbp]
	call	x64_sgdt

; 80   : 	gdt_entry& tss_entry = peek_gdt.gdtaddr[GDT_ENTRY_TSS];

	mov	eax, 8
	imul	rax, rax, 7
	mov	rcx, QWORD PTR peek_gdt$[rbp+2]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR tss_entry$[rbp], rax

; 81   : 
; 82   : 	_tss = (TSS*)(tss_entry.base_low + (tss_entry.base_mid << 16) + (tss_entry.base_high << 24) +

	mov	rax, QWORD PTR tss_entry$[rbp]
	movzx	eax, WORD PTR [rax+2]
	mov	rcx, QWORD PTR tss_entry$[rbp]
	movzx	ecx, BYTE PTR [rcx+4]
	shl	ecx, 16
	add	eax, ecx
	mov	rcx, QWORD PTR tss_entry$[rbp]
	movzx	ecx, BYTE PTR [rcx+7]
	shl	ecx, 24
	add	eax, ecx
	cdqe
	mov	ecx, 8
	imul	rcx, rcx, 8
	mov	rdx, QWORD PTR peek_gdt$[rbp+2]
	mov	ecx, DWORD PTR [rdx+rcx]
	shl	rcx, 32					; 00000020H
	add	rax, rcx
	mov	QWORD PTR ?_tss@@3PEAU0@EA, rax		; _tss
$LN1@x86_64_ini:

; 83   : 		((uint64_t)*(uint32_t*)&peek_gdt.gdtaddr[GDT_ENTRY_TSS + 1] << 32));
; 84   : 
; 85   : }

	lea	rsp, QWORD PTR [rbp+112]
	pop	rbp
	ret	0
?x86_64_init_user@@YAX_K@Z ENDP				; x86_64_init_user
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\x86_64_cpu.cpp
;	COMDAT ?x86_64_enable_syscall_ext@@YAXXZ
_TEXT	SEGMENT
efer$ = 0
?x86_64_enable_syscall_ext@@YAXXZ PROC			; x86_64_enable_syscall_ext, COMDAT

; 53   : void x86_64_enable_syscall_ext() {

$LN3:
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__F57A60C1_x86_64_cpu@cpp
	call	__CheckForDebuggerJustMyCode

; 54   : 	size_t efer = x64_read_msr(IA32_EFER);

	mov	ecx, -1073741696			; c0000080H
	call	x64_read_msr
	mov	QWORD PTR efer$[rbp], rax

; 55   : 	efer |= (1 << 11);

	mov	rax, QWORD PTR efer$[rbp]
	bts	rax, 11
	mov	QWORD PTR efer$[rbp], rax

; 56   : 	efer |= 1;

	mov	rax, QWORD PTR efer$[rbp]
	or	rax, 1
	mov	QWORD PTR efer$[rbp], rax

; 57   : 	x64_write_msr(IA32_EFER, efer);

	mov	rdx, QWORD PTR efer$[rbp]
	mov	ecx, -1073741696			; c0000080H
	call	x64_write_msr

; 58   : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
?x86_64_enable_syscall_ext@@YAXXZ ENDP			; x86_64_enable_syscall_ext
_TEXT	ENDS
END
