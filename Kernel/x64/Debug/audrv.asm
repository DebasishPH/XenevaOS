; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30154.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?drivers@@3PAPEAU_aurora_driver_@@A		; drivers
PUBLIC	?au_devices@@3PAPEAU_aurora_device_@@A		; au_devices
_BSS	SEGMENT
?drivers@@3PAPEAU_aurora_driver_@@A DQ 0100H DUP (?)	; drivers
?au_devices@@3PAPEAU_aurora_device_@@A DQ 0100H DUP (?)	; au_devices
_BSS	ENDS
msvcjmc	SEGMENT
__8CEAB164_audrv@cpp DB 01H
__303BDA61_stdint@h DB 01H
msvcjmc	ENDS
PUBLIC	?AuDrvMngrInitialize@@YAXPEAU_KERNEL_BOOT_INFO_@@@Z ; AuDrvMngrInitialize
PUBLIC	AuRegisterDevice
PUBLIC	AuCheckDevice
PUBLIC	?AuRequestDriverId@@YAIXZ			; AuRequestDriverId
PUBLIC	?AuDecreaseDriverCount@@YAXXZ			; AuDecreaseDriverCount
PUBLIC	?AuIncreaseDriverCount@@YAXXZ			; AuIncreaseDriverCount
PUBLIC	?AuGetConfEntry@@YAPEADIIPEAEH@Z		; AuGetConfEntry
PUBLIC	?AuCreateDriverInstance@@YAXPEAD@Z		; AuCreateDriverInstance
PUBLIC	?AuGetDriverName@@YAXIIPEAEH@Z			; AuGetDriverName
PUBLIC	?AuDriverLoad@@YAXPEADPEAU_aurora_driver_@@@Z	; AuDriverLoad
PUBLIC	??$raw_offset@PEAU_IMAGE_NT_HEADERS_PE32PLUS@@PEAU_IMAGE_DOS_HEADER_@@@@YAPEAU_IMAGE_NT_HEADERS_PE32PLUS@@PEAU_IMAGE_DOS_HEADER_@@H@Z ; raw_offset<_IMAGE_NT_HEADERS_PE32PLUS *,_IMAGE_DOS_HEADER_ *>
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_0BE@GNJNFAPE@Drivername?5?9?$DO?5?$CFs?5?$AN?6@ ; `string'
PUBLIC	??_C@_0N@CCEOOCAH@AuDriverMain@			; `string'
PUBLIC	??_C@_0P@JMPKLAAA@AuDriverUnload@		; `string'
PUBLIC	??_C@_0DB@GGOFEGOE@?$FLAurora?$FN?3?5Initializing?5drivers?0@ ; `string'
PUBLIC	??_C@_01KMDKNFGN@?1@				; `string'
PUBLIC	??_C@_0L@NBKMLOMK@?1audrv?4cnf@			; `string'
EXTRN	AuVFSOpen:PROC
EXTRN	AuVFSFind:PROC
EXTRN	AuVFSNodeReadBlock:PROC
EXTRN	AuPmmngrAlloc:PROC
EXTRN	P2V:PROC
EXTRN	V2P:PROC
EXTRN	AuMapPage:PROC
EXTRN	strcpy:PROC
EXTRN	strchr:PROC
EXTRN	memset:PROC
EXTRN	?AuGetProcAddress@@YAPEAXPEAXPEBD@Z:PROC	; AuGetProcAddress
EXTRN	?AuKernelLinkDLL@@YAXPEAX@Z:PROC		; AuKernelLinkDLL
EXTRN	?AuKernelRelocatePE@@YAXPEAXPEAU_IMAGE_NT_HEADERS_PE32PLUS@@H@Z:PROC ; AuKernelRelocatePE
EXTRN	?atoi@@YAHPEBD@Z:PROC				; atoi
EXTRN	printf:PROC
EXTRN	kmalloc:PROC
EXTRN	kfree:PROC
EXTRN	?AuPCIEGetDevice@@YA_KGHHH@Z:PROC		; AuPCIEGetDevice
EXTRN	AuPCIERead:PROC
EXTRN	SeTextOut:PROC
EXTRN	__CheckForDebuggerJustMyCode:PROC
_BSS	SEGMENT
?_dev_count_@@3HA DD 01H DUP (?)			; _dev_count_
?driver_class_unique_id@@3IA DD 01H DUP (?)		; driver_class_unique_id
?driver_load_base@@3_KA DQ 01H DUP (?)			; driver_load_base
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuDrvMngrInitialize@@YAXPEAU_KERNEL_BOOT_INFO_@@@Z DD imagerel $LN21
	DD	imagerel $LN21+679
	DD	imagerel $unwind$?AuDrvMngrInitialize@@YAXPEAU_KERNEL_BOOT_INFO_@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AuRegisterDevice DD imagerel $LN3
	DD	imagerel $LN3+69
	DD	imagerel $unwind$AuRegisterDevice
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AuCheckDevice DD imagerel $LN7
	DD	imagerel $LN7+159
	DD	imagerel $unwind$AuCheckDevice
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuRequestDriverId@@YAIXZ DD imagerel $LN3
	DD	imagerel $LN3+55
	DD	imagerel $unwind$?AuRequestDriverId@@YAIXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuDecreaseDriverCount@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+43
	DD	imagerel $unwind$?AuDecreaseDriverCount@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuIncreaseDriverCount@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+43
	DD	imagerel $unwind$?AuIncreaseDriverCount@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuGetConfEntry@@YAPEADIIPEAEH@Z DD imagerel $LN21
	DD	imagerel $LN21+559
	DD	imagerel $unwind$?AuGetConfEntry@@YAPEADIIPEAEH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuCreateDriverInstance@@YAXPEAD@Z DD imagerel $LN3
	DD	imagerel $LN3+125
	DD	imagerel $unwind$?AuCreateDriverInstance@@YAXPEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuGetDriverName@@YAXIIPEAEH@Z DD imagerel $LN9
	DD	imagerel $LN9+257
	DD	imagerel $unwind$?AuGetDriverName@@YAXIIPEAEH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuDriverLoad@@YAXPEADPEAU_aurora_driver_@@@Z DD imagerel $LN5
	DD	imagerel $LN5+544
	DD	imagerel $unwind$?AuDriverLoad@@YAXPEADPEAU_aurora_driver_@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$raw_offset@PEAU_IMAGE_NT_HEADERS_PE32PLUS@@PEAU_IMAGE_DOS_HEADER_@@@@YAPEAU_IMAGE_NT_HEADERS_PE32PLUS@@PEAU_IMAGE_DOS_HEADER_@@H@Z DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$??$raw_offset@PEAU_IMAGE_NT_HEADERS_PE32PLUS@@PEAU_IMAGE_DOS_HEADER_@@@@YAPEAU_IMAGE_NT_HEADERS_PE32PLUS@@PEAU_IMAGE_DOS_HEADER_@@H@Z
pdata	ENDS
;	COMDAT ??_C@_0L@NBKMLOMK@?1audrv?4cnf@
CONST	SEGMENT
??_C@_0L@NBKMLOMK@?1audrv?4cnf@ DB '/audrv.cnf', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01KMDKNFGN@?1@
CONST	SEGMENT
??_C@_01KMDKNFGN@?1@ DB '/', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@GGOFEGOE@?$FLAurora?$FN?3?5Initializing?5drivers?0@
CONST	SEGMENT
??_C@_0DB@GGOFEGOE@?$FLAurora?$FN?3?5Initializing?5drivers?0@ DB '[Aurora'
	DB	']: Initializing drivers, please wait... ', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@JMPKLAAA@AuDriverUnload@
CONST	SEGMENT
??_C@_0P@JMPKLAAA@AuDriverUnload@ DB 'AuDriverUnload', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@CCEOOCAH@AuDriverMain@
CONST	SEGMENT
??_C@_0N@CCEOOCAH@AuDriverMain@ DB 'AuDriverMain', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@GNJNFAPE@Drivername?5?9?$DO?5?$CFs?5?$AN?6@
CONST	SEGMENT
??_C@_0BE@GNJNFAPE@Drivername?5?9?$DO?5?$CFs?5?$AN?6@ DB 'Drivername -> %'
	DB	's ', 0dH, 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$raw_offset@PEAU_IMAGE_NT_HEADERS_PE32PLUS@@PEAU_IMAGE_DOS_HEADER_@@@@YAPEAU_IMAGE_NT_HEADERS_PE32PLUS@@PEAU_IMAGE_DOS_HEADER_@@H@Z DD 025031301H
	DD	0b20e2313H
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuDriverLoad@@YAXPEADPEAU_aurora_driver_@@@Z DD 025041701H
	DD	01122317H
	DD	0500b001aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuGetDriverName@@YAXIIPEAEH@Z DD 025041f01H
	DD	011a231fH
	DD	050130014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuCreateDriverInstance@@YAXPEAD@Z DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuGetConfEntry@@YAPEADIIPEAEH@Z DD 025041f01H
	DD	011a231fH
	DD	050130014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuIncreaseDriverCount@@YAXXZ DD 025030b01H
	DD	0b206230bH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuDecreaseDriverCount@@YAXXZ DD 025030b01H
	DD	0b206230bH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuRequestDriverId@@YAIXZ DD 025030b01H
	DD	0d206230bH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AuCheckDevice DD 025031901H
	DD	0d2142319H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AuRegisterDevice DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuDrvMngrInitialize@@YAXPEAU_KERNEL_BOOT_INFO_@@@Z DD 035041201H
	DD	010d3312H
	DD	05006001aH
xdata	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\BaseHdr\stdint.h
;	COMDAT ??$raw_offset@PEAU_IMAGE_NT_HEADERS_PE32PLUS@@PEAU_IMAGE_DOS_HEADER_@@@@YAPEAU_IMAGE_NT_HEADERS_PE32PLUS@@PEAU_IMAGE_DOS_HEADER_@@H@Z
_TEXT	SEGMENT
p1$ = 80
offset$ = 88
??$raw_offset@PEAU_IMAGE_NT_HEADERS_PE32PLUS@@PEAU_IMAGE_DOS_HEADER_@@@@YAPEAU_IMAGE_NT_HEADERS_PE32PLUS@@PEAU_IMAGE_DOS_HEADER_@@H@Z PROC ; raw_offset<_IMAGE_NT_HEADERS_PE32PLUS *,_IMAGE_DOS_HEADER_ *>, COMDAT

; 207  : 	{

$LN3:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__303BDA61_stdint@h
	call	__CheckForDebuggerJustMyCode

; 208  : 		return (T)((size_t)p1 + offset);

	movsxd	rax, DWORD PTR offset$[rbp]
	mov	rcx, QWORD PTR p1$[rbp]
	add	rcx, rax
	mov	rax, rcx

; 209  : 	};

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
??$raw_offset@PEAU_IMAGE_NT_HEADERS_PE32PLUS@@PEAU_IMAGE_DOS_HEADER_@@@@YAPEAU_IMAGE_NT_HEADERS_PE32PLUS@@PEAU_IMAGE_DOS_HEADER_@@H@Z ENDP ; raw_offset<_IMAGE_NT_HEADERS_PE32PLUS *,_IMAGE_DOS_HEADER_ *>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\audrv.cpp
;	COMDAT ?AuDriverLoad@@YAXPEADPEAU_aurora_driver_@@@Z
_TEXT	SEGMENT
next_base_offset$ = 0
virtual_base$ = 8
fsys$ = 16
file$ = 24
buffer$ = 32
block$1 = 40
dos_$ = 48
nt$ = 56
relocatebuff$ = 64
original_base$ = 72
new_addr$ = 80
diff$ = 88
entry_addr$ = 96
unload_addr$ = 104
filename$ = 192
driver$ = 200
?AuDriverLoad@@YAXPEADPEAU_aurora_driver_@@@Z PROC	; AuDriverLoad, COMDAT

; 206  : void AuDriverLoad(char* filename, AuDriver *driver) {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 208				; 000000d0H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__8CEAB164_audrv@cpp
	call	__CheckForDebuggerJustMyCode

; 207  : 	int next_base_offset = 0;

	mov	DWORD PTR next_base_offset$[rbp], 0

; 208  : 	uint64_t* virtual_base = (uint64_t*)driver_load_base;

	mov	rax, QWORD PTR ?driver_load_base@@3_KA
	mov	QWORD PTR virtual_base$[rbp], rax

; 209  : 
; 210  : 	AuVFSNode* fsys = AuVFSFind(filename);

	mov	rcx, QWORD PTR filename$[rbp]
	call	AuVFSFind
	mov	QWORD PTR fsys$[rbp], rax

; 211  : 	AuVFSNode *file = AuVFSOpen(filename);

	mov	rcx, QWORD PTR filename$[rbp]
	call	AuVFSOpen
	mov	QWORD PTR file$[rbp], rax

; 212  : 	uint64_t* buffer = (uint64_t*)AuPmmngrAlloc();

	call	AuPmmngrAlloc
	mov	QWORD PTR buffer$[rbp], rax

; 213  : 	memset(buffer, 0, 4096);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR buffer$[rbp]
	call	memset

; 214  : 	AuVFSNodeReadBlock(fsys,file, buffer);

	mov	r8, QWORD PTR buffer$[rbp]
	mov	rdx, QWORD PTR file$[rbp]
	mov	rcx, QWORD PTR fsys$[rbp]
	call	AuVFSNodeReadBlock

; 215  : 	AuMapPage((uint64_t)buffer, driver_load_base, 0);

	xor	r8d, r8d
	mov	rdx, QWORD PTR ?driver_load_base@@3_KA
	mov	rcx, QWORD PTR buffer$[rbp]
	call	AuMapPage

; 216  : 	next_base_offset = 1;

	mov	DWORD PTR next_base_offset$[rbp], 1
$LN2@AuDriverLo:

; 217  : 
; 218  : 
; 219  : 	while (file->eof != 1) {

	mov	rax, QWORD PTR file$[rbp]
	movzx	eax, BYTE PTR [rax+36]
	cmp	eax, 1
	je	SHORT $LN3@AuDriverLo

; 220  : 		uint64_t* block = (uint64_t*)AuPmmngrAlloc();

	call	AuPmmngrAlloc
	mov	QWORD PTR block$1[rbp], rax

; 221  : 		memset(block, 0, 4096);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR block$1[rbp]
	call	memset

; 222  : 		AuVFSNodeReadBlock(fsys,file, block);

	mov	r8, QWORD PTR block$1[rbp]
	mov	rdx, QWORD PTR file$[rbp]
	mov	rcx, QWORD PTR fsys$[rbp]
	call	AuVFSNodeReadBlock

; 223  : 		AuMapPage((uint64_t)block, (driver_load_base + next_base_offset * 4096), 0);

	imul	eax, DWORD PTR next_base_offset$[rbp], 4096 ; 00001000H
	cdqe
	mov	rcx, QWORD PTR ?driver_load_base@@3_KA
	add	rcx, rax
	mov	rax, rcx
	xor	r8d, r8d
	mov	rdx, rax
	mov	rcx, QWORD PTR block$1[rbp]
	call	AuMapPage

; 224  : 		next_base_offset++;

	mov	eax, DWORD PTR next_base_offset$[rbp]
	inc	eax
	mov	DWORD PTR next_base_offset$[rbp], eax

; 225  : 	}

	jmp	SHORT $LN2@AuDriverLo
$LN3@AuDriverLo:

; 226  : 
; 227  : 	IMAGE_DOS_HEADER *dos_ = (IMAGE_DOS_HEADER*)virtual_base;

	mov	rax, QWORD PTR virtual_base$[rbp]
	mov	QWORD PTR dos_$[rbp], rax

; 228  : 	PIMAGE_NT_HEADERS nt = raw_offset<PIMAGE_NT_HEADERS>(dos_, dos_->e_lfanew);

	mov	rax, QWORD PTR dos_$[rbp]
	movzx	eax, WORD PTR [rax+60]
	mov	edx, eax
	mov	rcx, QWORD PTR dos_$[rbp]
	call	??$raw_offset@PEAU_IMAGE_NT_HEADERS_PE32PLUS@@PEAU_IMAGE_DOS_HEADER_@@@@YAPEAU_IMAGE_NT_HEADERS_PE32PLUS@@PEAU_IMAGE_DOS_HEADER_@@H@Z ; raw_offset<_IMAGE_NT_HEADERS_PE32PLUS *,_IMAGE_DOS_HEADER_ *>
	mov	QWORD PTR nt$[rbp], rax

; 229  : 
; 230  : 	uint8_t* relocatebuff = (uint8_t*)virtual_base;

	mov	rax, QWORD PTR virtual_base$[rbp]
	mov	QWORD PTR relocatebuff$[rbp], rax

; 231  : 	uint64_t original_base = nt->OptionalHeader.ImageBase;

	mov	rax, QWORD PTR nt$[rbp]
	mov	rax, QWORD PTR [rax+48]
	mov	QWORD PTR original_base$[rbp], rax

; 232  : 	uint64_t new_addr = (uint64_t)virtual_base;

	mov	rax, QWORD PTR virtual_base$[rbp]
	mov	QWORD PTR new_addr$[rbp], rax

; 233  : 	uint64_t diff = new_addr - original_base;

	mov	rax, QWORD PTR original_base$[rbp]
	mov	rcx, QWORD PTR new_addr$[rbp]
	sub	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR diff$[rbp], rax

; 234  : 	AuKernelRelocatePE(relocatebuff, nt, diff);

	mov	r8d, DWORD PTR diff$[rbp]
	mov	rdx, QWORD PTR nt$[rbp]
	mov	rcx, QWORD PTR relocatebuff$[rbp]
	call	?AuKernelRelocatePE@@YAXPEAXPEAU_IMAGE_NT_HEADERS_PE32PLUS@@H@Z ; AuKernelRelocatePE

; 235  : 
; 236  : 	void* entry_addr = AuGetProcAddress((void*)driver_load_base, "AuDriverMain");

	lea	rdx, OFFSET FLAT:??_C@_0N@CCEOOCAH@AuDriverMain@
	mov	rcx, QWORD PTR ?driver_load_base@@3_KA
	call	?AuGetProcAddress@@YAPEAXPEAXPEBD@Z	; AuGetProcAddress
	mov	QWORD PTR entry_addr$[rbp], rax

; 237  : 	void* unload_addr = AuGetProcAddress((void*)driver_load_base, "AuDriverUnload");

	lea	rdx, OFFSET FLAT:??_C@_0P@JMPKLAAA@AuDriverUnload@
	mov	rcx, QWORD PTR ?driver_load_base@@3_KA
	call	?AuGetProcAddress@@YAPEAXPEAXPEBD@Z	; AuGetProcAddress
	mov	QWORD PTR unload_addr$[rbp], rax

; 238  : 
; 239  : 	AuKernelLinkDLL(virtual_base);

	mov	rcx, QWORD PTR virtual_base$[rbp]
	call	?AuKernelLinkDLL@@YAXPEAX@Z		; AuKernelLinkDLL

; 240  : 	driver->entry = (au_drv_entry)entry_addr;

	mov	rax, QWORD PTR driver$[rbp]
	mov	rcx, QWORD PTR entry_addr$[rbp]
	mov	QWORD PTR [rax+51], rcx

; 241  : 	driver->unload = (au_drv_unload)unload_addr;

	mov	rax, QWORD PTR driver$[rbp]
	mov	rcx, QWORD PTR unload_addr$[rbp]
	mov	QWORD PTR [rax+59], rcx

; 242  : 	driver->base = AU_DRIVER_BASE_START;

	mov	rax, QWORD PTR driver$[rbp]
	mov	rcx, -70368739983360			; ffffc00000400000H
	mov	QWORD PTR [rax+35], rcx

; 243  : 	driver->end = driver->base + file->size;

	mov	rax, QWORD PTR file$[rbp]
	mov	eax, DWORD PTR [rax+32]
	mov	rcx, QWORD PTR driver$[rbp]
	add	rax, QWORD PTR [rcx+35]
	mov	rcx, QWORD PTR driver$[rbp]
	mov	QWORD PTR [rcx+43], rax

; 244  : 	driver->present = true;

	mov	rax, QWORD PTR driver$[rbp]
	mov	BYTE PTR [rax+34], 1

; 245  : 	driver_load_base = driver_load_base + next_base_offset * 4096;

	imul	eax, DWORD PTR next_base_offset$[rbp], 4096 ; 00001000H
	cdqe
	mov	rcx, QWORD PTR ?driver_load_base@@3_KA
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR ?driver_load_base@@3_KA, rax

; 246  : 
; 247  : 	kfree(file);

	mov	rcx, QWORD PTR file$[rbp]
	call	kfree

; 248  : }

	lea	rsp, QWORD PTR [rbp+176]
	pop	rbp
	ret	0
?AuDriverLoad@@YAXPEADPEAU_aurora_driver_@@@Z ENDP	; AuDriverLoad
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\audrv.cpp
;	COMDAT ?AuGetDriverName@@YAXIIPEAEH@Z
_TEXT	SEGMENT
offset$ = 0
p$ = 8
drivername$ = 16
i$ = 48
vendor_id$ = 144
device_id$ = 152
buffer$ = 160
entryoff$ = 168
?AuGetDriverName@@YAXIIPEAEH@Z PROC			; AuGetDriverName, COMDAT

; 172  : void AuGetDriverName(uint32_t vendor_id, uint32_t device_id, uint8_t* buffer, int entryoff) {

$LN9:
	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	push	rbp
	sub	rsp, 160				; 000000a0H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__8CEAB164_audrv@cpp
	call	__CheckForDebuggerJustMyCode

; 173  : 
; 174  : 	/* Get the entry offset for required device driver */
; 175  : 	char* offset = AuGetConfEntry(vendor_id, device_id, buffer, entryoff);

	mov	r9d, DWORD PTR entryoff$[rbp]
	mov	r8, QWORD PTR buffer$[rbp]
	mov	edx, DWORD PTR device_id$[rbp]
	mov	ecx, DWORD PTR vendor_id$[rbp]
	call	?AuGetConfEntry@@YAPEADIIPEAEH@Z	; AuGetConfEntry
	mov	QWORD PTR offset$[rbp], rax

; 176  : 
; 177  : 	if (offset == NULL)

	cmp	QWORD PTR offset$[rbp], 0
	jne	SHORT $LN5@AuGetDrive

; 178  : 		return;

	jmp	$LN1@AuGetDrive
$LN5@AuGetDrive:

; 179  : 	char *p = strchr(offset, ']');

	mov	edx, 93					; 0000005dH
	mov	rcx, QWORD PTR offset$[rbp]
	call	strchr
	mov	QWORD PTR p$[rbp], rax

; 180  : 	if (p)

	cmp	QWORD PTR p$[rbp], 0
	je	SHORT $LN6@AuGetDrive

; 181  : 		p++;

	mov	rax, QWORD PTR p$[rbp]
	inc	rax
	mov	QWORD PTR p$[rbp], rax
$LN6@AuGetDrive:

; 182  : 
; 183  : 	/* get the driver path */
; 184  : 	char drivername[32];
; 185  : 	memset(drivername, 0, 32);

	mov	r8d, 32					; 00000020H
	xor	edx, edx
	lea	rcx, QWORD PTR drivername$[rbp]
	call	memset

; 186  : 	int i = 0;

	mov	DWORD PTR i$[rbp], 0

; 187  : 	for (i = 0; i < 32; i++) {

	mov	DWORD PTR i$[rbp], 0
	jmp	SHORT $LN4@AuGetDrive
$LN2@AuGetDrive:
	mov	eax, DWORD PTR i$[rbp]
	inc	eax
	mov	DWORD PTR i$[rbp], eax
$LN4@AuGetDrive:
	cmp	DWORD PTR i$[rbp], 32			; 00000020H
	jge	SHORT $LN3@AuGetDrive

; 188  : 		if (p[i] == '|')

	movsxd	rax, DWORD PTR i$[rbp]
	mov	rcx, QWORD PTR p$[rbp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 124				; 0000007cH
	jne	SHORT $LN7@AuGetDrive

; 189  : 			break;

	jmp	SHORT $LN3@AuGetDrive
$LN7@AuGetDrive:

; 190  : 		drivername[i] = p[i];

	movsxd	rax, DWORD PTR i$[rbp]
	movsxd	rcx, DWORD PTR i$[rbp]
	mov	rdx, QWORD PTR p$[rbp]
	movzx	eax, BYTE PTR [rdx+rax]
	mov	BYTE PTR drivername$[rbp+rcx], al

; 191  : 	}

	jmp	SHORT $LN2@AuGetDrive
$LN3@AuGetDrive:

; 192  : 
; 193  : 	SeTextOut("Drivername -> %s \r\n", drivername);

	lea	rdx, QWORD PTR drivername$[rbp]
	lea	rcx, OFFSET FLAT:??_C@_0BE@GNJNFAPE@Drivername?5?9?$DO?5?$CFs?5?$AN?6@
	call	SeTextOut

; 194  : 
; 195  : 	drivername[i] = 0;

	movsxd	rax, DWORD PTR i$[rbp]
	mov	BYTE PTR drivername$[rbp+rax], 0

; 196  : 
; 197  : 	AuCreateDriverInstance(drivername);

	lea	rcx, QWORD PTR drivername$[rbp]
	call	?AuCreateDriverInstance@@YAXPEAD@Z	; AuCreateDriverInstance
$LN1@AuGetDrive:

; 198  : 	return;
; 199  : }

	lea	rsp, QWORD PTR [rbp+128]
	pop	rbp
	ret	0
?AuGetDriverName@@YAXIIPEAEH@Z ENDP			; AuGetDriverName
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\audrv.cpp
;	COMDAT ?AuCreateDriverInstance@@YAXPEAD@Z
_TEXT	SEGMENT
driver$ = 0
drivername$ = 96
?AuCreateDriverInstance@@YAXPEAD@Z PROC			; AuCreateDriverInstance, COMDAT

; 156  : void AuCreateDriverInstance(char* drivername) {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__8CEAB164_audrv@cpp
	call	__CheckForDebuggerJustMyCode

; 157  : 	AuDriver *driver = (AuDriver*)kmalloc(sizeof(AuDriver));

	mov	ecx, 67					; 00000043H
	call	kmalloc
	mov	QWORD PTR driver$[rbp], rax

; 158  : 	memset(driver, 0, sizeof(AuDriver));

	mov	r8d, 67					; 00000043H
	xor	edx, edx
	mov	rcx, QWORD PTR driver$[rbp]
	call	memset

; 159  : 	strcpy(driver->name, drivername);

	mov	rax, QWORD PTR driver$[rbp]
	add	rax, 2
	mov	rdx, QWORD PTR drivername$[rbp]
	mov	rcx, rax
	call	strcpy

; 160  : 	driver->id = AuRequestDriverId();

	call	?AuRequestDriverId@@YAIXZ		; AuRequestDriverId
	mov	rcx, QWORD PTR driver$[rbp]
	mov	BYTE PTR [rcx], al

; 161  : 	driver->present = false;

	mov	rax, QWORD PTR driver$[rbp]
	mov	BYTE PTR [rax+34], 0

; 162  : 	drivers[driver->id] = driver;

	mov	rax, QWORD PTR driver$[rbp]
	movzx	eax, BYTE PTR [rax]
	lea	rcx, OFFSET FLAT:?drivers@@3PAPEAU_aurora_driver_@@A ; drivers
	mov	rdx, QWORD PTR driver$[rbp]
	mov	QWORD PTR [rcx+rax*8], rdx

; 163  : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
?AuCreateDriverInstance@@YAXPEAD@Z ENDP			; AuCreateDriverInstance
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\audrv.cpp
;	COMDAT ?AuGetConfEntry@@YAPEADIIPEAEH@Z
_TEXT	SEGMENT
entry_num$ = 0
fbuf$ = 8
p$ = 16
entret$ = 24
venid$ = 28
devid$ = 32
pi$ = 36
num$ = 40
i$ = 44
i$1 = 48
vendor_id$ = 144
device_id$ = 152
buffer$ = 160
entryoff$ = 168
?AuGetConfEntry@@YAPEADIIPEAEH@Z PROC			; AuGetConfEntry, COMDAT

; 80   : char* AuGetConfEntry(uint32_t vendor_id, uint32_t device_id, uint8_t* buffer, int entryoff) {

$LN21:
	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	push	rbp
	sub	rsp, 160				; 000000a0H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__8CEAB164_audrv@cpp
	call	__CheckForDebuggerJustMyCode
$re$22:

; 81   : re:
; 82   : 	int entry_num = entryoff;

	mov	eax, DWORD PTR entryoff$[rbp]
	mov	DWORD PTR entry_num$[rbp], eax

; 83   : 	char* fbuf = (char*)buffer;

	mov	rax, QWORD PTR buffer$[rbp]
	mov	QWORD PTR fbuf$[rbp], rax
$search$23:

; 84   : 	/* Check the entry for the device */
; 85   : search:
; 86   : 	char* p = strchr(fbuf, '(');

	mov	edx, 40					; 00000028H
	mov	rcx, QWORD PTR fbuf$[rbp]
	call	strchr
	mov	QWORD PTR p$[rbp], rax

; 87   : 	if (p) {

	cmp	QWORD PTR p$[rbp], 0
	je	SHORT $LN8@AuGetConfE

; 88   : 		p++;

	mov	rax, QWORD PTR p$[rbp]
	inc	rax
	mov	QWORD PTR p$[rbp], rax

; 89   : 		fbuf++;

	mov	rax, QWORD PTR fbuf$[rbp]
	inc	rax
	mov	QWORD PTR fbuf$[rbp], rax
$LN8@AuGetConfE:

; 90   : 	}
; 91   : 	int entret = atoi(p);

	mov	rcx, QWORD PTR p$[rbp]
	call	?atoi@@YAHPEBD@Z			; atoi
	mov	DWORD PTR entret$[rbp], eax

; 92   : 
; 93   : 	/* Check for last entry '(0)' it indicates that
; 94   : 	* there is no more entry
; 95   : 	*/
; 96   : 	if (entret == 0) {

	cmp	DWORD PTR entret$[rbp], 0
	jne	SHORT $LN9@AuGetConfE

; 97   : 		return 0;

	xor	eax, eax
	jmp	$LN1@AuGetConfE
$LN9@AuGetConfE:

; 98   : 	}
; 99   : 
; 100  : 	if (entret != entry_num)

	mov	eax, DWORD PTR entry_num$[rbp]
	cmp	DWORD PTR entret$[rbp], eax
	je	SHORT $LN10@AuGetConfE

; 101  : 		goto search;

	jmp	SHORT $search$23
$LN10@AuGetConfE:

; 102  : 
; 103  : 
; 104  : 	/* Search for vendor id of the product */
; 105  : 	fbuf = p;

	mov	rax, QWORD PTR p$[rbp]
	mov	QWORD PTR fbuf$[rbp], rax

; 106  : 	p = strchr(fbuf, '[');

	mov	edx, 91					; 0000005bH
	mov	rcx, QWORD PTR fbuf$[rbp]
	call	strchr
	mov	QWORD PTR p$[rbp], rax

; 107  : 	int venid, devid = 0;

	mov	DWORD PTR devid$[rbp], 0

; 108  : 	int pi = 0;

	mov	DWORD PTR pi$[rbp], 0

; 109  : 	if (p)

	cmp	QWORD PTR p$[rbp], 0
	je	SHORT $LN11@AuGetConfE

; 110  : 		p++;

	mov	rax, QWORD PTR p$[rbp]
	inc	rax
	mov	QWORD PTR p$[rbp], rax
$LN11@AuGetConfE:

; 111  : 
; 112  : 	fbuf = p;

	mov	rax, QWORD PTR p$[rbp]
	mov	QWORD PTR fbuf$[rbp], rax

; 113  : 	char num[2];
; 114  : 	memset(num, 0, 2);

	mov	r8d, 2
	xor	edx, edx
	lea	rcx, QWORD PTR num$[rbp]
	call	memset

; 115  : 	int i;
; 116  : 	for (i = 0; i < 2; i++) {

	mov	DWORD PTR i$[rbp], 0
	jmp	SHORT $LN4@AuGetConfE
$LN2@AuGetConfE:
	mov	eax, DWORD PTR i$[rbp]
	inc	eax
	mov	DWORD PTR i$[rbp], eax
$LN4@AuGetConfE:
	cmp	DWORD PTR i$[rbp], 2
	jge	SHORT $LN3@AuGetConfE

; 117  : 		if (p[i] == ',' || p[i] == ']')

	movsxd	rax, DWORD PTR i$[rbp]
	mov	rcx, QWORD PTR p$[rbp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 44					; 0000002cH
	je	SHORT $LN13@AuGetConfE
	movsxd	rax, DWORD PTR i$[rbp]
	mov	rcx, QWORD PTR p$[rbp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 93					; 0000005dH
	jne	SHORT $LN12@AuGetConfE
$LN13@AuGetConfE:

; 118  : 			break;

	jmp	SHORT $LN3@AuGetConfE
$LN12@AuGetConfE:

; 119  : 		num[i] = p[i];

	movsxd	rax, DWORD PTR i$[rbp]
	movsxd	rcx, DWORD PTR i$[rbp]
	mov	rdx, QWORD PTR p$[rbp]
	movzx	eax, BYTE PTR [rdx+rax]
	mov	BYTE PTR num$[rbp+rcx], al

; 120  : 		fbuf++;

	mov	rax, QWORD PTR fbuf$[rbp]
	inc	rax
	mov	QWORD PTR fbuf$[rbp], rax

; 121  : 	}

	jmp	SHORT $LN2@AuGetConfE
$LN3@AuGetConfE:

; 122  : 	num[i] = 0;

	movsxd	rax, DWORD PTR i$[rbp]
	mov	BYTE PTR num$[rbp+rax], 0

; 123  : 	venid = atoi(num);

	lea	rcx, QWORD PTR num$[rbp]
	call	?atoi@@YAHPEBD@Z			; atoi
	mov	DWORD PTR venid$[rbp], eax

; 124  : 
; 125  : 	/* Now search for device id / product id */
; 126  : 	p = strchr(fbuf, ',');

	mov	edx, 44					; 0000002cH
	mov	rcx, QWORD PTR fbuf$[rbp]
	call	strchr
	mov	QWORD PTR p$[rbp], rax

; 127  : 	if (p)

	cmp	QWORD PTR p$[rbp], 0
	je	SHORT $LN14@AuGetConfE

; 128  : 		p++;

	mov	rax, QWORD PTR p$[rbp]
	inc	rax
	mov	QWORD PTR p$[rbp], rax
$LN14@AuGetConfE:

; 129  : 	for (int i = 0; i < 2; i++) {

	mov	DWORD PTR i$1[rbp], 0
	jmp	SHORT $LN7@AuGetConfE
$LN5@AuGetConfE:
	mov	eax, DWORD PTR i$1[rbp]
	inc	eax
	mov	DWORD PTR i$1[rbp], eax
$LN7@AuGetConfE:
	cmp	DWORD PTR i$1[rbp], 2
	jge	SHORT $LN6@AuGetConfE

; 130  : 		if (p[i] == ',' || p[i] == ']')

	movsxd	rax, DWORD PTR i$1[rbp]
	mov	rcx, QWORD PTR p$[rbp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 44					; 0000002cH
	je	SHORT $LN16@AuGetConfE
	movsxd	rax, DWORD PTR i$1[rbp]
	mov	rcx, QWORD PTR p$[rbp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 93					; 0000005dH
	jne	SHORT $LN15@AuGetConfE
$LN16@AuGetConfE:

; 131  : 			break;

	jmp	SHORT $LN6@AuGetConfE
$LN15@AuGetConfE:

; 132  : 		num[i] = p[i];

	movsxd	rax, DWORD PTR i$1[rbp]
	movsxd	rcx, DWORD PTR i$1[rbp]
	mov	rdx, QWORD PTR p$[rbp]
	movzx	eax, BYTE PTR [rdx+rax]
	mov	BYTE PTR num$[rbp+rcx], al

; 133  : 	}

	jmp	SHORT $LN5@AuGetConfE
$LN6@AuGetConfE:

; 134  : 	num[i] = 0;

	movsxd	rax, DWORD PTR i$[rbp]
	mov	BYTE PTR num$[rbp+rax], 0

; 135  : 	devid = atoi(num);

	lea	rcx, QWORD PTR num$[rbp]
	call	?atoi@@YAHPEBD@Z			; atoi
	mov	DWORD PTR devid$[rbp], eax

; 136  : 
; 137  : 
; 138  : 	if (vendor_id != venid || devid != device_id) {

	mov	eax, DWORD PTR venid$[rbp]
	cmp	DWORD PTR vendor_id$[rbp], eax
	jne	SHORT $LN18@AuGetConfE
	mov	eax, DWORD PTR device_id$[rbp]
	cmp	DWORD PTR devid$[rbp], eax
	je	SHORT $LN17@AuGetConfE
$LN18@AuGetConfE:

; 139  : 		entryoff++;

	mov	eax, DWORD PTR entryoff$[rbp]
	inc	eax
	mov	DWORD PTR entryoff$[rbp], eax

; 140  : 		goto re;

	jmp	$re$22
$LN17@AuGetConfE:

; 141  : 	}
; 142  : 
; 143  : 	/* Finally we found the device driver */
; 144  : 	if (vendor_id == venid && devid == device_id) {

	mov	eax, DWORD PTR venid$[rbp]
	cmp	DWORD PTR vendor_id$[rbp], eax
	jne	SHORT $LN19@AuGetConfE
	mov	eax, DWORD PTR device_id$[rbp]
	cmp	DWORD PTR devid$[rbp], eax
	jne	SHORT $LN19@AuGetConfE

; 145  : 		return fbuf;

	mov	rax, QWORD PTR fbuf$[rbp]
	jmp	SHORT $LN1@AuGetConfE
$LN19@AuGetConfE:

; 146  : 	}
; 147  : 
; 148  : 	return 0;

	xor	eax, eax
$LN1@AuGetConfE:

; 149  : }

	lea	rsp, QWORD PTR [rbp+128]
	pop	rbp
	ret	0
?AuGetConfEntry@@YAPEADIIPEAEH@Z ENDP			; AuGetConfEntry
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\audrv.cpp
;	COMDAT ?AuIncreaseDriverCount@@YAXXZ
_TEXT	SEGMENT
?AuIncreaseDriverCount@@YAXXZ PROC			; AuIncreaseDriverCount, COMDAT

; 69   : void AuIncreaseDriverCount() {

$LN3:
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__8CEAB164_audrv@cpp
	call	__CheckForDebuggerJustMyCode

; 70   : 	_dev_count_++;

	mov	eax, DWORD PTR ?_dev_count_@@3HA
	inc	eax
	mov	DWORD PTR ?_dev_count_@@3HA, eax

; 71   : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
?AuIncreaseDriverCount@@YAXXZ ENDP			; AuIncreaseDriverCount
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\audrv.cpp
;	COMDAT ?AuDecreaseDriverCount@@YAXXZ
_TEXT	SEGMENT
?AuDecreaseDriverCount@@YAXXZ PROC			; AuDecreaseDriverCount, COMDAT

; 61   : void AuDecreaseDriverCount() {

$LN3:
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__8CEAB164_audrv@cpp
	call	__CheckForDebuggerJustMyCode

; 62   : 	_dev_count_--;

	mov	eax, DWORD PTR ?_dev_count_@@3HA
	dec	eax
	mov	DWORD PTR ?_dev_count_@@3HA, eax

; 63   : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
?AuDecreaseDriverCount@@YAXXZ ENDP			; AuDecreaseDriverCount
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\audrv.cpp
;	COMDAT ?AuRequestDriverId@@YAIXZ
_TEXT	SEGMENT
uid$ = 0
?AuRequestDriverId@@YAIXZ PROC				; AuRequestDriverId, COMDAT

; 51   : uint32_t AuRequestDriverId() {

$LN3:
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__8CEAB164_audrv@cpp
	call	__CheckForDebuggerJustMyCode

; 52   : 	uint32_t uid = driver_class_unique_id;

	mov	eax, DWORD PTR ?driver_class_unique_id@@3IA
	mov	DWORD PTR uid$[rbp], eax

; 53   : 	driver_class_unique_id++;

	mov	eax, DWORD PTR ?driver_class_unique_id@@3IA
	inc	eax
	mov	DWORD PTR ?driver_class_unique_id@@3IA, eax

; 54   : 	return uid;

	mov	eax, DWORD PTR uid$[rbp]

; 55   : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
?AuRequestDriverId@@YAIXZ ENDP				; AuRequestDriverId
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\audrv.cpp
;	COMDAT AuCheckDevice
_TEXT	SEGMENT
i$1 = 0
classC$ = 96
subclassC$ = 104
progIF$ = 112
AuCheckDevice PROC					; COMDAT

; 323  : AU_EXTERN AU_EXPORT bool AuCheckDevice(uint16_t classC, uint16_t subclassC, uint8_t progIF) {

$LN7:
	mov	BYTE PTR [rsp+24], r8b
	mov	WORD PTR [rsp+16], dx
	mov	WORD PTR [rsp+8], cx
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__8CEAB164_audrv@cpp
	call	__CheckForDebuggerJustMyCode

; 324  : 	for (int i = 0; i < _dev_count_; i++){

	mov	DWORD PTR i$1[rbp], 0
	jmp	SHORT $LN4@AuCheckDev
$LN2@AuCheckDev:
	mov	eax, DWORD PTR i$1[rbp]
	inc	eax
	mov	DWORD PTR i$1[rbp], eax
$LN4@AuCheckDev:
	mov	eax, DWORD PTR ?_dev_count_@@3HA
	cmp	DWORD PTR i$1[rbp], eax
	jge	SHORT $LN3@AuCheckDev

; 325  : 		if (au_devices[i]->classCode == classC &&
; 326  : 			au_devices[i]->subClassCode == subclassC &&

	movsxd	rax, DWORD PTR i$1[rbp]
	lea	rcx, OFFSET FLAT:?au_devices@@3PAPEAU_aurora_device_@@A ; au_devices
	mov	rax, QWORD PTR [rcx+rax*8]
	movzx	eax, WORD PTR [rax]
	movzx	ecx, WORD PTR classC$[rbp]
	cmp	eax, ecx
	jne	SHORT $LN5@AuCheckDev
	movsxd	rax, DWORD PTR i$1[rbp]
	lea	rcx, OFFSET FLAT:?au_devices@@3PAPEAU_aurora_device_@@A ; au_devices
	mov	rax, QWORD PTR [rcx+rax*8]
	movzx	eax, WORD PTR [rax+2]
	movzx	ecx, WORD PTR subclassC$[rbp]
	cmp	eax, ecx
	jne	SHORT $LN5@AuCheckDev
	movsxd	rax, DWORD PTR i$1[rbp]
	lea	rcx, OFFSET FLAT:?au_devices@@3PAPEAU_aurora_device_@@A ; au_devices
	mov	rax, QWORD PTR [rcx+rax*8]
	movzx	eax, BYTE PTR [rax+4]
	movzx	ecx, BYTE PTR progIF$[rbp]
	cmp	eax, ecx
	jne	SHORT $LN5@AuCheckDev

; 327  : 			au_devices[i]->progIf == progIF)
; 328  : 			return true;

	mov	al, 1
	jmp	SHORT $LN1@AuCheckDev
$LN5@AuCheckDev:

; 329  : 	}

	jmp	SHORT $LN2@AuCheckDev
$LN3@AuCheckDev:

; 330  : 	return false;

	xor	al, al
$LN1@AuCheckDev:

; 331  : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
AuCheckDevice ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\audrv.cpp
;	COMDAT AuRegisterDevice
_TEXT	SEGMENT
dev$ = 80
AuRegisterDevice PROC					; COMDAT

; 311  : AU_EXTERN AU_EXPORT void AuRegisterDevice(AuDevice* dev) {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__8CEAB164_audrv@cpp
	call	__CheckForDebuggerJustMyCode

; 312  : 	au_devices[_dev_count_] = dev;

	movsxd	rax, DWORD PTR ?_dev_count_@@3HA
	lea	rcx, OFFSET FLAT:?au_devices@@3PAPEAU_aurora_device_@@A ; au_devices
	mov	rdx, QWORD PTR dev$[rbp]
	mov	QWORD PTR [rcx+rax*8], rdx

; 313  : 	_dev_count_++;

	mov	eax, DWORD PTR ?_dev_count_@@3HA
	inc	eax
	mov	DWORD PTR ?_dev_count_@@3HA, eax

; 314  : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
AuRegisterDevice ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\audrv.cpp
;	COMDAT ?AuDrvMngrInitialize@@YAXPEAU_KERNEL_BOOT_INFO_@@@Z
_TEXT	SEGMENT
conf$ = 0
fsys$ = 8
file$ = 16
filesize$ = 24
confdata$ = 32
vend_id$ = 40
dev_id$ = 44
class_code$ = 48
sub_class$ = 52
device$ = 56
bus$1 = 60
dev$2 = 64
func$3 = 68
device$4 = 72
i$5 = 80
i$6 = 84
driver$7 = 88
info$ = 176
?AuDrvMngrInitialize@@YAXPEAU_KERNEL_BOOT_INFO_@@@Z PROC ; AuDrvMngrInitialize, COMDAT

; 254  : void AuDrvMngrInitialize(KERNEL_BOOT_INFO *info) {

$LN21:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 208				; 000000d0H
	lea	rbp, QWORD PTR [rsp+48]
	lea	rcx, OFFSET FLAT:__8CEAB164_audrv@cpp
	call	__CheckForDebuggerJustMyCode

; 255  : 	driver_class_unique_id = 0;

	mov	DWORD PTR ?driver_class_unique_id@@3IA, 0

; 256  : 	driver_load_base = AU_DRIVER_BASE_START;

	mov	rax, -70368739983360			; ffffc00000400000H
	mov	QWORD PTR ?driver_load_base@@3_KA, rax

; 257  : 	_dev_count_ = 0;

	mov	DWORD PTR ?_dev_count_@@3HA, 0

; 258  : 
; 259  : 	printf("[Aurora]: Initializing drivers, please wait... \n");

	lea	rcx, OFFSET FLAT:??_C@_0DB@GGOFEGOE@?$FLAurora?$FN?3?5Initializing?5drivers?0@
	call	printf

; 260  : 	/* Load the conf data */
; 261  : 	uint64_t* conf = (uint64_t*)P2V((size_t)AuPmmngrAlloc());

	call	AuPmmngrAlloc
	mov	rcx, rax
	call	P2V
	mov	QWORD PTR conf$[rbp], rax

; 262  : 	memset(conf, 0, 4096);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR conf$[rbp]
	call	memset

; 263  : 	AuVFSNode* fsys = AuVFSFind("/");

	lea	rcx, OFFSET FLAT:??_C@_01KMDKNFGN@?1@
	call	AuVFSFind
	mov	QWORD PTR fsys$[rbp], rax

; 264  : 	AuVFSNode* file = AuVFSOpen("/audrv.cnf");

	lea	rcx, OFFSET FLAT:??_C@_0L@NBKMLOMK@?1audrv?4cnf@
	call	AuVFSOpen
	mov	QWORD PTR file$[rbp], rax

; 265  : 	int filesize = file->size / 1024;

	xor	edx, edx
	mov	rax, QWORD PTR file$[rbp]
	mov	eax, DWORD PTR [rax+32]
	mov	ecx, 1024				; 00000400H
	div	ecx
	mov	DWORD PTR filesize$[rbp], eax

; 266  : 
; 267  : 	if (filesize < 4096)

	cmp	DWORD PTR filesize$[rbp], 4096		; 00001000H
	jge	SHORT $LN17@AuDrvMngrI

; 268  : 		AuVFSNodeReadBlock(fsys,file, (uint64_t*)V2P((size_t)conf));

	mov	rcx, QWORD PTR conf$[rbp]
	call	V2P
	mov	r8, rax
	mov	rdx, QWORD PTR file$[rbp]
	mov	rcx, QWORD PTR fsys$[rbp]
	call	AuVFSNodeReadBlock
$LN17@AuDrvMngrI:

; 269  : 
; 270  : 	uint8_t* confdata = (uint8_t*)conf;

	mov	rax, QWORD PTR conf$[rbp]
	mov	QWORD PTR confdata$[rbp], rax

; 271  : 
; 272  : 
; 273  : 	uint32_t vend_id, dev_id, class_code, sub_class = 0;

	mov	DWORD PTR sub_class$[rbp], 0

; 274  : 	uint32_t device = 0;

	mov	DWORD PTR device$[rbp], 0

; 275  : 	for (uint16_t bus = 0; bus < 0x20; bus++) {

	xor	eax, eax
	mov	WORD PTR bus$1[rbp], ax
	jmp	SHORT $LN4@AuDrvMngrI
$LN2@AuDrvMngrI:
	movzx	eax, WORD PTR bus$1[rbp]
	inc	ax
	mov	WORD PTR bus$1[rbp], ax
$LN4@AuDrvMngrI:
	movzx	eax, WORD PTR bus$1[rbp]
	cmp	eax, 32					; 00000020H
	jge	$LN3@AuDrvMngrI

; 276  : 		for (uint16_t dev = 0; dev < 32; dev++) {

	xor	eax, eax
	mov	WORD PTR dev$2[rbp], ax
	jmp	SHORT $LN7@AuDrvMngrI
$LN5@AuDrvMngrI:
	movzx	eax, WORD PTR dev$2[rbp]
	inc	ax
	mov	WORD PTR dev$2[rbp], ax
$LN7@AuDrvMngrI:
	movzx	eax, WORD PTR dev$2[rbp]
	cmp	eax, 32					; 00000020H
	jge	$LN6@AuDrvMngrI

; 277  : 			for (uint16_t func = 0; func < 8; func++) {

	xor	eax, eax
	mov	WORD PTR func$3[rbp], ax
	jmp	SHORT $LN10@AuDrvMngrI
$LN8@AuDrvMngrI:
	movzx	eax, WORD PTR func$3[rbp]
	inc	ax
	mov	WORD PTR func$3[rbp], ax
$LN10@AuDrvMngrI:
	movzx	eax, WORD PTR func$3[rbp]
	cmp	eax, 8
	jge	$LN9@AuDrvMngrI

; 278  : 
; 279  : 				uint64_t device = AuPCIEGetDevice(0, bus, dev, func);

	movzx	eax, WORD PTR func$3[rbp]
	movzx	ecx, WORD PTR dev$2[rbp]
	movzx	edx, WORD PTR bus$1[rbp]
	mov	r9d, eax
	mov	r8d, ecx
	xor	ecx, ecx
	call	?AuPCIEGetDevice@@YA_KGHHH@Z		; AuPCIEGetDevice
	mov	QWORD PTR device$4[rbp], rax

; 280  : 
; 281  : 				vend_id = AuPCIERead(device, PCI_VENDOR_ID, bus, dev, func);

	movzx	eax, WORD PTR func$3[rbp]
	movzx	ecx, WORD PTR dev$2[rbp]
	movzx	edx, WORD PTR bus$1[rbp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, ecx
	mov	r8d, edx
	xor	edx, edx
	mov	rcx, QWORD PTR device$4[rbp]
	call	AuPCIERead
	mov	DWORD PTR vend_id$[rbp], eax

; 282  : 				dev_id = AuPCIERead(device, PCI_DEVICE_ID, bus, dev, func);

	movzx	eax, WORD PTR func$3[rbp]
	movzx	ecx, WORD PTR dev$2[rbp]
	movzx	edx, WORD PTR bus$1[rbp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, ecx
	mov	r8d, edx
	mov	edx, 2
	mov	rcx, QWORD PTR device$4[rbp]
	call	AuPCIERead
	mov	DWORD PTR dev_id$[rbp], eax

; 283  : 				class_code = AuPCIERead(device, PCI_CLASS, bus, dev, func);

	movzx	eax, WORD PTR func$3[rbp]
	movzx	ecx, WORD PTR dev$2[rbp]
	movzx	edx, WORD PTR bus$1[rbp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, ecx
	mov	r8d, edx
	mov	edx, 11
	mov	rcx, QWORD PTR device$4[rbp]
	call	AuPCIERead
	mov	DWORD PTR class_code$[rbp], eax

; 284  : 				sub_class = AuPCIERead(device, PCI_SUBCLASS, bus, dev, func);

	movzx	eax, WORD PTR func$3[rbp]
	movzx	ecx, WORD PTR dev$2[rbp]
	movzx	edx, WORD PTR bus$1[rbp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, ecx
	mov	r8d, edx
	mov	edx, 10
	mov	rcx, QWORD PTR device$4[rbp]
	call	AuPCIERead
	mov	DWORD PTR sub_class$[rbp], eax

; 285  : 
; 286  : 				if (dev_id == 0xFFFF || vend_id == 0xFFFF)

	cmp	DWORD PTR dev_id$[rbp], 65535		; 0000ffffH
	je	SHORT $LN19@AuDrvMngrI
	cmp	DWORD PTR vend_id$[rbp], 65535		; 0000ffffH
	jne	SHORT $LN18@AuDrvMngrI
$LN19@AuDrvMngrI:

; 287  : 					continue;

	jmp	$LN8@AuDrvMngrI
$LN18@AuDrvMngrI:

; 288  : 				AuGetDriverName(class_code, sub_class, confdata, 1);

	mov	r9d, 1
	mov	r8, QWORD PTR confdata$[rbp]
	mov	edx, DWORD PTR sub_class$[rbp]
	mov	ecx, DWORD PTR class_code$[rbp]
	call	?AuGetDriverName@@YAXIIPEAEH@Z		; AuGetDriverName

; 289  : 				for (int i = 0; i < 1000; i++)

	mov	DWORD PTR i$5[rbp], 0
	jmp	SHORT $LN13@AuDrvMngrI
$LN11@AuDrvMngrI:
	mov	eax, DWORD PTR i$5[rbp]
	inc	eax
	mov	DWORD PTR i$5[rbp], eax
$LN13@AuDrvMngrI:
	cmp	DWORD PTR i$5[rbp], 1000		; 000003e8H
	jge	SHORT $LN12@AuDrvMngrI

; 290  : 					;

	jmp	SHORT $LN11@AuDrvMngrI
$LN12@AuDrvMngrI:

; 291  : 			}

	jmp	$LN8@AuDrvMngrI
$LN9@AuDrvMngrI:

; 292  : 		}

	jmp	$LN5@AuDrvMngrI
$LN6@AuDrvMngrI:

; 293  : 	}

	jmp	$LN2@AuDrvMngrI
$LN3@AuDrvMngrI:

; 294  : 
; 295  : 
; 296  : 	/* Serially call each startup entries of each driver */
; 297  : 	for (int i = 0; i < driver_class_unique_id; i++) {

	mov	DWORD PTR i$6[rbp], 0
	jmp	SHORT $LN16@AuDrvMngrI
$LN14@AuDrvMngrI:
	mov	eax, DWORD PTR i$6[rbp]
	inc	eax
	mov	DWORD PTR i$6[rbp], eax
$LN16@AuDrvMngrI:
	mov	eax, DWORD PTR ?driver_class_unique_id@@3IA
	cmp	DWORD PTR i$6[rbp], eax
	jae	SHORT $LN15@AuDrvMngrI

; 298  : 		AuDriver *driver = drivers[i];

	movsxd	rax, DWORD PTR i$6[rbp]
	lea	rcx, OFFSET FLAT:?drivers@@3PAPEAU_aurora_driver_@@A ; drivers
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR driver$7[rbp], rax

; 299  : 		AuDriverLoad(driver->name, driver);

	mov	rax, QWORD PTR driver$7[rbp]
	add	rax, 2
	mov	rdx, QWORD PTR driver$7[rbp]
	mov	rcx, rax
	call	?AuDriverLoad@@YAXPEADPEAU_aurora_driver_@@@Z ; AuDriverLoad

; 300  : 		driver->entry();

	mov	rax, QWORD PTR driver$7[rbp]
	call	QWORD PTR [rax+51]

; 301  : 	}

	jmp	SHORT $LN14@AuDrvMngrI
$LN15@AuDrvMngrI:

; 302  : 
; 303  : 	kfree(file);

	mov	rcx, QWORD PTR file$[rbp]
	call	kfree

; 304  : }

	lea	rsp, QWORD PTR [rbp+160]
	pop	rbp
	ret	0
?AuDrvMngrInitialize@@YAXPEAU_KERNEL_BOOT_INFO_@@@Z ENDP ; AuDrvMngrInitialize
_TEXT	ENDS
END
