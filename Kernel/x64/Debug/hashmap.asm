; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30154.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

msvcjmc	SEGMENT
__A596C1DE_hashmap@cpp DB 01H
msvcjmc	ENDS
PUBLIC	AuHashmapCreate
PUBLIC	AuHashmapCreateInt
PUBLIC	AuHashmapSet
PUBLIC	AuHashmapGet
PUBLIC	AuHashmapRemove
PUBLIC	AuHashmapHas
PUBLIC	AuHashmapFree
PUBLIC	AuHashmapIsEmpty
PUBLIC	?hashmap_string_hash@@YAIPEBX@Z			; hashmap_string_hash
PUBLIC	?hashmap_string_comp@@YAHPEBX0@Z		; hashmap_string_comp
PUBLIC	?hashmap_string_dupe@@YAPEAXPEBX@Z		; hashmap_string_dupe
PUBLIC	?hashmap_int_hash@@YAIPEBX@Z			; hashmap_int_hash
PUBLIC	?hashmap_int_comp@@YAHPEBX0@Z			; hashmap_int_comp
PUBLIC	?hashmap_int_dupe@@YAPEAXPEBX@Z			; hashmap_int_dupe
PUBLIC	__JustMyCode_Default
EXTRN	strcmp:PROC
EXTRN	memset:PROC
EXTRN	strdup:PROC
EXTRN	kmalloc:PROC
EXTRN	kfree:PROC
EXTRN	__CheckForDebuggerJustMyCode:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$AuHashmapCreate DD imagerel $LN3
	DD	imagerel $LN3+185
	DD	imagerel $unwind$AuHashmapCreate
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AuHashmapCreateInt DD imagerel $LN3
	DD	imagerel $LN3+185
	DD	imagerel $unwind$AuHashmapCreateInt
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AuHashmapSet DD imagerel $LN10
	DD	imagerel $LN10+388
	DD	imagerel $unwind$AuHashmapSet
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AuHashmapGet DD imagerel $LN9
	DD	imagerel $LN9+151
	DD	imagerel $unwind$AuHashmapGet
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AuHashmapRemove DD imagerel $LN11
	DD	imagerel $LN11+372
	DD	imagerel $unwind$AuHashmapRemove
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AuHashmapHas DD imagerel $LN9
	DD	imagerel $LN9+148
	DD	imagerel $unwind$AuHashmapHas
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AuHashmapFree DD imagerel $LN8
	DD	imagerel $LN8+154
	DD	imagerel $unwind$AuHashmapFree
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AuHashmapIsEmpty DD imagerel $LN7
	DD	imagerel $LN7+92
	DD	imagerel $unwind$AuHashmapIsEmpty
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?hashmap_string_hash@@YAIPEBX@Z DD imagerel $LN5
	DD	imagerel $LN5+116
	DD	imagerel $unwind$?hashmap_string_hash@@YAIPEBX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?hashmap_string_comp@@YAHPEBX0@Z DD imagerel $LN5
	DD	imagerel $LN5+74
	DD	imagerel $unwind$?hashmap_string_comp@@YAHPEBX0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?hashmap_string_dupe@@YAPEAXPEBX@Z DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$?hashmap_string_dupe@@YAPEAXPEBX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?hashmap_int_hash@@YAIPEBX@Z DD imagerel $LN3
	DD	imagerel $LN3+36
	DD	imagerel $unwind$?hashmap_int_hash@@YAIPEBX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?hashmap_int_comp@@YAHPEBX0@Z DD imagerel $LN5
	DD	imagerel $LN5+65
	DD	imagerel $unwind$?hashmap_int_comp@@YAHPEBX0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?hashmap_int_dupe@@YAPEAXPEBX@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$?hashmap_int_dupe@@YAPEAXPEBX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?hashmap_int_free@@YAXPEAX@Z DD imagerel ?hashmap_int_free@@YAXPEAX@Z
	DD	imagerel ?hashmap_int_free@@YAXPEAX@Z+33
	DD	imagerel $unwind$?hashmap_int_free@@YAXPEAX@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?hashmap_int_free@@YAXPEAX@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?hashmap_int_dupe@@YAPEAXPEBX@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?hashmap_int_comp@@YAHPEBX0@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?hashmap_int_hash@@YAIPEBX@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?hashmap_string_dupe@@YAPEAXPEBX@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?hashmap_string_comp@@YAHPEBX0@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?hashmap_string_hash@@YAIPEBX@Z DD 025031201H
	DD	0f20d2312H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AuHashmapIsEmpty DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AuHashmapFree DD 025031201H
	DD	0f20d2312H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AuHashmapHas DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AuHashmapRemove DD 025041701H
	DD	01122317H
	DD	0500b0012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AuHashmapGet DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AuHashmapSet DD 025041c01H
	DD	0117231cH
	DD	050100012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AuHashmapCreateInt DD 025030e01H
	DD	0d209230eH
	DD	05005H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AuHashmapCreate DD 025030e01H
	DD	0d209230eH
	DD	05005H
xdata	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\BaseHdr\hashmap.cpp
;	COMDAT ?hashmap_int_free@@YAXPEAX@Z
_TEXT	SEGMENT
ptr$ = 80
?hashmap_int_free@@YAXPEAX@Z PROC			; hashmap_int_free, COMDAT

; 64   : static void hashmap_int_free(void* ptr) {

	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__A596C1DE_hashmap@cpp
	call	__CheckForDebuggerJustMyCode

; 65   : 	(void)ptr;
; 66   : 	return;
; 67   : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
?hashmap_int_free@@YAXPEAX@Z ENDP			; hashmap_int_free
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\BaseHdr\hashmap.cpp
;	COMDAT ?hashmap_int_dupe@@YAPEAXPEBX@Z
_TEXT	SEGMENT
key$ = 80
?hashmap_int_dupe@@YAPEAXPEBX@Z PROC			; hashmap_int_dupe, COMDAT

; 60   : void* hashmap_int_dupe(const void* key) {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__A596C1DE_hashmap@cpp
	call	__CheckForDebuggerJustMyCode

; 61   : 	return (void*)key;

	mov	rax, QWORD PTR key$[rbp]

; 62   : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
?hashmap_int_dupe@@YAPEAXPEBX@Z ENDP			; hashmap_int_dupe
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\BaseHdr\hashmap.cpp
;	COMDAT ?hashmap_int_comp@@YAHPEBX0@Z
_TEXT	SEGMENT
tv65 = 64
a$ = 96
b$ = 104
?hashmap_int_comp@@YAHPEBX0@Z PROC			; hashmap_int_comp, COMDAT

; 56   : int hashmap_int_comp(const void * a, const void* b) {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__A596C1DE_hashmap@cpp
	call	__CheckForDebuggerJustMyCode

; 57   : 	return (intptr_t)a == (intptr_t)b;

	mov	eax, DWORD PTR b$[rbp]
	cmp	DWORD PTR a$[rbp], eax
	jne	SHORT $LN3@hashmap_in
	mov	DWORD PTR tv65[rbp], 1
	jmp	SHORT $LN4@hashmap_in
$LN3@hashmap_in:
	mov	DWORD PTR tv65[rbp], 0
$LN4@hashmap_in:
	mov	eax, DWORD PTR tv65[rbp]

; 58   : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
?hashmap_int_comp@@YAHPEBX0@Z ENDP			; hashmap_int_comp
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\BaseHdr\hashmap.cpp
;	COMDAT ?hashmap_int_hash@@YAIPEBX@Z
_TEXT	SEGMENT
key$ = 80
?hashmap_int_hash@@YAIPEBX@Z PROC			; hashmap_int_hash, COMDAT

; 52   : unsigned int hashmap_int_hash(const void* key){

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__A596C1DE_hashmap@cpp
	call	__CheckForDebuggerJustMyCode

; 53   : 	return (intptr_t)key;

	mov	eax, DWORD PTR key$[rbp]

; 54   : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
?hashmap_int_hash@@YAIPEBX@Z ENDP			; hashmap_int_hash
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\BaseHdr\hashmap.cpp
;	COMDAT ?hashmap_string_dupe@@YAPEAXPEBX@Z
_TEXT	SEGMENT
key$ = 80
?hashmap_string_dupe@@YAPEAXPEBX@Z PROC			; hashmap_string_dupe, COMDAT

; 48   : void* hashmap_string_dupe(const void* key) {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__A596C1DE_hashmap@cpp
	call	__CheckForDebuggerJustMyCode

; 49   : 	return strdup((const char*)key);

	mov	rcx, QWORD PTR key$[rbp]
	call	strdup

; 50   : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
?hashmap_string_dupe@@YAPEAXPEBX@Z ENDP			; hashmap_string_dupe
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\BaseHdr\hashmap.cpp
;	COMDAT ?hashmap_string_comp@@YAHPEBX0@Z
_TEXT	SEGMENT
tv68 = 64
a$ = 96
b$ = 104
?hashmap_string_comp@@YAHPEBX0@Z PROC			; hashmap_string_comp, COMDAT

; 44   : int hashmap_string_comp(const void* a, const void* b){

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__A596C1DE_hashmap@cpp
	call	__CheckForDebuggerJustMyCode

; 45   : 	return !strcmp((const char*)a,(const char*)b);

	mov	rdx, QWORD PTR b$[rbp]
	mov	rcx, QWORD PTR a$[rbp]
	call	strcmp
	test	eax, eax
	jne	SHORT $LN3@hashmap_st
	mov	DWORD PTR tv68[rbp], 1
	jmp	SHORT $LN4@hashmap_st
$LN3@hashmap_st:
	mov	DWORD PTR tv68[rbp], 0
$LN4@hashmap_st:
	mov	eax, DWORD PTR tv68[rbp]

; 46   : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
?hashmap_string_comp@@YAHPEBX0@Z ENDP			; hashmap_string_comp
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\BaseHdr\hashmap.cpp
;	COMDAT ?hashmap_string_hash@@YAIPEBX@Z
_TEXT	SEGMENT
hash$ = 0
key$ = 8
c$ = 16
tv67 = 84
_key$ = 112
?hashmap_string_hash@@YAIPEBX@Z PROC			; hashmap_string_hash, COMDAT

; 35   : unsigned int hashmap_string_hash(const void* _key) {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 128				; 00000080H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__A596C1DE_hashmap@cpp
	call	__CheckForDebuggerJustMyCode

; 36   : 	unsigned int hash = 0;

	mov	DWORD PTR hash$[rbp], 0

; 37   : 	char* key = (char*)_key;

	mov	rax, QWORD PTR _key$[rbp]
	mov	QWORD PTR key$[rbp], rax
$LN2@hashmap_st:

; 38   : 	int c;
; 39   : 	while ((c = *key++))

	mov	rax, QWORD PTR key$[rbp]
	movsx	eax, BYTE PTR [rax]
	mov	DWORD PTR c$[rbp], eax
	mov	eax, DWORD PTR c$[rbp]
	mov	DWORD PTR tv67[rbp], eax
	mov	rax, QWORD PTR key$[rbp]
	inc	rax
	mov	QWORD PTR key$[rbp], rax
	cmp	DWORD PTR tv67[rbp], 0
	je	SHORT $LN3@hashmap_st

; 40   : 		hash = c + (hash << 6) + (hash << 16) - hash;

	mov	eax, DWORD PTR hash$[rbp]
	shl	eax, 6
	mov	ecx, DWORD PTR c$[rbp]
	add	ecx, eax
	mov	eax, ecx
	mov	ecx, DWORD PTR hash$[rbp]
	shl	ecx, 16
	add	eax, ecx
	sub	eax, DWORD PTR hash$[rbp]
	mov	DWORD PTR hash$[rbp], eax
	jmp	SHORT $LN2@hashmap_st
$LN3@hashmap_st:

; 41   : 	return hash;

	mov	eax, DWORD PTR hash$[rbp]

; 42   : }

	lea	rsp, QWORD PTR [rbp+96]
	pop	rbp
	ret	0
?hashmap_string_hash@@YAIPEBX@Z ENDP			; hashmap_string_hash
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\BaseHdr\hashmap.cpp
;	COMDAT AuHashmapIsEmpty
_TEXT	SEGMENT
i$1 = 0
map$ = 96
AuHashmapIsEmpty PROC					; COMDAT

; 211  : int AuHashmapIsEmpty(hashmap_t* map) {

$LN7:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__A596C1DE_hashmap@cpp
	call	__CheckForDebuggerJustMyCode

; 212  : 	for (unsigned int i = 0; i < map->size; ++i){

	mov	DWORD PTR i$1[rbp], 0
	jmp	SHORT $LN4@AuHashmapI
$LN2@AuHashmapI:
	mov	eax, DWORD PTR i$1[rbp]
	inc	eax
	mov	DWORD PTR i$1[rbp], eax
$LN4@AuHashmapI:
	mov	eax, DWORD PTR i$1[rbp]
	mov	rcx, QWORD PTR map$[rbp]
	cmp	rax, QWORD PTR [rcx+40]
	jae	SHORT $LN3@AuHashmapI

; 213  : 		if (map->entries[i]) return 0;

	mov	eax, DWORD PTR i$1[rbp]
	mov	rcx, QWORD PTR map$[rbp]
	mov	rcx, QWORD PTR [rcx+48]
	cmp	QWORD PTR [rcx+rax*8], 0
	je	SHORT $LN5@AuHashmapI
	xor	eax, eax
	jmp	SHORT $LN1@AuHashmapI
$LN5@AuHashmapI:

; 214  : 	}

	jmp	SHORT $LN2@AuHashmapI
$LN3@AuHashmapI:

; 215  : 	return 1;

	mov	eax, 1
$LN1@AuHashmapI:

; 216  : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
AuHashmapIsEmpty ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\BaseHdr\hashmap.cpp
;	COMDAT AuHashmapFree
_TEXT	SEGMENT
i$1 = 0
x$2 = 8
p$3 = 16
map$ = 112
AuHashmapFree PROC					; COMDAT

; 197  : void AuHashmapFree(hashmap_t *map){

$LN8:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 128				; 00000080H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__A596C1DE_hashmap@cpp
	call	__CheckForDebuggerJustMyCode

; 198  : 	for (unsigned int i = 0; i < map->size; ++i){

	mov	DWORD PTR i$1[rbp], 0
	jmp	SHORT $LN4@AuHashmapF
$LN2@AuHashmapF:
	mov	eax, DWORD PTR i$1[rbp]
	inc	eax
	mov	DWORD PTR i$1[rbp], eax
$LN4@AuHashmapF:
	mov	eax, DWORD PTR i$1[rbp]
	mov	rcx, QWORD PTR map$[rbp]
	cmp	rax, QWORD PTR [rcx+40]
	jae	SHORT $LN3@AuHashmapF

; 199  : 		hashmap_entry_t * x = map->entries[i], *p;

	mov	eax, DWORD PTR i$1[rbp]
	mov	rcx, QWORD PTR map$[rbp]
	mov	rcx, QWORD PTR [rcx+48]
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR x$2[rbp], rax
$LN5@AuHashmapF:

; 200  : 		while (x){

	cmp	QWORD PTR x$2[rbp], 0
	je	SHORT $LN6@AuHashmapF

; 201  : 			p = x;

	mov	rax, QWORD PTR x$2[rbp]
	mov	QWORD PTR p$3[rbp], rax

; 202  : 			x = x->next;

	mov	rax, QWORD PTR x$2[rbp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR x$2[rbp], rax

; 203  : 			map->hash_key_free(p->key);

	mov	rax, QWORD PTR p$3[rbp]
	mov	rcx, QWORD PTR [rax]
	mov	rax, QWORD PTR map$[rbp]
	call	QWORD PTR [rax+24]

; 204  : 			map->hash_val_free(p);

	mov	rcx, QWORD PTR p$3[rbp]
	mov	rax, QWORD PTR map$[rbp]
	call	QWORD PTR [rax+32]

; 205  : 		}

	jmp	SHORT $LN5@AuHashmapF
$LN6@AuHashmapF:

; 206  : 	}

	jmp	SHORT $LN2@AuHashmapF
$LN3@AuHashmapF:

; 207  : 	kfree(map->entries);

	mov	rax, QWORD PTR map$[rbp]
	mov	rcx, QWORD PTR [rax+48]
	call	kfree

; 208  : }

	lea	rsp, QWORD PTR [rbp+96]
	pop	rbp
	ret	0
AuHashmapFree ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\BaseHdr\hashmap.cpp
;	COMDAT AuHashmapHas
_TEXT	SEGMENT
hash$ = 0
x$ = 8
map$ = 96
key$ = 104
AuHashmapHas PROC					; COMDAT

; 182  : int AuHashmapHas(hashmap_t* map, const void* key) {

$LN9:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__A596C1DE_hashmap@cpp
	call	__CheckForDebuggerJustMyCode

; 183  : 	unsigned int hash = map->hash_func(key) % map->size;

	mov	rcx, QWORD PTR key$[rbp]
	mov	rax, QWORD PTR map$[rbp]
	call	QWORD PTR [rax]
	mov	eax, eax
	xor	edx, edx
	mov	rcx, QWORD PTR map$[rbp]
	div	QWORD PTR [rcx+40]
	mov	rax, rdx
	mov	DWORD PTR hash$[rbp], eax

; 184  : 	hashmap_entry_t* x = map->entries[hash]; 

	mov	eax, DWORD PTR hash$[rbp]
	mov	rcx, QWORD PTR map$[rbp]
	mov	rcx, QWORD PTR [rcx+48]
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR x$[rbp], rax

; 185  : 	if (!x)

	cmp	QWORD PTR x$[rbp], 0
	jne	SHORT $LN5@AuHashmapH

; 186  : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@AuHashmapH
	jmp	SHORT $LN6@AuHashmapH
$LN5@AuHashmapH:
$LN4@AuHashmapH:

; 187  : 	else {
; 188  : 		do{
; 189  : 			if (map->hash_comp(x->key, key))

	mov	rdx, QWORD PTR key$[rbp]
	mov	rax, QWORD PTR x$[rbp]
	mov	rcx, QWORD PTR [rax]
	mov	rax, QWORD PTR map$[rbp]
	call	QWORD PTR [rax+8]
	test	eax, eax
	je	SHORT $LN7@AuHashmapH

; 190  : 				return 1;

	mov	eax, 1
	jmp	SHORT $LN1@AuHashmapH
$LN7@AuHashmapH:

; 191  : 			x = x->next;

	mov	rax, QWORD PTR x$[rbp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR x$[rbp], rax

; 192  : 		} while (x);

	cmp	QWORD PTR x$[rbp], 0
	jne	SHORT $LN4@AuHashmapH

; 193  : 		return 0;

	xor	eax, eax
$LN6@AuHashmapH:
$LN1@AuHashmapH:

; 194  : 	}
; 195  : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
AuHashmapHas ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\BaseHdr\hashmap.cpp
;	COMDAT AuHashmapRemove
_TEXT	SEGMENT
hash$ = 0
x$ = 8
out$1 = 16
p$2 = 24
out$3 = 32
map$ = 128
key$ = 136
AuHashmapRemove PROC					; COMDAT

; 149  : void* AuHashmapRemove(hashmap_t* map, const void* key) {

$LN11:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 144				; 00000090H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__A596C1DE_hashmap@cpp
	call	__CheckForDebuggerJustMyCode

; 150  : 	unsigned int hash = map->hash_func(key) % map->size;

	mov	rcx, QWORD PTR key$[rbp]
	mov	rax, QWORD PTR map$[rbp]
	call	QWORD PTR [rax]
	mov	eax, eax
	xor	edx, edx
	mov	rcx, QWORD PTR map$[rbp]
	div	QWORD PTR [rcx+40]
	mov	rax, rdx
	mov	DWORD PTR hash$[rbp], eax

; 151  : 
; 152  : 	hashmap_entry_t* x = map->entries[hash];

	mov	eax, DWORD PTR hash$[rbp]
	mov	rcx, QWORD PTR map$[rbp]
	mov	rcx, QWORD PTR [rcx+48]
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR x$[rbp], rax

; 153  : 	if (!x)

	cmp	QWORD PTR x$[rbp], 0
	jne	SHORT $LN5@AuHashmapR

; 154  : 		return NULL;

	xor	eax, eax
	jmp	$LN1@AuHashmapR
	jmp	$LN6@AuHashmapR
$LN5@AuHashmapR:

; 155  : 	else {
; 156  : 		if (map->hash_comp(x->key, key)){

	mov	rdx, QWORD PTR key$[rbp]
	mov	rax, QWORD PTR x$[rbp]
	mov	rcx, QWORD PTR [rax]
	mov	rax, QWORD PTR map$[rbp]
	call	QWORD PTR [rax+8]
	test	eax, eax
	je	SHORT $LN7@AuHashmapR

; 157  : 			void* out = x->value;

	mov	rax, QWORD PTR x$[rbp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR out$1[rbp], rax

; 158  : 			map->entries[hash] = x->next;

	mov	eax, DWORD PTR hash$[rbp]
	mov	rcx, QWORD PTR map$[rbp]
	mov	rcx, QWORD PTR [rcx+48]
	mov	rdx, QWORD PTR x$[rbp]
	mov	rdx, QWORD PTR [rdx+16]
	mov	QWORD PTR [rcx+rax*8], rdx

; 159  : 			map->hash_key_free(x->key);

	mov	rax, QWORD PTR x$[rbp]
	mov	rcx, QWORD PTR [rax]
	mov	rax, QWORD PTR map$[rbp]
	call	QWORD PTR [rax+24]

; 160  : 			map->hash_val_free(x);

	mov	rcx, QWORD PTR x$[rbp]
	mov	rax, QWORD PTR map$[rbp]
	call	QWORD PTR [rax+32]

; 161  : 			return out;

	mov	rax, QWORD PTR out$1[rbp]
	jmp	$LN1@AuHashmapR

; 162  : 		}

	jmp	$LN8@AuHashmapR
$LN7@AuHashmapR:

; 163  : 		else {
; 164  : 			hashmap_entry_t* p = x;

	mov	rax, QWORD PTR x$[rbp]
	mov	QWORD PTR p$2[rbp], rax

; 165  : 			x = x->next;

	mov	rax, QWORD PTR x$[rbp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR x$[rbp], rax
$LN4@AuHashmapR:

; 166  : 			do {
; 167  : 				if (map->hash_comp(x->key, key)){

	mov	rdx, QWORD PTR key$[rbp]
	mov	rax, QWORD PTR x$[rbp]
	mov	rcx, QWORD PTR [rax]
	mov	rax, QWORD PTR map$[rbp]
	call	QWORD PTR [rax+8]
	test	eax, eax
	je	SHORT $LN9@AuHashmapR

; 168  : 					void* out = x->value;

	mov	rax, QWORD PTR x$[rbp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR out$3[rbp], rax

; 169  : 					p->next = x->next;

	mov	rax, QWORD PTR p$2[rbp]
	mov	rcx, QWORD PTR x$[rbp]
	mov	rcx, QWORD PTR [rcx+16]
	mov	QWORD PTR [rax+16], rcx

; 170  : 					map->hash_key_free(x->key);

	mov	rax, QWORD PTR x$[rbp]
	mov	rcx, QWORD PTR [rax]
	mov	rax, QWORD PTR map$[rbp]
	call	QWORD PTR [rax+24]

; 171  : 					map->hash_val_free(x);

	mov	rcx, QWORD PTR x$[rbp]
	mov	rax, QWORD PTR map$[rbp]
	call	QWORD PTR [rax+32]

; 172  : 					return out;

	mov	rax, QWORD PTR out$3[rbp]
	jmp	SHORT $LN1@AuHashmapR
$LN9@AuHashmapR:

; 173  : 				}
; 174  : 				p = x;

	mov	rax, QWORD PTR x$[rbp]
	mov	QWORD PTR p$2[rbp], rax

; 175  : 				x = x->next;

	mov	rax, QWORD PTR x$[rbp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR x$[rbp], rax

; 176  : 			} while (x);

	cmp	QWORD PTR x$[rbp], 0
	jne	SHORT $LN4@AuHashmapR
$LN8@AuHashmapR:

; 177  : 		}
; 178  : 		return NULL;

	xor	eax, eax
$LN6@AuHashmapR:
$LN1@AuHashmapR:

; 179  : 	}
; 180  : }

	lea	rsp, QWORD PTR [rbp+112]
	pop	rbp
	ret	0
AuHashmapRemove ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\BaseHdr\hashmap.cpp
;	COMDAT AuHashmapGet
_TEXT	SEGMENT
hash$ = 0
x$ = 8
map$ = 96
key$ = 104
AuHashmapGet PROC					; COMDAT

; 133  : void* AuHashmapGet(hashmap_t* map, const void* key) {

$LN9:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__A596C1DE_hashmap@cpp
	call	__CheckForDebuggerJustMyCode

; 134  : 	unsigned int hash = map->hash_func(key) % map->size;

	mov	rcx, QWORD PTR key$[rbp]
	mov	rax, QWORD PTR map$[rbp]
	call	QWORD PTR [rax]
	mov	eax, eax
	xor	edx, edx
	mov	rcx, QWORD PTR map$[rbp]
	div	QWORD PTR [rcx+40]
	mov	rax, rdx
	mov	DWORD PTR hash$[rbp], eax

; 135  : 	hashmap_entry_t* x = map->entries[hash];

	mov	eax, DWORD PTR hash$[rbp]
	mov	rcx, QWORD PTR map$[rbp]
	mov	rcx, QWORD PTR [rcx+48]
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR x$[rbp], rax

; 136  : 	if (!x) {

	cmp	QWORD PTR x$[rbp], 0
	jne	SHORT $LN5@AuHashmapG

; 137  : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@AuHashmapG

; 138  : 	}

	jmp	SHORT $LN6@AuHashmapG
$LN5@AuHashmapG:
$LN4@AuHashmapG:

; 139  : 	else {
; 140  : 		do {
; 141  : 			if (map->hash_comp(x->key, key))

	mov	rdx, QWORD PTR key$[rbp]
	mov	rax, QWORD PTR x$[rbp]
	mov	rcx, QWORD PTR [rax]
	mov	rax, QWORD PTR map$[rbp]
	call	QWORD PTR [rax+8]
	test	eax, eax
	je	SHORT $LN7@AuHashmapG

; 142  : 				return x->value;

	mov	rax, QWORD PTR x$[rbp]
	mov	rax, QWORD PTR [rax+8]
	jmp	SHORT $LN1@AuHashmapG
$LN7@AuHashmapG:

; 143  : 			x = x->next;

	mov	rax, QWORD PTR x$[rbp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR x$[rbp], rax

; 144  : 		} while (x);

	cmp	QWORD PTR x$[rbp], 0
	jne	SHORT $LN4@AuHashmapG

; 145  : 		return NULL;

	xor	eax, eax
$LN6@AuHashmapG:
$LN1@AuHashmapG:

; 146  : 	}
; 147  : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
AuHashmapGet ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\BaseHdr\hashmap.cpp
;	COMDAT AuHashmapSet
_TEXT	SEGMENT
hash$ = 0
x$ = 8
e$1 = 16
p$2 = 24
out$3 = 32
e$4 = 40
map$ = 128
key$ = 136
value$ = 144
AuHashmapSet PROC					; COMDAT

; 100  : void* AuHashmapSet(hashmap_t* map, const void* key, void* value) {

$LN10:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 144				; 00000090H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__A596C1DE_hashmap@cpp
	call	__CheckForDebuggerJustMyCode

; 101  : 	unsigned int hash = map->hash_func(key) % map->size;

	mov	rcx, QWORD PTR key$[rbp]
	mov	rax, QWORD PTR map$[rbp]
	call	QWORD PTR [rax]
	mov	eax, eax
	xor	edx, edx
	mov	rcx, QWORD PTR map$[rbp]
	div	QWORD PTR [rcx+40]
	mov	rax, rdx
	mov	DWORD PTR hash$[rbp], eax

; 102  : 	hashmap_entry_t* x = map->entries[hash];

	mov	eax, DWORD PTR hash$[rbp]
	mov	rcx, QWORD PTR map$[rbp]
	mov	rcx, QWORD PTR [rcx+48]
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR x$[rbp], rax

; 103  : 	if (!x) {

	cmp	QWORD PTR x$[rbp], 0
	jne	SHORT $LN5@AuHashmapS

; 104  : 		hashmap_entry_t* e = (hashmap_entry_t*)kmalloc(sizeof(hashmap_entry_t));

	mov	ecx, 24
	call	kmalloc
	mov	QWORD PTR e$1[rbp], rax

; 105  : 		e->key = (char*)map->hash_key_dup(key);

	mov	rcx, QWORD PTR key$[rbp]
	mov	rax, QWORD PTR map$[rbp]
	call	QWORD PTR [rax+16]
	mov	rcx, QWORD PTR e$1[rbp]
	mov	QWORD PTR [rcx], rax

; 106  : 		e->value = value;

	mov	rax, QWORD PTR e$1[rbp]
	mov	rcx, QWORD PTR value$[rbp]
	mov	QWORD PTR [rax+8], rcx

; 107  : 		e->next = NULL;

	mov	rax, QWORD PTR e$1[rbp]
	mov	QWORD PTR [rax+16], 0

; 108  : 		map->entries[hash] = e;

	mov	eax, DWORD PTR hash$[rbp]
	mov	rcx, QWORD PTR map$[rbp]
	mov	rcx, QWORD PTR [rcx+48]
	mov	rdx, QWORD PTR e$1[rbp]
	mov	QWORD PTR [rcx+rax*8], rdx

; 109  : 		return NULL;

	xor	eax, eax
	jmp	$LN1@AuHashmapS

; 110  : 	}

	jmp	$LN6@AuHashmapS
$LN5@AuHashmapS:

; 111  : 	else {
; 112  : 		hashmap_entry_t *p = NULL;

	mov	QWORD PTR p$2[rbp], 0
$LN4@AuHashmapS:

; 113  : 		do{
; 114  : 			if (map->hash_comp(x->key, key)){

	mov	rdx, QWORD PTR key$[rbp]
	mov	rax, QWORD PTR x$[rbp]
	mov	rcx, QWORD PTR [rax]
	mov	rax, QWORD PTR map$[rbp]
	call	QWORD PTR [rax+8]
	test	eax, eax
	je	SHORT $LN7@AuHashmapS

; 115  : 				void* out = x->value;

	mov	rax, QWORD PTR x$[rbp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR out$3[rbp], rax

; 116  : 				x->value = value;

	mov	rax, QWORD PTR x$[rbp]
	mov	rcx, QWORD PTR value$[rbp]
	mov	QWORD PTR [rax+8], rcx

; 117  : 				return out;

	mov	rax, QWORD PTR out$3[rbp]
	jmp	SHORT $LN1@AuHashmapS

; 118  : 			}

	jmp	SHORT $LN8@AuHashmapS
$LN7@AuHashmapS:

; 119  : 			else {
; 120  : 				p = x;

	mov	rax, QWORD PTR x$[rbp]
	mov	QWORD PTR p$2[rbp], rax

; 121  : 				x = x->next;

	mov	rax, QWORD PTR x$[rbp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR x$[rbp], rax
$LN8@AuHashmapS:

; 122  : 			}
; 123  : 		} while (x);

	cmp	QWORD PTR x$[rbp], 0
	jne	SHORT $LN4@AuHashmapS

; 124  : 		hashmap_entry_t* e = (hashmap_entry_t*)kmalloc(sizeof(hashmap_entry_t));

	mov	ecx, 24
	call	kmalloc
	mov	QWORD PTR e$4[rbp], rax

; 125  : 		e->key = (char*)map->hash_key_dup(key);

	mov	rcx, QWORD PTR key$[rbp]
	mov	rax, QWORD PTR map$[rbp]
	call	QWORD PTR [rax+16]
	mov	rcx, QWORD PTR e$4[rbp]
	mov	QWORD PTR [rcx], rax

; 126  : 		e->value = value;

	mov	rax, QWORD PTR e$4[rbp]
	mov	rcx, QWORD PTR value$[rbp]
	mov	QWORD PTR [rax+8], rcx

; 127  : 		e->next = NULL;

	mov	rax, QWORD PTR e$4[rbp]
	mov	QWORD PTR [rax+16], 0

; 128  : 		p->next = e;

	mov	rax, QWORD PTR p$2[rbp]
	mov	rcx, QWORD PTR e$4[rbp]
	mov	QWORD PTR [rax+16], rcx

; 129  : 		return NULL;

	xor	eax, eax
$LN6@AuHashmapS:
$LN1@AuHashmapS:

; 130  : 	}
; 131  : }

	lea	rsp, QWORD PTR [rbp+112]
	pop	rbp
	ret	0
AuHashmapSet ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\BaseHdr\hashmap.cpp
;	COMDAT AuHashmapCreateInt
_TEXT	SEGMENT
map$ = 0
size$ = 96
AuHashmapCreateInt PROC					; COMDAT

; 87   : hashmap_t* AuHashmapCreateInt(int size) {

$LN3:
	mov	DWORD PTR [rsp+8], ecx
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__A596C1DE_hashmap@cpp
	call	__CheckForDebuggerJustMyCode

; 88   : 	hashmap_t* map = (hashmap_t*)kmalloc(sizeof(hashmap_t));

	mov	ecx, 56					; 00000038H
	call	kmalloc
	mov	QWORD PTR map$[rbp], rax

; 89   : 	map->hash_func = hashmap_int_hash;

	mov	rax, QWORD PTR map$[rbp]
	lea	rcx, OFFSET FLAT:?hashmap_int_hash@@YAIPEBX@Z ; hashmap_int_hash
	mov	QWORD PTR [rax], rcx

; 90   : 	map->hash_comp = hashmap_int_comp;

	mov	rax, QWORD PTR map$[rbp]
	lea	rcx, OFFSET FLAT:?hashmap_int_comp@@YAHPEBX0@Z ; hashmap_int_comp
	mov	QWORD PTR [rax+8], rcx

; 91   : 	map->hash_key_dup = hashmap_int_dupe;

	mov	rax, QWORD PTR map$[rbp]
	lea	rcx, OFFSET FLAT:?hashmap_int_dupe@@YAPEAXPEBX@Z ; hashmap_int_dupe
	mov	QWORD PTR [rax+16], rcx

; 92   : 	map->hash_key_free = hashmap_int_free;

	mov	rax, QWORD PTR map$[rbp]
	lea	rcx, OFFSET FLAT:?hashmap_int_free@@YAXPEAX@Z ; hashmap_int_free
	mov	QWORD PTR [rax+24], rcx

; 93   : 	map->hash_val_free = hashmap_int_free;

	mov	rax, QWORD PTR map$[rbp]
	lea	rcx, OFFSET FLAT:?hashmap_int_free@@YAXPEAX@Z ; hashmap_int_free
	mov	QWORD PTR [rax+32], rcx

; 94   : 	map->size = size;

	movsxd	rax, DWORD PTR size$[rbp]
	mov	rcx, QWORD PTR map$[rbp]
	mov	QWORD PTR [rcx+40], rax

; 95   : 	map->entries = (hashmap_entry_t**)kmalloc(sizeof(hashmap_entry_t*)*size);

	movsxd	rax, DWORD PTR size$[rbp]
	shl	rax, 3
	mov	ecx, eax
	call	kmalloc
	mov	rcx, QWORD PTR map$[rbp]
	mov	QWORD PTR [rcx+48], rax

; 96   : 	memset(map->entries, 0, sizeof(hashmap_entry_t*)* size);

	movsxd	rax, DWORD PTR size$[rbp]
	shl	rax, 3
	mov	r8d, eax
	xor	edx, edx
	mov	rax, QWORD PTR map$[rbp]
	mov	rcx, QWORD PTR [rax+48]
	call	memset

; 97   : 	return map;

	mov	rax, QWORD PTR map$[rbp]

; 98   : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
AuHashmapCreateInt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\BaseHdr\hashmap.cpp
;	COMDAT AuHashmapCreate
_TEXT	SEGMENT
map$ = 0
size$ = 96
AuHashmapCreate PROC					; COMDAT

; 73   : hashmap_t* AuHashmapCreate(int size) {

$LN3:
	mov	DWORD PTR [rsp+8], ecx
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__A596C1DE_hashmap@cpp
	call	__CheckForDebuggerJustMyCode

; 74   : 	hashmap_t* map = (hashmap_t*)kmalloc(sizeof(hashmap_t));

	mov	ecx, 56					; 00000038H
	call	kmalloc
	mov	QWORD PTR map$[rbp], rax

; 75   : 	map->hash_func = hashmap_string_hash;

	mov	rax, QWORD PTR map$[rbp]
	lea	rcx, OFFSET FLAT:?hashmap_string_hash@@YAIPEBX@Z ; hashmap_string_hash
	mov	QWORD PTR [rax], rcx

; 76   : 	map->hash_comp = hashmap_string_comp;

	mov	rax, QWORD PTR map$[rbp]
	lea	rcx, OFFSET FLAT:?hashmap_string_comp@@YAHPEBX0@Z ; hashmap_string_comp
	mov	QWORD PTR [rax+8], rcx

; 77   : 	map->hash_key_dup = hashmap_string_dupe;

	mov	rax, QWORD PTR map$[rbp]
	lea	rcx, OFFSET FLAT:?hashmap_string_dupe@@YAPEAXPEBX@Z ; hashmap_string_dupe
	mov	QWORD PTR [rax+16], rcx

; 78   : 	map->hash_key_free = kfree;

	mov	rax, QWORD PTR map$[rbp]
	lea	rcx, OFFSET FLAT:kfree
	mov	QWORD PTR [rax+24], rcx

; 79   : 	map->hash_val_free = kfree;

	mov	rax, QWORD PTR map$[rbp]
	lea	rcx, OFFSET FLAT:kfree
	mov	QWORD PTR [rax+32], rcx

; 80   : 	map->size = size;

	movsxd	rax, DWORD PTR size$[rbp]
	mov	rcx, QWORD PTR map$[rbp]
	mov	QWORD PTR [rcx+40], rax

; 81   : 	map->entries = (hashmap_entry_t**)kmalloc(sizeof(hashmap_entry_t*)* size);

	movsxd	rax, DWORD PTR size$[rbp]
	shl	rax, 3
	mov	ecx, eax
	call	kmalloc
	mov	rcx, QWORD PTR map$[rbp]
	mov	QWORD PTR [rcx+48], rax

; 82   : 	memset(map->entries, 0, sizeof(hashmap_entry_t*)*size);

	movsxd	rax, DWORD PTR size$[rbp]
	shl	rax, 3
	mov	r8d, eax
	xor	edx, edx
	mov	rax, QWORD PTR map$[rbp]
	mov	rcx, QWORD PTR [rax+48]
	call	memset

; 83   : 
; 84   : 	return map;

	mov	rax, QWORD PTR map$[rbp]

; 85   : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
AuHashmapCreate ENDP
_TEXT	ENDS
END
