; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.21005.1 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	AuHashmapCreate
PUBLIC	AuHashmapCreateInt
PUBLIC	AuHashmapSet
PUBLIC	AuHashmapGet
PUBLIC	AuHashmapRemove
PUBLIC	AuHashmapHas
PUBLIC	AuHashmapFree
PUBLIC	AuHashmapIsEmpty
PUBLIC	?hashmap_string_hash@@YAIPEBX@Z			; hashmap_string_hash
PUBLIC	?hashmap_string_comp@@YAHPEBX0@Z		; hashmap_string_comp
PUBLIC	?hashmap_string_dupe@@YAPEAXPEBX@Z		; hashmap_string_dupe
PUBLIC	?hashmap_int_hash@@YAIPEBX@Z			; hashmap_int_hash
PUBLIC	?hashmap_int_comp@@YAHPEBX0@Z			; hashmap_int_comp
PUBLIC	?hashmap_int_dupe@@YAPEAXPEBX@Z			; hashmap_int_dupe
EXTRN	strcmp:PROC
EXTRN	memset:PROC
EXTRN	strdup:PROC
EXTRN	kmalloc:PROC
EXTRN	kfree:PROC
pdata	SEGMENT
$pdata$AuHashmapCreate DD imagerel $LN3
	DD	imagerel $LN3+179
	DD	imagerel $unwind$AuHashmapCreate
$pdata$AuHashmapCreateInt DD imagerel $LN3
	DD	imagerel $LN3+179
	DD	imagerel $unwind$AuHashmapCreateInt
$pdata$AuHashmapSet DD imagerel $LN10
	DD	imagerel $LN10+365
	DD	imagerel $unwind$AuHashmapSet
$pdata$AuHashmapGet DD imagerel $LN9
	DD	imagerel $LN9+147
	DD	imagerel $unwind$AuHashmapGet
$pdata$AuHashmapRemove DD imagerel $LN11
	DD	imagerel $LN11+353
	DD	imagerel $unwind$AuHashmapRemove
$pdata$AuHashmapHas DD imagerel $LN9
	DD	imagerel $LN9+143
	DD	imagerel $unwind$AuHashmapHas
$pdata$AuHashmapFree DD imagerel $LN8
	DD	imagerel $LN8+150
	DD	imagerel $unwind$AuHashmapFree
$pdata$AuHashmapIsEmpty DD imagerel $LN7
	DD	imagerel $LN7+75
	DD	imagerel $unwind$AuHashmapIsEmpty
$pdata$?hashmap_string_hash@@YAIPEBX@Z DD imagerel $LN5
	DD	imagerel $LN5+104
	DD	imagerel $unwind$?hashmap_string_hash@@YAIPEBX@Z
$pdata$?hashmap_string_comp@@YAHPEBX0@Z DD imagerel $LN5
	DD	imagerel $LN5+60
	DD	imagerel $unwind$?hashmap_string_comp@@YAHPEBX0@Z
$pdata$?hashmap_string_dupe@@YAPEAXPEBX@Z DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$?hashmap_string_dupe@@YAPEAXPEBX@Z
$pdata$?hashmap_int_comp@@YAHPEBX0@Z DD imagerel $LN5
	DD	imagerel $LN5+48
	DD	imagerel $unwind$?hashmap_int_comp@@YAHPEBX0@Z
pdata	ENDS
xdata	SEGMENT
$unwind$AuHashmapCreate DD 010801H
	DD	06208H
$unwind$AuHashmapCreateInt DD 010801H
	DD	06208H
$unwind$AuHashmapSet DD 011301H
	DD	0a213H
$unwind$AuHashmapGet DD 010e01H
	DD	0620eH
$unwind$AuHashmapRemove DD 010e01H
	DD	0a20eH
$unwind$AuHashmapHas DD 010e01H
	DD	0620eH
$unwind$AuHashmapFree DD 010901H
	DD	08209H
$unwind$AuHashmapIsEmpty DD 010901H
	DD	02209H
$unwind$?hashmap_string_hash@@YAIPEBX@Z DD 010901H
	DD	04209H
$unwind$?hashmap_string_comp@@YAHPEBX0@Z DD 010e01H
	DD	0620eH
$unwind$?hashmap_string_dupe@@YAPEAXPEBX@Z DD 010901H
	DD	04209H
$unwind$?hashmap_int_comp@@YAHPEBX0@Z DD 010e01H
	DD	0220eH
xdata	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\basehdr\hashmap.cpp
_TEXT	SEGMENT
ptr$ = 8
?hashmap_int_free@@YAXPEAX@Z PROC			; hashmap_int_free

; 64   : static void hashmap_int_free(void* ptr) {

	mov	QWORD PTR [rsp+8], rcx

; 65   : 	(void)ptr;
; 66   : 	return;
; 67   : }

	ret	0
?hashmap_int_free@@YAXPEAX@Z ENDP			; hashmap_int_free
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\basehdr\hashmap.cpp
_TEXT	SEGMENT
key$ = 8
?hashmap_int_dupe@@YAPEAXPEBX@Z PROC			; hashmap_int_dupe

; 60   : void* hashmap_int_dupe(const void* key) {

	mov	QWORD PTR [rsp+8], rcx

; 61   : 	return (void*)key;

	mov	rax, QWORD PTR key$[rsp]

; 62   : }

	ret	0
?hashmap_int_dupe@@YAPEAXPEBX@Z ENDP			; hashmap_int_dupe
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\basehdr\hashmap.cpp
_TEXT	SEGMENT
tv65 = 0
a$ = 32
b$ = 40
?hashmap_int_comp@@YAHPEBX0@Z PROC			; hashmap_int_comp

; 56   : int hashmap_int_comp(const void * a, const void* b) {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 57   : 	return (intptr_t)a == (intptr_t)b;

	mov	eax, DWORD PTR b$[rsp]
	cmp	DWORD PTR a$[rsp], eax
	jne	SHORT $LN3@hashmap_in
	mov	DWORD PTR tv65[rsp], 1
	jmp	SHORT $LN4@hashmap_in
$LN3@hashmap_in:
	mov	DWORD PTR tv65[rsp], 0
$LN4@hashmap_in:
	mov	eax, DWORD PTR tv65[rsp]

; 58   : }

	add	rsp, 24
	ret	0
?hashmap_int_comp@@YAHPEBX0@Z ENDP			; hashmap_int_comp
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\basehdr\hashmap.cpp
_TEXT	SEGMENT
key$ = 8
?hashmap_int_hash@@YAIPEBX@Z PROC			; hashmap_int_hash

; 52   : unsigned int hashmap_int_hash(const void* key){

	mov	QWORD PTR [rsp+8], rcx

; 53   : 	return (intptr_t)key;

	mov	eax, DWORD PTR key$[rsp]

; 54   : }

	ret	0
?hashmap_int_hash@@YAIPEBX@Z ENDP			; hashmap_int_hash
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\basehdr\hashmap.cpp
_TEXT	SEGMENT
key$ = 48
?hashmap_string_dupe@@YAPEAXPEBX@Z PROC			; hashmap_string_dupe

; 48   : void* hashmap_string_dupe(const void* key) {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 49   : 	return strdup((const char*)key);

	mov	rcx, QWORD PTR key$[rsp]
	call	strdup

; 50   : }

	add	rsp, 40					; 00000028H
	ret	0
?hashmap_string_dupe@@YAPEAXPEBX@Z ENDP			; hashmap_string_dupe
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\basehdr\hashmap.cpp
_TEXT	SEGMENT
tv68 = 32
a$ = 64
b$ = 72
?hashmap_string_comp@@YAHPEBX0@Z PROC			; hashmap_string_comp

; 44   : int hashmap_string_comp(const void* a, const void* b){

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 45   : 	return !strcmp((const char*)a,(const char*)b);

	mov	rdx, QWORD PTR b$[rsp]
	mov	rcx, QWORD PTR a$[rsp]
	call	strcmp
	test	eax, eax
	jne	SHORT $LN3@hashmap_st
	mov	DWORD PTR tv68[rsp], 1
	jmp	SHORT $LN4@hashmap_st
$LN3@hashmap_st:
	mov	DWORD PTR tv68[rsp], 0
$LN4@hashmap_st:
	mov	eax, DWORD PTR tv68[rsp]

; 46   : }

	add	rsp, 56					; 00000038H
	ret	0
?hashmap_string_comp@@YAHPEBX0@Z ENDP			; hashmap_string_comp
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\basehdr\hashmap.cpp
_TEXT	SEGMENT
hash$ = 0
c$ = 4
tv67 = 8
key$ = 16
_key$ = 48
?hashmap_string_hash@@YAIPEBX@Z PROC			; hashmap_string_hash

; 35   : unsigned int hashmap_string_hash(const void* _key) {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 36   : 	unsigned int hash = 0;

	mov	DWORD PTR hash$[rsp], 0

; 37   : 	char* key = (char*)_key;

	mov	rax, QWORD PTR _key$[rsp]
	mov	QWORD PTR key$[rsp], rax
$LN2@hashmap_st:

; 38   : 	int c;
; 39   : 	while ((c = *key++))

	mov	rax, QWORD PTR key$[rsp]
	movsx	eax, BYTE PTR [rax]
	mov	DWORD PTR c$[rsp], eax
	mov	eax, DWORD PTR c$[rsp]
	mov	DWORD PTR tv67[rsp], eax
	mov	rax, QWORD PTR key$[rsp]
	inc	rax
	mov	QWORD PTR key$[rsp], rax
	cmp	DWORD PTR tv67[rsp], 0
	je	SHORT $LN1@hashmap_st

; 40   : 		hash = c + (hash << 6) + (hash << 16) - hash;

	mov	eax, DWORD PTR hash$[rsp]
	shl	eax, 6
	mov	ecx, DWORD PTR c$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	ecx, DWORD PTR hash$[rsp]
	shl	ecx, 16
	add	eax, ecx
	sub	eax, DWORD PTR hash$[rsp]
	mov	DWORD PTR hash$[rsp], eax
	jmp	SHORT $LN2@hashmap_st
$LN1@hashmap_st:

; 41   : 	return hash;

	mov	eax, DWORD PTR hash$[rsp]

; 42   : }

	add	rsp, 40					; 00000028H
	ret	0
?hashmap_string_hash@@YAIPEBX@Z ENDP			; hashmap_string_hash
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\basehdr\hashmap.cpp
_TEXT	SEGMENT
i$1 = 0
map$ = 32
AuHashmapIsEmpty PROC

; 211  : int AuHashmapIsEmpty(hashmap_t* map) {

$LN7:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 212  : 	for (unsigned int i = 0; i < map->size; ++i){

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN4@AuHashmapI
$LN3@AuHashmapI:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN4@AuHashmapI:
	mov	eax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR map$[rsp]
	cmp	rax, QWORD PTR [rcx+40]
	jae	SHORT $LN2@AuHashmapI

; 213  : 		if (map->entries[i]) return 0;

	mov	eax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR map$[rsp]
	mov	rcx, QWORD PTR [rcx+48]
	cmp	QWORD PTR [rcx+rax*8], 0
	je	SHORT $LN1@AuHashmapI
	xor	eax, eax
	jmp	SHORT $LN5@AuHashmapI
$LN1@AuHashmapI:

; 214  : 	}

	jmp	SHORT $LN3@AuHashmapI
$LN2@AuHashmapI:

; 215  : 	return 1;

	mov	eax, 1
$LN5@AuHashmapI:

; 216  : }

	add	rsp, 24
	ret	0
AuHashmapIsEmpty ENDP
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\basehdr\hashmap.cpp
_TEXT	SEGMENT
i$1 = 32
x$2 = 40
p$3 = 48
map$ = 80
AuHashmapFree PROC

; 197  : void AuHashmapFree(hashmap_t *map){

$LN8:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 198  : 	for (unsigned int i = 0; i < map->size; ++i){

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN5@AuHashmapF
$LN4@AuHashmapF:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN5@AuHashmapF:
	mov	eax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR map$[rsp]
	cmp	rax, QWORD PTR [rcx+40]
	jae	SHORT $LN3@AuHashmapF

; 199  : 		hashmap_entry_t * x = map->entries[i], *p;

	mov	eax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR map$[rsp]
	mov	rcx, QWORD PTR [rcx+48]
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR x$2[rsp], rax
$LN2@AuHashmapF:

; 200  : 		while (x){

	cmp	QWORD PTR x$2[rsp], 0
	je	SHORT $LN1@AuHashmapF

; 201  : 			p = x;

	mov	rax, QWORD PTR x$2[rsp]
	mov	QWORD PTR p$3[rsp], rax

; 202  : 			x = x->next;

	mov	rax, QWORD PTR x$2[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR x$2[rsp], rax

; 203  : 			map->hash_key_free(p->key);

	mov	rax, QWORD PTR p$3[rsp]
	mov	rcx, QWORD PTR [rax]
	mov	rax, QWORD PTR map$[rsp]
	call	QWORD PTR [rax+24]

; 204  : 			map->hash_val_free(p);

	mov	rcx, QWORD PTR p$3[rsp]
	mov	rax, QWORD PTR map$[rsp]
	call	QWORD PTR [rax+32]

; 205  : 		}

	jmp	SHORT $LN2@AuHashmapF
$LN1@AuHashmapF:

; 206  : 	}

	jmp	SHORT $LN4@AuHashmapF
$LN3@AuHashmapF:

; 207  : 	kfree(map->entries);

	mov	rax, QWORD PTR map$[rsp]
	mov	rcx, QWORD PTR [rax+48]
	call	kfree

; 208  : }

	add	rsp, 72					; 00000048H
	ret	0
AuHashmapFree ENDP
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\basehdr\hashmap.cpp
_TEXT	SEGMENT
hash$ = 32
x$ = 40
map$ = 64
key$ = 72
AuHashmapHas PROC

; 182  : int AuHashmapHas(hashmap_t* map, const void* key) {

$LN9:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 183  : 	unsigned int hash = map->hash_func(key) % map->size;

	mov	rcx, QWORD PTR key$[rsp]
	mov	rax, QWORD PTR map$[rsp]
	call	QWORD PTR [rax]
	mov	eax, eax
	xor	edx, edx
	mov	rcx, QWORD PTR map$[rsp]
	div	QWORD PTR [rcx+40]
	mov	rax, rdx
	mov	DWORD PTR hash$[rsp], eax

; 184  : 	hashmap_entry_t* x = map->entries[hash]; 

	mov	eax, DWORD PTR hash$[rsp]
	mov	rcx, QWORD PTR map$[rsp]
	mov	rcx, QWORD PTR [rcx+48]
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR x$[rsp], rax

; 185  : 	if (!x)

	cmp	QWORD PTR x$[rsp], 0
	jne	SHORT $LN6@AuHashmapH

; 186  : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN7@AuHashmapH

; 187  : 	else {

	jmp	SHORT $LN5@AuHashmapH
$LN6@AuHashmapH:
$LN4@AuHashmapH:

; 188  : 		do{
; 189  : 			if (map->hash_comp(x->key, key))

	mov	rdx, QWORD PTR key$[rsp]
	mov	rax, QWORD PTR x$[rsp]
	mov	rcx, QWORD PTR [rax]
	mov	rax, QWORD PTR map$[rsp]
	call	QWORD PTR [rax+8]
	test	eax, eax
	je	SHORT $LN1@AuHashmapH

; 190  : 				return 1;

	mov	eax, 1
	jmp	SHORT $LN7@AuHashmapH
$LN1@AuHashmapH:

; 191  : 			x = x->next;

	mov	rax, QWORD PTR x$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR x$[rsp], rax

; 192  : 		} while (x);

	cmp	QWORD PTR x$[rsp], 0
	jne	SHORT $LN4@AuHashmapH

; 193  : 		return 0;

	xor	eax, eax
$LN5@AuHashmapH:
$LN7@AuHashmapH:

; 194  : 	}
; 195  : }

	add	rsp, 56					; 00000038H
	ret	0
AuHashmapHas ENDP
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\basehdr\hashmap.cpp
_TEXT	SEGMENT
hash$ = 32
x$ = 40
p$1 = 48
out$2 = 56
out$3 = 64
map$ = 96
key$ = 104
AuHashmapRemove PROC

; 149  : void* AuHashmapRemove(hashmap_t* map, const void* key) {

$LN11:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 150  : 	unsigned int hash = map->hash_func(key) % map->size;

	mov	rcx, QWORD PTR key$[rsp]
	mov	rax, QWORD PTR map$[rsp]
	call	QWORD PTR [rax]
	mov	eax, eax
	xor	edx, edx
	mov	rcx, QWORD PTR map$[rsp]
	div	QWORD PTR [rcx+40]
	mov	rax, rdx
	mov	DWORD PTR hash$[rsp], eax

; 151  : 
; 152  : 	hashmap_entry_t* x = map->entries[hash];

	mov	eax, DWORD PTR hash$[rsp]
	mov	rcx, QWORD PTR map$[rsp]
	mov	rcx, QWORD PTR [rcx+48]
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR x$[rsp], rax

; 153  : 	if (!x)

	cmp	QWORD PTR x$[rsp], 0
	jne	SHORT $LN8@AuHashmapR

; 154  : 		return NULL;

	xor	eax, eax
	jmp	$LN9@AuHashmapR

; 155  : 	else {

	jmp	$LN7@AuHashmapR
$LN8@AuHashmapR:

; 156  : 		if (map->hash_comp(x->key, key)){

	mov	rdx, QWORD PTR key$[rsp]
	mov	rax, QWORD PTR x$[rsp]
	mov	rcx, QWORD PTR [rax]
	mov	rax, QWORD PTR map$[rsp]
	call	QWORD PTR [rax+8]
	test	eax, eax
	je	SHORT $LN6@AuHashmapR

; 157  : 			void* out = x->value;

	mov	rax, QWORD PTR x$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR out$2[rsp], rax

; 158  : 			map->entries[hash] = x->next;

	mov	eax, DWORD PTR hash$[rsp]
	mov	rcx, QWORD PTR map$[rsp]
	mov	rcx, QWORD PTR [rcx+48]
	mov	rdx, QWORD PTR x$[rsp]
	mov	rdx, QWORD PTR [rdx+16]
	mov	QWORD PTR [rcx+rax*8], rdx

; 159  : 			map->hash_key_free(x->key);

	mov	rax, QWORD PTR x$[rsp]
	mov	rcx, QWORD PTR [rax]
	mov	rax, QWORD PTR map$[rsp]
	call	QWORD PTR [rax+24]

; 160  : 			map->hash_val_free(x);

	mov	rcx, QWORD PTR x$[rsp]
	mov	rax, QWORD PTR map$[rsp]
	call	QWORD PTR [rax+32]

; 161  : 			return out;

	mov	rax, QWORD PTR out$2[rsp]
	jmp	$LN9@AuHashmapR

; 162  : 		}
; 163  : 		else {

	jmp	$LN5@AuHashmapR
$LN6@AuHashmapR:

; 164  : 			hashmap_entry_t* p = x;

	mov	rax, QWORD PTR x$[rsp]
	mov	QWORD PTR p$1[rsp], rax

; 165  : 			x = x->next;

	mov	rax, QWORD PTR x$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR x$[rsp], rax
$LN4@AuHashmapR:

; 166  : 			do {
; 167  : 				if (map->hash_comp(x->key, key)){

	mov	rdx, QWORD PTR key$[rsp]
	mov	rax, QWORD PTR x$[rsp]
	mov	rcx, QWORD PTR [rax]
	mov	rax, QWORD PTR map$[rsp]
	call	QWORD PTR [rax+8]
	test	eax, eax
	je	SHORT $LN1@AuHashmapR

; 168  : 					void* out = x->value;

	mov	rax, QWORD PTR x$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR out$3[rsp], rax

; 169  : 					p->next = x->next;

	mov	rax, QWORD PTR p$1[rsp]
	mov	rcx, QWORD PTR x$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	mov	QWORD PTR [rax+16], rcx

; 170  : 					map->hash_key_free(x->key);

	mov	rax, QWORD PTR x$[rsp]
	mov	rcx, QWORD PTR [rax]
	mov	rax, QWORD PTR map$[rsp]
	call	QWORD PTR [rax+24]

; 171  : 					map->hash_val_free(x);

	mov	rcx, QWORD PTR x$[rsp]
	mov	rax, QWORD PTR map$[rsp]
	call	QWORD PTR [rax+32]

; 172  : 					return out;

	mov	rax, QWORD PTR out$3[rsp]
	jmp	SHORT $LN9@AuHashmapR
$LN1@AuHashmapR:

; 173  : 				}
; 174  : 				p = x;

	mov	rax, QWORD PTR x$[rsp]
	mov	QWORD PTR p$1[rsp], rax

; 175  : 				x = x->next;

	mov	rax, QWORD PTR x$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR x$[rsp], rax

; 176  : 			} while (x);

	cmp	QWORD PTR x$[rsp], 0
	jne	SHORT $LN4@AuHashmapR
$LN5@AuHashmapR:

; 177  : 		}
; 178  : 		return NULL;

	xor	eax, eax
$LN7@AuHashmapR:
$LN9@AuHashmapR:

; 179  : 	}
; 180  : }

	add	rsp, 88					; 00000058H
	ret	0
AuHashmapRemove ENDP
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\basehdr\hashmap.cpp
_TEXT	SEGMENT
hash$ = 32
x$ = 40
map$ = 64
key$ = 72
AuHashmapGet PROC

; 133  : void* AuHashmapGet(hashmap_t* map, const void* key) {

$LN9:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 134  : 	unsigned int hash = map->hash_func(key) % map->size;

	mov	rcx, QWORD PTR key$[rsp]
	mov	rax, QWORD PTR map$[rsp]
	call	QWORD PTR [rax]
	mov	eax, eax
	xor	edx, edx
	mov	rcx, QWORD PTR map$[rsp]
	div	QWORD PTR [rcx+40]
	mov	rax, rdx
	mov	DWORD PTR hash$[rsp], eax

; 135  : 	hashmap_entry_t* x = map->entries[hash];

	mov	eax, DWORD PTR hash$[rsp]
	mov	rcx, QWORD PTR map$[rsp]
	mov	rcx, QWORD PTR [rcx+48]
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR x$[rsp], rax

; 136  : 	if (!x) {

	cmp	QWORD PTR x$[rsp], 0
	jne	SHORT $LN6@AuHashmapG

; 137  : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN7@AuHashmapG

; 138  : 	}
; 139  : 	else {

	jmp	SHORT $LN5@AuHashmapG
$LN6@AuHashmapG:
$LN4@AuHashmapG:

; 140  : 		do {
; 141  : 			if (map->hash_comp(x->key, key))

	mov	rdx, QWORD PTR key$[rsp]
	mov	rax, QWORD PTR x$[rsp]
	mov	rcx, QWORD PTR [rax]
	mov	rax, QWORD PTR map$[rsp]
	call	QWORD PTR [rax+8]
	test	eax, eax
	je	SHORT $LN1@AuHashmapG

; 142  : 				return x->value;

	mov	rax, QWORD PTR x$[rsp]
	mov	rax, QWORD PTR [rax+8]
	jmp	SHORT $LN7@AuHashmapG
$LN1@AuHashmapG:

; 143  : 			x = x->next;

	mov	rax, QWORD PTR x$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR x$[rsp], rax

; 144  : 		} while (x);

	cmp	QWORD PTR x$[rsp], 0
	jne	SHORT $LN4@AuHashmapG

; 145  : 		return NULL;

	xor	eax, eax
$LN5@AuHashmapG:
$LN7@AuHashmapG:

; 146  : 	}
; 147  : }

	add	rsp, 56					; 00000038H
	ret	0
AuHashmapGet ENDP
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\basehdr\hashmap.cpp
_TEXT	SEGMENT
hash$ = 32
x$ = 40
e$1 = 48
e$2 = 56
p$3 = 64
out$4 = 72
map$ = 96
key$ = 104
value$ = 112
AuHashmapSet PROC

; 100  : void* AuHashmapSet(hashmap_t* map, const void* key, void* value) {

$LN10:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 101  : 	unsigned int hash = map->hash_func(key) % map->size;

	mov	rcx, QWORD PTR key$[rsp]
	mov	rax, QWORD PTR map$[rsp]
	call	QWORD PTR [rax]
	mov	eax, eax
	xor	edx, edx
	mov	rcx, QWORD PTR map$[rsp]
	div	QWORD PTR [rcx+40]
	mov	rax, rdx
	mov	DWORD PTR hash$[rsp], eax

; 102  : 	hashmap_entry_t* x = map->entries[hash];

	mov	eax, DWORD PTR hash$[rsp]
	mov	rcx, QWORD PTR map$[rsp]
	mov	rcx, QWORD PTR [rcx+48]
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR x$[rsp], rax

; 103  : 	if (!x) {

	cmp	QWORD PTR x$[rsp], 0
	jne	SHORT $LN7@AuHashmapS

; 104  : 		hashmap_entry_t* e = (hashmap_entry_t*)kmalloc(sizeof(hashmap_entry_t));

	mov	ecx, 24
	call	kmalloc
	mov	QWORD PTR e$1[rsp], rax

; 105  : 		e->key = (char*)map->hash_key_dup(key);

	mov	rcx, QWORD PTR key$[rsp]
	mov	rax, QWORD PTR map$[rsp]
	call	QWORD PTR [rax+16]
	mov	rcx, QWORD PTR e$1[rsp]
	mov	QWORD PTR [rcx], rax

; 106  : 		e->value = value;

	mov	rax, QWORD PTR e$1[rsp]
	mov	rcx, QWORD PTR value$[rsp]
	mov	QWORD PTR [rax+8], rcx

; 107  : 		e->next = NULL;

	mov	rax, QWORD PTR e$1[rsp]
	mov	QWORD PTR [rax+16], 0

; 108  : 		map->entries[hash] = e;

	mov	eax, DWORD PTR hash$[rsp]
	mov	rcx, QWORD PTR map$[rsp]
	mov	rcx, QWORD PTR [rcx+48]
	mov	rdx, QWORD PTR e$1[rsp]
	mov	QWORD PTR [rcx+rax*8], rdx

; 109  : 		return NULL;

	xor	eax, eax
	jmp	$LN8@AuHashmapS

; 110  : 	}
; 111  : 	else {

	jmp	$LN6@AuHashmapS
$LN7@AuHashmapS:

; 112  : 		hashmap_entry_t *p = NULL;

	mov	QWORD PTR p$3[rsp], 0
$LN5@AuHashmapS:

; 113  : 		do{
; 114  : 			if (map->hash_comp(x->key, key)){

	mov	rdx, QWORD PTR key$[rsp]
	mov	rax, QWORD PTR x$[rsp]
	mov	rcx, QWORD PTR [rax]
	mov	rax, QWORD PTR map$[rsp]
	call	QWORD PTR [rax+8]
	test	eax, eax
	je	SHORT $LN2@AuHashmapS

; 115  : 				void* out = x->value;

	mov	rax, QWORD PTR x$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR out$4[rsp], rax

; 116  : 				x->value = value;

	mov	rax, QWORD PTR x$[rsp]
	mov	rcx, QWORD PTR value$[rsp]
	mov	QWORD PTR [rax+8], rcx

; 117  : 				return out;

	mov	rax, QWORD PTR out$4[rsp]
	jmp	SHORT $LN8@AuHashmapS

; 118  : 			}
; 119  : 			else {

	jmp	SHORT $LN1@AuHashmapS
$LN2@AuHashmapS:

; 120  : 				p = x;

	mov	rax, QWORD PTR x$[rsp]
	mov	QWORD PTR p$3[rsp], rax

; 121  : 				x = x->next;

	mov	rax, QWORD PTR x$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR x$[rsp], rax
$LN1@AuHashmapS:

; 122  : 			}
; 123  : 		} while (x);

	cmp	QWORD PTR x$[rsp], 0
	jne	SHORT $LN5@AuHashmapS

; 124  : 		hashmap_entry_t* e = (hashmap_entry_t*)kmalloc(sizeof(hashmap_entry_t));

	mov	ecx, 24
	call	kmalloc
	mov	QWORD PTR e$2[rsp], rax

; 125  : 		e->key = (char*)map->hash_key_dup(key);

	mov	rcx, QWORD PTR key$[rsp]
	mov	rax, QWORD PTR map$[rsp]
	call	QWORD PTR [rax+16]
	mov	rcx, QWORD PTR e$2[rsp]
	mov	QWORD PTR [rcx], rax

; 126  : 		e->value = value;

	mov	rax, QWORD PTR e$2[rsp]
	mov	rcx, QWORD PTR value$[rsp]
	mov	QWORD PTR [rax+8], rcx

; 127  : 		e->next = NULL;

	mov	rax, QWORD PTR e$2[rsp]
	mov	QWORD PTR [rax+16], 0

; 128  : 		p->next = e;

	mov	rax, QWORD PTR p$3[rsp]
	mov	rcx, QWORD PTR e$2[rsp]
	mov	QWORD PTR [rax+16], rcx

; 129  : 		return NULL;

	xor	eax, eax
$LN6@AuHashmapS:
$LN8@AuHashmapS:

; 130  : 	}
; 131  : }

	add	rsp, 88					; 00000058H
	ret	0
AuHashmapSet ENDP
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\basehdr\hashmap.cpp
_TEXT	SEGMENT
map$ = 32
size$ = 64
AuHashmapCreateInt PROC

; 87   : hashmap_t* AuHashmapCreateInt(int size) {

$LN3:
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 56					; 00000038H

; 88   : 	hashmap_t* map = (hashmap_t*)kmalloc(sizeof(hashmap_t));

	mov	ecx, 56					; 00000038H
	call	kmalloc
	mov	QWORD PTR map$[rsp], rax

; 89   : 	map->hash_func = hashmap_int_hash;

	mov	rax, QWORD PTR map$[rsp]
	lea	rcx, OFFSET FLAT:?hashmap_int_hash@@YAIPEBX@Z ; hashmap_int_hash
	mov	QWORD PTR [rax], rcx

; 90   : 	map->hash_comp = hashmap_int_comp;

	mov	rax, QWORD PTR map$[rsp]
	lea	rcx, OFFSET FLAT:?hashmap_int_comp@@YAHPEBX0@Z ; hashmap_int_comp
	mov	QWORD PTR [rax+8], rcx

; 91   : 	map->hash_key_dup = hashmap_int_dupe;

	mov	rax, QWORD PTR map$[rsp]
	lea	rcx, OFFSET FLAT:?hashmap_int_dupe@@YAPEAXPEBX@Z ; hashmap_int_dupe
	mov	QWORD PTR [rax+16], rcx

; 92   : 	map->hash_key_free = hashmap_int_free;

	mov	rax, QWORD PTR map$[rsp]
	lea	rcx, OFFSET FLAT:?hashmap_int_free@@YAXPEAX@Z ; hashmap_int_free
	mov	QWORD PTR [rax+24], rcx

; 93   : 	map->hash_val_free = hashmap_int_free;

	mov	rax, QWORD PTR map$[rsp]
	lea	rcx, OFFSET FLAT:?hashmap_int_free@@YAXPEAX@Z ; hashmap_int_free
	mov	QWORD PTR [rax+32], rcx

; 94   : 	map->size = size;

	movsxd	rax, DWORD PTR size$[rsp]
	mov	rcx, QWORD PTR map$[rsp]
	mov	QWORD PTR [rcx+40], rax

; 95   : 	map->entries = (hashmap_entry_t**)kmalloc(sizeof(hashmap_entry_t*)*size);

	movsxd	rax, DWORD PTR size$[rsp]
	shl	rax, 3
	mov	ecx, eax
	call	kmalloc
	mov	rcx, QWORD PTR map$[rsp]
	mov	QWORD PTR [rcx+48], rax

; 96   : 	memset(map->entries, 0, sizeof(hashmap_entry_t*)* size);

	movsxd	rax, DWORD PTR size$[rsp]
	shl	rax, 3
	mov	r8d, eax
	xor	edx, edx
	mov	rax, QWORD PTR map$[rsp]
	mov	rcx, QWORD PTR [rax+48]
	call	memset

; 97   : 	return map;

	mov	rax, QWORD PTR map$[rsp]

; 98   : }

	add	rsp, 56					; 00000038H
	ret	0
AuHashmapCreateInt ENDP
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\basehdr\hashmap.cpp
_TEXT	SEGMENT
map$ = 32
size$ = 64
AuHashmapCreate PROC

; 73   : hashmap_t* AuHashmapCreate(int size) {

$LN3:
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 56					; 00000038H

; 74   : 	hashmap_t* map = (hashmap_t*)kmalloc(sizeof(hashmap_t));

	mov	ecx, 56					; 00000038H
	call	kmalloc
	mov	QWORD PTR map$[rsp], rax

; 75   : 	map->hash_func = hashmap_string_hash;

	mov	rax, QWORD PTR map$[rsp]
	lea	rcx, OFFSET FLAT:?hashmap_string_hash@@YAIPEBX@Z ; hashmap_string_hash
	mov	QWORD PTR [rax], rcx

; 76   : 	map->hash_comp = hashmap_string_comp;

	mov	rax, QWORD PTR map$[rsp]
	lea	rcx, OFFSET FLAT:?hashmap_string_comp@@YAHPEBX0@Z ; hashmap_string_comp
	mov	QWORD PTR [rax+8], rcx

; 77   : 	map->hash_key_dup = hashmap_string_dupe;

	mov	rax, QWORD PTR map$[rsp]
	lea	rcx, OFFSET FLAT:?hashmap_string_dupe@@YAPEAXPEBX@Z ; hashmap_string_dupe
	mov	QWORD PTR [rax+16], rcx

; 78   : 	map->hash_key_free = kfree;

	mov	rax, QWORD PTR map$[rsp]
	lea	rcx, OFFSET FLAT:kfree
	mov	QWORD PTR [rax+24], rcx

; 79   : 	map->hash_val_free = kfree;

	mov	rax, QWORD PTR map$[rsp]
	lea	rcx, OFFSET FLAT:kfree
	mov	QWORD PTR [rax+32], rcx

; 80   : 	map->size = size;

	movsxd	rax, DWORD PTR size$[rsp]
	mov	rcx, QWORD PTR map$[rsp]
	mov	QWORD PTR [rcx+40], rax

; 81   : 	map->entries = (hashmap_entry_t**)kmalloc(sizeof(hashmap_entry_t*)* size);

	movsxd	rax, DWORD PTR size$[rsp]
	shl	rax, 3
	mov	ecx, eax
	call	kmalloc
	mov	rcx, QWORD PTR map$[rsp]
	mov	QWORD PTR [rcx+48], rax

; 82   : 	memset(map->entries, 0, sizeof(hashmap_entry_t*)*size);

	movsxd	rax, DWORD PTR size$[rsp]
	shl	rax, 3
	mov	r8d, eax
	xor	edx, edx
	mov	rax, QWORD PTR map$[rsp]
	mov	rcx, QWORD PTR [rax+48]
	call	memset

; 83   : 
; 84   : 	return map;

	mov	rax, QWORD PTR map$[rsp]

; 85   : }

	add	rsp, 56					; 00000038H
	ret	0
AuHashmapCreate ENDP
_TEXT	ENDS
END
