; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30154.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

msvcjmc	SEGMENT
__C6938175_FatDir@cpp DB 01H
msvcjmc	ENDS
PUBLIC	?FatCreateDir@@YAPEAU__VFS_NODE__@@PEAU1@PEAD@Z	; FatCreateDir
PUBLIC	?FatRemoveDir@@YAHPEAU__VFS_NODE__@@0@Z		; FatRemoveDir
PUBLIC	?FatOpenDir@@YAPEAU__VFS_NODE__@@PEAU1@PEAD@Z	; FatOpenDir
PUBLIC	?FatDirectoryRead@@YAHPEAU__VFS_NODE__@@0PEAU_AuDirectoryEnty_@@@Z ; FatDirectoryRead
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_0BF@FKKOCNDK@Ret?5filename?5?9?$DO?$CFs?5?$AN?6@ ; `string'
PUBLIC	??_C@_0P@NDONFAJC@FS?5Flag?5dir?5?$AN?6@	; `string'
PUBLIC	??_C@_0P@LIJOLHPC@freeing?5ret?5?$AN?6@		; `string'
PUBLIC	??_C@_01KMDKNFGN@?1@				; `string'
EXTRN	AuVDiskRead:PROC
EXTRN	AuVDiskWrite:PROC
EXTRN	?FatClusterToSector32@@YA_KPEAU_FatFS_@@_K@Z:PROC ; FatClusterToSector32
EXTRN	?FatToDOSFilename@@YAXPEBDPEADI@Z:PROC		; FatToDOSFilename
EXTRN	?FatFindFreeCluster@@YAIPEAU__VFS_NODE__@@@Z:PROC ; FatFindFreeCluster
EXTRN	?FatAllocCluster@@YAXPEAU__VFS_NODE__@@HI@Z:PROC ; FatAllocCluster
EXTRN	?FatClearCluster@@YAXPEAU__VFS_NODE__@@I@Z:PROC	; FatClearCluster
EXTRN	?FatReadFAT@@YAIPEAU__VFS_NODE__@@_K@Z:PROC	; FatReadFAT
EXTRN	?FatOpen@@YAPEAU__VFS_NODE__@@PEAU1@PEAD@Z:PROC	; FatOpen
EXTRN	?FatFormatDate@@YAGXZ:PROC			; FatFormatDate
EXTRN	?FatFormatTime@@YAGXZ:PROC			; FatFormatTime
EXTRN	?FatFromDosToFilename@@YAXPEAD0@Z:PROC		; FatFromDosToFilename
EXTRN	?FatFileGetParent@@YAPEAU__VFS_NODE__@@PEAU1@PEBD@Z:PROC ; FatFileGetParent
EXTRN	?FatFileRemove@@YAHPEAU__VFS_NODE__@@0@Z:PROC	; FatFileRemove
EXTRN	kmalloc:PROC
EXTRN	kfree:PROC
EXTRN	AuPmmngrAlloc:PROC
EXTRN	AuPmmngrFree:PROC
EXTRN	P2V:PROC
EXTRN	V2P:PROC
EXTRN	strcpy:PROC
EXTRN	strchr:PROC
EXTRN	memset:PROC
EXTRN	memcpy:PROC
EXTRN	SeTextOut:PROC
EXTRN	__CheckForDebuggerJustMyCode:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$?FatCreateDir@@YAPEAU__VFS_NODE__@@PEAU1@PEAD@Z DD imagerel $LN28
	DD	imagerel $LN28+1800
	DD	imagerel $unwind$?FatCreateDir@@YAPEAU__VFS_NODE__@@PEAU1@PEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?FatRemoveDir@@YAHPEAU__VFS_NODE__@@0@Z DD imagerel $LN16
	DD	imagerel $LN16+510
	DD	imagerel $unwind$?FatRemoveDir@@YAHPEAU__VFS_NODE__@@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?FatOpenDir@@YAPEAU__VFS_NODE__@@PEAU1@PEAD@Z DD imagerel $LN9
	DD	imagerel $LN9+403
	DD	imagerel $unwind$?FatOpenDir@@YAPEAU__VFS_NODE__@@PEAU1@PEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?FatDirectoryRead@@YAHPEAU__VFS_NODE__@@0PEAU_AuDirectoryEnty_@@@Z DD imagerel $LN15
	DD	imagerel $LN15+1048
	DD	imagerel $unwind$?FatDirectoryRead@@YAHPEAU__VFS_NODE__@@0PEAU_AuDirectoryEnty_@@@Z
pdata	ENDS
;	COMDAT ??_C@_01KMDKNFGN@?1@
CONST	SEGMENT
??_C@_01KMDKNFGN@?1@ DB '/', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@LIJOLHPC@freeing?5ret?5?$AN?6@
CONST	SEGMENT
??_C@_0P@LIJOLHPC@freeing?5ret?5?$AN?6@ DB 'freeing ret ', 0dH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@NDONFAJC@FS?5Flag?5dir?5?$AN?6@
CONST	SEGMENT
??_C@_0P@NDONFAJC@FS?5Flag?5dir?5?$AN?6@ DB 'FS Flag dir ', 0dH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@FKKOCNDK@Ret?5filename?5?9?$DO?$CFs?5?$AN?6@
CONST	SEGMENT
??_C@_0BF@FKKOCNDK@Ret?5filename?5?9?$DO?$CFs?5?$AN?6@ DB 'Ret filename -'
	DB	'>%s ', 0dH, 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?FatDirectoryRead@@YAHPEAU__VFS_NODE__@@0PEAU_AuDirectoryEnty_@@@Z DD 025041c01H
	DD	0117231cH
	DD	050100018H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?FatOpenDir@@YAPEAU__VFS_NODE__@@PEAU1@PEAD@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?FatRemoveDir@@YAHPEAU__VFS_NODE__@@0@Z DD 025041701H
	DD	01122317H
	DD	0500b0016H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?FatCreateDir@@YAPEAU__VFS_NODE__@@PEAU1@PEAD@Z DD 025041701H
	DD	01122317H
	DD	0500b0020H
xdata	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Fs\Fat\FatDir.cpp
;	COMDAT ?FatDirectoryRead@@YAHPEAU__VFS_NODE__@@0PEAU_AuDirectoryEnty_@@@Z
_TEXT	SEGMENT
index$ = 0
fatfs$ = 8
vdisk$ = 16
buf$ = 24
aligned_buf$ = 32
dir_$ = 40
filename$ = 48
name$ = 64
tv88 = 144
tv92 = 152
fs$ = 176
dir$ = 184
dirent$ = 192
?FatDirectoryRead@@YAHPEAU__VFS_NODE__@@0PEAU_AuDirectoryEnty_@@@Z PROC ; FatDirectoryRead, COMDAT

; 298  : int FatDirectoryRead(AuVFSNode* fs, AuVFSNode* dir, AuDirectoryEntry* dirent) {

$LN15:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 192				; 000000c0H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__C6938175_FatDir@cpp
	call	__CheckForDebuggerJustMyCode

; 299  : 	if (!dirent)

	cmp	QWORD PTR dirent$[rbp], 0
	jne	SHORT $LN2@FatDirecto

; 300  : 		return -1;

	mov	eax, -1
	jmp	$LN1@FatDirecto
$LN2@FatDirecto:

; 301  : 	if (!dir)

	cmp	QWORD PTR dir$[rbp], 0
	jne	SHORT $LN3@FatDirecto

; 302  : 		return -1;

	mov	eax, -1
	jmp	$LN1@FatDirecto
$LN3@FatDirecto:

; 303  : 	memset(dirent->filename, 0, 32);

	mov	rax, QWORD PTR dirent$[rbp]
	mov	r8d, 32					; 00000020H
	xor	edx, edx
	mov	rcx, rax
	call	memset

; 304  : 	int index = dirent->index;

	mov	rax, QWORD PTR dirent$[rbp]
	mov	eax, DWORD PTR [rax+32]
	mov	DWORD PTR index$[rbp], eax

; 305  : 	FatFS* fatfs = (FatFS*)fs->device;

	mov	rax, QWORD PTR fs$[rbp]
	mov	rax, QWORD PTR [rax+64]
	mov	QWORD PTR fatfs$[rbp], rax

; 306  : 	AuVDisk* vdisk = (AuVDisk*)fatfs->vdisk;

	mov	rax, QWORD PTR fatfs$[rbp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR vdisk$[rbp], rax

; 307  : 
; 308  : 	uint64_t* buf = (uint64_t*)P2V((uint64_t)AuPmmngrAlloc());

	call	AuPmmngrAlloc
	mov	rcx, rax
	call	P2V
	mov	QWORD PTR buf$[rbp], rax

; 309  : 	memset(buf, 0, PAGE_SIZE);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR buf$[rbp]
	call	memset

; 310  : 		
; 311  : 	if ((index / 16) > fatfs->__SectorPerCluster) {

	mov	eax, DWORD PTR index$[rbp]
	cdq
	and	edx, 15
	add	eax, edx
	sar	eax, 4
	mov	rcx, QWORD PTR fatfs$[rbp]
	movzx	ecx, BYTE PTR [rcx+36]
	cmp	eax, ecx
	jle	SHORT $LN4@FatDirecto

; 312  : 		dirent->index = -1;

	mov	rax, QWORD PTR dirent$[rbp]
	mov	DWORD PTR [rax+32], -1

; 313  : 		AuPmmngrFree((void*)V2P((size_t)buf));

	mov	rcx, QWORD PTR buf$[rbp]
	call	V2P
	mov	rcx, rax
	call	AuPmmngrFree

; 314  : 		return -1;

	mov	eax, -1
	jmp	$LN1@FatDirecto
$LN4@FatDirecto:

; 315  : 	}
; 316  : 
; 317  : 
; 318  : 	uint8_t* aligned_buf = (uint8_t*)buf;

	mov	rax, QWORD PTR buf$[rbp]
	mov	QWORD PTR aligned_buf$[rbp], rax

; 319  : 	AuVDiskRead(vdisk, FatClusterToSector32(fatfs, dir->first_block) + index/16, 1, (uint64_t*)V2P((uint64_t)buf));

	mov	rcx, QWORD PTR buf$[rbp]
	call	V2P
	mov	QWORD PTR tv88[rbp], rax
	mov	rcx, QWORD PTR dir$[rbp]
	mov	rdx, QWORD PTR [rcx+45]
	mov	rcx, QWORD PTR fatfs$[rbp]
	call	?FatClusterToSector32@@YA_KPEAU_FatFS_@@_K@Z ; FatClusterToSector32
	mov	QWORD PTR tv92[rbp], rax
	mov	eax, DWORD PTR index$[rbp]
	cdq
	and	edx, 15
	add	eax, edx
	sar	eax, 4
	cdqe
	mov	rcx, QWORD PTR tv92[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR tv88[rbp]
	mov	r9, rcx
	mov	r8d, 1
	mov	rdx, rax
	mov	rcx, QWORD PTR vdisk$[rbp]
	call	AuVDiskRead

; 320  : 	FatDir* dir_ = (FatDir*)(aligned_buf + ((index % 16) * sizeof(FatDir)));

	mov	eax, DWORD PTR index$[rbp]
	cdq
	and	edx, 15
	add	eax, edx
	and	eax, 15
	sub	eax, edx
	cdqe
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR aligned_buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR dir_$[rbp], rax

; 321  : 
; 322  : 	if (dir_->filename[0] == 0x00){

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR dir_$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	jne	SHORT $LN5@FatDirecto

; 323  : 		dirent->index = -1;

	mov	rax, QWORD PTR dirent$[rbp]
	mov	DWORD PTR [rax+32], -1

; 324  : 		AuPmmngrFree((void*)V2P((size_t)buf));

	mov	rcx, QWORD PTR buf$[rbp]
	call	V2P
	mov	rcx, rax
	call	AuPmmngrFree

; 325  : 		return -1;

	mov	eax, -1
	jmp	$LN1@FatDirecto
$LN5@FatDirecto:

; 326  : 	}
; 327  : 
; 328  : 	if (dir_->filename[0] == 0xE5 || 
; 329  : 		dir_->filename[0] == 0x05 ||

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR dir_$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 229				; 000000e5H
	je	SHORT $LN7@FatDirecto
	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR dir_$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 5
	je	SHORT $LN7@FatDirecto
	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR dir_$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 255				; 000000ffH
	jne	SHORT $LN6@FatDirecto
$LN7@FatDirecto:

; 330  : 		dir_->filename[0] == 0xFF) {
; 331  : 		AuPmmngrFree((void*)V2P((size_t)buf));

	mov	rcx, QWORD PTR buf$[rbp]
	call	V2P
	mov	rcx, rax
	call	AuPmmngrFree

; 332  : 		dirent->index += 1;

	mov	rax, QWORD PTR dirent$[rbp]
	mov	eax, DWORD PTR [rax+32]
	inc	eax
	mov	rcx, QWORD PTR dirent$[rbp]
	mov	DWORD PTR [rcx+32], eax

; 333  : 		return -1;

	mov	eax, -1
	jmp	$LN1@FatDirecto
$LN6@FatDirecto:

; 334  : 	}
; 335  : 
; 336  : 	if (dir_->attrib & 0x02){

	mov	rax, QWORD PTR dir_$[rbp]
	movzx	eax, BYTE PTR [rax+11]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN8@FatDirecto

; 337  : 		AuPmmngrFree((void*)V2P((size_t)buf));

	mov	rcx, QWORD PTR buf$[rbp]
	call	V2P
	mov	rcx, rax
	call	AuPmmngrFree

; 338  : 		dirent->index += 1;

	mov	rax, QWORD PTR dirent$[rbp]
	mov	eax, DWORD PTR [rax+32]
	inc	eax
	mov	rcx, QWORD PTR dirent$[rbp]
	mov	DWORD PTR [rcx+32], eax

; 339  : 		return -1;

	mov	eax, -1
	jmp	$LN1@FatDirecto
$LN8@FatDirecto:

; 340  : 	}
; 341  : 
; 342  : 	if (dir_->attrib & 0x04) {

	mov	rax, QWORD PTR dir_$[rbp]
	movzx	eax, BYTE PTR [rax+11]
	and	eax, 4
	test	eax, eax
	je	SHORT $LN9@FatDirecto

; 343  : 		AuPmmngrFree((void*)V2P((size_t)buf));

	mov	rcx, QWORD PTR buf$[rbp]
	call	V2P
	mov	rcx, rax
	call	AuPmmngrFree

; 344  : 		dirent->index += 1;

	mov	rax, QWORD PTR dirent$[rbp]
	mov	eax, DWORD PTR [rax+32]
	inc	eax
	mov	rcx, QWORD PTR dirent$[rbp]
	mov	DWORD PTR [rcx+32], eax

; 345  : 		return -1;

	mov	eax, -1
	jmp	$LN1@FatDirecto
$LN9@FatDirecto:

; 346  : 	}
; 347  : 
; 348  : 	if (dir_->attrib & 0x08) {

	mov	rax, QWORD PTR dir_$[rbp]
	movzx	eax, BYTE PTR [rax+11]
	and	eax, 8
	test	eax, eax
	je	SHORT $LN10@FatDirecto

; 349  : 		AuPmmngrFree((void*)V2P((size_t)buf));

	mov	rcx, QWORD PTR buf$[rbp]
	call	V2P
	mov	rcx, rax
	call	AuPmmngrFree

; 350  : 		dirent->index += 1;

	mov	rax, QWORD PTR dirent$[rbp]
	mov	eax, DWORD PTR [rax+32]
	inc	eax
	mov	rcx, QWORD PTR dirent$[rbp]
	mov	DWORD PTR [rcx+32], eax

; 351  : 		return -1;

	mov	eax, -1
	jmp	$LN1@FatDirecto
$LN10@FatDirecto:

; 352  : 	}
; 353  : 
; 354  : 	if (dir_->attrib & 0x01) {

	mov	rax, QWORD PTR dir_$[rbp]
	movzx	eax, BYTE PTR [rax+11]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN11@FatDirecto

; 355  : 		AuPmmngrFree((void*)V2P((size_t)buf));

	mov	rcx, QWORD PTR buf$[rbp]
	call	V2P
	mov	rcx, rax
	call	AuPmmngrFree

; 356  : 		dirent->index += 1;

	mov	rax, QWORD PTR dirent$[rbp]
	mov	eax, DWORD PTR [rax+32]
	inc	eax
	mov	rcx, QWORD PTR dirent$[rbp]
	mov	DWORD PTR [rcx+32], eax

; 357  : 		return -1;

	mov	eax, -1
	jmp	$LN1@FatDirecto
$LN11@FatDirecto:

; 358  : 	}
; 359  : 
; 360  : 	char filename[11];
; 361  : 	char name[11];
; 362  : 	memset(name, 0, 11);

	mov	r8d, 11
	xor	edx, edx
	lea	rcx, QWORD PTR name$[rbp]
	call	memset

; 363  : 	memcpy(name, dir_->filename, 11);

	mov	rax, QWORD PTR dir_$[rbp]
	mov	r8d, 11
	mov	rdx, rax
	lea	rcx, QWORD PTR name$[rbp]
	call	memcpy

; 364  : 	FatFromDosToFilename(filename, (char*)dir_->filename);

	mov	rax, QWORD PTR dir_$[rbp]
	mov	rdx, rax
	lea	rcx, QWORD PTR filename$[rbp]
	call	?FatFromDosToFilename@@YAXPEAD0@Z	; FatFromDosToFilename

; 365  : 	strcpy(dirent->filename,filename);

	mov	rax, QWORD PTR dirent$[rbp]
	lea	rdx, QWORD PTR filename$[rbp]
	mov	rcx, rax
	call	strcpy

; 366  : 	dirent->size = dir_->file_size;

	mov	rax, QWORD PTR dirent$[rbp]
	mov	rcx, QWORD PTR dir_$[rbp]
	mov	ecx, DWORD PTR [rcx+28]
	mov	DWORD PTR [rax+36], ecx

; 367  : 	dirent->time = dir_->time_created;

	mov	rax, QWORD PTR dir_$[rbp]
	movzx	eax, WORD PTR [rax+14]
	mov	rcx, QWORD PTR dirent$[rbp]
	mov	DWORD PTR [rcx+44], eax

; 368  : 	dirent->date = dir_->date_created;

	mov	rax, QWORD PTR dir_$[rbp]
	movzx	eax, WORD PTR [rax+16]
	mov	rcx, QWORD PTR dirent$[rbp]
	mov	DWORD PTR [rcx+40], eax

; 369  : 	if (dir_->attrib & 0x10)

	mov	rax, QWORD PTR dir_$[rbp]
	movzx	eax, BYTE PTR [rax+11]
	and	eax, 16
	test	eax, eax
	je	SHORT $LN12@FatDirecto

; 370  : 		dirent->flags = FS_FLAG_DIRECTORY;

	mov	rax, QWORD PTR dirent$[rbp]
	mov	BYTE PTR [rax+48], 2
$LN12@FatDirecto:

; 371  : 	if (dir_->attrib & 0x20)

	mov	rax, QWORD PTR dir_$[rbp]
	movzx	eax, BYTE PTR [rax+11]
	and	eax, 32					; 00000020H
	test	eax, eax
	je	SHORT $LN13@FatDirecto

; 372  : 		dirent->flags = FS_FLAG_GENERAL;

	mov	rax, QWORD PTR dirent$[rbp]
	mov	BYTE PTR [rax+48], 4
$LN13@FatDirecto:

; 373  : 	AuPmmngrFree((void*)V2P((size_t)buf));

	mov	rcx, QWORD PTR buf$[rbp]
	call	V2P
	mov	rcx, rax
	call	AuPmmngrFree

; 374  : 	dirent->index += 1;

	mov	rax, QWORD PTR dirent$[rbp]
	mov	eax, DWORD PTR [rax+32]
	inc	eax
	mov	rcx, QWORD PTR dirent$[rbp]
	mov	DWORD PTR [rcx+32], eax

; 375  : 	return 0;

	xor	eax, eax
$LN1@FatDirecto:

; 376  : }

	lea	rsp, QWORD PTR [rbp+160]
	pop	rbp
	ret	0
?FatDirectoryRead@@YAHPEAU__VFS_NODE__@@0PEAU_AuDirectoryEnty_@@@Z ENDP ; FatDirectoryRead
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Fs\Fat\FatDir.cpp
;	COMDAT ?FatOpenDir@@YAPEAU__VFS_NODE__@@PEAU1@PEAD@Z
_TEXT	SEGMENT
ret$ = 0
fatfs$ = 8
fs$ = 96
path$ = 104
?FatOpenDir@@YAPEAU__VFS_NODE__@@PEAU1@PEAD@Z PROC	; FatOpenDir, COMDAT

; 252  : AuVFSNode* FatOpenDir(AuVFSNode* fs, char *path) {

$LN9:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__C6938175_FatDir@cpp
	call	__CheckForDebuggerJustMyCode

; 253  : 	AuVFSNode* ret = NULL;

	mov	QWORD PTR ret$[rbp], 0

; 254  : 	if (!fs)

	cmp	QWORD PTR fs$[rbp], 0
	jne	SHORT $LN2@FatOpenDir

; 255  : 		return ret;

	mov	rax, QWORD PTR ret$[rbp]
	jmp	$LN1@FatOpenDir
$LN2@FatOpenDir:

; 256  : 	FatFS* fatfs = (FatFS*)fs->device;

	mov	rax, QWORD PTR fs$[rbp]
	mov	rax, QWORD PTR [rax+64]
	mov	QWORD PTR fatfs$[rbp], rax

; 257  : 	if (!fatfs)

	cmp	QWORD PTR fatfs$[rbp], 0
	jne	SHORT $LN3@FatOpenDir

; 258  : 		return ret;

	mov	rax, QWORD PTR ret$[rbp]
	jmp	$LN1@FatOpenDir
$LN3@FatOpenDir:

; 259  : 	ret = FatOpen(fs, path);

	mov	rdx, QWORD PTR path$[rbp]
	mov	rcx, QWORD PTR fs$[rbp]
	call	?FatOpen@@YAPEAU__VFS_NODE__@@PEAU1@PEAD@Z ; FatOpen
	mov	QWORD PTR ret$[rbp], rax

; 260  : 	if (ret) {

	cmp	QWORD PTR ret$[rbp], 0
	je	SHORT $LN4@FatOpenDir

; 261  : 		SeTextOut("Ret filename ->%s \r\n", ret->filename);

	mov	rax, QWORD PTR ret$[rbp]
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:??_C@_0BF@FKKOCNDK@Ret?5filename?5?9?$DO?$CFs?5?$AN?6@
	call	SeTextOut

; 262  : 		if (ret->flags & FS_FLAG_DIRECTORY)

	mov	rax, QWORD PTR ret$[rbp]
	movzx	eax, WORD PTR [rax+61]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN5@FatOpenDir

; 263  : 			SeTextOut("FS Flag dir \r\n");

	lea	rcx, OFFSET FLAT:??_C@_0P@NDONFAJC@FS?5Flag?5dir?5?$AN?6@
	call	SeTextOut
$LN5@FatOpenDir:
$LN4@FatOpenDir:

; 264  : 	}
; 265  : 	if (ret && !(ret->flags & FS_FLAG_DIRECTORY)) {

	cmp	QWORD PTR ret$[rbp], 0
	je	SHORT $LN6@FatOpenDir
	mov	rax, QWORD PTR ret$[rbp]
	movzx	eax, WORD PTR [rax+61]
	and	eax, 2
	test	eax, eax
	jne	SHORT $LN6@FatOpenDir

; 266  : 		SeTextOut("freeing ret \r\n");

	lea	rcx, OFFSET FLAT:??_C@_0P@LIJOLHPC@freeing?5ret?5?$AN?6@
	call	SeTextOut

; 267  : 		kfree(ret);

	mov	rcx, QWORD PTR ret$[rbp]
	call	kfree

; 268  : 		return NULL;

	xor	eax, eax
	jmp	$LN1@FatOpenDir
$LN6@FatOpenDir:

; 269  : 	}
; 270  : 	if (!ret) {

	cmp	QWORD PTR ret$[rbp], 0
	jne	$LN7@FatOpenDir

; 271  : 		/* if no returnable file found, simply return
; 272  : 		 * the root directory by creating a new vfs
; 273  : 		 * instance
; 274  : 		 */
; 275  : 		ret = (AuVFSNode*)kmalloc(sizeof(AuVFSNode));

	mov	ecx, 178				; 000000b2H
	call	kmalloc
	mov	QWORD PTR ret$[rbp], rax

; 276  : 		memset(ret, 0, sizeof(AuVFSNode));

	mov	r8d, 178				; 000000b2H
	xor	edx, edx
	mov	rcx, QWORD PTR ret$[rbp]
	call	memset

; 277  : 		strcpy(ret->filename, "/");

	mov	rax, QWORD PTR ret$[rbp]
	lea	rdx, OFFSET FLAT:??_C@_01KMDKNFGN@?1@
	mov	rcx, rax
	call	strcpy

; 278  : 		ret->current = fatfs->__RootDirFirstCluster;

	mov	rax, QWORD PTR fatfs$[rbp]
	mov	eax, DWORD PTR [rax+40]
	mov	rcx, QWORD PTR ret$[rbp]
	mov	QWORD PTR [rcx+53], rax

; 279  : 		ret->size = 0;

	mov	rax, QWORD PTR ret$[rbp]
	mov	DWORD PTR [rax+32], 0

; 280  : 		ret->eof = 0;

	mov	rax, QWORD PTR ret$[rbp]
	mov	BYTE PTR [rax+36], 0

; 281  : 		ret->status = FS_STATUS_FOUND;

	mov	rax, QWORD PTR ret$[rbp]
	mov	BYTE PTR [rax+63], 1

; 282  : 		ret->close = 0;

	mov	rax, QWORD PTR ret$[rbp]
	mov	QWORD PTR [rax+138], 0

; 283  : 		ret->first_block = fatfs->__RootDirFirstCluster;

	mov	rax, QWORD PTR fatfs$[rbp]
	mov	eax, DWORD PTR [rax+40]
	mov	rcx, QWORD PTR ret$[rbp]
	mov	QWORD PTR [rcx+45], rax

; 284  : 		ret->pos = 0;

	mov	rax, QWORD PTR ret$[rbp]
	mov	DWORD PTR [rax+37], 0

; 285  : 		ret->device = fs;

	mov	rax, QWORD PTR ret$[rbp]
	mov	rcx, QWORD PTR fs$[rbp]
	mov	QWORD PTR [rax+64], rcx

; 286  : 		ret->parent_block = fatfs->__RootDirFirstCluster;

	mov	rax, QWORD PTR ret$[rbp]
	mov	rcx, QWORD PTR fatfs$[rbp]
	mov	ecx, DWORD PTR [rcx+40]
	mov	DWORD PTR [rax+41], ecx

; 287  : 		ret->flags |= FS_FLAG_DIRECTORY;

	mov	rax, QWORD PTR ret$[rbp]
	movzx	eax, WORD PTR [rax+61]
	or	eax, 2
	mov	rcx, QWORD PTR ret$[rbp]
	mov	WORD PTR [rcx+61], ax
$LN7@FatOpenDir:

; 288  : 	}
; 289  : 	return ret;

	mov	rax, QWORD PTR ret$[rbp]
$LN1@FatOpenDir:

; 290  : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
?FatOpenDir@@YAPEAU__VFS_NODE__@@PEAU1@PEAD@Z ENDP	; FatOpenDir
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Fs\Fat\FatDir.cpp
;	COMDAT ?FatRemoveDir@@YAHPEAU__VFS_NODE__@@0@Z
_TEXT	SEGMENT
_fs$ = 0
dir_clust$ = 8
_is_empty$ = 12
buff$ = 16
j$1 = 24
dirent$2 = 32
i$3 = 40
name$4 = 48
tv83 = 128
fsys$ = 160
file$ = 168
?FatRemoveDir@@YAHPEAU__VFS_NODE__@@0@Z PROC		; FatRemoveDir, COMDAT

; 198  : int FatRemoveDir(AuVFSNode* fsys, AuVFSNode* file) {

$LN16:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 176				; 000000b0H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__C6938175_FatDir@cpp
	call	__CheckForDebuggerJustMyCode

; 199  : 	if (!fsys)

	cmp	QWORD PTR fsys$[rbp], 0
	jne	SHORT $LN10@FatRemoveD

; 200  : 		return -1;

	mov	eax, -1
	jmp	$LN1@FatRemoveD
$LN10@FatRemoveD:

; 201  : 	if (!file)

	cmp	QWORD PTR file$[rbp], 0
	jne	SHORT $LN11@FatRemoveD

; 202  : 		return -1;

	mov	eax, -1
	jmp	$LN1@FatRemoveD
$LN11@FatRemoveD:

; 203  : 
; 204  : 	FatFS* _fs = (FatFS*)fsys->device;

	mov	rax, QWORD PTR fsys$[rbp]
	mov	rax, QWORD PTR [rax+64]
	mov	QWORD PTR _fs$[rbp], rax

; 205  : 
; 206  : 	uint32_t dir_clust = file->current;

	mov	rax, QWORD PTR file$[rbp]
	mov	eax, DWORD PTR [rax+53]
	mov	DWORD PTR dir_clust$[rbp], eax

; 207  : 
; 208  : 	bool _is_empty = true;

	mov	BYTE PTR _is_empty$[rbp], 1

; 209  : 
; 210  : 	uint64_t* buff = (uint64_t*)P2V((size_t)AuPmmngrAlloc());

	call	AuPmmngrAlloc
	mov	rcx, rax
	call	P2V
	mov	QWORD PTR buff$[rbp], rax

; 211  : 	memset(buff, 0, PAGE_SIZE);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR buff$[rbp]
	call	memset
$LN2@FatRemoveD:

; 212  : 	/* verify, if the directory is empty*/
; 213  : 	while (1) {

	xor	eax, eax
	cmp	eax, 1
	je	$LN3@FatRemoveD

; 214  : 		for (int j = 0; j < _fs->__SectorPerCluster; j++) {

	mov	DWORD PTR j$1[rbp], 0
	jmp	SHORT $LN6@FatRemoveD
$LN4@FatRemoveD:
	mov	eax, DWORD PTR j$1[rbp]
	inc	eax
	mov	DWORD PTR j$1[rbp], eax
$LN6@FatRemoveD:
	mov	rax, QWORD PTR _fs$[rbp]
	movzx	eax, BYTE PTR [rax+36]
	cmp	DWORD PTR j$1[rbp], eax
	jge	$LN5@FatRemoveD

; 215  : 			memset(buff, 0, PAGE_SIZE);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR buff$[rbp]
	call	memset

; 216  : 			AuVDiskRead(_fs->vdisk, FatClusterToSector32(_fs, dir_clust) + j, 1, (uint64_t*)V2P((size_t)buff));

	mov	rcx, QWORD PTR buff$[rbp]
	call	V2P
	mov	QWORD PTR tv83[rbp], rax
	mov	ecx, DWORD PTR dir_clust$[rbp]
	mov	edx, ecx
	mov	rcx, QWORD PTR _fs$[rbp]
	call	?FatClusterToSector32@@YA_KPEAU_FatFS_@@_K@Z ; FatClusterToSector32
	movsxd	rcx, DWORD PTR j$1[rbp]
	add	rax, rcx
	mov	rcx, QWORD PTR tv83[rbp]
	mov	r9, rcx
	mov	r8d, 1
	mov	rdx, rax
	mov	rax, QWORD PTR _fs$[rbp]
	mov	rcx, QWORD PTR [rax+8]
	call	AuVDiskRead

; 217  : 
; 218  : 			FatDir *dirent = (FatDir*)buff;

	mov	rax, QWORD PTR buff$[rbp]
	mov	QWORD PTR dirent$2[rbp], rax

; 219  : 			for (int i = 0; i < 16; i++) {

	mov	DWORD PTR i$3[rbp], 0
	jmp	SHORT $LN9@FatRemoveD
$LN7@FatRemoveD:
	mov	eax, DWORD PTR i$3[rbp]
	inc	eax
	mov	DWORD PTR i$3[rbp], eax
$LN9@FatRemoveD:
	cmp	DWORD PTR i$3[rbp], 16
	jge	SHORT $LN8@FatRemoveD

; 220  : 				char name[11];
; 221  : 				memcpy(name, dirent->filename, 11);

	mov	rax, QWORD PTR dirent$2[rbp]
	mov	r8d, 11
	mov	rdx, rax
	lea	rcx, QWORD PTR name$4[rbp]
	call	memcpy

; 222  : 				name[10] = 0;

	mov	eax, 1
	imul	rax, rax, 10
	mov	BYTE PTR name$4[rbp+rax], 0

; 223  : 
; 224  : 				if ((dirent->filename[0] != 0x00) && (dirent->filename[0] != 0xE5)) {

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR dirent$2[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN12@FatRemoveD
	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR dirent$2[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 229				; 000000e5H
	je	SHORT $LN12@FatRemoveD

; 225  : 					AuPmmngrFree((void*)V2P((size_t)buff));

	mov	rcx, QWORD PTR buff$[rbp]
	call	V2P
	mov	rcx, rax
	call	AuPmmngrFree

; 226  : 					_is_empty = false;

	mov	BYTE PTR _is_empty$[rbp], 0

; 227  : 					break;

	jmp	SHORT $LN8@FatRemoveD
$LN12@FatRemoveD:

; 228  : 				}
; 229  : 				dirent++;

	mov	rax, QWORD PTR dirent$2[rbp]
	add	rax, 32					; 00000020H
	mov	QWORD PTR dirent$2[rbp], rax

; 230  : 			}

	jmp	$LN7@FatRemoveD
$LN8@FatRemoveD:

; 231  : 		}

	jmp	$LN4@FatRemoveD
$LN5@FatRemoveD:

; 232  : 
; 233  : 		dir_clust = FatReadFAT(fsys, dir_clust);

	mov	eax, DWORD PTR dir_clust$[rbp]
	mov	edx, eax
	mov	rcx, QWORD PTR fsys$[rbp]
	call	?FatReadFAT@@YAIPEAU__VFS_NODE__@@_K@Z	; FatReadFAT
	mov	DWORD PTR dir_clust$[rbp], eax

; 234  : 		if (dir_clust == (FAT_EOC_MARK & 0x0FFFFFFF))

	cmp	DWORD PTR dir_clust$[rbp], 268435448	; 0ffffff8H
	jne	SHORT $LN13@FatRemoveD

; 235  : 			break;

	jmp	SHORT $LN3@FatRemoveD
$LN13@FatRemoveD:

; 236  : 	}

	jmp	$LN2@FatRemoveD
$LN3@FatRemoveD:

; 237  : 
; 238  : 	if (_is_empty) {

	movzx	eax, BYTE PTR _is_empty$[rbp]
	test	eax, eax
	je	SHORT $LN14@FatRemoveD

; 239  : 		FatFileRemove(fsys, file);

	mov	rdx, QWORD PTR file$[rbp]
	mov	rcx, QWORD PTR fsys$[rbp]
	call	?FatFileRemove@@YAHPEAU__VFS_NODE__@@0@Z ; FatFileRemove

; 240  : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@FatRemoveD
$LN14@FatRemoveD:

; 241  : 	}
; 242  : 
; 243  : 	return -1;

	mov	eax, -1
$LN1@FatRemoveD:

; 244  : }

	lea	rsp, QWORD PTR [rbp+144]
	pop	rbp
	ret	0
?FatRemoveDir@@YAHPEAU__VFS_NODE__@@0@Z ENDP		; FatRemoveDir
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Fs\Fat\FatDir.cpp
;	COMDAT ?FatCreateDir@@YAPEAU__VFS_NODE__@@PEAU1@PEAD@Z
_TEXT	SEGMENT
_fs$ = 0
parent_clust$ = 8
parent$ = 16
file$ = 24
buff$ = 32
path$ = 40
p$ = 48
extract$ = 56
i$1 = 72
fname$ = 80
j$2 = 96
dirent$3 = 104
i$4 = 112
cluster$5 = 116
entrybuf$6 = 120
dot_entry$7 = 128
dotdot$8 = 136
tv294 = 208
tv281 = 208
tv166 = 208
tv285 = 216
fsys$ = 240
filename$ = 248
?FatCreateDir@@YAPEAU__VFS_NODE__@@PEAU1@PEAD@Z PROC	; FatCreateDir, COMDAT

; 46   : AuVFSNode* FatCreateDir(AuVFSNode* fsys,char* filename) {

$LN28:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 256				; 00000100H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__C6938175_FatDir@cpp
	call	__CheckForDebuggerJustMyCode

; 47   : 	if (!fsys)

	cmp	QWORD PTR fsys$[rbp], 0
	jne	SHORT $LN15@FatCreateD

; 48   : 		return NULL;

	xor	eax, eax
	jmp	$LN1@FatCreateD
$LN15@FatCreateD:

; 49   : 
; 50   : 	FatFS* _fs = (FatFS*)fsys->device;

	mov	rax, QWORD PTR fsys$[rbp]
	mov	rax, QWORD PTR [rax+64]
	mov	QWORD PTR _fs$[rbp], rax

; 51   : 
; 52   : 	uint32_t parent_clust = 0;

	mov	DWORD PTR parent_clust$[rbp], 0

; 53   : 
; 54   : 	AuVFSNode* parent = FatFileGetParent(fsys, filename);

	mov	rdx, QWORD PTR filename$[rbp]
	mov	rcx, QWORD PTR fsys$[rbp]
	call	?FatFileGetParent@@YAPEAU__VFS_NODE__@@PEAU1@PEBD@Z ; FatFileGetParent
	mov	QWORD PTR parent$[rbp], rax

; 55   : 	if (!parent)

	cmp	QWORD PTR parent$[rbp], 0
	jne	SHORT $LN16@FatCreateD

; 56   : 		return NULL;

	xor	eax, eax
	jmp	$LN1@FatCreateD
$LN16@FatCreateD:

; 57   : 
; 58   : 	parent_clust = parent->current;

	mov	rax, QWORD PTR parent$[rbp]
	mov	eax, DWORD PTR [rax+53]
	mov	DWORD PTR parent_clust$[rbp], eax

; 59   : 
; 60   : 	if (!parent_clust)

	cmp	DWORD PTR parent_clust$[rbp], 0
	jne	SHORT $LN17@FatCreateD

; 61   : 		parent_clust = _fs->__RootDirFirstCluster;

	mov	rax, QWORD PTR _fs$[rbp]
	mov	eax, DWORD PTR [rax+40]
	mov	DWORD PTR parent_clust$[rbp], eax
$LN17@FatCreateD:

; 62   : 
; 63   : 	AuVFSNode* file = (AuVFSNode*)kmalloc(sizeof(AuVFSNode));

	mov	ecx, 178				; 000000b2H
	call	kmalloc
	mov	QWORD PTR file$[rbp], rax

; 64   : 	memset(file, 0, sizeof(AuVFSNode));

	mov	r8d, 178				; 000000b2H
	xor	edx, edx
	mov	rcx, QWORD PTR file$[rbp]
	call	memset

; 65   : 
; 66   : 	uint64_t* buff = (uint64_t*)P2V((size_t)AuPmmngrAlloc());

	call	AuPmmngrAlloc
	mov	rcx, rax
	call	P2V
	mov	QWORD PTR buff$[rbp], rax

; 67   : 	memset(buff, 0, PAGE_SIZE);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR buff$[rbp]
	call	memset

; 68   : 
; 69   : 	/* now extract only the filename from
; 70   : 	 * entire path */
; 71   : 	char* path = (char*)filename;

	mov	rax, QWORD PTR filename$[rbp]
	mov	QWORD PTR path$[rbp], rax

; 72   : 	char* p = strchr(path, '/');

	mov	edx, 47					; 0000002fH
	mov	rcx, QWORD PTR path$[rbp]
	call	strchr
	mov	QWORD PTR p$[rbp], rax

; 73   : 	if (p)

	cmp	QWORD PTR p$[rbp], 0
	je	SHORT $LN18@FatCreateD

; 74   : 		p++;

	mov	rax, QWORD PTR p$[rbp]
	inc	rax
	mov	QWORD PTR p$[rbp], rax
$LN18@FatCreateD:

; 75   : 
; 76   : 	char extract[16];
; 77   : 	memset(extract, 0, 16);

	mov	r8d, 16
	xor	edx, edx
	lea	rcx, QWORD PTR extract$[rbp]
	call	memset
$LN2@FatCreateD:

; 78   : 	while (p) {

	cmp	QWORD PTR p$[rbp], 0
	je	$LN3@FatCreateD

; 79   : 		int i = 0;

	mov	DWORD PTR i$1[rbp], 0

; 80   : 		for (i = 0; i < 16; i++) {

	mov	DWORD PTR i$1[rbp], 0
	jmp	SHORT $LN6@FatCreateD
$LN4@FatCreateD:
	mov	eax, DWORD PTR i$1[rbp]
	inc	eax
	mov	DWORD PTR i$1[rbp], eax
$LN6@FatCreateD:
	cmp	DWORD PTR i$1[rbp], 16
	jge	SHORT $LN5@FatCreateD

; 81   : 			if (p[i] == '/' || p[i] == '\0')

	movsxd	rax, DWORD PTR i$1[rbp]
	mov	rcx, QWORD PTR p$[rbp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 47					; 0000002fH
	je	SHORT $LN20@FatCreateD
	movsxd	rax, DWORD PTR i$1[rbp]
	mov	rcx, QWORD PTR p$[rbp]
	movsx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	jne	SHORT $LN19@FatCreateD
$LN20@FatCreateD:

; 82   : 				break;

	jmp	SHORT $LN5@FatCreateD
$LN19@FatCreateD:

; 83   : 			extract[i] = p[i];

	movsxd	rax, DWORD PTR i$1[rbp]
	movsxd	rcx, DWORD PTR i$1[rbp]
	mov	rdx, QWORD PTR p$[rbp]
	movzx	eax, BYTE PTR [rdx+rax]
	mov	BYTE PTR extract$[rbp+rcx], al

; 84   : 		}

	jmp	SHORT $LN4@FatCreateD
$LN5@FatCreateD:

; 85   : 		p = strchr(p + 1, '/');

	mov	rax, QWORD PTR p$[rbp]
	inc	rax
	mov	edx, 47					; 0000002fH
	mov	rcx, rax
	call	strchr
	mov	QWORD PTR p$[rbp], rax

; 86   : 		if (p)

	cmp	QWORD PTR p$[rbp], 0
	je	SHORT $LN21@FatCreateD

; 87   : 			p++;

	mov	rax, QWORD PTR p$[rbp]
	inc	rax
	mov	QWORD PTR p$[rbp], rax
$LN21@FatCreateD:

; 88   : 	}

	jmp	$LN2@FatCreateD
$LN3@FatCreateD:

; 89   : 
; 90   : 	char fname[11];
; 91   : 	memset(fname, 0, 11);

	mov	r8d, 11
	xor	edx, edx
	lea	rcx, QWORD PTR fname$[rbp]
	call	memset

; 92   : 	FatToDOSFilename(extract, fname, 11);

	mov	r8d, 11
	lea	rdx, QWORD PTR fname$[rbp]
	lea	rcx, QWORD PTR extract$[rbp]
	call	?FatToDOSFilename@@YAXPEBDPEADI@Z	; FatToDOSFilename

; 93   : 	fname[10] = 0;

	mov	eax, 1
	imul	rax, rax, 10
	mov	BYTE PTR fname$[rbp+rax], 0
$LN7@FatCreateD:

; 94   : 
; 95   : 	while (1) {

	xor	eax, eax
	cmp	eax, 1
	je	$LN8@FatCreateD

; 96   : 		for (int j = 0; j < _fs->__SectorPerCluster; j++) {

	mov	DWORD PTR j$2[rbp], 0
	jmp	SHORT $LN11@FatCreateD
$LN9@FatCreateD:
	mov	eax, DWORD PTR j$2[rbp]
	inc	eax
	mov	DWORD PTR j$2[rbp], eax
$LN11@FatCreateD:
	mov	rax, QWORD PTR _fs$[rbp]
	movzx	eax, BYTE PTR [rax+36]
	cmp	DWORD PTR j$2[rbp], eax
	jge	$LN10@FatCreateD

; 97   : 			memset(buff, 0, PAGE_SIZE);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR buff$[rbp]
	call	memset

; 98   : 			AuVDiskRead(_fs->vdisk, FatClusterToSector32(_fs, parent_clust) + j, 1, (uint64_t*)V2P((size_t)buff));

	mov	rcx, QWORD PTR buff$[rbp]
	call	V2P
	mov	QWORD PTR tv166[rbp], rax
	mov	ecx, DWORD PTR parent_clust$[rbp]
	mov	edx, ecx
	mov	rcx, QWORD PTR _fs$[rbp]
	call	?FatClusterToSector32@@YA_KPEAU_FatFS_@@_K@Z ; FatClusterToSector32
	movsxd	rcx, DWORD PTR j$2[rbp]
	add	rax, rcx
	mov	rcx, QWORD PTR tv166[rbp]
	mov	r9, rcx
	mov	r8d, 1
	mov	rdx, rax
	mov	rax, QWORD PTR _fs$[rbp]
	mov	rcx, QWORD PTR [rax+8]
	call	AuVDiskRead

; 99   : 
; 100  : 			FatDir *dirent = (FatDir*)buff;

	mov	rax, QWORD PTR buff$[rbp]
	mov	QWORD PTR dirent$3[rbp], rax

; 101  : 			for (int i = 0; i < 16; i++) {

	mov	DWORD PTR i$4[rbp], 0
	jmp	SHORT $LN14@FatCreateD
$LN12@FatCreateD:
	mov	eax, DWORD PTR i$4[rbp]
	inc	eax
	mov	DWORD PTR i$4[rbp], eax
$LN14@FatCreateD:
	cmp	DWORD PTR i$4[rbp], 16
	jge	$LN13@FatCreateD

; 102  : 				if (dirent->filename[0] == 0x00 || dirent->filename[0] == 0xE5) {

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR dirent$3[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN23@FatCreateD
	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR dirent$3[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 229				; 000000e5H
	jne	$LN22@FatCreateD
$LN23@FatCreateD:

; 103  : 
; 104  : 					/* fill this direntry*/
; 105  : 					memcpy(dirent->filename, fname, 11);

	mov	rax, QWORD PTR dirent$3[rbp]
	mov	r8d, 11
	lea	rdx, QWORD PTR fname$[rbp]
	mov	rcx, rax
	call	memcpy

; 106  : 
; 107  : 					/* allocate a new cluster for dir*/
; 108  : 					uint32_t cluster = FatFindFreeCluster(fsys);

	mov	rcx, QWORD PTR fsys$[rbp]
	call	?FatFindFreeCluster@@YAIPEAU__VFS_NODE__@@@Z ; FatFindFreeCluster
	mov	DWORD PTR cluster$5[rbp], eax

; 109  : 					FatAllocCluster(fsys, cluster, FAT_EOC_MARK);

	mov	r8d, -8					; fffffff8H
	mov	edx, DWORD PTR cluster$5[rbp]
	mov	rcx, QWORD PTR fsys$[rbp]
	call	?FatAllocCluster@@YAXPEAU__VFS_NODE__@@HI@Z ; FatAllocCluster

; 110  : 					FatClearCluster(fsys, cluster);

	mov	edx, DWORD PTR cluster$5[rbp]
	mov	rcx, QWORD PTR fsys$[rbp]
	call	?FatClearCluster@@YAXPEAU__VFS_NODE__@@I@Z ; FatClearCluster

; 111  : 
; 112  : 					dirent->attrib = FAT_ATTRIBUTE_DIRECTORY;

	mov	rax, QWORD PTR dirent$3[rbp]
	mov	BYTE PTR [rax+11], 16

; 113  : 					dirent->first_cluster = cluster & 0x0000FFFF;

	mov	eax, DWORD PTR cluster$5[rbp]
	and	eax, 65535				; 0000ffffH
	mov	rcx, QWORD PTR dirent$3[rbp]
	mov	WORD PTR [rcx+26], ax

; 114  : 					dirent->first_cluster_hi_bytes = (cluster & 0x0FFF0000) >> 16;

	mov	eax, DWORD PTR cluster$5[rbp]
	and	eax, 268369920				; 0fff0000H
	shr	eax, 16
	mov	rcx, QWORD PTR dirent$3[rbp]
	mov	WORD PTR [rcx+20], ax

; 115  : 					dirent->date_created = FatFormatDate();

	call	?FatFormatDate@@YAGXZ			; FatFormatDate
	mov	rcx, QWORD PTR dirent$3[rbp]
	mov	WORD PTR [rcx+16], ax

; 116  : 					dirent->time_created = FatFormatTime();

	call	?FatFormatTime@@YAGXZ			; FatFormatTime
	mov	rcx, QWORD PTR dirent$3[rbp]
	mov	WORD PTR [rcx+14], ax

; 117  : 					dirent->last_wrt_date = dirent->date_created;

	mov	rax, QWORD PTR dirent$3[rbp]
	mov	rcx, QWORD PTR dirent$3[rbp]
	movzx	ecx, WORD PTR [rcx+16]
	mov	WORD PTR [rax+24], cx

; 118  : 					dirent->last_wrt_time = dirent->last_wrt_time;

	mov	rax, QWORD PTR dirent$3[rbp]
	movzx	ecx, WORD PTR [rax+22]
	mov	WORD PTR [rax+22], cx

; 119  : 					dirent->date_last_accessed = 0;

	xor	eax, eax
	mov	rcx, QWORD PTR dirent$3[rbp]
	mov	WORD PTR [rcx+18], ax

; 120  : 					dirent->file_size = 0;

	mov	rax, QWORD PTR dirent$3[rbp]
	mov	DWORD PTR [rax+28], 0

; 121  : 
; 122  : 					uint64_t* entrybuf = (uint64_t*)P2V((size_t)AuPmmngrAlloc());

	call	AuPmmngrAlloc
	mov	rcx, rax
	call	P2V
	mov	QWORD PTR entrybuf$6[rbp], rax

; 123  : 					memset(entrybuf, 0, PAGE_SIZE);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR entrybuf$6[rbp]
	call	memset

; 124  : 
; 125  : 					FatDir* dot_entry = (FatDir*)entrybuf;

	mov	rax, QWORD PTR entrybuf$6[rbp]
	mov	QWORD PTR dot_entry$7[rbp], rax

; 126  : 					memset(dot_entry, 0, sizeof(FatDir));

	mov	r8d, 32					; 00000020H
	xor	edx, edx
	mov	rcx, QWORD PTR dot_entry$7[rbp]
	call	memset

; 127  : 					dot_entry->filename[0] = '.';

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR dot_entry$7[rbp]
	mov	BYTE PTR [rcx+rax], 46			; 0000002eH

; 128  : 					memset(dot_entry->filename + 1, 0x20, 10);

	mov	rax, QWORD PTR dot_entry$7[rbp]
	inc	rax
	mov	r8d, 10
	mov	dl, 32					; 00000020H
	mov	rcx, rax
	call	memset

; 129  : 					dot_entry->attrib = FAT_ATTRIBUTE_DIRECTORY;

	mov	rax, QWORD PTR dot_entry$7[rbp]
	mov	BYTE PTR [rax+11], 16

; 130  : 					dot_entry->date_created = dirent->date_created;

	mov	rax, QWORD PTR dot_entry$7[rbp]
	mov	rcx, QWORD PTR dirent$3[rbp]
	movzx	ecx, WORD PTR [rcx+16]
	mov	WORD PTR [rax+16], cx

; 131  : 					dot_entry->time_created = dirent->time_created;

	mov	rax, QWORD PTR dot_entry$7[rbp]
	mov	rcx, QWORD PTR dirent$3[rbp]
	movzx	ecx, WORD PTR [rcx+14]
	mov	WORD PTR [rax+14], cx

; 132  : 					dot_entry->file_size = 0;

	mov	rax, QWORD PTR dot_entry$7[rbp]
	mov	DWORD PTR [rax+28], 0

; 133  : 					dot_entry->first_cluster = dirent->first_cluster;

	mov	rax, QWORD PTR dot_entry$7[rbp]
	mov	rcx, QWORD PTR dirent$3[rbp]
	movzx	ecx, WORD PTR [rcx+26]
	mov	WORD PTR [rax+26], cx

; 134  : 					dot_entry->first_cluster_hi_bytes = dirent->first_cluster_hi_bytes;

	mov	rax, QWORD PTR dot_entry$7[rbp]
	mov	rcx, QWORD PTR dirent$3[rbp]
	movzx	ecx, WORD PTR [rcx+20]
	mov	WORD PTR [rax+20], cx

; 135  : 					dot_entry->last_wrt_date = dirent->last_wrt_date;

	mov	rax, QWORD PTR dot_entry$7[rbp]
	mov	rcx, QWORD PTR dirent$3[rbp]
	movzx	ecx, WORD PTR [rcx+24]
	mov	WORD PTR [rax+24], cx

; 136  : 					dot_entry->last_wrt_time = dirent->last_wrt_time;

	mov	rax, QWORD PTR dot_entry$7[rbp]
	mov	rcx, QWORD PTR dirent$3[rbp]
	movzx	ecx, WORD PTR [rcx+22]
	mov	WORD PTR [rax+22], cx

; 137  : 
; 138  : 					FatDir* dotdot = (FatDir*)((uint8_t*)entrybuf + sizeof(FatDir));

	mov	rax, QWORD PTR entrybuf$6[rbp]
	add	rax, 32					; 00000020H
	mov	QWORD PTR dotdot$8[rbp], rax

; 139  : 					memset(dotdot, 0, sizeof(FatDir));

	mov	r8d, 32					; 00000020H
	xor	edx, edx
	mov	rcx, QWORD PTR dotdot$8[rbp]
	call	memset

; 140  : 					dotdot->filename[0] = '.';

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR dotdot$8[rbp]
	mov	BYTE PTR [rcx+rax], 46			; 0000002eH

; 141  : 					dotdot->filename[1] = '.';

	mov	eax, 1
	imul	rax, rax, 1
	mov	rcx, QWORD PTR dotdot$8[rbp]
	mov	BYTE PTR [rcx+rax], 46			; 0000002eH

; 142  : 					dotdot->attrib = FAT_ATTRIBUTE_DIRECTORY;

	mov	rax, QWORD PTR dotdot$8[rbp]
	mov	BYTE PTR [rax+11], 16

; 143  : 					dotdot->date_created = dirent->date_created;

	mov	rax, QWORD PTR dotdot$8[rbp]
	mov	rcx, QWORD PTR dirent$3[rbp]
	movzx	ecx, WORD PTR [rcx+16]
	mov	WORD PTR [rax+16], cx

; 144  : 					dotdot->time_created = dirent->time_created;

	mov	rax, QWORD PTR dotdot$8[rbp]
	mov	rcx, QWORD PTR dirent$3[rbp]
	movzx	ecx, WORD PTR [rcx+14]
	mov	WORD PTR [rax+14], cx

; 145  : 					dotdot->date_last_accessed = dirent->date_last_accessed;

	mov	rax, QWORD PTR dotdot$8[rbp]
	mov	rcx, QWORD PTR dirent$3[rbp]
	movzx	ecx, WORD PTR [rcx+18]
	mov	WORD PTR [rax+18], cx

; 146  : 					dotdot->file_size = 0;

	mov	rax, QWORD PTR dotdot$8[rbp]
	mov	DWORD PTR [rax+28], 0

; 147  : 
; 148  : 					if (parent_clust == _fs->__RootDirFirstCluster) {

	mov	rax, QWORD PTR _fs$[rbp]
	mov	eax, DWORD PTR [rax+40]
	cmp	DWORD PTR parent_clust$[rbp], eax
	jne	SHORT $LN24@FatCreateD

; 149  : 						dotdot->first_cluster = 0 & 0x0000FFFF;

	xor	eax, eax
	mov	rcx, QWORD PTR dotdot$8[rbp]
	mov	WORD PTR [rcx+26], ax

; 150  : 						dotdot->first_cluster_hi_bytes = (0 & 0x0FFF0000) >> 16;

	xor	eax, eax
	mov	rcx, QWORD PTR dotdot$8[rbp]
	mov	WORD PTR [rcx+20], ax

; 151  : 					}

	jmp	SHORT $LN25@FatCreateD
$LN24@FatCreateD:

; 152  : 					else {
; 153  : 						dotdot->first_cluster = parent_clust & 0x0000FFFF;

	mov	eax, DWORD PTR parent_clust$[rbp]
	and	eax, 65535				; 0000ffffH
	mov	rcx, QWORD PTR dotdot$8[rbp]
	mov	WORD PTR [rcx+26], ax

; 154  : 						dotdot->first_cluster_hi_bytes = (0 & 0x0FFF0000) >> 16;

	xor	eax, eax
	mov	rcx, QWORD PTR dotdot$8[rbp]
	mov	WORD PTR [rcx+20], ax
$LN25@FatCreateD:

; 155  : 					}
; 156  : 
; 157  : 					dotdot->last_wrt_date = dirent->last_wrt_date;

	mov	rax, QWORD PTR dotdot$8[rbp]
	mov	rcx, QWORD PTR dirent$3[rbp]
	movzx	ecx, WORD PTR [rcx+24]
	mov	WORD PTR [rax+24], cx

; 158  : 					dotdot->last_wrt_time = dirent->last_wrt_time;

	mov	rax, QWORD PTR dotdot$8[rbp]
	mov	rcx, QWORD PTR dirent$3[rbp]
	movzx	ecx, WORD PTR [rcx+22]
	mov	WORD PTR [rax+22], cx

; 159  : 
; 160  : 					AuVDiskWrite(_fs->vdisk, FatClusterToSector32(_fs, cluster), _fs->__SectorPerCluster, (uint64_t*)V2P((size_t)entrybuf));

	mov	rcx, QWORD PTR entrybuf$6[rbp]
	call	V2P
	mov	QWORD PTR tv281[rbp], rax
	mov	rcx, QWORD PTR _fs$[rbp]
	movzx	ecx, BYTE PTR [rcx+36]
	mov	DWORD PTR tv285[rbp], ecx
	mov	edx, DWORD PTR cluster$5[rbp]
	mov	rcx, QWORD PTR _fs$[rbp]
	call	?FatClusterToSector32@@YA_KPEAU_FatFS_@@_K@Z ; FatClusterToSector32
	mov	rcx, QWORD PTR tv281[rbp]
	mov	r9, rcx
	mov	ecx, DWORD PTR tv285[rbp]
	mov	r8d, ecx
	mov	rdx, rax
	mov	rax, QWORD PTR _fs$[rbp]
	mov	rcx, QWORD PTR [rax+8]
	call	AuVDiskWrite

; 161  : 					AuVDiskWrite(_fs->vdisk, FatClusterToSector32(_fs, parent_clust) + j, 1, (uint64_t*)V2P((size_t)buff));

	mov	rcx, QWORD PTR buff$[rbp]
	call	V2P
	mov	QWORD PTR tv294[rbp], rax
	mov	ecx, DWORD PTR parent_clust$[rbp]
	mov	edx, ecx
	mov	rcx, QWORD PTR _fs$[rbp]
	call	?FatClusterToSector32@@YA_KPEAU_FatFS_@@_K@Z ; FatClusterToSector32
	movsxd	rcx, DWORD PTR j$2[rbp]
	add	rax, rcx
	mov	rcx, QWORD PTR tv294[rbp]
	mov	r9, rcx
	mov	r8d, 1
	mov	rdx, rax
	mov	rax, QWORD PTR _fs$[rbp]
	mov	rcx, QWORD PTR [rax+8]
	call	AuVDiskWrite

; 162  : 
; 163  : 					AuPmmngrFree((void*)V2P((size_t)entrybuf));

	mov	rcx, QWORD PTR entrybuf$6[rbp]
	call	V2P
	mov	rcx, rax
	call	AuPmmngrFree

; 164  : 					AuPmmngrFree((void*)V2P((size_t)buff));

	mov	rcx, QWORD PTR buff$[rbp]
	call	V2P
	mov	rcx, rax
	call	AuPmmngrFree

; 165  : 
; 166  : 					strcpy(file->filename, extract);

	mov	rax, QWORD PTR file$[rbp]
	lea	rdx, QWORD PTR extract$[rbp]
	mov	rcx, rax
	call	strcpy

; 167  : 					file->size = 0;

	mov	rax, QWORD PTR file$[rbp]
	mov	DWORD PTR [rax+32], 0

; 168  : 					file->eof = 0;

	mov	rax, QWORD PTR file$[rbp]
	mov	BYTE PTR [rax+36], 0

; 169  : 					file->pos = 0;

	mov	rax, QWORD PTR file$[rbp]
	mov	DWORD PTR [rax+37], 0

; 170  : 					file->current = cluster;

	mov	eax, DWORD PTR cluster$5[rbp]
	mov	rcx, QWORD PTR file$[rbp]
	mov	QWORD PTR [rcx+53], rax

; 171  : 					file->device = fsys;

	mov	rax, QWORD PTR file$[rbp]
	mov	rcx, QWORD PTR fsys$[rbp]
	mov	QWORD PTR [rax+64], rcx

; 172  : 					file->first_block = file->current;

	mov	rax, QWORD PTR file$[rbp]
	mov	rcx, QWORD PTR file$[rbp]
	mov	rcx, QWORD PTR [rcx+53]
	mov	QWORD PTR [rax+45], rcx

; 173  : 					file->parent_block = parent_clust;

	mov	rax, QWORD PTR file$[rbp]
	mov	ecx, DWORD PTR parent_clust$[rbp]
	mov	DWORD PTR [rax+41], ecx

; 174  : 					file->flags |= FS_FLAG_DIRECTORY;

	mov	rax, QWORD PTR file$[rbp]
	movzx	eax, WORD PTR [rax+61]
	or	eax, 2
	mov	rcx, QWORD PTR file$[rbp]
	mov	WORD PTR [rcx+61], ax

; 175  : 					kfree(parent);

	mov	rcx, QWORD PTR parent$[rbp]
	call	kfree

; 176  : 					return file;

	mov	rax, QWORD PTR file$[rbp]
	jmp	SHORT $LN1@FatCreateD
$LN22@FatCreateD:

; 177  : 				}
; 178  : 				dirent++;

	mov	rax, QWORD PTR dirent$3[rbp]
	add	rax, 32					; 00000020H
	mov	QWORD PTR dirent$3[rbp], rax

; 179  : 			}

	jmp	$LN12@FatCreateD
$LN13@FatCreateD:

; 180  : 		}

	jmp	$LN9@FatCreateD
$LN10@FatCreateD:

; 181  : 
; 182  : 		parent_clust = FatReadFAT(fsys, parent_clust);

	mov	eax, DWORD PTR parent_clust$[rbp]
	mov	edx, eax
	mov	rcx, QWORD PTR fsys$[rbp]
	call	?FatReadFAT@@YAIPEAU__VFS_NODE__@@_K@Z	; FatReadFAT
	mov	DWORD PTR parent_clust$[rbp], eax

; 183  : 		if (parent_clust == (FAT_EOC_MARK & 0x0FFFFFFF))

	cmp	DWORD PTR parent_clust$[rbp], 268435448	; 0ffffff8H
	jne	SHORT $LN26@FatCreateD

; 184  : 			break;

	jmp	SHORT $LN8@FatCreateD
$LN26@FatCreateD:

; 185  : 	}

	jmp	$LN7@FatCreateD
$LN8@FatCreateD:

; 186  : 
; 187  : 	AuPmmngrFree((void*)V2P((size_t)buff));

	mov	rcx, QWORD PTR buff$[rbp]
	call	V2P
	mov	rcx, rax
	call	AuPmmngrFree

; 188  : 	kfree(parent);

	mov	rcx, QWORD PTR parent$[rbp]
	call	kfree

; 189  : 	kfree(file);

	mov	rcx, QWORD PTR file$[rbp]
	call	kfree

; 190  : 	return NULL;

	xor	eax, eax
$LN1@FatCreateD:

; 191  : }

	lea	rsp, QWORD PTR [rbp+224]
	pop	rbp
	ret	0
?FatCreateDir@@YAPEAU__VFS_NODE__@@PEAU1@PEAD@Z ENDP	; FatCreateDir
_TEXT	ENDS
END
