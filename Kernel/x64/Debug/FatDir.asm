; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.21005.1 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?FatCreateDir@@YAPEAU__VFS_NODE__@@PEAU1@PEAD@Z	; FatCreateDir
PUBLIC	?FatRemoveDir@@YAHPEAU__VFS_NODE__@@0@Z		; FatRemoveDir
EXTRN	AuVDiskRead:PROC
EXTRN	AuVDiskWrite:PROC
EXTRN	?FatClusterToSector32@@YA_KPEAU_FatFS_@@_K@Z:PROC ; FatClusterToSector32
EXTRN	?FatToDOSFilename@@YAXPEBDPEADI@Z:PROC		; FatToDOSFilename
EXTRN	?FatFindFreeCluster@@YAIPEAU__VFS_NODE__@@@Z:PROC ; FatFindFreeCluster
EXTRN	?FatAllocCluster@@YAXPEAU__VFS_NODE__@@HI@Z:PROC ; FatAllocCluster
EXTRN	?FatClearCluster@@YAXPEAU__VFS_NODE__@@I@Z:PROC	; FatClearCluster
EXTRN	?FatReadFAT@@YAIPEAU__VFS_NODE__@@I@Z:PROC	; FatReadFAT
EXTRN	?FatFormatDate@@YAGXZ:PROC			; FatFormatDate
EXTRN	?FatFormatTime@@YAGXZ:PROC			; FatFormatTime
EXTRN	?FatFileGetParent@@YAPEAU__VFS_NODE__@@PEAU1@PEBD@Z:PROC ; FatFileGetParent
EXTRN	?FatFileRemove@@YAHPEAU__VFS_NODE__@@0@Z:PROC	; FatFileRemove
EXTRN	kmalloc:PROC
EXTRN	kfree:PROC
EXTRN	AuPmmngrAlloc:PROC
EXTRN	AuPmmngrFree:PROC
EXTRN	P2V:PROC
EXTRN	V2P:PROC
EXTRN	strcpy:PROC
EXTRN	strchr:PROC
EXTRN	memset:PROC
EXTRN	memcpy:PROC
pdata	SEGMENT
$pdata$?FatCreateDir@@YAPEAU__VFS_NODE__@@PEAU1@PEAD@Z DD imagerel $LN28
	DD	imagerel $LN28+1920
	DD	imagerel $unwind$?FatCreateDir@@YAPEAU__VFS_NODE__@@PEAU1@PEAD@Z
$pdata$?FatRemoveDir@@YAHPEAU__VFS_NODE__@@0@Z DD imagerel $LN17
	DD	imagerel $LN17+503
	DD	imagerel $unwind$?FatRemoveDir@@YAHPEAU__VFS_NODE__@@0@Z
pdata	ENDS
xdata	SEGMENT
$unwind$?FatCreateDir@@YAPEAU__VFS_NODE__@@PEAU1@PEAD@Z DD 021101H
	DD	01b0111H
$unwind$?FatRemoveDir@@YAHPEAU__VFS_NODE__@@0@Z DD 010e01H
	DD	0c20eH
xdata	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\fs\fat\fatdir.cpp
_TEXT	SEGMENT
_is_empty$ = 32
j$1 = 36
dir_clust$ = 40
i$2 = 44
buff$ = 48
dirent$3 = 56
_fs$ = 64
tv83 = 72
name$4 = 80
fsys$ = 112
file$ = 120
?FatRemoveDir@@YAHPEAU__VFS_NODE__@@0@Z PROC		; FatRemoveDir

; 197  : int FatRemoveDir(AuVFSNode* fsys, AuVFSNode* file) {

$LN17:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 198  : 	if (!fsys)

	cmp	QWORD PTR fsys$[rsp], 0
	jne	SHORT $LN14@FatRemoveD

; 199  : 		return -1;

	mov	eax, -1
	jmp	$LN15@FatRemoveD
$LN14@FatRemoveD:

; 200  : 	if (!file)

	cmp	QWORD PTR file$[rsp], 0
	jne	SHORT $LN13@FatRemoveD

; 201  : 		return -1;

	mov	eax, -1
	jmp	$LN15@FatRemoveD
$LN13@FatRemoveD:

; 202  : 
; 203  : 	FatFS* _fs = (FatFS*)fsys->device;

	mov	rax, QWORD PTR fsys$[rsp]
	mov	rax, QWORD PTR [rax+63]
	mov	QWORD PTR _fs$[rsp], rax

; 204  : 
; 205  : 	uint32_t dir_clust = file->current;

	mov	rax, QWORD PTR file$[rsp]
	mov	eax, DWORD PTR [rax+53]
	mov	DWORD PTR dir_clust$[rsp], eax

; 206  : 
; 207  : 	bool _is_empty = true;

	mov	BYTE PTR _is_empty$[rsp], 1

; 208  : 
; 209  : 	uint64_t* buff = (uint64_t*)P2V((size_t)AuPmmngrAlloc());

	call	AuPmmngrAlloc
	mov	rcx, rax
	call	P2V
	mov	QWORD PTR buff$[rsp], rax

; 210  : 	memset(buff, 0, PAGE_SIZE);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR buff$[rsp]
	call	memset
$LN12@FatRemoveD:

; 211  : 	/* verify, if the directory is empty*/
; 212  : 	while (1) {

	xor	eax, eax
	cmp	eax, 1
	je	$LN11@FatRemoveD

; 213  : 		for (int j = 0; j < _fs->__SectorPerCluster; j++) {

	mov	DWORD PTR j$1[rsp], 0
	jmp	SHORT $LN10@FatRemoveD
$LN9@FatRemoveD:
	mov	eax, DWORD PTR j$1[rsp]
	inc	eax
	mov	DWORD PTR j$1[rsp], eax
$LN10@FatRemoveD:
	mov	rax, QWORD PTR _fs$[rsp]
	movzx	eax, BYTE PTR [rax+33]
	cmp	DWORD PTR j$1[rsp], eax
	jge	$LN8@FatRemoveD

; 214  : 			memset(buff, 0, PAGE_SIZE);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR buff$[rsp]
	call	memset

; 215  : 			AuVDiskRead(_fs->vdisk, FatClusterToSector32(_fs, dir_clust) + j, 1, (uint64_t*)V2P((size_t)buff));

	mov	rcx, QWORD PTR buff$[rsp]
	call	V2P
	mov	QWORD PTR tv83[rsp], rax
	mov	ecx, DWORD PTR dir_clust$[rsp]
	mov	edx, ecx
	mov	rcx, QWORD PTR _fs$[rsp]
	call	?FatClusterToSector32@@YA_KPEAU_FatFS_@@_K@Z ; FatClusterToSector32
	movsxd	rcx, DWORD PTR j$1[rsp]
	add	rax, rcx
	mov	rcx, QWORD PTR tv83[rsp]
	mov	r9, rcx
	mov	r8d, 1
	mov	rdx, rax
	mov	rax, QWORD PTR _fs$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	AuVDiskRead

; 216  : 
; 217  : 			FatDir *dirent = (FatDir*)buff;

	mov	rax, QWORD PTR buff$[rsp]
	mov	QWORD PTR dirent$3[rsp], rax

; 218  : 			for (int i = 0; i < 16; i++) {

	mov	DWORD PTR i$2[rsp], 0
	jmp	SHORT $LN7@FatRemoveD
$LN6@FatRemoveD:
	mov	eax, DWORD PTR i$2[rsp]
	inc	eax
	mov	DWORD PTR i$2[rsp], eax
$LN7@FatRemoveD:
	cmp	DWORD PTR i$2[rsp], 16
	jge	$LN5@FatRemoveD

; 219  : 				char name[11];
; 220  : 				memcpy(name, dirent->filename, 11);

	mov	rax, QWORD PTR dirent$3[rsp]
	mov	r8d, 11
	mov	rdx, rax
	lea	rcx, QWORD PTR name$4[rsp]
	call	memcpy

; 221  : 				name[11] = 0;

	mov	eax, 1
	imul	rax, rax, 11
	mov	BYTE PTR name$4[rsp+rax], 0

; 222  : 
; 223  : 				if (dirent->filename[0] != 0x00 || dirent->filename[0] != 0xE5) {

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR dirent$3[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	jne	SHORT $LN3@FatRemoveD
	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR dirent$3[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 229				; 000000e5H
	je	SHORT $LN4@FatRemoveD
$LN3@FatRemoveD:

; 224  : 					AuPmmngrFree((void*)V2P((size_t)buff));

	mov	rcx, QWORD PTR buff$[rsp]
	call	V2P
	mov	rcx, rax
	call	AuPmmngrFree

; 225  : 					_is_empty = false;

	mov	BYTE PTR _is_empty$[rsp], 0

; 226  : 					break;

	jmp	SHORT $LN5@FatRemoveD
$LN4@FatRemoveD:

; 227  : 				}
; 228  : 				dirent++;

	mov	rax, QWORD PTR dirent$3[rsp]
	add	rax, 32					; 00000020H
	mov	QWORD PTR dirent$3[rsp], rax

; 229  : 			}

	jmp	$LN6@FatRemoveD
$LN5@FatRemoveD:

; 230  : 		}

	jmp	$LN9@FatRemoveD
$LN8@FatRemoveD:

; 231  : 
; 232  : 		dir_clust = FatReadFAT(fsys, dir_clust);

	mov	edx, DWORD PTR dir_clust$[rsp]
	mov	rcx, QWORD PTR fsys$[rsp]
	call	?FatReadFAT@@YAIPEAU__VFS_NODE__@@I@Z	; FatReadFAT
	mov	DWORD PTR dir_clust$[rsp], eax

; 233  : 		if (dir_clust == (FAT_EOC_MARK & 0x0FFFFFFF))

	cmp	DWORD PTR dir_clust$[rsp], 268435448	; 0ffffff8H
	jne	SHORT $LN2@FatRemoveD

; 234  : 			break;

	jmp	SHORT $LN11@FatRemoveD
$LN2@FatRemoveD:

; 235  : 	}

	jmp	$LN12@FatRemoveD
$LN11@FatRemoveD:

; 236  : 
; 237  : 	if (_is_empty) {

	movzx	eax, BYTE PTR _is_empty$[rsp]
	test	eax, eax
	je	SHORT $LN1@FatRemoveD

; 238  : 		FatFileRemove(fsys, file);

	mov	rdx, QWORD PTR file$[rsp]
	mov	rcx, QWORD PTR fsys$[rsp]
	call	?FatFileRemove@@YAHPEAU__VFS_NODE__@@0@Z ; FatFileRemove

; 239  : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN15@FatRemoveD
$LN1@FatRemoveD:

; 240  : 	}
; 241  : 
; 242  : 	return -1;

	mov	eax, -1
$LN15@FatRemoveD:

; 243  : }

	add	rsp, 104				; 00000068H
	ret	0
?FatRemoveDir@@YAHPEAU__VFS_NODE__@@0@Z ENDP		; FatRemoveDir
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\fs\fat\fatdir.cpp
_TEXT	SEGMENT
dirent$1 = 32
parent_clust$ = 40
i$2 = 44
dotdot$3 = 48
file$ = 56
cluster$4 = 64
p$ = 72
dot_entry$5 = 80
j$6 = 88
_fs$ = 96
i$7 = 104
buff$ = 112
entrybuf$8 = 120
parent$ = 128
tv285 = 136
fname$ = 144
tv281 = 160
tv294 = 168
tv166 = 176
path$ = 184
extract$ = 192
fsys$ = 224
filename$ = 232
?FatCreateDir@@YAPEAU__VFS_NODE__@@PEAU1@PEAD@Z PROC	; FatCreateDir

; 45   : AuVFSNode* FatCreateDir(AuVFSNode* fsys,char* filename) {

$LN28:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 216				; 000000d8H

; 46   : 	if (!fsys)

	cmp	QWORD PTR fsys$[rsp], 0
	jne	SHORT $LN25@FatCreateD

; 47   : 		return NULL;

	xor	eax, eax
	jmp	$LN26@FatCreateD
$LN25@FatCreateD:

; 48   : 
; 49   : 	FatFS* _fs = (FatFS*)fsys->device;

	mov	rax, QWORD PTR fsys$[rsp]
	mov	rax, QWORD PTR [rax+63]
	mov	QWORD PTR _fs$[rsp], rax

; 50   : 
; 51   : 	uint32_t parent_clust = 0;

	mov	DWORD PTR parent_clust$[rsp], 0

; 52   : 
; 53   : 	AuVFSNode* parent = FatFileGetParent(fsys, filename);

	mov	rdx, QWORD PTR filename$[rsp]
	mov	rcx, QWORD PTR fsys$[rsp]
	call	?FatFileGetParent@@YAPEAU__VFS_NODE__@@PEAU1@PEBD@Z ; FatFileGetParent
	mov	QWORD PTR parent$[rsp], rax

; 54   : 	if (!parent)

	cmp	QWORD PTR parent$[rsp], 0
	jne	SHORT $LN24@FatCreateD

; 55   : 		return NULL;

	xor	eax, eax
	jmp	$LN26@FatCreateD
$LN24@FatCreateD:

; 56   : 
; 57   : 	parent_clust = parent->current;

	mov	rax, QWORD PTR parent$[rsp]
	mov	eax, DWORD PTR [rax+53]
	mov	DWORD PTR parent_clust$[rsp], eax

; 58   : 
; 59   : 	if (!parent_clust)

	cmp	DWORD PTR parent_clust$[rsp], 0
	jne	SHORT $LN23@FatCreateD

; 60   : 		parent_clust = _fs->__RootDirFirstCluster;

	mov	rax, QWORD PTR _fs$[rsp]
	mov	eax, DWORD PTR [rax+34]
	mov	DWORD PTR parent_clust$[rsp], eax
$LN23@FatCreateD:

; 61   : 
; 62   : 	AuVFSNode* file = (AuVFSNode*)kmalloc(sizeof(AuVFSNode));

	mov	ecx, 159				; 0000009fH
	call	kmalloc
	mov	QWORD PTR file$[rsp], rax

; 63   : 	memset(file, 0, sizeof(AuVFSNode));

	mov	r8d, 159				; 0000009fH
	xor	edx, edx
	mov	rcx, QWORD PTR file$[rsp]
	call	memset

; 64   : 
; 65   : 	uint64_t* buff = (uint64_t*)P2V((size_t)AuPmmngrAlloc());

	call	AuPmmngrAlloc
	mov	rcx, rax
	call	P2V
	mov	QWORD PTR buff$[rsp], rax

; 66   : 	memset(buff, 0, PAGE_SIZE);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR buff$[rsp]
	call	memset

; 67   : 
; 68   : 	/* now extract only the filename from
; 69   : 	 * entire path */
; 70   : 	char* path = (char*)filename;

	mov	rax, QWORD PTR filename$[rsp]
	mov	QWORD PTR path$[rsp], rax

; 71   : 	char* p = strchr(path, '/');

	mov	edx, 47					; 0000002fH
	mov	rcx, QWORD PTR path$[rsp]
	call	strchr
	mov	QWORD PTR p$[rsp], rax

; 72   : 	if (p)

	cmp	QWORD PTR p$[rsp], 0
	je	SHORT $LN22@FatCreateD

; 73   : 		p++;

	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax
$LN22@FatCreateD:

; 74   : 
; 75   : 	char extract[16];
; 76   : 	memset(extract, 0, 16);

	mov	r8d, 16
	xor	edx, edx
	lea	rcx, QWORD PTR extract$[rsp]
	call	memset
$LN21@FatCreateD:

; 77   : 	while (p) {

	cmp	QWORD PTR p$[rsp], 0
	je	$LN20@FatCreateD

; 78   : 		int i = 0;

	mov	DWORD PTR i$2[rsp], 0

; 79   : 		for (i = 0; i < 16; i++) {

	mov	DWORD PTR i$2[rsp], 0
	jmp	SHORT $LN19@FatCreateD
$LN18@FatCreateD:
	mov	eax, DWORD PTR i$2[rsp]
	inc	eax
	mov	DWORD PTR i$2[rsp], eax
$LN19@FatCreateD:
	cmp	DWORD PTR i$2[rsp], 16
	jge	SHORT $LN17@FatCreateD

; 80   : 			if (p[i] == '/' || p[i] == '\0')

	movsxd	rax, DWORD PTR i$2[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 47					; 0000002fH
	je	SHORT $LN15@FatCreateD
	movsxd	rax, DWORD PTR i$2[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	jne	SHORT $LN16@FatCreateD
$LN15@FatCreateD:

; 81   : 				break;

	jmp	SHORT $LN17@FatCreateD
$LN16@FatCreateD:

; 82   : 			extract[i] = p[i];

	movsxd	rax, DWORD PTR i$2[rsp]
	movsxd	rcx, DWORD PTR i$2[rsp]
	mov	rdx, QWORD PTR p$[rsp]
	movzx	eax, BYTE PTR [rdx+rax]
	mov	BYTE PTR extract$[rsp+rcx], al

; 83   : 		}

	jmp	SHORT $LN18@FatCreateD
$LN17@FatCreateD:

; 84   : 		p = strchr(p + 1, '/');

	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	edx, 47					; 0000002fH
	mov	rcx, rax
	call	strchr
	mov	QWORD PTR p$[rsp], rax

; 85   : 		if (p)

	cmp	QWORD PTR p$[rsp], 0
	je	SHORT $LN14@FatCreateD

; 86   : 			p++;

	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax
$LN14@FatCreateD:

; 87   : 	}

	jmp	$LN21@FatCreateD
$LN20@FatCreateD:

; 88   : 
; 89   : 	char fname[11];
; 90   : 	memset(fname, 0, 11);

	mov	r8d, 11
	xor	edx, edx
	lea	rcx, QWORD PTR fname$[rsp]
	call	memset

; 91   : 	FatToDOSFilename(extract, fname, 11);

	mov	r8d, 11
	lea	rdx, QWORD PTR fname$[rsp]
	lea	rcx, QWORD PTR extract$[rsp]
	call	?FatToDOSFilename@@YAXPEBDPEADI@Z	; FatToDOSFilename

; 92   : 	fname[11] = 0;

	mov	eax, 1
	imul	rax, rax, 11
	mov	BYTE PTR fname$[rsp+rax], 0
$LN13@FatCreateD:

; 93   : 
; 94   : 	while (1) {

	xor	eax, eax
	cmp	eax, 1
	je	$LN12@FatCreateD

; 95   : 		for (int j = 0; j < _fs->__SectorPerCluster; j++) {

	mov	DWORD PTR j$6[rsp], 0
	jmp	SHORT $LN11@FatCreateD
$LN10@FatCreateD:
	mov	eax, DWORD PTR j$6[rsp]
	inc	eax
	mov	DWORD PTR j$6[rsp], eax
$LN11@FatCreateD:
	mov	rax, QWORD PTR _fs$[rsp]
	movzx	eax, BYTE PTR [rax+33]
	cmp	DWORD PTR j$6[rsp], eax
	jge	$LN9@FatCreateD

; 96   : 			memset(buff, 0, PAGE_SIZE);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR buff$[rsp]
	call	memset

; 97   : 			AuVDiskRead(_fs->vdisk, FatClusterToSector32(_fs, parent_clust) + j, 1, (uint64_t*)V2P((size_t)buff));

	mov	rcx, QWORD PTR buff$[rsp]
	call	V2P
	mov	QWORD PTR tv166[rsp], rax
	mov	ecx, DWORD PTR parent_clust$[rsp]
	mov	edx, ecx
	mov	rcx, QWORD PTR _fs$[rsp]
	call	?FatClusterToSector32@@YA_KPEAU_FatFS_@@_K@Z ; FatClusterToSector32
	movsxd	rcx, DWORD PTR j$6[rsp]
	add	rax, rcx
	mov	rcx, QWORD PTR tv166[rsp]
	mov	r9, rcx
	mov	r8d, 1
	mov	rdx, rax
	mov	rax, QWORD PTR _fs$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	AuVDiskRead

; 98   : 
; 99   : 			FatDir *dirent = (FatDir*)buff;

	mov	rax, QWORD PTR buff$[rsp]
	mov	QWORD PTR dirent$1[rsp], rax

; 100  : 			for (int i = 0; i < 16; i++) {

	mov	DWORD PTR i$7[rsp], 0
	jmp	SHORT $LN8@FatCreateD
$LN7@FatCreateD:
	mov	eax, DWORD PTR i$7[rsp]
	inc	eax
	mov	DWORD PTR i$7[rsp], eax
$LN8@FatCreateD:
	cmp	DWORD PTR i$7[rsp], 16
	jge	$LN6@FatCreateD

; 101  : 				if (dirent->filename[0] == 0x00 || dirent->filename[0] == 0xE5) {

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR dirent$1[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN4@FatCreateD
	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR dirent$1[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 229				; 000000e5H
	jne	$LN5@FatCreateD
$LN4@FatCreateD:

; 102  : 
; 103  : 					/* fill this direntry*/
; 104  : 					memcpy(dirent->filename, fname, 11);

	mov	rax, QWORD PTR dirent$1[rsp]
	mov	r8d, 11
	lea	rdx, QWORD PTR fname$[rsp]
	mov	rcx, rax
	call	memcpy

; 105  : 
; 106  : 					/* allocate a new cluster for dir*/
; 107  : 					uint32_t cluster = FatFindFreeCluster(fsys);

	mov	rcx, QWORD PTR fsys$[rsp]
	call	?FatFindFreeCluster@@YAIPEAU__VFS_NODE__@@@Z ; FatFindFreeCluster
	mov	DWORD PTR cluster$4[rsp], eax

; 108  : 					FatAllocCluster(fsys, cluster, FAT_EOC_MARK);

	mov	r8d, -8					; fffffff8H
	mov	edx, DWORD PTR cluster$4[rsp]
	mov	rcx, QWORD PTR fsys$[rsp]
	call	?FatAllocCluster@@YAXPEAU__VFS_NODE__@@HI@Z ; FatAllocCluster

; 109  : 					FatClearCluster(fsys, cluster);

	mov	edx, DWORD PTR cluster$4[rsp]
	mov	rcx, QWORD PTR fsys$[rsp]
	call	?FatClearCluster@@YAXPEAU__VFS_NODE__@@I@Z ; FatClearCluster

; 110  : 
; 111  : 					dirent->attrib = FAT_ATTRIBUTE_DIRECTORY;

	mov	rax, QWORD PTR dirent$1[rsp]
	mov	BYTE PTR [rax+11], 16

; 112  : 					dirent->first_cluster = cluster & 0x0000FFFF;

	mov	eax, DWORD PTR cluster$4[rsp]
	and	eax, 65535				; 0000ffffH
	mov	rcx, QWORD PTR dirent$1[rsp]
	mov	WORD PTR [rcx+26], ax

; 113  : 					dirent->first_cluster_hi_bytes = (cluster & 0x0FFF0000) >> 16;

	mov	eax, DWORD PTR cluster$4[rsp]
	and	eax, 268369920				; 0fff0000H
	shr	eax, 16
	mov	rcx, QWORD PTR dirent$1[rsp]
	mov	WORD PTR [rcx+20], ax

; 114  : 					dirent->date_created = FatFormatDate();

	call	?FatFormatDate@@YAGXZ			; FatFormatDate
	mov	rcx, QWORD PTR dirent$1[rsp]
	mov	WORD PTR [rcx+16], ax

; 115  : 					dirent->time_created = FatFormatTime();

	call	?FatFormatTime@@YAGXZ			; FatFormatTime
	mov	rcx, QWORD PTR dirent$1[rsp]
	mov	WORD PTR [rcx+14], ax

; 116  : 					dirent->last_wrt_date = dirent->date_created;

	mov	rax, QWORD PTR dirent$1[rsp]
	mov	rcx, QWORD PTR dirent$1[rsp]
	movzx	ecx, WORD PTR [rcx+16]
	mov	WORD PTR [rax+24], cx

; 117  : 					dirent->last_wrt_time = dirent->last_wrt_time;

	mov	rax, QWORD PTR dirent$1[rsp]
	movzx	ecx, WORD PTR [rax+22]
	mov	WORD PTR [rax+22], cx

; 118  : 					dirent->date_last_accessed = 0;

	xor	eax, eax
	mov	rcx, QWORD PTR dirent$1[rsp]
	mov	WORD PTR [rcx+18], ax

; 119  : 					dirent->file_size = 0;

	mov	rax, QWORD PTR dirent$1[rsp]
	mov	DWORD PTR [rax+28], 0

; 120  : 
; 121  : 					uint64_t* entrybuf = (uint64_t*)P2V((size_t)AuPmmngrAlloc());

	call	AuPmmngrAlloc
	mov	rcx, rax
	call	P2V
	mov	QWORD PTR entrybuf$8[rsp], rax

; 122  : 					memset(entrybuf, 0, PAGE_SIZE);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR entrybuf$8[rsp]
	call	memset

; 123  : 
; 124  : 					FatDir* dot_entry = (FatDir*)entrybuf;

	mov	rax, QWORD PTR entrybuf$8[rsp]
	mov	QWORD PTR dot_entry$5[rsp], rax

; 125  : 					memset(dot_entry, 0, sizeof(FatDir));

	mov	r8d, 32					; 00000020H
	xor	edx, edx
	mov	rcx, QWORD PTR dot_entry$5[rsp]
	call	memset

; 126  : 					dot_entry->filename[0] = '.';

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR dot_entry$5[rsp]
	mov	BYTE PTR [rcx+rax], 46			; 0000002eH

; 127  : 					memset(dot_entry->filename + 1, 0x20, 10);

	mov	rax, QWORD PTR dot_entry$5[rsp]
	inc	rax
	mov	r8d, 10
	mov	dl, 32					; 00000020H
	mov	rcx, rax
	call	memset

; 128  : 					dot_entry->attrib = FAT_ATTRIBUTE_DIRECTORY;

	mov	rax, QWORD PTR dot_entry$5[rsp]
	mov	BYTE PTR [rax+11], 16

; 129  : 					dot_entry->date_created = dirent->date_created;

	mov	rax, QWORD PTR dot_entry$5[rsp]
	mov	rcx, QWORD PTR dirent$1[rsp]
	movzx	ecx, WORD PTR [rcx+16]
	mov	WORD PTR [rax+16], cx

; 130  : 					dot_entry->time_created = dirent->time_created;

	mov	rax, QWORD PTR dot_entry$5[rsp]
	mov	rcx, QWORD PTR dirent$1[rsp]
	movzx	ecx, WORD PTR [rcx+14]
	mov	WORD PTR [rax+14], cx

; 131  : 					dot_entry->file_size = 0;

	mov	rax, QWORD PTR dot_entry$5[rsp]
	mov	DWORD PTR [rax+28], 0

; 132  : 					dot_entry->first_cluster = dirent->first_cluster;

	mov	rax, QWORD PTR dot_entry$5[rsp]
	mov	rcx, QWORD PTR dirent$1[rsp]
	movzx	ecx, WORD PTR [rcx+26]
	mov	WORD PTR [rax+26], cx

; 133  : 					dot_entry->first_cluster_hi_bytes = dirent->first_cluster_hi_bytes;

	mov	rax, QWORD PTR dot_entry$5[rsp]
	mov	rcx, QWORD PTR dirent$1[rsp]
	movzx	ecx, WORD PTR [rcx+20]
	mov	WORD PTR [rax+20], cx

; 134  : 					dot_entry->last_wrt_date = dirent->last_wrt_date;

	mov	rax, QWORD PTR dot_entry$5[rsp]
	mov	rcx, QWORD PTR dirent$1[rsp]
	movzx	ecx, WORD PTR [rcx+24]
	mov	WORD PTR [rax+24], cx

; 135  : 					dot_entry->last_wrt_time = dirent->last_wrt_time;

	mov	rax, QWORD PTR dot_entry$5[rsp]
	mov	rcx, QWORD PTR dirent$1[rsp]
	movzx	ecx, WORD PTR [rcx+22]
	mov	WORD PTR [rax+22], cx

; 136  : 
; 137  : 					FatDir* dotdot = (FatDir*)(entrybuf + sizeof(FatDir));

	mov	rax, QWORD PTR entrybuf$8[rsp]
	add	rax, 256				; 00000100H
	mov	QWORD PTR dotdot$3[rsp], rax

; 138  : 					memset(dotdot, 0, sizeof(FatDir));

	mov	r8d, 32					; 00000020H
	xor	edx, edx
	mov	rcx, QWORD PTR dotdot$3[rsp]
	call	memset

; 139  : 					dotdot->filename[0] = '.';

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR dotdot$3[rsp]
	mov	BYTE PTR [rcx+rax], 46			; 0000002eH

; 140  : 					dotdot->filename[1] = '.';

	mov	eax, 1
	imul	rax, rax, 1
	mov	rcx, QWORD PTR dotdot$3[rsp]
	mov	BYTE PTR [rcx+rax], 46			; 0000002eH

; 141  : 					dotdot->attrib = FAT_ATTRIBUTE_DIRECTORY;

	mov	rax, QWORD PTR dotdot$3[rsp]
	mov	BYTE PTR [rax+11], 16

; 142  : 					dotdot->date_created = dirent->date_created;

	mov	rax, QWORD PTR dotdot$3[rsp]
	mov	rcx, QWORD PTR dirent$1[rsp]
	movzx	ecx, WORD PTR [rcx+16]
	mov	WORD PTR [rax+16], cx

; 143  : 					dotdot->time_created = dirent->time_created;

	mov	rax, QWORD PTR dotdot$3[rsp]
	mov	rcx, QWORD PTR dirent$1[rsp]
	movzx	ecx, WORD PTR [rcx+14]
	mov	WORD PTR [rax+14], cx

; 144  : 					dotdot->date_last_accessed = dirent->date_last_accessed;

	mov	rax, QWORD PTR dotdot$3[rsp]
	mov	rcx, QWORD PTR dirent$1[rsp]
	movzx	ecx, WORD PTR [rcx+18]
	mov	WORD PTR [rax+18], cx

; 145  : 					dotdot->file_size = 0;

	mov	rax, QWORD PTR dotdot$3[rsp]
	mov	DWORD PTR [rax+28], 0

; 146  : 
; 147  : 					if (parent_clust == _fs->__RootDirFirstCluster) {

	mov	rax, QWORD PTR _fs$[rsp]
	mov	eax, DWORD PTR [rax+34]
	cmp	DWORD PTR parent_clust$[rsp], eax
	jne	SHORT $LN3@FatCreateD

; 148  : 						dotdot->first_cluster = 0 & 0x0000FFFF;

	xor	eax, eax
	mov	rcx, QWORD PTR dotdot$3[rsp]
	mov	WORD PTR [rcx+26], ax

; 149  : 						dotdot->first_cluster_hi_bytes = (0 & 0x0FFF0000) >> 16;

	xor	eax, eax
	mov	rcx, QWORD PTR dotdot$3[rsp]
	mov	WORD PTR [rcx+20], ax

; 150  : 					}
; 151  : 					else {

	jmp	SHORT $LN2@FatCreateD
$LN3@FatCreateD:

; 152  : 						dotdot->first_cluster = parent_clust & 0x0000FFFF;

	mov	eax, DWORD PTR parent_clust$[rsp]
	and	eax, 65535				; 0000ffffH
	mov	rcx, QWORD PTR dotdot$3[rsp]
	mov	WORD PTR [rcx+26], ax

; 153  : 						dotdot->first_cluster_hi_bytes = (0 & 0x0FFF0000) >> 16;

	xor	eax, eax
	mov	rcx, QWORD PTR dotdot$3[rsp]
	mov	WORD PTR [rcx+20], ax
$LN2@FatCreateD:

; 154  : 					}
; 155  : 
; 156  : 					dotdot->last_wrt_date = dirent->last_wrt_date;

	mov	rax, QWORD PTR dotdot$3[rsp]
	mov	rcx, QWORD PTR dirent$1[rsp]
	movzx	ecx, WORD PTR [rcx+24]
	mov	WORD PTR [rax+24], cx

; 157  : 					dotdot->last_wrt_time = dirent->last_wrt_time;

	mov	rax, QWORD PTR dotdot$3[rsp]
	mov	rcx, QWORD PTR dirent$1[rsp]
	movzx	ecx, WORD PTR [rcx+22]
	mov	WORD PTR [rax+22], cx

; 158  : 
; 159  : 					AuVDiskWrite(_fs->vdisk, FatClusterToSector32(_fs, cluster), _fs->__SectorPerCluster, (uint64_t*)V2P((size_t)entrybuf));

	mov	rcx, QWORD PTR entrybuf$8[rsp]
	call	V2P
	mov	QWORD PTR tv281[rsp], rax
	mov	rcx, QWORD PTR _fs$[rsp]
	movzx	ecx, BYTE PTR [rcx+33]
	mov	DWORD PTR tv285[rsp], ecx
	mov	edx, DWORD PTR cluster$4[rsp]
	mov	rcx, QWORD PTR _fs$[rsp]
	call	?FatClusterToSector32@@YA_KPEAU_FatFS_@@_K@Z ; FatClusterToSector32
	mov	rcx, QWORD PTR tv281[rsp]
	mov	r9, rcx
	mov	ecx, DWORD PTR tv285[rsp]
	mov	r8d, ecx
	mov	rdx, rax
	mov	rax, QWORD PTR _fs$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	AuVDiskWrite

; 160  : 					AuVDiskWrite(_fs->vdisk, FatClusterToSector32(_fs, parent_clust) + j, 1, (uint64_t*)V2P((size_t)buff));

	mov	rcx, QWORD PTR buff$[rsp]
	call	V2P
	mov	QWORD PTR tv294[rsp], rax
	mov	ecx, DWORD PTR parent_clust$[rsp]
	mov	edx, ecx
	mov	rcx, QWORD PTR _fs$[rsp]
	call	?FatClusterToSector32@@YA_KPEAU_FatFS_@@_K@Z ; FatClusterToSector32
	movsxd	rcx, DWORD PTR j$6[rsp]
	add	rax, rcx
	mov	rcx, QWORD PTR tv294[rsp]
	mov	r9, rcx
	mov	r8d, 1
	mov	rdx, rax
	mov	rax, QWORD PTR _fs$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	AuVDiskWrite

; 161  : 
; 162  : 					AuPmmngrFree((void*)V2P((size_t)entrybuf));

	mov	rcx, QWORD PTR entrybuf$8[rsp]
	call	V2P
	mov	rcx, rax
	call	AuPmmngrFree

; 163  : 					AuPmmngrFree((void*)V2P((size_t)buff));

	mov	rcx, QWORD PTR buff$[rsp]
	call	V2P
	mov	rcx, rax
	call	AuPmmngrFree

; 164  : 
; 165  : 					strcpy(file->filename, extract);

	mov	rax, QWORD PTR file$[rsp]
	lea	rdx, QWORD PTR extract$[rsp]
	mov	rcx, rax
	call	strcpy

; 166  : 					file->size = 0;

	mov	rax, QWORD PTR file$[rsp]
	mov	DWORD PTR [rax+32], 0

; 167  : 					file->eof = 0;

	mov	rax, QWORD PTR file$[rsp]
	mov	BYTE PTR [rax+36], 0

; 168  : 					file->pos = 0;

	mov	rax, QWORD PTR file$[rsp]
	mov	DWORD PTR [rax+37], 0

; 169  : 					file->current = cluster;

	mov	eax, DWORD PTR cluster$4[rsp]
	mov	rcx, QWORD PTR file$[rsp]
	mov	QWORD PTR [rcx+53], rax

; 170  : 					file->device = fsys;

	mov	rax, QWORD PTR file$[rsp]
	mov	rcx, QWORD PTR fsys$[rsp]
	mov	QWORD PTR [rax+63], rcx

; 171  : 					file->first_block = file->current;

	mov	rax, QWORD PTR file$[rsp]
	mov	rcx, QWORD PTR file$[rsp]
	mov	rcx, QWORD PTR [rcx+53]
	mov	QWORD PTR [rax+45], rcx

; 172  : 					file->parent_block = parent_clust;

	mov	rax, QWORD PTR file$[rsp]
	mov	ecx, DWORD PTR parent_clust$[rsp]
	mov	DWORD PTR [rax+41], ecx

; 173  : 					file->flags |= FS_FLAG_DIRECTORY;

	mov	rax, QWORD PTR file$[rsp]
	movzx	eax, BYTE PTR [rax+61]
	or	eax, 2
	mov	rcx, QWORD PTR file$[rsp]
	mov	BYTE PTR [rcx+61], al

; 174  : 					kfree(parent);

	mov	rcx, QWORD PTR parent$[rsp]
	call	kfree

; 175  : 					return file;

	mov	rax, QWORD PTR file$[rsp]
	jmp	SHORT $LN26@FatCreateD
$LN5@FatCreateD:

; 176  : 				}
; 177  : 				dirent++;

	mov	rax, QWORD PTR dirent$1[rsp]
	add	rax, 32					; 00000020H
	mov	QWORD PTR dirent$1[rsp], rax

; 178  : 			}

	jmp	$LN7@FatCreateD
$LN6@FatCreateD:

; 179  : 		}

	jmp	$LN10@FatCreateD
$LN9@FatCreateD:

; 180  : 
; 181  : 		parent_clust = FatReadFAT(fsys, parent_clust);

	mov	edx, DWORD PTR parent_clust$[rsp]
	mov	rcx, QWORD PTR fsys$[rsp]
	call	?FatReadFAT@@YAIPEAU__VFS_NODE__@@I@Z	; FatReadFAT
	mov	DWORD PTR parent_clust$[rsp], eax

; 182  : 		if (parent_clust == (FAT_EOC_MARK & 0x0FFFFFFF))

	cmp	DWORD PTR parent_clust$[rsp], 268435448	; 0ffffff8H
	jne	SHORT $LN1@FatCreateD

; 183  : 			break;

	jmp	SHORT $LN12@FatCreateD
$LN1@FatCreateD:

; 184  : 	}

	jmp	$LN13@FatCreateD
$LN12@FatCreateD:

; 185  : 
; 186  : 	AuPmmngrFree((void*)V2P((size_t)buff));

	mov	rcx, QWORD PTR buff$[rsp]
	call	V2P
	mov	rcx, rax
	call	AuPmmngrFree

; 187  : 	kfree(parent);

	mov	rcx, QWORD PTR parent$[rsp]
	call	kfree

; 188  : 	kfree(file);

	mov	rcx, QWORD PTR file$[rsp]
	call	kfree

; 189  : 	return NULL;

	xor	eax, eax
$LN26@FatCreateD:

; 190  : }

	add	rsp, 216				; 000000d8H
	ret	0
?FatCreateDir@@YAPEAU__VFS_NODE__@@PEAU1@PEAD@Z ENDP	; FatCreateDir
_TEXT	ENDS
END
