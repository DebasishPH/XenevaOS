; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30154.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

msvcjmc	SEGMENT
__F42D56B2_x86_64_idt@cpp DB 01H
msvcjmc	ENDS
PUBLIC	?x86_64_idt_init@@YAXXZ				; x86_64_idt_init
PUBLIC	setvect
PUBLIC	?x86_64_idt_init_ap@@YAXXZ			; x86_64_idt_init_ap
PUBLIC	interrupt_dispatcher
PUBLIC	?default_irq@@YAX_KPEAX@Z			; default_irq
PUBLIC	?x86_64_idt_reg_default_handlers@@YAXXZ		; x86_64_idt_reg_default_handlers
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_0DN@FBCOFCGJ@?$CK?$CK?$CK?5?$FLx64_idt?$FN?5x64_default_handl@ ; `string'
EXTRN	?set_gdt_entry@@YAXAEAU_gdt@@_K1EE@Z:PROC	; set_gdt_entry
EXTRN	?AuPerCPUSetKernelTSS@@YAXPEAU_tss@@@Z:PROC	; AuPerCPUSetKernelTSS
EXTRN	x64_cli:PROC
EXTRN	x64_sgdt:PROC
EXTRN	x64_lidt:PROC
EXTRN	x64_ltr:PROC
EXTRN	kmalloc:PROC
EXTRN	AuTextOut:PROC
EXTRN	__CheckForDebuggerJustMyCode:PROC
EXTRN	default_irq_handlers:BYTE
_BSS	SEGMENT
?interrupts_handlers@@3PAP6AX_KPEAX@ZA DQ 0100H DUP (?)	; interrupts_handlers
?the_idt@@3PAU_idt@@A DB 01000H DUP (?)			; the_idt
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?x86_64_idt_init@@YAXXZ DD imagerel $LN6
	DD	imagerel $LN6+407
	DD	imagerel $unwind$?x86_64_idt_init@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$setvect DD imagerel $LN3
	DD	imagerel $LN3+57
	DD	imagerel $unwind$setvect
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?x86_64_idt_init_ap@@YAXXZ DD imagerel $LN6
	DD	imagerel $LN6+411
	DD	imagerel $unwind$?x86_64_idt_init_ap@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?register_irq@@YAXPEAU_idt@@PEAX@Z DD imagerel ?register_irq@@YAXPEAU_idt@@PEAX@Z
	DD	imagerel ?register_irq@@YAXPEAU_idt@@PEAX@Z+108
	DD	imagerel $unwind$?register_irq@@YAXPEAU_idt@@PEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$interrupt_dispatcher DD imagerel $LN3
	DD	imagerel $LN3+61
	DD	imagerel $unwind$interrupt_dispatcher
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?default_irq@@YAX_KPEAX@Z DD imagerel $LN6
	DD	imagerel $LN6+57
	DD	imagerel $unwind$?default_irq@@YAX_KPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?x86_64_idt_reg_default_handlers@@YAXXZ DD imagerel $LN6
	DD	imagerel $LN6+76
	DD	imagerel $unwind$?x86_64_idt_reg_default_handlers@@YAXXZ
pdata	ENDS
;	COMDAT ??_C@_0DN@FBCOFCGJ@?$CK?$CK?$CK?5?$FLx64_idt?$FN?5x64_default_handl@
CONST	SEGMENT
??_C@_0DN@FBCOFCGJ@?$CK?$CK?$CK?5?$FLx64_idt?$FN?5x64_default_handl@ DB '*'
	DB	'** [x64_idt] x64_default_handler: Unhandled Exception *** ', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?x86_64_idt_reg_default_handlers@@YAXXZ DD 025030b01H
	DD	0d206230bH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?default_irq@@YAX_KPEAX@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$interrupt_dispatcher DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?register_irq@@YAXPEAU_idt@@PEAX@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?x86_64_idt_init_ap@@YAXXZ DD 035040e01H
	DD	0109330eH
	DD	050020016H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$setvect DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?x86_64_idt_init@@YAXXZ DD 035040e01H
	DD	0109330eH
	DD	050020016H
xdata	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\x86_64_idt.cpp
;	COMDAT ?x86_64_idt_reg_default_handlers@@YAXXZ
_TEXT	SEGMENT
i$1 = 0
?x86_64_idt_reg_default_handlers@@YAXXZ PROC		; x86_64_idt_reg_default_handlers, COMDAT

; 77   : void x86_64_idt_reg_default_handlers() {

$LN6:
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__F42D56B2_x86_64_idt@cpp
	call	__CheckForDebuggerJustMyCode

; 78   : 	for (int i = 0; i < 256; i++)

	mov	DWORD PTR i$1[rbp], 0
	jmp	SHORT $LN4@x86_64_idt
$LN2@x86_64_idt:
	mov	eax, DWORD PTR i$1[rbp]
	inc	eax
	mov	DWORD PTR i$1[rbp], eax
$LN4@x86_64_idt:
	cmp	DWORD PTR i$1[rbp], 256			; 00000100H
	jge	SHORT $LN3@x86_64_idt

; 79   : 		setvect(i, default_irq);

	movsxd	rax, DWORD PTR i$1[rbp]
	lea	rdx, OFFSET FLAT:?default_irq@@YAX_KPEAX@Z ; default_irq
	mov	rcx, rax
	call	setvect
	jmp	SHORT $LN2@x86_64_idt
$LN3@x86_64_idt:

; 80   : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
?x86_64_idt_reg_default_handlers@@YAXXZ ENDP		; x86_64_idt_reg_default_handlers
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\x86_64_idt.cpp
;	COMDAT ?default_irq@@YAX_KPEAX@Z
_TEXT	SEGMENT
vect$ = 80
param$ = 88
?default_irq@@YAX_KPEAX@Z PROC				; default_irq, COMDAT

; 66   : void default_irq(size_t vect, void* param){

$LN6:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__F42D56B2_x86_64_idt@cpp
	call	__CheckForDebuggerJustMyCode

; 67   : 	x64_cli();

	call	x64_cli

; 68   : 	AuTextOut("*** [x64_idt] x64_default_handler: Unhandled Exception *** \n");

	lea	rcx, OFFSET FLAT:??_C@_0DN@FBCOFCGJ@?$CK?$CK?$CK?5?$FLx64_idt?$FN?5x64_default_handl@
	call	AuTextOut
$LN2@default_ir:

; 69   : 	for (;;);

	jmp	SHORT $LN2@default_ir

; 70   : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
?default_irq@@YAX_KPEAX@Z ENDP				; default_irq
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\x86_64_idt.cpp
;	COMDAT interrupt_dispatcher
_TEXT	SEGMENT
num$ = 80
frame$ = 88
interrupt_dispatcher PROC				; COMDAT

; 59   : {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__F42D56B2_x86_64_idt@cpp
	call	__CheckForDebuggerJustMyCode

; 60   : 	interrupts_handlers[num](num, frame);

	lea	rax, OFFSET FLAT:?interrupts_handlers@@3PAP6AX_KPEAX@ZA
	mov	rdx, QWORD PTR frame$[rbp]
	mov	rcx, QWORD PTR num$[rbp]
	mov	r8, QWORD PTR num$[rbp]
	call	QWORD PTR [rax+r8*8]

; 61   : 	return;
; 62   : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
interrupt_dispatcher ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\x86_64_idt.cpp
;	COMDAT ?register_irq@@YAXPEAU_idt@@PEAX@Z
_TEXT	SEGMENT
faddr$ = 0
entry$ = 96
function$ = 104
?register_irq@@YAXPEAU_idt@@PEAX@Z PROC			; register_irq, COMDAT

; 46   : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__F42D56B2_x86_64_idt@cpp
	call	__CheckForDebuggerJustMyCode

; 47   : 	size_t faddr = (size_t)function;

	mov	rax, QWORD PTR function$[rbp]
	mov	QWORD PTR faddr$[rbp], rax

; 48   : 	entry->offset_1 = faddr & UINT16_MAX;

	mov	rax, QWORD PTR faddr$[rbp]
	and	rax, 65535				; 0000ffffH
	mov	rcx, QWORD PTR entry$[rbp]
	mov	WORD PTR [rcx], ax

; 49   : 	entry->offset_2 = (faddr >> 16) & UINT16_MAX;

	mov	rax, QWORD PTR faddr$[rbp]
	shr	rax, 16
	and	rax, 65535				; 0000ffffH
	mov	rcx, QWORD PTR entry$[rbp]
	mov	WORD PTR [rcx+6], ax

; 50   : 	entry->offset_3 = (faddr >> 32) & UINT32_MAX;

	mov	rax, QWORD PTR faddr$[rbp]
	shr	rax, 32					; 00000020H
	mov	ecx, -1					; ffffffffH
	and	rax, rcx
	mov	rcx, QWORD PTR entry$[rbp]
	mov	DWORD PTR [rcx+8], eax

; 51   : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
?register_irq@@YAXPEAU_idt@@PEAX@Z ENDP			; register_irq
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\x86_64_idt.cpp
;	COMDAT ?x86_64_idt_init_ap@@YAXXZ
_TEXT	SEGMENT
tss$ = 0
tss_addr$ = 8
curr_gdt$ = 16
thegdt$ = 32
idtr$ = 40
n$1 = 48
tv142 = 120
?x86_64_idt_init_ap@@YAXXZ PROC				; x86_64_idt_init_ap, COMDAT

; 121  : void  x86_64_idt_init_ap() {

$LN6:
	push	rbp
	sub	rsp, 176				; 000000b0H
	lea	rbp, QWORD PTR [rsp+48]
	lea	rcx, OFFSET FLAT:__F42D56B2_x86_64_idt@cpp
	call	__CheckForDebuggerJustMyCode

; 122  : 	TSS* tss = (TSS*)kmalloc(sizeof(TSS));

	mov	ecx, 104				; 00000068H
	call	kmalloc
	mov	QWORD PTR tss$[rbp], rax

; 123  : 	tss->iomapbase = sizeof(TSS);

	mov	eax, 104				; 00000068H
	mov	rcx, QWORD PTR tss$[rbp]
	mov	WORD PTR [rcx+102], ax

; 124  : 	size_t tss_addr = (size_t)tss;

	mov	rax, QWORD PTR tss$[rbp]
	mov	QWORD PTR tss_addr$[rbp], rax

; 125  : 
; 126  : 	gdtr curr_gdt;
; 127  : 	x64_sgdt(&curr_gdt);

	lea	rcx, QWORD PTR curr_gdt$[rbp]
	call	x64_sgdt

; 128  : 	gdt_entry* thegdt = curr_gdt.gdtaddr; //curr_gdt.gdtaddr;

	mov	rax, QWORD PTR curr_gdt$[rbp+2]
	mov	QWORD PTR thegdt$[rbp], rax

; 129  : 	set_gdt_entry(thegdt[GDT_ENTRY_TSS], (tss_addr & UINT32_MAX), sizeof(TSS), GDT_ACCESS_PRESENT | 0x9, 0);

	mov	eax, -1					; ffffffffH
	mov	rcx, QWORD PTR tss_addr$[rbp]
	and	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 7
	mov	rdx, QWORD PTR thegdt$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	BYTE PTR [rsp+32], 0
	mov	r9b, 137				; 00000089H
	mov	r8d, 104				; 00000068H
	mov	rdx, rax
	call	?set_gdt_entry@@YAXAEAU_gdt@@_K1EE@Z	; set_gdt_entry

; 130  : 	*(uint64_t*)&thegdt[GDT_ENTRY_TSS + 1] = (tss_addr >> 32);

	mov	rax, QWORD PTR tss_addr$[rbp]
	shr	rax, 32					; 00000020H
	mov	ecx, 8
	imul	rcx, rcx, 8
	mov	rdx, QWORD PTR thegdt$[rbp]
	mov	QWORD PTR [rdx+rcx], rax

; 131  : 	x64_ltr(SEGVAL(GDT_ENTRY_TSS, 3));

	mov	cx, 59					; 0000003bH
	call	x64_ltr

; 132  : 
; 133  : 	AuPerCPUSetKernelTSS(tss);

	mov	rcx, QWORD PTR tss$[rbp]
	call	?AuPerCPUSetKernelTSS@@YAXPEAU_tss@@@Z	; AuPerCPUSetKernelTSS

; 134  : 
; 135  : 	IDTR *idtr = (IDTR*)kmalloc(sizeof(IDTR));  //0xFFFFD80000000000;

	mov	ecx, 10
	call	kmalloc
	mov	QWORD PTR idtr$[rbp], rax

; 136  : 	idtr->idtaddr = the_idt;

	mov	rax, QWORD PTR idtr$[rbp]
	lea	rcx, OFFSET FLAT:?the_idt@@3PAU_idt@@A
	mov	QWORD PTR [rax+2], rcx

; 137  : 	idtr->length = 256 * sizeof(IDT)-1;

	mov	eax, 4095				; 00000fffH
	mov	rcx, QWORD PTR idtr$[rbp]
	mov	WORD PTR [rcx], ax

; 138  : 	x64_lidt(idtr);

	mov	rcx, QWORD PTR idtr$[rbp]
	call	x64_lidt

; 139  : 	for (int n = 0; n < 256; n++)

	mov	DWORD PTR n$1[rbp], 0
	jmp	SHORT $LN4@x86_64_idt
$LN2@x86_64_idt:
	mov	eax, DWORD PTR n$1[rbp]
	inc	eax
	mov	DWORD PTR n$1[rbp], eax
$LN4@x86_64_idt:
	cmp	DWORD PTR n$1[rbp], 256			; 00000100H
	jge	$LN3@x86_64_idt

; 140  : 	{
; 141  : 		the_idt[n].ist = 0;

	movsxd	rax, DWORD PTR n$1[rbp]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:?the_idt@@3PAU_idt@@A
	mov	BYTE PTR [rcx+rax+4], 0

; 142  : 		the_idt[n].selector = SEGVAL(GDT_ENTRY_KERNEL_CODE, 0);

	movsxd	rax, DWORD PTR n$1[rbp]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:?the_idt@@3PAU_idt@@A
	mov	edx, 8
	mov	WORD PTR [rcx+rax+2], dx

; 143  : 		the_idt[n].zero = 0;

	movsxd	rax, DWORD PTR n$1[rbp]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:?the_idt@@3PAU_idt@@A
	mov	DWORD PTR [rcx+rax+12], 0

; 144  : 		the_idt[n].type_attr = GDT_ACCESS_PRESENT | 0xE;

	movsxd	rax, DWORD PTR n$1[rbp]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:?the_idt@@3PAU_idt@@A
	mov	BYTE PTR [rcx+rax+5], 142		; 0000008eH

; 145  : 		register_irq(&the_idt[n], default_irq_handlers[n]);

	movsxd	rax, DWORD PTR n$1[rbp]
	lea	rcx, OFFSET FLAT:default_irq_handlers
	movsxd	rdx, DWORD PTR n$1[rbp]
	imul	rdx, rdx, 16
	lea	r8, OFFSET FLAT:?the_idt@@3PAU_idt@@A
	add	r8, rdx
	mov	rdx, r8
	mov	QWORD PTR tv142[rbp], rdx
	mov	rdx, QWORD PTR [rcx+rax*8]
	mov	rax, QWORD PTR tv142[rbp]
	mov	rcx, rax
	call	?register_irq@@YAXPEAU_idt@@PEAX@Z	; register_irq

; 146  : 	}

	jmp	$LN2@x86_64_idt
$LN3@x86_64_idt:

; 147  : }

	lea	rsp, QWORD PTR [rbp+128]
	pop	rbp
	ret	0
?x86_64_idt_init_ap@@YAXXZ ENDP				; x86_64_idt_init_ap
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\x86_64_idt.cpp
;	COMDAT setvect
_TEXT	SEGMENT
vector$ = 80
function$ = 88
setvect	PROC						; COMDAT

; 54   : {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__F42D56B2_x86_64_idt@cpp
	call	__CheckForDebuggerJustMyCode

; 55   : 	interrupts_handlers[vector] = function;

	lea	rax, OFFSET FLAT:?interrupts_handlers@@3PAP6AX_KPEAX@ZA
	mov	rcx, QWORD PTR vector$[rbp]
	mov	rdx, QWORD PTR function$[rbp]
	mov	QWORD PTR [rax+rcx*8], rdx

; 56   : };

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
setvect	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\x86_64_idt.cpp
;	COMDAT ?x86_64_idt_init@@YAXXZ
_TEXT	SEGMENT
tss$ = 0
tss_addr$ = 8
curr_gdt$ = 16
thegdt$ = 32
idtr$ = 40
n$1 = 48
tv141 = 120
?x86_64_idt_init@@YAXXZ PROC				; x86_64_idt_init, COMDAT

; 86   : void  x86_64_idt_init() {

$LN6:
	push	rbp
	sub	rsp, 176				; 000000b0H
	lea	rbp, QWORD PTR [rsp+48]
	lea	rcx, OFFSET FLAT:__F42D56B2_x86_64_idt@cpp
	call	__CheckForDebuggerJustMyCode

; 87   : 
; 88   : 	TSS *tss = (TSS*)kmalloc(sizeof(TSS));

	mov	ecx, 104				; 00000068H
	call	kmalloc
	mov	QWORD PTR tss$[rbp], rax

; 89   : 	tss->iomapbase = sizeof(TSS);

	mov	eax, 104				; 00000068H
	mov	rcx, QWORD PTR tss$[rbp]
	mov	WORD PTR [rcx+102], ax

; 90   : 	size_t tss_addr = (size_t)tss;

	mov	rax, QWORD PTR tss$[rbp]
	mov	QWORD PTR tss_addr$[rbp], rax

; 91   : 
; 92   : 	gdtr curr_gdt;
; 93   : 	x64_sgdt(&curr_gdt);

	lea	rcx, QWORD PTR curr_gdt$[rbp]
	call	x64_sgdt

; 94   : 	gdt_entry* thegdt = curr_gdt.gdtaddr;

	mov	rax, QWORD PTR curr_gdt$[rbp+2]
	mov	QWORD PTR thegdt$[rbp], rax

; 95   : 	set_gdt_entry(thegdt[GDT_ENTRY_TSS], (tss_addr & UINT32_MAX), sizeof(TSS), GDT_ACCESS_PRESENT | 0x9, 0);

	mov	eax, -1					; ffffffffH
	mov	rcx, QWORD PTR tss_addr$[rbp]
	and	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 7
	mov	rdx, QWORD PTR thegdt$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	BYTE PTR [rsp+32], 0
	mov	r9b, 137				; 00000089H
	mov	r8d, 104				; 00000068H
	mov	rdx, rax
	call	?set_gdt_entry@@YAXAEAU_gdt@@_K1EE@Z	; set_gdt_entry

; 96   : 	*(uint64_t*)&thegdt[GDT_ENTRY_TSS + 1] = (tss_addr >> 32);

	mov	rax, QWORD PTR tss_addr$[rbp]
	shr	rax, 32					; 00000020H
	mov	ecx, 8
	imul	rcx, rcx, 8
	mov	rdx, QWORD PTR thegdt$[rbp]
	mov	QWORD PTR [rdx+rcx], rax

; 97   : 	x64_ltr(SEGVAL(GDT_ENTRY_TSS, 3));

	mov	cx, 59					; 0000003bH
	call	x64_ltr

; 98   : 
; 99   : 	//AuPCPUSetKernelTSS(tss);
; 100  : 	IDTR *idtr = (IDTR*)kmalloc(sizeof(IDTR));

	mov	ecx, 10
	call	kmalloc
	mov	QWORD PTR idtr$[rbp], rax

; 101  : 	idtr->idtaddr = the_idt;

	mov	rax, QWORD PTR idtr$[rbp]
	lea	rcx, OFFSET FLAT:?the_idt@@3PAU_idt@@A
	mov	QWORD PTR [rax+2], rcx

; 102  : 	idtr->length = 256 * sizeof(IDT)-1;

	mov	eax, 4095				; 00000fffH
	mov	rcx, QWORD PTR idtr$[rbp]
	mov	WORD PTR [rcx], ax

; 103  : 	x64_lidt(idtr);

	mov	rcx, QWORD PTR idtr$[rbp]
	call	x64_lidt

; 104  : 
; 105  : 	for (int n = 0; n < 256; n++)

	mov	DWORD PTR n$1[rbp], 0
	jmp	SHORT $LN4@x86_64_idt
$LN2@x86_64_idt:
	mov	eax, DWORD PTR n$1[rbp]
	inc	eax
	mov	DWORD PTR n$1[rbp], eax
$LN4@x86_64_idt:
	cmp	DWORD PTR n$1[rbp], 256			; 00000100H
	jge	$LN3@x86_64_idt

; 106  : 	{
; 107  : 		the_idt[n].ist = 0;

	movsxd	rax, DWORD PTR n$1[rbp]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:?the_idt@@3PAU_idt@@A
	mov	BYTE PTR [rcx+rax+4], 0

; 108  : 		the_idt[n].selector = SEGVAL(GDT_ENTRY_KERNEL_CODE, 0);

	movsxd	rax, DWORD PTR n$1[rbp]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:?the_idt@@3PAU_idt@@A
	mov	edx, 8
	mov	WORD PTR [rcx+rax+2], dx

; 109  : 		the_idt[n].zero = 0;

	movsxd	rax, DWORD PTR n$1[rbp]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:?the_idt@@3PAU_idt@@A
	mov	DWORD PTR [rcx+rax+12], 0

; 110  : 		the_idt[n].type_attr = GDT_ACCESS_PRESENT | 0xE;

	movsxd	rax, DWORD PTR n$1[rbp]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:?the_idt@@3PAU_idt@@A
	mov	BYTE PTR [rcx+rax+5], 142		; 0000008eH

; 111  : 		register_irq(&the_idt[n], default_irq_handlers[n]);

	movsxd	rax, DWORD PTR n$1[rbp]
	lea	rcx, OFFSET FLAT:default_irq_handlers
	movsxd	rdx, DWORD PTR n$1[rbp]
	imul	rdx, rdx, 16
	lea	r8, OFFSET FLAT:?the_idt@@3PAU_idt@@A
	add	r8, rdx
	mov	rdx, r8
	mov	QWORD PTR tv141[rbp], rdx
	mov	rdx, QWORD PTR [rcx+rax*8]
	mov	rax, QWORD PTR tv141[rbp]
	mov	rcx, rax
	call	?register_irq@@YAXPEAU_idt@@PEAX@Z	; register_irq

; 112  : 	}

	jmp	$LN2@x86_64_idt
$LN3@x86_64_idt:

; 113  : 
; 114  : 	x86_64_idt_reg_default_handlers();

	call	?x86_64_idt_reg_default_handlers@@YAXXZ	; x86_64_idt_reg_default_handlers

; 115  : }

	lea	rsp, QWORD PTR [rbp+128]
	pop	rbp
	ret	0
?x86_64_idt_init@@YAXXZ ENDP				; x86_64_idt_init
_TEXT	ENDS
END
