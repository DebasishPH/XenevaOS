; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.21005.1 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG3408	DB	'*** [x64_idt] x64_default_handler: Unhandled Exception *'
	DB	'** ', 0aH, 00H
CONST	ENDS
PUBLIC	?x86_64_idt_init@@YAXXZ				; x86_64_idt_init
PUBLIC	setvect
PUBLIC	?x86_64_idt_init_ap@@YAXXZ			; x86_64_idt_init_ap
PUBLIC	interrupt_dispatcher
PUBLIC	?default_irq@@YAX_KPEAX@Z			; default_irq
PUBLIC	?x86_64_idt_reg_default_handlers@@YAXXZ		; x86_64_idt_reg_default_handlers
EXTRN	?set_gdt_entry@@YAXAEAU_gdt@@_K1EE@Z:PROC	; set_gdt_entry
EXTRN	?AuPerCPUSetKernelTSS@@YAXPEAU_tss@@@Z:PROC	; AuPerCPUSetKernelTSS
EXTRN	x64_cli:PROC
EXTRN	x64_sgdt:PROC
EXTRN	x64_lidt:PROC
EXTRN	x64_ltr:PROC
EXTRN	kmalloc:PROC
EXTRN	AuTextOut:PROC
EXTRN	default_irq_handlers:BYTE
_BSS	SEGMENT
interrupts_handlers DQ 0100H DUP (?)
the_idt	DB	01000H DUP (?)
_BSS	ENDS
pdata	SEGMENT
$pdata$?x86_64_idt_init@@YAXXZ DD imagerel $LN6
	DD	imagerel $LN6+408
	DD	imagerel $unwind$?x86_64_idt_init@@YAXXZ
$pdata$?x86_64_idt_init_ap@@YAXXZ DD imagerel $LN6
	DD	imagerel $LN6+413
	DD	imagerel $unwind$?x86_64_idt_init_ap@@YAXXZ
$pdata$?register_irq@@YAXPEAU_idt@@PEAX@Z DD imagerel ?register_irq@@YAXPEAU_idt@@PEAX@Z
	DD	imagerel ?register_irq@@YAXPEAU_idt@@PEAX@Z+93
	DD	imagerel $unwind$?register_irq@@YAXPEAU_idt@@PEAX@Z
$pdata$interrupt_dispatcher DD imagerel $LN3
	DD	imagerel $LN3+45
	DD	imagerel $unwind$interrupt_dispatcher
$pdata$?default_irq@@YAX_KPEAX@Z DD imagerel $LN5
	DD	imagerel $LN5+38
	DD	imagerel $unwind$?default_irq@@YAX_KPEAX@Z
$pdata$?x86_64_idt_reg_default_handlers@@YAXXZ DD imagerel $LN6
	DD	imagerel $LN6+61
	DD	imagerel $unwind$?x86_64_idt_reg_default_handlers@@YAXXZ
pdata	ENDS
xdata	SEGMENT
$unwind$?x86_64_idt_init@@YAXXZ DD 010401H
	DD	0e204H
$unwind$?x86_64_idt_init_ap@@YAXXZ DD 010401H
	DD	0e204H
$unwind$?register_irq@@YAXPEAU_idt@@PEAX@Z DD 010e01H
	DD	0220eH
$unwind$interrupt_dispatcher DD 010e01H
	DD	0420eH
$unwind$?default_irq@@YAX_KPEAX@Z DD 010e01H
	DD	0420eH
$unwind$?x86_64_idt_reg_default_handlers@@YAXXZ DD 010401H
	DD	06204H
xdata	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\hal\x86_64_idt.cpp
_TEXT	SEGMENT
i$1 = 32
?x86_64_idt_reg_default_handlers@@YAXXZ PROC		; x86_64_idt_reg_default_handlers

; 77   : void x86_64_idt_reg_default_handlers() {

$LN6:
	sub	rsp, 56					; 00000038H

; 78   : 	for (int i = 0; i < 256; i++)

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN3@x86_64_idt
$LN2@x86_64_idt:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN3@x86_64_idt:
	cmp	DWORD PTR i$1[rsp], 256			; 00000100H
	jge	SHORT $LN1@x86_64_idt

; 79   : 		setvect(i, default_irq);

	movsxd	rax, DWORD PTR i$1[rsp]
	lea	rdx, OFFSET FLAT:?default_irq@@YAX_KPEAX@Z ; default_irq
	mov	rcx, rax
	call	setvect
	jmp	SHORT $LN2@x86_64_idt
$LN1@x86_64_idt:

; 80   : }

	add	rsp, 56					; 00000038H
	ret	0
?x86_64_idt_reg_default_handlers@@YAXXZ ENDP		; x86_64_idt_reg_default_handlers
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\hal\x86_64_idt.cpp
_TEXT	SEGMENT
vect$ = 48
param$ = 56
?default_irq@@YAX_KPEAX@Z PROC				; default_irq

; 66   : void default_irq(size_t vect, void* param){

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 67   : 	x64_cli();

	call	x64_cli

; 68   : 	AuTextOut("*** [x64_idt] x64_default_handler: Unhandled Exception *** \n");

	lea	rcx, OFFSET FLAT:$SG3408
	call	AuTextOut
$LN2@default_ir:

; 69   : 	for (;;);

	jmp	SHORT $LN2@default_ir

; 70   : }

	add	rsp, 40					; 00000028H
	ret	0
?default_irq@@YAX_KPEAX@Z ENDP				; default_irq
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\hal\x86_64_idt.cpp
_TEXT	SEGMENT
num$ = 48
frame$ = 56
interrupt_dispatcher PROC

; 59   : {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 60   : 	interrupts_handlers[num](num, frame);

	lea	rax, OFFSET FLAT:interrupts_handlers
	mov	rdx, QWORD PTR frame$[rsp]
	mov	rcx, QWORD PTR num$[rsp]
	mov	r8, QWORD PTR num$[rsp]
	call	QWORD PTR [rax+r8*8]

; 61   : 	return;
; 62   : }

	add	rsp, 40					; 00000028H
	ret	0
interrupt_dispatcher ENDP
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\hal\x86_64_idt.cpp
_TEXT	SEGMENT
faddr$ = 0
entry$ = 32
function$ = 40
?register_irq@@YAXPEAU_idt@@PEAX@Z PROC			; register_irq

; 46   : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 47   : 	size_t faddr = (size_t)function;

	mov	rax, QWORD PTR function$[rsp]
	mov	QWORD PTR faddr$[rsp], rax

; 48   : 	entry->offset_1 = faddr & UINT16_MAX;

	mov	rax, QWORD PTR faddr$[rsp]
	and	rax, 65535				; 0000ffffH
	mov	rcx, QWORD PTR entry$[rsp]
	mov	WORD PTR [rcx], ax

; 49   : 	entry->offset_2 = (faddr >> 16) & UINT16_MAX;

	mov	rax, QWORD PTR faddr$[rsp]
	shr	rax, 16
	and	rax, 65535				; 0000ffffH
	mov	rcx, QWORD PTR entry$[rsp]
	mov	WORD PTR [rcx+6], ax

; 50   : 	entry->offset_3 = (faddr >> 32) & UINT32_MAX;

	mov	rax, QWORD PTR faddr$[rsp]
	shr	rax, 32					; 00000020H
	mov	ecx, -1					; ffffffffH
	and	rax, rcx
	mov	rcx, QWORD PTR entry$[rsp]
	mov	DWORD PTR [rcx+8], eax

; 51   : }

	add	rsp, 24
	ret	0
?register_irq@@YAXPEAU_idt@@PEAX@Z ENDP			; register_irq
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\hal\x86_64_idt.cpp
_TEXT	SEGMENT
n$1 = 48
tss$ = 56
idtr$ = 64
tss_addr$ = 72
thegdt$ = 80
tv142 = 88
curr_gdt$ = 96
?x86_64_idt_init_ap@@YAXXZ PROC				; x86_64_idt_init_ap

; 121  : void  x86_64_idt_init_ap() {

$LN6:
	sub	rsp, 120				; 00000078H

; 122  : 	TSS* tss = (TSS*)kmalloc(sizeof(TSS));

	mov	ecx, 104				; 00000068H
	call	kmalloc
	mov	QWORD PTR tss$[rsp], rax

; 123  : 	tss->iomapbase = sizeof(TSS);

	mov	eax, 104				; 00000068H
	mov	rcx, QWORD PTR tss$[rsp]
	mov	WORD PTR [rcx+102], ax

; 124  : 	size_t tss_addr = (size_t)tss;

	mov	rax, QWORD PTR tss$[rsp]
	mov	QWORD PTR tss_addr$[rsp], rax

; 125  : 
; 126  : 	gdtr curr_gdt;
; 127  : 	x64_sgdt(&curr_gdt);

	lea	rcx, QWORD PTR curr_gdt$[rsp]
	call	x64_sgdt

; 128  : 	gdt_entry* thegdt = curr_gdt.gdtaddr; //curr_gdt.gdtaddr;

	mov	rax, QWORD PTR curr_gdt$[rsp+2]
	mov	QWORD PTR thegdt$[rsp], rax

; 129  : 	set_gdt_entry(thegdt[GDT_ENTRY_TSS], (tss_addr & UINT32_MAX), sizeof(TSS), GDT_ACCESS_PRESENT | 0x9, 0);

	mov	eax, -1					; ffffffffH
	mov	rcx, QWORD PTR tss_addr$[rsp]
	and	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 7
	mov	rdx, QWORD PTR thegdt$[rsp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	BYTE PTR [rsp+32], 0
	mov	r9b, 137				; 00000089H
	mov	r8d, 104				; 00000068H
	mov	rdx, rax
	call	?set_gdt_entry@@YAXAEAU_gdt@@_K1EE@Z	; set_gdt_entry

; 130  : 	*(uint64_t*)&thegdt[GDT_ENTRY_TSS + 1] = (tss_addr >> 32);

	mov	rax, QWORD PTR tss_addr$[rsp]
	shr	rax, 32					; 00000020H
	mov	ecx, 8
	imul	rcx, rcx, 8
	mov	rdx, QWORD PTR thegdt$[rsp]
	mov	QWORD PTR [rdx+rcx], rax

; 131  : 	x64_ltr(SEGVAL(GDT_ENTRY_TSS, 3));

	mov	cx, 59					; 0000003bH
	call	x64_ltr

; 132  : 
; 133  : 	AuPerCPUSetKernelTSS(tss);

	mov	rcx, QWORD PTR tss$[rsp]
	call	?AuPerCPUSetKernelTSS@@YAXPEAU_tss@@@Z	; AuPerCPUSetKernelTSS

; 134  : 
; 135  : 	IDTR *idtr = (IDTR*)kmalloc(sizeof(IDTR));  //0xFFFFD80000000000;

	mov	ecx, 10
	call	kmalloc
	mov	QWORD PTR idtr$[rsp], rax

; 136  : 	idtr->idtaddr = the_idt;

	mov	rax, QWORD PTR idtr$[rsp]
	lea	rcx, OFFSET FLAT:the_idt
	mov	QWORD PTR [rax+2], rcx

; 137  : 	idtr->length = 256 * sizeof(IDT)-1;

	mov	eax, 4095				; 00000fffH
	mov	rcx, QWORD PTR idtr$[rsp]
	mov	WORD PTR [rcx], ax

; 138  : 	x64_lidt(idtr);

	mov	rcx, QWORD PTR idtr$[rsp]
	call	x64_lidt

; 139  : 	for (int n = 0; n < 256; n++)

	mov	DWORD PTR n$1[rsp], 0
	jmp	SHORT $LN3@x86_64_idt
$LN2@x86_64_idt:
	mov	eax, DWORD PTR n$1[rsp]
	inc	eax
	mov	DWORD PTR n$1[rsp], eax
$LN3@x86_64_idt:
	cmp	DWORD PTR n$1[rsp], 256			; 00000100H
	jge	$LN1@x86_64_idt

; 140  : 	{
; 141  : 		the_idt[n].ist = 0;

	movsxd	rax, DWORD PTR n$1[rsp]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:the_idt
	mov	BYTE PTR [rcx+rax+4], 0

; 142  : 		the_idt[n].selector = SEGVAL(GDT_ENTRY_KERNEL_CODE, 0);

	movsxd	rax, DWORD PTR n$1[rsp]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:the_idt
	mov	edx, 8
	mov	WORD PTR [rcx+rax+2], dx

; 143  : 		the_idt[n].zero = 0;

	movsxd	rax, DWORD PTR n$1[rsp]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:the_idt
	mov	DWORD PTR [rcx+rax+12], 0

; 144  : 		the_idt[n].type_attr = GDT_ACCESS_PRESENT | 0xE;

	movsxd	rax, DWORD PTR n$1[rsp]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:the_idt
	mov	BYTE PTR [rcx+rax+5], 142		; 0000008eH

; 145  : 		register_irq(&the_idt[n], default_irq_handlers[n]);

	movsxd	rax, DWORD PTR n$1[rsp]
	lea	rcx, OFFSET FLAT:default_irq_handlers
	movsxd	rdx, DWORD PTR n$1[rsp]
	imul	rdx, rdx, 16
	lea	r8, OFFSET FLAT:the_idt
	add	r8, rdx
	mov	rdx, r8
	mov	QWORD PTR tv142[rsp], rdx
	mov	rdx, QWORD PTR [rcx+rax*8]
	mov	rax, QWORD PTR tv142[rsp]
	mov	rcx, rax
	call	?register_irq@@YAXPEAU_idt@@PEAX@Z	; register_irq

; 146  : 	}

	jmp	$LN2@x86_64_idt
$LN1@x86_64_idt:

; 147  : }

	add	rsp, 120				; 00000078H
	ret	0
?x86_64_idt_init_ap@@YAXXZ ENDP				; x86_64_idt_init_ap
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\hal\x86_64_idt.cpp
_TEXT	SEGMENT
vector$ = 8
function$ = 16
setvect	PROC

; 54   : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 55   : 	interrupts_handlers[vector] = function;

	lea	rax, OFFSET FLAT:interrupts_handlers
	mov	rcx, QWORD PTR vector$[rsp]
	mov	rdx, QWORD PTR function$[rsp]
	mov	QWORD PTR [rax+rcx*8], rdx

; 56   : };

	ret	0
setvect	ENDP
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\hal\x86_64_idt.cpp
_TEXT	SEGMENT
n$1 = 48
idtr$ = 56
tss$ = 64
tss_addr$ = 72
thegdt$ = 80
tv141 = 88
curr_gdt$ = 96
?x86_64_idt_init@@YAXXZ PROC				; x86_64_idt_init

; 86   : void  x86_64_idt_init() {

$LN6:
	sub	rsp, 120				; 00000078H

; 87   : 
; 88   : 	TSS *tss = (TSS*)kmalloc(sizeof(TSS));

	mov	ecx, 104				; 00000068H
	call	kmalloc
	mov	QWORD PTR tss$[rsp], rax

; 89   : 	tss->iomapbase = sizeof(TSS);

	mov	eax, 104				; 00000068H
	mov	rcx, QWORD PTR tss$[rsp]
	mov	WORD PTR [rcx+102], ax

; 90   : 	size_t tss_addr = (size_t)tss;

	mov	rax, QWORD PTR tss$[rsp]
	mov	QWORD PTR tss_addr$[rsp], rax

; 91   : 
; 92   : 	gdtr curr_gdt;
; 93   : 	x64_sgdt(&curr_gdt);

	lea	rcx, QWORD PTR curr_gdt$[rsp]
	call	x64_sgdt

; 94   : 	gdt_entry* thegdt = curr_gdt.gdtaddr;

	mov	rax, QWORD PTR curr_gdt$[rsp+2]
	mov	QWORD PTR thegdt$[rsp], rax

; 95   : 	set_gdt_entry(thegdt[GDT_ENTRY_TSS], (tss_addr & UINT32_MAX), sizeof(TSS), GDT_ACCESS_PRESENT | 0x9, 0);

	mov	eax, -1					; ffffffffH
	mov	rcx, QWORD PTR tss_addr$[rsp]
	and	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 7
	mov	rdx, QWORD PTR thegdt$[rsp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	BYTE PTR [rsp+32], 0
	mov	r9b, 137				; 00000089H
	mov	r8d, 104				; 00000068H
	mov	rdx, rax
	call	?set_gdt_entry@@YAXAEAU_gdt@@_K1EE@Z	; set_gdt_entry

; 96   : 	*(uint64_t*)&thegdt[GDT_ENTRY_TSS + 1] = (tss_addr >> 32);

	mov	rax, QWORD PTR tss_addr$[rsp]
	shr	rax, 32					; 00000020H
	mov	ecx, 8
	imul	rcx, rcx, 8
	mov	rdx, QWORD PTR thegdt$[rsp]
	mov	QWORD PTR [rdx+rcx], rax

; 97   : 	x64_ltr(SEGVAL(GDT_ENTRY_TSS, 3));

	mov	cx, 59					; 0000003bH
	call	x64_ltr

; 98   : 
; 99   : 	//AuPCPUSetKernelTSS(tss);
; 100  : 	IDTR *idtr = (IDTR*)kmalloc(sizeof(IDTR));

	mov	ecx, 10
	call	kmalloc
	mov	QWORD PTR idtr$[rsp], rax

; 101  : 	idtr->idtaddr = the_idt;

	mov	rax, QWORD PTR idtr$[rsp]
	lea	rcx, OFFSET FLAT:the_idt
	mov	QWORD PTR [rax+2], rcx

; 102  : 	idtr->length = 256 * sizeof(IDT)-1;

	mov	eax, 4095				; 00000fffH
	mov	rcx, QWORD PTR idtr$[rsp]
	mov	WORD PTR [rcx], ax

; 103  : 	x64_lidt(idtr);

	mov	rcx, QWORD PTR idtr$[rsp]
	call	x64_lidt

; 104  : 
; 105  : 	for (int n = 0; n < 256; n++)

	mov	DWORD PTR n$1[rsp], 0
	jmp	SHORT $LN3@x86_64_idt
$LN2@x86_64_idt:
	mov	eax, DWORD PTR n$1[rsp]
	inc	eax
	mov	DWORD PTR n$1[rsp], eax
$LN3@x86_64_idt:
	cmp	DWORD PTR n$1[rsp], 256			; 00000100H
	jge	$LN1@x86_64_idt

; 106  : 	{
; 107  : 		the_idt[n].ist = 0;

	movsxd	rax, DWORD PTR n$1[rsp]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:the_idt
	mov	BYTE PTR [rcx+rax+4], 0

; 108  : 		the_idt[n].selector = SEGVAL(GDT_ENTRY_KERNEL_CODE, 0);

	movsxd	rax, DWORD PTR n$1[rsp]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:the_idt
	mov	edx, 8
	mov	WORD PTR [rcx+rax+2], dx

; 109  : 		the_idt[n].zero = 0;

	movsxd	rax, DWORD PTR n$1[rsp]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:the_idt
	mov	DWORD PTR [rcx+rax+12], 0

; 110  : 		the_idt[n].type_attr = GDT_ACCESS_PRESENT | 0xE;

	movsxd	rax, DWORD PTR n$1[rsp]
	imul	rax, rax, 16
	lea	rcx, OFFSET FLAT:the_idt
	mov	BYTE PTR [rcx+rax+5], 142		; 0000008eH

; 111  : 		register_irq(&the_idt[n], default_irq_handlers[n]);

	movsxd	rax, DWORD PTR n$1[rsp]
	lea	rcx, OFFSET FLAT:default_irq_handlers
	movsxd	rdx, DWORD PTR n$1[rsp]
	imul	rdx, rdx, 16
	lea	r8, OFFSET FLAT:the_idt
	add	r8, rdx
	mov	rdx, r8
	mov	QWORD PTR tv141[rsp], rdx
	mov	rdx, QWORD PTR [rcx+rax*8]
	mov	rax, QWORD PTR tv141[rsp]
	mov	rcx, rax
	call	?register_irq@@YAXPEAU_idt@@PEAX@Z	; register_irq

; 112  : 	}

	jmp	$LN2@x86_64_idt
$LN1@x86_64_idt:

; 113  : 
; 114  : 	x86_64_idt_reg_default_handlers();

	call	?x86_64_idt_reg_default_handlers@@YAXXZ	; x86_64_idt_reg_default_handlers

; 115  : }

	add	rsp, 120				; 00000078H
	ret	0
?x86_64_idt_init@@YAXXZ ENDP				; x86_64_idt_init
_TEXT	ENDS
END
