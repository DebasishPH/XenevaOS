; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.21005.1 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	strcmp
PUBLIC	strcpy
PUBLIC	strlen
PUBLIC	strncmp
PUBLIC	strncpy
PUBLIC	strchr
PUBLIC	strcat
PUBLIC	strncat
PUBLIC	memset
PUBLIC	memcpy
PUBLIC	memcmp
EXTRN	_fastcpy:PROC
pdata	SEGMENT
$pdata$strcmp DD imagerel $LN9
	DD	imagerel $LN9+145
	DD	imagerel $unwind$strcmp
$pdata$strcpy DD imagerel $LN7
	DD	imagerel $LN7+114
	DD	imagerel $unwind$strcpy
$pdata$strlen DD imagerel $LN5
	DD	imagerel $LN5+71
	DD	imagerel $unwind$strlen
$pdata$strncmp DD imagerel $LN7
	DD	imagerel $LN7+150
	DD	imagerel $unwind$strncmp
$pdata$strncpy DD imagerel $LN11
	DD	imagerel $LN11+171
	DD	imagerel $unwind$strncpy
$pdata$strchr DD imagerel $LN7
	DD	imagerel $LN7+71
	DD	imagerel $unwind$strchr
$pdata$strcat DD imagerel $LN11
	DD	imagerel $LN11+171
	DD	imagerel $unwind$strcat
$pdata$strncat DD imagerel $LN13
	DD	imagerel $LN13+235
	DD	imagerel $unwind$strncat
$pdata$memset DD imagerel $LN5
	DD	imagerel $LN5+83
	DD	imagerel $unwind$memset
$pdata$memcpy DD imagerel $LN3
	DD	imagerel $LN3+44
	DD	imagerel $unwind$memcpy
$pdata$memcmp DD imagerel $LN9
	DD	imagerel $LN9+156
	DD	imagerel $unwind$memcmp
pdata	ENDS
xdata	SEGMENT
$unwind$strcmp DD 010e01H
	DD	0220eH
$unwind$strcpy DD 010e01H
	DD	0220eH
$unwind$strlen DD 010901H
	DD	02209H
$unwind$strncmp DD 011301H
	DD	02213H
$unwind$strncpy DD 011301H
	DD	02213H
$unwind$strchr DD 010d01H
	DD	0220dH
$unwind$strcat DD 010e01H
	DD	0220eH
$unwind$strncat DD 011301H
	DD	02213H
$unwind$memset DD 011201H
	DD	02212H
$unwind$memcpy DD 011301H
	DD	04213H
$unwind$memcmp DD 011301H
	DD	02213H
xdata	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\string.cpp
_TEXT	SEGMENT
count$ = 0
first$ = 32
second$ = 40
length$ = 48
memcmp	PROC

; 47   : int memcmp(const void *first, const void *second, size_t length){

$LN9:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 48   : 	size_t count;
; 49   : 	for (count = 0; count < length; count++)

	mov	QWORD PTR count$[rsp], 0
	jmp	SHORT $LN6@memcmp
$LN5@memcmp:
	mov	rax, QWORD PTR count$[rsp]
	inc	rax
	mov	QWORD PTR count$[rsp], rax
$LN6@memcmp:
	mov	rax, QWORD PTR length$[rsp]
	cmp	QWORD PTR count$[rsp], rax
	jae	SHORT $LN4@memcmp

; 50   : 	{
; 51   : 		if (((unsigned char*)first)[count] != ((unsigned char *)second)[count])

	mov	rax, QWORD PTR count$[rsp]
	mov	rcx, QWORD PTR first$[rsp]
	add	rcx, rax
	mov	rax, rcx
	movzx	eax, BYTE PTR [rax]
	mov	rcx, QWORD PTR count$[rsp]
	mov	rdx, QWORD PTR second$[rsp]
	add	rdx, rcx
	mov	rcx, rdx
	movzx	ecx, BYTE PTR [rcx]
	cmp	eax, ecx
	je	SHORT $LN3@memcmp

; 52   : 		{
; 53   : 			if (((unsigned char*)first)[count] < ((unsigned char *)second)[count])

	mov	rax, QWORD PTR count$[rsp]
	mov	rcx, QWORD PTR first$[rsp]
	add	rcx, rax
	mov	rax, rcx
	movzx	eax, BYTE PTR [rax]
	mov	rcx, QWORD PTR count$[rsp]
	mov	rdx, QWORD PTR second$[rsp]
	add	rdx, rcx
	mov	rcx, rdx
	movzx	ecx, BYTE PTR [rcx]
	cmp	eax, ecx
	jge	SHORT $LN2@memcmp

; 54   : 			{
; 55   : 				return (-1);

	mov	eax, -1
	jmp	SHORT $LN7@memcmp

; 56   : 			}
; 57   : 			else

	jmp	SHORT $LN1@memcmp
$LN2@memcmp:

; 58   : 			{
; 59   : 				return (1);

	mov	eax, 1
	jmp	SHORT $LN7@memcmp
$LN1@memcmp:
$LN3@memcmp:

; 60   : 			}
; 61   : 		}
; 62   : 	}

	jmp	SHORT $LN5@memcmp
$LN4@memcmp:

; 63   : 
; 64   : 	return (0); //return successful code

	xor	eax, eax
$LN7@memcmp:

; 65   : }

	add	rsp, 24
	ret	0
memcmp	ENDP
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\string.cpp
_TEXT	SEGMENT
dest$ = 48
src$ = 56
count$ = 64
memcpy	PROC

; 68   : void memcpy(void *dest, void *src, size_t count){

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 69   : 	_fastcpy(dest, src, count);

	mov	r8, QWORD PTR count$[rsp]
	mov	rdx, QWORD PTR src$[rsp]
	mov	rcx, QWORD PTR dest$[rsp]
	call	_fastcpy

; 70   : }

	add	rsp, 40					; 00000028H
	ret	0
memcpy	ENDP
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\string.cpp
_TEXT	SEGMENT
tv66 = 0
t$ = 8
targ$ = 32
val$ = 40
len$ = 48
memset	PROC

; 41   : void memset(void *targ, uint8_t val, uint32_t len){

$LN5:
	mov	DWORD PTR [rsp+24], r8d
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 42   : 	uint8_t *t = (uint8_t*)targ;

	mov	rax, QWORD PTR targ$[rsp]
	mov	QWORD PTR t$[rsp], rax
$LN2@memset:

; 43   : 	while (len--)

	mov	eax, DWORD PTR len$[rsp]
	mov	DWORD PTR tv66[rsp], eax
	mov	eax, DWORD PTR len$[rsp]
	dec	eax
	mov	DWORD PTR len$[rsp], eax
	cmp	DWORD PTR tv66[rsp], 0
	je	SHORT $LN1@memset

; 44   : 		*t++ = val;

	mov	rax, QWORD PTR t$[rsp]
	movzx	ecx, BYTE PTR val$[rsp]
	mov	BYTE PTR [rax], cl
	mov	rax, QWORD PTR t$[rsp]
	inc	rax
	mov	QWORD PTR t$[rsp], rax
	jmp	SHORT $LN2@memset
$LN1@memset:

; 45   : }

	add	rsp, 24
	ret	0
memset	ENDP
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\string.cpp
_TEXT	SEGMENT
sourceChar$ = 0
count1$ = 4
count2$ = 8
endFlag$ = 12
destString$ = 32
sourceString$ = 40
maxLength$ = 48
strncat	PROC

; 188  : {

$LN13:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 189  : 	unsigned count1, count2;
; 190  : 	int endFlag = 0;

	mov	DWORD PTR endFlag$[rsp], 0

; 191  : 	char sourceChar;
; 192  : 
; 193  : 	// Find the end of the first String
; 194  : 	for (count1 = 0; count1 < MAX_STRING_LENGTH;)

	mov	DWORD PTR count1$[rsp], 0
$LN10@strncat:
	cmp	DWORD PTR count1$[rsp], 25
	jae	SHORT $LN9@strncat

; 195  : 	{
; 196  : 		if (destString[count1] == '\0')

	mov	eax, DWORD PTR count1$[rsp]
	mov	rcx, QWORD PTR destString$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	jne	SHORT $LN8@strncat

; 197  : 			break;

	jmp	SHORT $LN9@strncat

; 198  : 		else

	jmp	SHORT $LN7@strncat
$LN8@strncat:

; 199  : 			count1++;

	mov	eax, DWORD PTR count1$[rsp]
	inc	eax
	mov	DWORD PTR count1$[rsp], eax
$LN7@strncat:

; 200  : 	}

	jmp	SHORT $LN10@strncat
$LN9@strncat:

; 201  : 
; 202  : 	// If this is true, then we probably have an unterminated string
; 203  : 	// constant.  Checking for a string that exceeds MAXSTRINGLENGTH will
; 204  : 	// help to prevent the function from running off too far into memory.
; 205  : 	if (count1 >= MAX_STRING_LENGTH)

	cmp	DWORD PTR count1$[rsp], 25
	jb	SHORT $LN6@strncat

; 206  : 	{
; 207  : 		//errno = ERR_BOUNDS;
; 208  : 		return (destString = NULL);

	mov	QWORD PTR destString$[rsp], 0
	mov	rax, QWORD PTR destString$[rsp]
	jmp	$LN11@strncat
$LN6@strncat:

; 209  : 	}
; 210  : 
; 211  : 	// Now copy the source string into the dest.  If source is shorter than
; 212  : 	// maxLength, pad dest with NULL characters.
; 213  : 	for (count2 = 0; count2 < maxLength;)

	mov	DWORD PTR count2$[rsp], 0
$LN5@strncat:
	mov	eax, DWORD PTR count2$[rsp]
	cmp	rax, QWORD PTR maxLength$[rsp]
	jae	SHORT $LN4@strncat

; 214  : 	{
; 215  : 		if ((sourceString[count2] == '\0') || (endFlag == 1))

	mov	eax, DWORD PTR count2$[rsp]
	mov	rcx, QWORD PTR sourceString$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN2@strncat
	cmp	DWORD PTR endFlag$[rsp], 1
	jne	SHORT $LN3@strncat
$LN2@strncat:

; 216  : 		{
; 217  : 			endFlag = 1;

	mov	DWORD PTR endFlag$[rsp], 1

; 218  : 			sourceChar = (char)NULL;

	mov	BYTE PTR sourceChar$[rsp], 0

; 219  : 		}
; 220  : 		else

	jmp	SHORT $LN1@strncat
$LN3@strncat:

; 221  : 		{
; 222  : 			sourceChar = sourceString[count2];

	mov	eax, DWORD PTR count2$[rsp]
	mov	rcx, QWORD PTR sourceString$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	BYTE PTR sourceChar$[rsp], al
$LN1@strncat:

; 223  : 		}
; 224  : 
; 225  : 		destString[count1] = sourceChar;

	mov	eax, DWORD PTR count1$[rsp]
	mov	rcx, QWORD PTR destString$[rsp]
	movzx	edx, BYTE PTR sourceChar$[rsp]
	mov	BYTE PTR [rcx+rax], dl

; 226  : 		count1++; count2++;

	mov	eax, DWORD PTR count1$[rsp]
	inc	eax
	mov	DWORD PTR count1$[rsp], eax
	mov	eax, DWORD PTR count2$[rsp]
	inc	eax
	mov	DWORD PTR count2$[rsp], eax

; 227  : 	}

	jmp	SHORT $LN5@strncat
$LN4@strncat:

; 228  : 
; 229  : 	// Make sure there's a NULL at the end
; 230  : 	destString[count1] = NULL;

	mov	eax, DWORD PTR count1$[rsp]
	mov	rcx, QWORD PTR destString$[rsp]
	mov	BYTE PTR [rcx+rax], 0

; 231  : 
; 232  : 	// Return success
; 233  : 	return (destString);

	mov	rax, QWORD PTR destString$[rsp]
$LN11@strncat:

; 234  : }

	add	rsp, 24
	ret	0
strncat	ENDP
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\string.cpp
_TEXT	SEGMENT
count1$ = 0
count2$ = 4
destString$ = 32
sourceString$ = 40
strcat	PROC

; 153  : {

$LN11:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 154  : 	int count1, count2;
; 155  : 
; 156  : 	// Find the end of the first String
; 157  : 	for (count1 = 0; count1 < MAX_STRING_LENGTH;)

	mov	DWORD PTR count1$[rsp], 0
$LN8@strcat:
	cmp	DWORD PTR count1$[rsp], 25
	jge	SHORT $LN7@strcat

; 158  : 	{
; 159  : 		if (!destString[count1])

	movsxd	rax, DWORD PTR count1$[rsp]
	mov	rcx, QWORD PTR destString$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	jne	SHORT $LN6@strcat

; 160  : 			break;

	jmp	SHORT $LN7@strcat
$LN6@strcat:

; 161  : 
; 162  : 		count1 += 1;

	mov	eax, DWORD PTR count1$[rsp]
	inc	eax
	mov	DWORD PTR count1$[rsp], eax

; 163  : 	}

	jmp	SHORT $LN8@strcat
$LN7@strcat:

; 164  : 
; 165  : 	// If this is true, then we possibly have an unterminated string constant.
; 166  : 	// Checking for a string that exceeds MAXSTRINGLENGTH will help to prevent
; 167  : 	// the function from running off too far into memory.
; 168  : 	if (count1 >= MAX_STRING_LENGTH)

	cmp	DWORD PTR count1$[rsp], 25
	jl	SHORT $LN5@strcat

; 169  : 	{
; 170  : 		//errno = ERR_BOUNDS;
; 171  : 		return (destString = NULL);

	mov	QWORD PTR destString$[rsp], 0
	mov	rax, QWORD PTR destString$[rsp]
	jmp	SHORT $LN9@strcat
$LN5@strcat:

; 172  : 	}
; 173  : 
; 174  : 	// Now copy the source string into the dest until the source is a NULL
; 175  : 	// character.
; 176  : 	for (count2 = 0; count1 < MAX_STRING_LENGTH; count1++, count2++)

	mov	DWORD PTR count2$[rsp], 0
	jmp	SHORT $LN4@strcat
$LN3@strcat:
	mov	eax, DWORD PTR count1$[rsp]
	inc	eax
	mov	DWORD PTR count1$[rsp], eax
	mov	eax, DWORD PTR count2$[rsp]
	inc	eax
	mov	DWORD PTR count2$[rsp], eax
$LN4@strcat:
	cmp	DWORD PTR count1$[rsp], 25
	jge	SHORT $LN2@strcat

; 177  : 	{
; 178  : 		destString[count1] = sourceString[count2];

	movsxd	rax, DWORD PTR count2$[rsp]
	movsxd	rcx, DWORD PTR count1$[rsp]
	mov	rdx, QWORD PTR destString$[rsp]
	mov	r8, QWORD PTR sourceString$[rsp]
	movzx	eax, BYTE PTR [r8+rax]
	mov	BYTE PTR [rdx+rcx], al

; 179  : 
; 180  : 		if (!sourceString[count2])

	movsxd	rax, DWORD PTR count2$[rsp]
	mov	rcx, QWORD PTR sourceString$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	jne	SHORT $LN1@strcat

; 181  : 			break;

	jmp	SHORT $LN2@strcat
$LN1@strcat:

; 182  : 	}

	jmp	SHORT $LN3@strcat
$LN2@strcat:

; 183  : 
; 184  : 	return (destString);

	mov	rax, QWORD PTR destString$[rsp]
$LN9@strcat:

; 185  : }

	add	rsp, 24
	ret	0
strcat	ENDP
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\string.cpp
_TEXT	SEGMENT
tv69 = 0
str$ = 32
character$ = 40
strchr	PROC

; 142  : char* strchr(char* str, int character) {

$LN7:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
$LN4@strchr:

; 143  : 
; 144  : 	do {
; 145  : 		if (*str == character)

	mov	rax, QWORD PTR str$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, DWORD PTR character$[rsp]
	jne	SHORT $LN1@strchr

; 146  : 			return (char*)str;

	mov	rax, QWORD PTR str$[rsp]
	jmp	SHORT $LN5@strchr
$LN1@strchr:

; 147  : 	} while (*str++);

	mov	rax, QWORD PTR str$[rsp]
	movsx	eax, BYTE PTR [rax]
	mov	DWORD PTR tv69[rsp], eax
	mov	rax, QWORD PTR str$[rsp]
	inc	rax
	mov	QWORD PTR str$[rsp], rax
	cmp	DWORD PTR tv69[rsp], 0
	jne	SHORT $LN4@strchr

; 148  : 
; 149  : 	return 0;

	xor	eax, eax
$LN5@strchr:

; 150  : }

	add	rsp, 24
	ret	0
strchr	ENDP
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\string.cpp
_TEXT	SEGMENT
count$ = 0
destString$ = 32
sourceString$ = 40
maxLength$ = 48
strncpy	PROC

; 114  : char *strncpy(char *destString, const char* sourceString, size_t maxLength){

$LN11:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 115  : 	unsigned count;
; 116  : 
; 117  : 	if ((destString == (char*)NULL) || (sourceString == (char*)NULL))

	cmp	QWORD PTR destString$[rsp], 0
	je	SHORT $LN7@strncpy
	cmp	QWORD PTR sourceString$[rsp], 0
	jne	SHORT $LN8@strncpy
$LN7@strncpy:

; 118  : 	{
; 119  : 		return (destString = NULL);

	mov	QWORD PTR destString$[rsp], 0
	mov	rax, QWORD PTR destString$[rsp]
	jmp	SHORT $LN9@strncpy
$LN8@strncpy:

; 120  : 	}
; 121  : 
; 122  : 	if (maxLength > MAX_STRING_LENGTH)

	cmp	QWORD PTR maxLength$[rsp], 25
	jbe	SHORT $LN6@strncpy

; 123  : 		maxLength = MAX_STRING_LENGTH;

	mov	QWORD PTR maxLength$[rsp], 25
$LN6@strncpy:

; 124  : 
; 125  : 	for (count = 0; count < maxLength; count++)

	mov	DWORD PTR count$[rsp], 0
	jmp	SHORT $LN5@strncpy
$LN4@strncpy:
	mov	eax, DWORD PTR count$[rsp]
	inc	eax
	mov	DWORD PTR count$[rsp], eax
$LN5@strncpy:
	mov	eax, DWORD PTR count$[rsp]
	cmp	rax, QWORD PTR maxLength$[rsp]
	jae	SHORT $LN3@strncpy

; 126  : 	{
; 127  : 		destString[count] = sourceString[count];

	mov	eax, DWORD PTR count$[rsp]
	mov	ecx, DWORD PTR count$[rsp]
	mov	rdx, QWORD PTR destString$[rsp]
	mov	r8, QWORD PTR sourceString$[rsp]
	movzx	eax, BYTE PTR [r8+rax]
	mov	BYTE PTR [rdx+rcx], al

; 128  : 
; 129  : 		if (sourceString[count] == '\0')

	mov	eax, DWORD PTR count$[rsp]
	mov	rcx, QWORD PTR sourceString$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	jne	SHORT $LN2@strncpy

; 130  : 			break;

	jmp	SHORT $LN3@strncpy
$LN2@strncpy:

; 131  : 	}

	jmp	SHORT $LN4@strncpy
$LN3@strncpy:

; 132  : 
; 133  : 	if (count >= MAX_STRING_LENGTH)

	cmp	DWORD PTR count$[rsp], 25
	jb	SHORT $LN1@strncpy

; 134  : 	{
; 135  : 		return (destString = NULL);

	mov	QWORD PTR destString$[rsp], 0
	mov	rax, QWORD PTR destString$[rsp]
	jmp	SHORT $LN9@strncpy
$LN1@strncpy:

; 136  : 	}
; 137  : 
; 138  : 	return (destString);

	mov	rax, QWORD PTR destString$[rsp]
$LN9@strncpy:

; 139  : }

	add	rsp, 24
	ret	0
strncpy	ENDP
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\string.cpp
_TEXT	SEGMENT
tv78 = 0
s1$ = 32
s2$ = 40
n$ = 48
strncmp	PROC

; 106  : int strncmp(const char* s1, const char *s2, size_t n){

$LN7:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
$LN2@strncmp:

; 107  : 	while (n > 0 && *s1 != '\0' && *s1 == *s2) {

	cmp	QWORD PTR n$[rsp], 0
	jbe	SHORT $LN1@strncmp
	mov	rax, QWORD PTR s1$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN1@strncmp
	mov	rax, QWORD PTR s1$[rsp]
	movsx	eax, BYTE PTR [rax]
	mov	rcx, QWORD PTR s2$[rsp]
	movsx	ecx, BYTE PTR [rcx]
	cmp	eax, ecx
	jne	SHORT $LN1@strncmp

; 108  : 		n--, s1++, s2++;

	mov	rax, QWORD PTR n$[rsp]
	dec	rax
	mov	QWORD PTR n$[rsp], rax
	mov	rax, QWORD PTR s1$[rsp]
	inc	rax
	mov	QWORD PTR s1$[rsp], rax
	mov	rax, QWORD PTR s2$[rsp]
	inc	rax
	mov	QWORD PTR s2$[rsp], rax

; 109  : 	}

	jmp	SHORT $LN2@strncmp
$LN1@strncmp:

; 110  : 
; 111  : 	return (n == 0) ? 0 : (size_t)((unsigned char)*s1 - (unsigned char)*s2);

	cmp	QWORD PTR n$[rsp], 0
	jne	SHORT $LN5@strncmp
	mov	QWORD PTR tv78[rsp], 0
	jmp	SHORT $LN6@strncmp
$LN5@strncmp:
	mov	rax, QWORD PTR s1$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	rcx, QWORD PTR s2$[rsp]
	movzx	ecx, BYTE PTR [rcx]
	sub	eax, ecx
	cdqe
	mov	QWORD PTR tv78[rsp], rax
$LN6@strncmp:
	mov	eax, DWORD PTR tv78[rsp]

; 112  : }

	add	rsp, 24
	ret	0
strncmp	ENDP
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\string.cpp
_TEXT	SEGMENT
tv69 = 0
len$ = 8
str$ = 32
strlen	PROC

; 99   : size_t strlen(const char* str){

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 100  : 	size_t len = 0;

	mov	QWORD PTR len$[rsp], 0
$LN2@strlen:

; 101  : 	while (str[len++]);

	mov	rax, QWORD PTR len$[rsp]
	mov	rcx, QWORD PTR str$[rsp]
	add	rcx, rax
	mov	rax, rcx
	movsx	eax, BYTE PTR [rax]
	mov	DWORD PTR tv69[rsp], eax
	mov	rax, QWORD PTR len$[rsp]
	inc	rax
	mov	QWORD PTR len$[rsp], rax
	cmp	DWORD PTR tv69[rsp], 0
	je	SHORT $LN1@strlen
	jmp	SHORT $LN2@strlen
$LN1@strlen:

; 102  : 	return len;

	mov	rax, QWORD PTR len$[rsp]

; 103  : }

	add	rsp, 24
	ret	0
strlen	ENDP
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\string.cpp
_TEXT	SEGMENT
tv70 = 0
s1_p$ = 8
s1$ = 32
s2$ = 40
strcpy	PROC

; 90   : {

$LN7:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 91   : 	if (s1 == NULL || s2 == NULL)

	cmp	QWORD PTR s1$[rsp], 0
	je	SHORT $LN3@strcpy
	cmp	QWORD PTR s2$[rsp], 0
	jne	SHORT $LN4@strcpy
$LN3@strcpy:

; 92   : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN5@strcpy
$LN4@strcpy:

; 93   : 
; 94   : 	char *s1_p = s1;

	mov	rax, QWORD PTR s1$[rsp]
	mov	QWORD PTR s1_p$[rsp], rax
$LN2@strcpy:

; 95   : 	while (*s1++ = *s2++);

	mov	rax, QWORD PTR s1$[rsp]
	mov	rcx, QWORD PTR s2$[rsp]
	movzx	ecx, BYTE PTR [rcx]
	mov	BYTE PTR [rax], cl
	mov	rax, QWORD PTR s1$[rsp]
	movsx	eax, BYTE PTR [rax]
	mov	DWORD PTR tv70[rsp], eax
	mov	rax, QWORD PTR s1$[rsp]
	inc	rax
	mov	QWORD PTR s1$[rsp], rax
	mov	rax, QWORD PTR s2$[rsp]
	inc	rax
	mov	QWORD PTR s2$[rsp], rax
	cmp	DWORD PTR tv70[rsp], 0
	je	SHORT $LN1@strcpy
	jmp	SHORT $LN2@strcpy
$LN1@strcpy:

; 96   : 	return s1_p;

	mov	rax, QWORD PTR s1_p$[rsp]
$LN5@strcpy:

; 97   : }

	add	rsp, 24
	ret	0
strcpy	ENDP
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\string.cpp
_TEXT	SEGMENT
res$ = 0
str1$ = 32
str2$ = 40
strcmp	PROC

; 73   : int strcmp(const char* str1, const char* str2){

$LN9:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 74   : 	if (str1 == NULL || str2 == NULL)

	cmp	QWORD PTR str1$[rsp], 0
	je	SHORT $LN5@strcmp
	cmp	QWORD PTR str2$[rsp], 0
	jne	SHORT $LN6@strcmp
$LN5@strcmp:

; 75   : 		return -1;

	mov	eax, -1
	jmp	SHORT $LN7@strcmp
$LN6@strcmp:

; 76   : 
; 77   : 	int res = 0;

	mov	DWORD PTR res$[rsp], 0
$LN4@strcmp:

; 78   : 	while (!(res = *(unsigned char*)str1 - *(unsigned char*)str2) && *str2)

	mov	rax, QWORD PTR str1$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	rcx, QWORD PTR str2$[rsp]
	movzx	ecx, BYTE PTR [rcx]
	sub	eax, ecx
	mov	DWORD PTR res$[rsp], eax
	cmp	DWORD PTR res$[rsp], 0
	jne	SHORT $LN3@strcmp
	mov	rax, QWORD PTR str2$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN3@strcmp

; 79   : 		++str1, ++str2;

	mov	rax, QWORD PTR str1$[rsp]
	inc	rax
	mov	QWORD PTR str1$[rsp], rax
	mov	rax, QWORD PTR str2$[rsp]
	inc	rax
	mov	QWORD PTR str2$[rsp], rax
	jmp	SHORT $LN4@strcmp
$LN3@strcmp:

; 80   : 
; 81   : 	if (res < 0)

	cmp	DWORD PTR res$[rsp], 0
	jge	SHORT $LN2@strcmp

; 82   : 		res = -1;

	mov	DWORD PTR res$[rsp], -1
$LN2@strcmp:

; 83   : 	if (res > 0)

	cmp	DWORD PTR res$[rsp], 0
	jle	SHORT $LN1@strcmp

; 84   : 		res = 1;

	mov	DWORD PTR res$[rsp], 1
$LN1@strcmp:

; 85   : 
; 86   : 	return res;

	mov	eax, DWORD PTR res$[rsp]
$LN7@strcmp:

; 87   : }

	add	rsp, 24
	ret	0
strcmp	ENDP
_TEXT	ENDS
END
