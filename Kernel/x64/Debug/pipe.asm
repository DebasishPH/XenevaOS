; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30154.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

msvcjmc	SEGMENT
__AA583385_pipe@cpp DB 01H
msvcjmc	ENDS
PUBLIC	?AuPipeUnread@@YA_KPEAU_pipe_@@@Z		; AuPipeUnread
PUBLIC	?AuCreatePipe@@YAPEAU__VFS_NODE__@@PEAD_K@Z	; AuCreatePipe
PUBLIC	?AuPipeGetAvailableBytes@@YA_KPEAU_pipe_@@@Z	; AuPipeGetAvailableBytes
PUBLIC	?AuPipeIncrementRead@@YAXPEAU_pipe_@@@Z		; AuPipeIncrementRead
PUBLIC	?AuPipeIncrementWrite@@YAXPEAU_pipe_@@@Z	; AuPipeIncrementWrite
PUBLIC	?AuPipeIncrementWriteAmount@@YAXPEAU_pipe_@@_K@Z ; AuPipeIncrementWriteAmount
PUBLIC	?AuPipeRead@@YA_KPEAU__VFS_NODE__@@0PEA_KI@Z	; AuPipeRead
PUBLIC	?AuPipeWrite@@YA_KPEAU__VFS_NODE__@@0PEA_KI@Z	; AuPipeWrite
PUBLIC	?AuPipeOpen@@YAPEAU__VFS_NODE__@@PEAU1@PEAD@Z	; AuPipeOpen
PUBLIC	?AuPipeClose@@YAHPEAU__VFS_NODE__@@0@Z		; AuPipeClose
PUBLIC	__JustMyCode_Default
EXTRN	initialize_list:PROC
EXTRN	kmalloc:PROC
EXTRN	kfree:PROC
EXTRN	strcpy:PROC
EXTRN	memset:PROC
EXTRN	__CheckForDebuggerJustMyCode:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuPipeUnread@@YA_KPEAU_pipe_@@@Z DD imagerel $LN6
	DD	imagerel $LN6+123
	DD	imagerel $unwind$?AuPipeUnread@@YA_KPEAU_pipe_@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuCreatePipe@@YAPEAU__VFS_NODE__@@PEAD_K@Z DD imagerel $LN3
	DD	imagerel $LN3+286
	DD	imagerel $unwind$?AuCreatePipe@@YAPEAU__VFS_NODE__@@PEAD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuPipeGetAvailableBytes@@YA_KPEAU_pipe_@@@Z DD imagerel $LN6
	DD	imagerel $LN6+140
	DD	imagerel $unwind$?AuPipeGetAvailableBytes@@YA_KPEAU_pipe_@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuPipeIncrementRead@@YAXPEAU_pipe_@@@Z DD imagerel $LN4
	DD	imagerel $LN4+82
	DD	imagerel $unwind$?AuPipeIncrementRead@@YAXPEAU_pipe_@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuPipeIncrementWrite@@YAXPEAU_pipe_@@@Z DD imagerel $LN4
	DD	imagerel $LN4+82
	DD	imagerel $unwind$?AuPipeIncrementWrite@@YAXPEAU_pipe_@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuPipeIncrementWriteAmount@@YAXPEAU_pipe_@@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+66
	DD	imagerel $unwind$?AuPipeIncrementWriteAmount@@YAXPEAU_pipe_@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuPipeRead@@YA_KPEAU__VFS_NODE__@@0PEA_KI@Z DD imagerel $LN9
	DD	imagerel $LN9+202
	DD	imagerel $unwind$?AuPipeRead@@YA_KPEAU__VFS_NODE__@@0PEA_KI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuPipeWrite@@YA_KPEAU__VFS_NODE__@@0PEA_KI@Z DD imagerel $LN8
	DD	imagerel $LN8+203
	DD	imagerel $unwind$?AuPipeWrite@@YA_KPEAU__VFS_NODE__@@0PEA_KI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuPipeOpen@@YAPEAU__VFS_NODE__@@PEAU1@PEAD@Z DD imagerel $LN3
	DD	imagerel $LN3+73
	DD	imagerel $unwind$?AuPipeOpen@@YAPEAU__VFS_NODE__@@PEAU1@PEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuPipeClose@@YAHPEAU__VFS_NODE__@@0@Z DD imagerel $LN4
	DD	imagerel $LN4+144
	DD	imagerel $unwind$?AuPipeClose@@YAHPEAU__VFS_NODE__@@0@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuPipeClose@@YAHPEAU__VFS_NODE__@@0@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuPipeOpen@@YAPEAU__VFS_NODE__@@PEAU1@PEAD@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuPipeWrite@@YA_KPEAU__VFS_NODE__@@0PEA_KI@Z DD 025032101H
	DD	0f21c2321H
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuPipeRead@@YA_KPEAU__VFS_NODE__@@0PEA_KI@Z DD 025032101H
	DD	0f21c2321H
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuPipeIncrementWriteAmount@@YAXPEAU_pipe_@@_K@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuPipeIncrementWrite@@YAXPEAU_pipe_@@@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuPipeIncrementRead@@YAXPEAU_pipe_@@@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuPipeGetAvailableBytes@@YA_KPEAU_pipe_@@@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuCreatePipe@@YAPEAU__VFS_NODE__@@PEAD_K@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuPipeUnread@@YA_KPEAU_pipe_@@@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Fs\pipe.cpp
;	COMDAT ?AuPipeClose@@YAHPEAU__VFS_NODE__@@0@Z
_TEXT	SEGMENT
pipe$ = 0
fs$ = 96
file$ = 104
?AuPipeClose@@YAHPEAU__VFS_NODE__@@0@Z PROC		; AuPipeClose, COMDAT

; 143  : int AuPipeClose(AuVFSNode* fs, AuVFSNode* file) {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__AA583385_pipe@cpp
	call	__CheckForDebuggerJustMyCode

; 144  : 	AuPipe* pipe = (AuPipe*)fs->device;

	mov	rax, QWORD PTR fs$[rbp]
	mov	rax, QWORD PTR [rax+64]
	mov	QWORD PTR pipe$[rbp], rax

; 145  : 	pipe->refcount--;

	mov	rax, QWORD PTR pipe$[rbp]
	mov	rax, QWORD PTR [rax+32]
	dec	rax
	mov	rcx, QWORD PTR pipe$[rbp]
	mov	QWORD PTR [rcx+32], rax

; 146  : 	if (pipe->refcount == 0) {

	mov	rax, QWORD PTR pipe$[rbp]
	cmp	QWORD PTR [rax+32], 0
	jne	SHORT $LN2@AuPipeClos

; 147  : 		kfree(pipe->buffer);

	mov	rax, QWORD PTR pipe$[rbp]
	mov	rcx, QWORD PTR [rax]
	call	kfree

; 148  : 		kfree(pipe->readers_wait_queue);

	mov	rax, QWORD PTR pipe$[rbp]
	mov	rcx, QWORD PTR [rax+40]
	call	kfree

; 149  : 		kfree(pipe->writers_wait_queue);

	mov	rax, QWORD PTR pipe$[rbp]
	mov	rcx, QWORD PTR [rax+48]
	call	kfree

; 150  : 		kfree(pipe);

	mov	rcx, QWORD PTR pipe$[rbp]
	call	kfree

; 151  : 		fs->device = NULL;

	mov	rax, QWORD PTR fs$[rbp]
	mov	QWORD PTR [rax+64], 0
$LN2@AuPipeClos:

; 152  : 	}
; 153  : 	return 1;

	mov	eax, 1

; 154  : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
?AuPipeClose@@YAHPEAU__VFS_NODE__@@0@Z ENDP		; AuPipeClose
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Fs\pipe.cpp
;	COMDAT ?AuPipeOpen@@YAPEAU__VFS_NODE__@@PEAU1@PEAD@Z
_TEXT	SEGMENT
pipe$ = 0
node$ = 96
path$ = 104
?AuPipeOpen@@YAPEAU__VFS_NODE__@@PEAU1@PEAD@Z PROC	; AuPipeOpen, COMDAT

; 132  : AuVFSNode* AuPipeOpen(AuVFSNode *node, char* path){

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__AA583385_pipe@cpp
	call	__CheckForDebuggerJustMyCode

; 133  : 	AuPipe* pipe = (AuPipe*)node->device;

	mov	rax, QWORD PTR node$[rbp]
	mov	rax, QWORD PTR [rax+64]
	mov	QWORD PTR pipe$[rbp], rax

; 134  : 	pipe->refcount++;

	mov	rax, QWORD PTR pipe$[rbp]
	mov	rax, QWORD PTR [rax+32]
	inc	rax
	mov	rcx, QWORD PTR pipe$[rbp]
	mov	QWORD PTR [rcx+32], rax

; 135  : 	return node;

	mov	rax, QWORD PTR node$[rbp]

; 136  : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
?AuPipeOpen@@YAPEAU__VFS_NODE__@@PEAU1@PEAD@Z ENDP	; AuPipeOpen
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Fs\pipe.cpp
;	COMDAT ?AuPipeWrite@@YA_KPEAU__VFS_NODE__@@0PEA_KI@Z
_TEXT	SEGMENT
aligned_buff$ = 0
pipe$ = 8
written$ = 16
fs$ = 112
file$ = 120
buffer$ = 128
length$ = 136
?AuPipeWrite@@YA_KPEAU__VFS_NODE__@@0PEA_KI@Z PROC	; AuPipeWrite, COMDAT

; 114  : size_t AuPipeWrite(AuVFSNode *fs, AuVFSNode *file, uint64_t* buffer, uint32_t length) {

$LN8:
	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 128				; 00000080H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__AA583385_pipe@cpp
	call	__CheckForDebuggerJustMyCode

; 115  : 	uint8_t* aligned_buff = (uint8_t*)buffer;

	mov	rax, QWORD PTR buffer$[rbp]
	mov	QWORD PTR aligned_buff$[rbp], rax

; 116  : 	AuPipe* pipe = (AuPipe*)fs->device;

	mov	rax, QWORD PTR fs$[rbp]
	mov	rax, QWORD PTR [rax+64]
	mov	QWORD PTR pipe$[rbp], rax

; 117  : 
; 118  : 	size_t written = 0;

	mov	QWORD PTR written$[rbp], 0
$LN2@AuPipeWrit:

; 119  : 	while (written < length) {

	mov	eax, DWORD PTR length$[rbp]
	cmp	QWORD PTR written$[rbp], rax
	jae	SHORT $LN3@AuPipeWrit

; 120  : 		if (AuPipeGetAvailableBytes(pipe) > length) {

	mov	rcx, QWORD PTR pipe$[rbp]
	call	?AuPipeGetAvailableBytes@@YA_KPEAU_pipe_@@@Z ; AuPipeGetAvailableBytes
	mov	ecx, DWORD PTR length$[rbp]
	cmp	rax, rcx
	jbe	SHORT $LN6@AuPipeWrit
$LN4@AuPipeWrit:

; 121  : 			while (AuPipeGetAvailableBytes(pipe) > 0 && written < length) {

	mov	rcx, QWORD PTR pipe$[rbp]
	call	?AuPipeGetAvailableBytes@@YA_KPEAU_pipe_@@@Z ; AuPipeGetAvailableBytes
	test	rax, rax
	jbe	SHORT $LN5@AuPipeWrit
	mov	eax, DWORD PTR length$[rbp]
	cmp	QWORD PTR written$[rbp], rax
	jae	SHORT $LN5@AuPipeWrit

; 122  : 				pipe->buffer[pipe->write_ptr] = aligned_buff[written];

	mov	rax, QWORD PTR pipe$[rbp]
	mov	rax, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR pipe$[rbp]
	mov	rcx, QWORD PTR [rcx]
	mov	rdx, QWORD PTR written$[rbp]
	mov	r8, QWORD PTR aligned_buff$[rbp]
	add	r8, rdx
	mov	rdx, r8
	movzx	edx, BYTE PTR [rdx]
	mov	BYTE PTR [rcx+rax], dl

; 123  : 				AuPipeIncrementWrite(pipe);

	mov	rcx, QWORD PTR pipe$[rbp]
	call	?AuPipeIncrementWrite@@YAXPEAU_pipe_@@@Z ; AuPipeIncrementWrite

; 124  : 				written++;

	mov	rax, QWORD PTR written$[rbp]
	inc	rax
	mov	QWORD PTR written$[rbp], rax

; 125  : 			}

	jmp	SHORT $LN4@AuPipeWrit
$LN5@AuPipeWrit:
$LN6@AuPipeWrit:

; 126  : 		}
; 127  : 	}

	jmp	SHORT $LN2@AuPipeWrit
$LN3@AuPipeWrit:

; 128  : 	
; 129  : 	return written;

	mov	rax, QWORD PTR written$[rbp]

; 130  : }

	lea	rsp, QWORD PTR [rbp+96]
	pop	rbp
	ret	0
?AuPipeWrite@@YA_KPEAU__VFS_NODE__@@0PEA_KI@Z ENDP	; AuPipeWrite
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Fs\pipe.cpp
;	COMDAT ?AuPipeRead@@YA_KPEAU__VFS_NODE__@@0PEA_KI@Z
_TEXT	SEGMENT
aligned_buff$ = 0
pipe$ = 8
collected$ = 16
fs$ = 112
file$ = 120
buffer$ = 128
length$ = 136
?AuPipeRead@@YA_KPEAU__VFS_NODE__@@0PEA_KI@Z PROC	; AuPipeRead, COMDAT

; 86   : size_t AuPipeRead(AuVFSNode *fs, AuVFSNode *file, uint64_t* buffer, uint32_t length) {

$LN9:
	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 128				; 00000080H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__AA583385_pipe@cpp
	call	__CheckForDebuggerJustMyCode

; 87   : 	uint8_t* aligned_buff = (uint8_t*)buffer;

	mov	rax, QWORD PTR buffer$[rbp]
	mov	QWORD PTR aligned_buff$[rbp], rax

; 88   : 	AuPipe *pipe = (AuPipe*)fs->device;

	mov	rax, QWORD PTR fs$[rbp]
	mov	rax, QWORD PTR [rax+64]
	mov	QWORD PTR pipe$[rbp], rax

; 89   : 
; 90   : 	size_t collected = 0;

	mov	QWORD PTR collected$[rbp], 0
$LN2@AuPipeRead:

; 91   : 	while (collected == 0) {

	cmp	QWORD PTR collected$[rbp], 0
	jne	SHORT $LN3@AuPipeRead

; 92   : 		if (AuPipeUnread(pipe) >= length) {

	mov	rcx, QWORD PTR pipe$[rbp]
	call	?AuPipeUnread@@YA_KPEAU_pipe_@@@Z	; AuPipeUnread
	mov	ecx, DWORD PTR length$[rbp]
	cmp	rax, rcx
	jb	SHORT $LN6@AuPipeRead
$LN4@AuPipeRead:

; 93   : 			while (AuPipeUnread(pipe) > 0 && collected < length) {

	mov	rcx, QWORD PTR pipe$[rbp]
	call	?AuPipeUnread@@YA_KPEAU_pipe_@@@Z	; AuPipeUnread
	test	rax, rax
	jbe	SHORT $LN5@AuPipeRead
	mov	eax, DWORD PTR length$[rbp]
	cmp	QWORD PTR collected$[rbp], rax
	jae	SHORT $LN5@AuPipeRead

; 94   : 				aligned_buff[collected] = pipe->buffer[pipe->read_ptr];

	mov	rax, QWORD PTR pipe$[rbp]
	mov	rax, QWORD PTR [rax+16]
	mov	rcx, QWORD PTR pipe$[rbp]
	mov	rcx, QWORD PTR [rcx]
	mov	rdx, QWORD PTR collected$[rbp]
	mov	r8, QWORD PTR aligned_buff$[rbp]
	add	r8, rdx
	mov	rdx, r8
	movzx	eax, BYTE PTR [rcx+rax]
	mov	BYTE PTR [rdx], al

; 95   : 				AuPipeIncrementRead(pipe);

	mov	rcx, QWORD PTR pipe$[rbp]
	call	?AuPipeIncrementRead@@YAXPEAU_pipe_@@@Z	; AuPipeIncrementRead

; 96   : 				collected++;

	mov	rax, QWORD PTR collected$[rbp]
	inc	rax
	mov	QWORD PTR collected$[rbp], rax

; 97   : 			}

	jmp	SHORT $LN4@AuPipeRead
$LN5@AuPipeRead:

; 98   : 			
; 99   : 		}

	jmp	SHORT $LN7@AuPipeRead
$LN6@AuPipeRead:

; 100  : 		else 
; 101  : 			break;

	jmp	SHORT $LN3@AuPipeRead
$LN7@AuPipeRead:

; 102  : 	}

	jmp	SHORT $LN2@AuPipeRead
$LN3@AuPipeRead:

; 103  : 
; 104  : 	return collected;

	mov	rax, QWORD PTR collected$[rbp]

; 105  : }

	lea	rsp, QWORD PTR [rbp+96]
	pop	rbp
	ret	0
?AuPipeRead@@YA_KPEAU__VFS_NODE__@@0PEA_KI@Z ENDP	; AuPipeRead
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Fs\pipe.cpp
;	COMDAT ?AuPipeIncrementWriteAmount@@YAXPEAU_pipe_@@_K@Z
_TEXT	SEGMENT
pipe$ = 80
amount$ = 88
?AuPipeIncrementWriteAmount@@YAXPEAU_pipe_@@_K@Z PROC	; AuPipeIncrementWriteAmount, COMDAT

; 75   : void AuPipeIncrementWriteAmount(AuPipe* pipe, size_t amount) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__AA583385_pipe@cpp
	call	__CheckForDebuggerJustMyCode

; 76   : 	pipe->write_ptr = (pipe->write_ptr + amount) & pipe->size;

	mov	rax, QWORD PTR pipe$[rbp]
	mov	rax, QWORD PTR [rax+8]
	add	rax, QWORD PTR amount$[rbp]
	mov	rcx, QWORD PTR pipe$[rbp]
	and	rax, QWORD PTR [rcx+24]
	mov	rcx, QWORD PTR pipe$[rbp]
	mov	QWORD PTR [rcx+8], rax

; 77   : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
?AuPipeIncrementWriteAmount@@YAXPEAU_pipe_@@_K@Z ENDP	; AuPipeIncrementWriteAmount
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Fs\pipe.cpp
;	COMDAT ?AuPipeIncrementWrite@@YAXPEAU_pipe_@@@Z
_TEXT	SEGMENT
pipe$ = 80
?AuPipeIncrementWrite@@YAXPEAU_pipe_@@@Z PROC		; AuPipeIncrementWrite, COMDAT

; 63   : void AuPipeIncrementWrite(AuPipe* pipe) {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__AA583385_pipe@cpp
	call	__CheckForDebuggerJustMyCode

; 64   : 	pipe->write_ptr++;

	mov	rax, QWORD PTR pipe$[rbp]
	mov	rax, QWORD PTR [rax+8]
	inc	rax
	mov	rcx, QWORD PTR pipe$[rbp]
	mov	QWORD PTR [rcx+8], rax

; 65   : 	if (pipe->write_ptr == pipe->size)

	mov	rax, QWORD PTR pipe$[rbp]
	mov	rcx, QWORD PTR pipe$[rbp]
	mov	rcx, QWORD PTR [rcx+24]
	cmp	QWORD PTR [rax+8], rcx
	jne	SHORT $LN2@AuPipeIncr

; 66   : 		pipe->write_ptr = 0;

	mov	rax, QWORD PTR pipe$[rbp]
	mov	QWORD PTR [rax+8], 0
$LN2@AuPipeIncr:

; 67   : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
?AuPipeIncrementWrite@@YAXPEAU_pipe_@@@Z ENDP		; AuPipeIncrementWrite
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Fs\pipe.cpp
;	COMDAT ?AuPipeIncrementRead@@YAXPEAU_pipe_@@@Z
_TEXT	SEGMENT
pipe$ = 80
?AuPipeIncrementRead@@YAXPEAU_pipe_@@@Z PROC		; AuPipeIncrementRead, COMDAT

; 57   : void AuPipeIncrementRead(AuPipe* pipe) {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__AA583385_pipe@cpp
	call	__CheckForDebuggerJustMyCode

; 58   : 	pipe->read_ptr++;

	mov	rax, QWORD PTR pipe$[rbp]
	mov	rax, QWORD PTR [rax+16]
	inc	rax
	mov	rcx, QWORD PTR pipe$[rbp]
	mov	QWORD PTR [rcx+16], rax

; 59   : 	if (pipe->read_ptr == pipe->size)

	mov	rax, QWORD PTR pipe$[rbp]
	mov	rcx, QWORD PTR pipe$[rbp]
	mov	rcx, QWORD PTR [rcx+24]
	cmp	QWORD PTR [rax+16], rcx
	jne	SHORT $LN2@AuPipeIncr

; 60   : 		pipe->read_ptr = 0;

	mov	rax, QWORD PTR pipe$[rbp]
	mov	QWORD PTR [rax+16], 0
$LN2@AuPipeIncr:

; 61   : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
?AuPipeIncrementRead@@YAXPEAU_pipe_@@@Z ENDP		; AuPipeIncrementRead
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Fs\pipe.cpp
;	COMDAT ?AuPipeGetAvailableBytes@@YA_KPEAU_pipe_@@@Z
_TEXT	SEGMENT
pipe$ = 80
?AuPipeGetAvailableBytes@@YA_KPEAU_pipe_@@@Z PROC	; AuPipeGetAvailableBytes, COMDAT

; 46   : size_t AuPipeGetAvailableBytes(AuPipe *pipe) {

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__AA583385_pipe@cpp
	call	__CheckForDebuggerJustMyCode

; 47   : 	if (pipe->read_ptr == pipe->write_ptr) 

	mov	rax, QWORD PTR pipe$[rbp]
	mov	rcx, QWORD PTR pipe$[rbp]
	mov	rcx, QWORD PTR [rcx+8]
	cmp	QWORD PTR [rax+16], rcx
	jne	SHORT $LN2@AuPipeGetA

; 48   : 		return pipe->size - 1;

	mov	rax, QWORD PTR pipe$[rbp]
	mov	rax, QWORD PTR [rax+24]
	dec	rax
	jmp	SHORT $LN1@AuPipeGetA
$LN2@AuPipeGetA:

; 49   : 
; 50   : 	if (pipe->read_ptr > pipe->write_ptr)

	mov	rax, QWORD PTR pipe$[rbp]
	mov	rcx, QWORD PTR pipe$[rbp]
	mov	rcx, QWORD PTR [rcx+8]
	cmp	QWORD PTR [rax+16], rcx
	jbe	SHORT $LN3@AuPipeGetA

; 51   : 		return pipe->read_ptr - pipe->write_ptr - 1;

	mov	rax, QWORD PTR pipe$[rbp]
	mov	rcx, QWORD PTR pipe$[rbp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	rax, QWORD PTR [rax+16]
	sub	rax, rcx
	dec	rax
	jmp	SHORT $LN1@AuPipeGetA
	jmp	SHORT $LN4@AuPipeGetA
$LN3@AuPipeGetA:

; 52   : 	else
; 53   : 		return (pipe->size - pipe->write_ptr) + pipe->read_ptr - 1;

	mov	rax, QWORD PTR pipe$[rbp]
	mov	rcx, QWORD PTR pipe$[rbp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	rax, QWORD PTR [rax+24]
	sub	rax, rcx
	mov	rcx, QWORD PTR pipe$[rbp]
	mov	rcx, QWORD PTR [rcx+16]
	lea	rax, QWORD PTR [rax+rcx-1]
$LN4@AuPipeGetA:
$LN1@AuPipeGetA:

; 54   : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
?AuPipeGetAvailableBytes@@YA_KPEAU_pipe_@@@Z ENDP	; AuPipeGetAvailableBytes
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Fs\pipe.cpp
;	COMDAT ?AuCreatePipe@@YAPEAU__VFS_NODE__@@PEAD_K@Z
_TEXT	SEGMENT
node$ = 0
pipe$ = 8
name$ = 96
sz$ = 104
?AuCreatePipe@@YAPEAU__VFS_NODE__@@PEAD_K@Z PROC	; AuCreatePipe, COMDAT

; 161  : AuVFSNode* AuCreatePipe(char* name, size_t sz) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__AA583385_pipe@cpp
	call	__CheckForDebuggerJustMyCode

; 162  : 	AuVFSNode* node = (AuVFSNode*)kmalloc(sizeof(AuVFSNode));

	mov	ecx, 178				; 000000b2H
	call	kmalloc
	mov	QWORD PTR node$[rbp], rax

; 163  : 	AuPipe *pipe = (AuPipe*)kmalloc(sizeof(AuPipe));

	mov	ecx, 56					; 00000038H
	call	kmalloc
	mov	QWORD PTR pipe$[rbp], rax

; 164  : 	memset(node, 0, sizeof(AuVFSNode));

	mov	r8d, 178				; 000000b2H
	xor	edx, edx
	mov	rcx, QWORD PTR node$[rbp]
	call	memset

; 165  : 	memset(pipe, 0, sizeof(AuPipe));

	mov	r8d, 56					; 00000038H
	xor	edx, edx
	mov	rcx, QWORD PTR pipe$[rbp]
	call	memset

; 166  : 
; 167  : 	pipe->buffer = (uint8_t*)kmalloc(sz);

	mov	ecx, DWORD PTR sz$[rbp]
	call	kmalloc
	mov	rcx, QWORD PTR pipe$[rbp]
	mov	QWORD PTR [rcx], rax

; 168  : 	pipe->readers_wait_queue = initialize_list();

	call	initialize_list
	mov	rcx, QWORD PTR pipe$[rbp]
	mov	QWORD PTR [rcx+40], rax

; 169  : 	pipe->writers_wait_queue = initialize_list();

	call	initialize_list
	mov	rcx, QWORD PTR pipe$[rbp]
	mov	QWORD PTR [rcx+48], rax

; 170  : 	pipe->size = sz;

	mov	rax, QWORD PTR pipe$[rbp]
	mov	rcx, QWORD PTR sz$[rbp]
	mov	QWORD PTR [rax+24], rcx

; 171  : 
; 172  : 	strcpy(node->filename, name);

	mov	rax, QWORD PTR node$[rbp]
	mov	rdx, QWORD PTR name$[rbp]
	mov	rcx, rax
	call	strcpy

; 173  : 	node->flags = FS_FLAG_DEVICE | FS_FLAG_PIPE;

	mov	eax, 136				; 00000088H
	mov	rcx, QWORD PTR node$[rbp]
	mov	WORD PTR [rcx+61], ax

; 174  : 	node->size = sz;

	mov	rax, QWORD PTR node$[rbp]
	mov	ecx, DWORD PTR sz$[rbp]
	mov	DWORD PTR [rax+32], ecx

; 175  : 	node->device = pipe;

	mov	rax, QWORD PTR node$[rbp]
	mov	rcx, QWORD PTR pipe$[rbp]
	mov	QWORD PTR [rax+64], rcx

; 176  : 	node->read = AuPipeRead;

	mov	rax, QWORD PTR node$[rbp]
	lea	rcx, OFFSET FLAT:?AuPipeRead@@YA_KPEAU__VFS_NODE__@@0PEA_KI@Z ; AuPipeRead
	mov	QWORD PTR [rax+90], rcx

; 177  : 	node->write = AuPipeWrite;

	mov	rax, QWORD PTR node$[rbp]
	lea	rcx, OFFSET FLAT:?AuPipeWrite@@YA_KPEAU__VFS_NODE__@@0PEA_KI@Z ; AuPipeWrite
	mov	QWORD PTR [rax+98], rcx

; 178  : 	node->open = AuPipeOpen;

	mov	rax, QWORD PTR node$[rbp]
	lea	rcx, OFFSET FLAT:?AuPipeOpen@@YAPEAU__VFS_NODE__@@PEAU1@PEAD@Z ; AuPipeOpen
	mov	QWORD PTR [rax+74], rcx

; 179  : 	node->close = AuPipeClose;

	mov	rax, QWORD PTR node$[rbp]
	lea	rcx, OFFSET FLAT:?AuPipeClose@@YAHPEAU__VFS_NODE__@@0@Z ; AuPipeClose
	mov	QWORD PTR [rax+138], rcx

; 180  : 	node->iocontrol = NULL;

	mov	rax, QWORD PTR node$[rbp]
	mov	QWORD PTR [rax+170], 0

; 181  : 	
; 182  : 	return node;

	mov	rax, QWORD PTR node$[rbp]

; 183  : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
?AuCreatePipe@@YAPEAU__VFS_NODE__@@PEAD_K@Z ENDP	; AuCreatePipe
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Fs\pipe.cpp
;	COMDAT ?AuPipeUnread@@YA_KPEAU_pipe_@@@Z
_TEXT	SEGMENT
pipe$ = 80
?AuPipeUnread@@YA_KPEAU_pipe_@@@Z PROC			; AuPipeUnread, COMDAT

; 37   : size_t AuPipeUnread(AuPipe* pipe) {

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__AA583385_pipe@cpp
	call	__CheckForDebuggerJustMyCode

; 38   : 	if (pipe->read_ptr == pipe->write_ptr)

	mov	rax, QWORD PTR pipe$[rbp]
	mov	rcx, QWORD PTR pipe$[rbp]
	mov	rcx, QWORD PTR [rcx+8]
	cmp	QWORD PTR [rax+16], rcx
	jne	SHORT $LN2@AuPipeUnre

; 39   : 		return 0; //0 bytes difference

	xor	eax, eax
	jmp	SHORT $LN1@AuPipeUnre
$LN2@AuPipeUnre:

; 40   : 	if (pipe->read_ptr > pipe->write_ptr)

	mov	rax, QWORD PTR pipe$[rbp]
	mov	rcx, QWORD PTR pipe$[rbp]
	mov	rcx, QWORD PTR [rcx+8]
	cmp	QWORD PTR [rax+16], rcx
	jbe	SHORT $LN3@AuPipeUnre

; 41   : 		return (pipe->size - pipe->read_ptr) + pipe->write_ptr;

	mov	rax, QWORD PTR pipe$[rbp]
	mov	rcx, QWORD PTR pipe$[rbp]
	mov	rcx, QWORD PTR [rcx+16]
	mov	rax, QWORD PTR [rax+24]
	sub	rax, rcx
	mov	rcx, QWORD PTR pipe$[rbp]
	add	rax, QWORD PTR [rcx+8]
	jmp	SHORT $LN1@AuPipeUnre
	jmp	SHORT $LN4@AuPipeUnre
$LN3@AuPipeUnre:

; 42   : 	else
; 43   : 		return (pipe->write_ptr - pipe->read_ptr);

	mov	rax, QWORD PTR pipe$[rbp]
	mov	rcx, QWORD PTR pipe$[rbp]
	mov	rcx, QWORD PTR [rcx+16]
	mov	rax, QWORD PTR [rax+8]
	sub	rax, rcx
$LN4@AuPipeUnre:
$LN1@AuPipeUnre:

; 44   : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
?AuPipeUnread@@YA_KPEAU_pipe_@@@Z ENDP			; AuPipeUnread
_TEXT	ENDS
END
