; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30154.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?pipeFS@@3PEAU__VFS_NODE__@@EA			; pipeFS
_BSS	SEGMENT
?pipeFS@@3PEAU__VFS_NODE__@@EA DQ 01H DUP (?)		; pipeFS
_BSS	ENDS
msvcjmc	SEGMENT
__AA583385_pipe@cpp DB 01H
msvcjmc	ENDS
PUBLIC	?AuPipeUnread@@YA_KPEAU_pipe_@@@Z		; AuPipeUnread
PUBLIC	?AuCreatePipe@@YAHPEAD_K@Z			; AuCreatePipe
PUBLIC	?AuPipeFSAddFile@@YAHPEAU__VFS_NODE__@@PEAD0@Z	; AuPipeFSAddFile
PUBLIC	?AuPipeFSInitialise@@YAXXZ			; AuPipeFSInitialise
PUBLIC	?AuPipeGetAvailableBytes@@YA_KPEAU_pipe_@@@Z	; AuPipeGetAvailableBytes
PUBLIC	?AuPipeIncrementRead@@YAXPEAU_pipe_@@@Z		; AuPipeIncrementRead
PUBLIC	?AuPipeIncrementWrite@@YAXPEAU_pipe_@@@Z	; AuPipeIncrementWrite
PUBLIC	?AuPipeIncrementWriteAmount@@YAXPEAU_pipe_@@_K@Z ; AuPipeIncrementWriteAmount
PUBLIC	?AuPipeRead@@YA_KPEAU__VFS_NODE__@@0PEA_KI@Z	; AuPipeRead
PUBLIC	?AuPipeWrite@@YA_KPEAU__VFS_NODE__@@0PEA_KI@Z	; AuPipeWrite
PUBLIC	?AuPipeOpen@@YAPEAU__VFS_NODE__@@PEAU1@PEAD@Z	; AuPipeOpen
PUBLIC	?AuPipeClose@@YAHPEAU__VFS_NODE__@@0@Z		; AuPipeClose
PUBLIC	?AuPipeFSOpen@@YAPEAU__VFS_NODE__@@PEAU1@PEAD@Z	; AuPipeFSOpen
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_0BD@LACECMDD@Pipe?5proc?5?9?$DO?5?$CFs?5?$AN?6@ ; `string'
PUBLIC	??_C@_01KMDKNFGN@?1@				; `string'
PUBLIC	??_C@_0BI@BEIFGIPP@Pipe?5Created?5?9?$DO?5?$CFd?5?$CFs?$AN?6@ ; `string'
PUBLIC	??_C@_04MKFKKHBG@pipe@				; `string'
EXTRN	initialize_list:PROC
EXTRN	list_add:PROC
EXTRN	list_get_at:PROC
EXTRN	AuVFSAddFileSystem:PROC
EXTRN	kmalloc:PROC
EXTRN	kfree:PROC
EXTRN	strcmp:PROC
EXTRN	strcpy:PROC
EXTRN	strchr:PROC
EXTRN	memset:PROC
EXTRN	SeTextOut:PROC
EXTRN	AuGetCurrentThread:PROC
EXTRN	?AuProcessFindThread@@YAPEAU_au_proc_@@PEAU_au_thread_@@@Z:PROC ; AuProcessFindThread
EXTRN	?AuProcessFindSubThread@@YAPEAU_au_proc_@@PEAU_au_thread_@@@Z:PROC ; AuProcessFindSubThread
EXTRN	?AuProcessGetFileDesc@@YAHPEAU_au_proc_@@@Z:PROC ; AuProcessGetFileDesc
EXTRN	x64_cli:PROC
EXTRN	__CheckForDebuggerJustMyCode:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuPipeUnread@@YA_KPEAU_pipe_@@@Z DD imagerel $LN6
	DD	imagerel $LN6+123
	DD	imagerel $unwind$?AuPipeUnread@@YA_KPEAU_pipe_@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuCreatePipe@@YAHPEAD_K@Z DD imagerel $LN7
	DD	imagerel $LN7+513
	DD	imagerel $unwind$?AuCreatePipe@@YAHPEAD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuPipeFSAddFile@@YAHPEAU__VFS_NODE__@@PEAD0@Z DD imagerel $LN18
	DD	imagerel $LN18+398
	DD	imagerel $unwind$?AuPipeFSAddFile@@YAHPEAU__VFS_NODE__@@PEAD0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuPipeFSInitialise@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+171
	DD	imagerel $unwind$?AuPipeFSInitialise@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuPipeGetAvailableBytes@@YA_KPEAU_pipe_@@@Z DD imagerel $LN6
	DD	imagerel $LN6+140
	DD	imagerel $unwind$?AuPipeGetAvailableBytes@@YA_KPEAU_pipe_@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuPipeIncrementRead@@YAXPEAU_pipe_@@@Z DD imagerel $LN4
	DD	imagerel $LN4+82
	DD	imagerel $unwind$?AuPipeIncrementRead@@YAXPEAU_pipe_@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuPipeIncrementWrite@@YAXPEAU_pipe_@@@Z DD imagerel $LN4
	DD	imagerel $LN4+82
	DD	imagerel $unwind$?AuPipeIncrementWrite@@YAXPEAU_pipe_@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuPipeIncrementWriteAmount@@YAXPEAU_pipe_@@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+66
	DD	imagerel $unwind$?AuPipeIncrementWriteAmount@@YAXPEAU_pipe_@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuPipeRead@@YA_KPEAU__VFS_NODE__@@0PEA_KI@Z DD imagerel $LN9
	DD	imagerel $LN9+196
	DD	imagerel $unwind$?AuPipeRead@@YA_KPEAU__VFS_NODE__@@0PEA_KI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuPipeWrite@@YA_KPEAU__VFS_NODE__@@0PEA_KI@Z DD imagerel $LN8
	DD	imagerel $LN8+203
	DD	imagerel $unwind$?AuPipeWrite@@YA_KPEAU__VFS_NODE__@@0PEA_KI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuPipeOpen@@YAPEAU__VFS_NODE__@@PEAU1@PEAD@Z DD imagerel $LN3
	DD	imagerel $LN3+73
	DD	imagerel $unwind$?AuPipeOpen@@YAPEAU__VFS_NODE__@@PEAU1@PEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuPipeClose@@YAHPEAU__VFS_NODE__@@0@Z DD imagerel $LN4
	DD	imagerel $LN4+144
	DD	imagerel $unwind$?AuPipeClose@@YAHPEAU__VFS_NODE__@@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuPipeFSOpen@@YAPEAU__VFS_NODE__@@PEAU1@PEAD@Z DD imagerel $LN21
	DD	imagerel $LN21+404
	DD	imagerel $unwind$?AuPipeFSOpen@@YAPEAU__VFS_NODE__@@PEAU1@PEAD@Z
pdata	ENDS
;	COMDAT ??_C@_04MKFKKHBG@pipe@
CONST	SEGMENT
??_C@_04MKFKKHBG@pipe@ DB 'pipe', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@BEIFGIPP@Pipe?5Created?5?9?$DO?5?$CFd?5?$CFs?$AN?6@
CONST	SEGMENT
??_C@_0BI@BEIFGIPP@Pipe?5Created?5?9?$DO?5?$CFd?5?$CFs?$AN?6@ DB 'Pipe Cr'
	DB	'eated -> %d %s', 0dH, 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01KMDKNFGN@?1@
CONST	SEGMENT
??_C@_01KMDKNFGN@?1@ DB '/', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@LACECMDD@Pipe?5proc?5?9?$DO?5?$CFs?5?$AN?6@
CONST	SEGMENT
??_C@_0BD@LACECMDD@Pipe?5proc?5?9?$DO?5?$CFs?5?$AN?6@ DB 'Pipe proc -> %s'
	DB	' ', 0dH, 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuPipeFSOpen@@YAPEAU__VFS_NODE__@@PEAU1@PEAD@Z DD 025041701H
	DD	01122317H
	DD	0500b0014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuPipeClose@@YAHPEAU__VFS_NODE__@@0@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuPipeOpen@@YAPEAU__VFS_NODE__@@PEAU1@PEAD@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuPipeWrite@@YA_KPEAU__VFS_NODE__@@0PEA_KI@Z DD 025032101H
	DD	0f21c2321H
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuPipeRead@@YA_KPEAU__VFS_NODE__@@0PEA_KI@Z DD 025032101H
	DD	0f21c2321H
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuPipeIncrementWriteAmount@@YAXPEAU_pipe_@@_K@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuPipeIncrementWrite@@YAXPEAU_pipe_@@@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuPipeIncrementRead@@YAXPEAU_pipe_@@@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuPipeGetAvailableBytes@@YA_KPEAU_pipe_@@@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuPipeFSInitialise@@YAXXZ DD 025030b01H
	DD	0d206230bH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuPipeFSAddFile@@YAHPEAU__VFS_NODE__@@PEAD0@Z DD 025041c01H
	DD	0117231cH
	DD	050100014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuCreatePipe@@YAHPEAD_K@Z DD 025041701H
	DD	01122317H
	DD	0500b0012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuPipeUnread@@YA_KPEAU_pipe_@@@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Fs\pipe.cpp
;	COMDAT ?AuPipeFSOpen@@YAPEAU__VFS_NODE__@@PEAU1@PEAD@Z
_TEXT	SEGMENT
entries$ = 0
next$ = 8
first_list$ = 16
node_to_ret$ = 24
pathname$1 = 32
i$2 = 48
j$3 = 52
node_$4 = 56
fs$ = 144
path$ = 152
?AuPipeFSOpen@@YAPEAU__VFS_NODE__@@PEAU1@PEAD@Z PROC	; AuPipeFSOpen, COMDAT

; 259  : AuVFSNode* AuPipeFSOpen(AuVFSNode* fs, char* path) {

$LN21:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 160				; 000000a0H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__AA583385_pipe@cpp
	call	__CheckForDebuggerJustMyCode

; 260  : 	AuVFSContainer* entries = (AuVFSContainer*)fs->device;

	mov	rax, QWORD PTR fs$[rbp]
	mov	rax, QWORD PTR [rax+64]
	mov	QWORD PTR entries$[rbp], rax

; 261  : 	/* now verify the path and add the directory to the list */
; 262  : 	char* next = strchr(path, '/');

	mov	edx, 47					; 0000002fH
	mov	rcx, QWORD PTR path$[rbp]
	call	strchr
	mov	QWORD PTR next$[rbp], rax

; 263  : 	if (next)

	cmp	QWORD PTR next$[rbp], 0
	je	SHORT $LN10@AuPipeFSOp

; 264  : 		next++;

	mov	rax, QWORD PTR next$[rbp]
	inc	rax
	mov	QWORD PTR next$[rbp], rax
$LN10@AuPipeFSOp:

; 265  : 
; 266  : 	AuVFSContainer* first_list = entries;

	mov	rax, QWORD PTR entries$[rbp]
	mov	QWORD PTR first_list$[rbp], rax

; 267  : 	AuVFSNode* node_to_ret = NULL;

	mov	QWORD PTR node_to_ret$[rbp], 0
$LN2@AuPipeFSOp:

; 268  : 	while (next) {

	cmp	QWORD PTR next$[rbp], 0
	je	$LN3@AuPipeFSOp

; 269  : 		char pathname[16];
; 270  : 		int i;
; 271  : 		for (i = 0; i < 16; i++) {

	mov	DWORD PTR i$2[rbp], 0
	jmp	SHORT $LN6@AuPipeFSOp
$LN4@AuPipeFSOp:
	mov	eax, DWORD PTR i$2[rbp]
	inc	eax
	mov	DWORD PTR i$2[rbp], eax
$LN6@AuPipeFSOp:
	cmp	DWORD PTR i$2[rbp], 16
	jge	SHORT $LN5@AuPipeFSOp

; 272  : 			if (next[i] == '/' || next[i] == '\0')

	movsxd	rax, DWORD PTR i$2[rbp]
	mov	rcx, QWORD PTR next$[rbp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 47					; 0000002fH
	je	SHORT $LN12@AuPipeFSOp
	movsxd	rax, DWORD PTR i$2[rbp]
	mov	rcx, QWORD PTR next$[rbp]
	movsx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	jne	SHORT $LN11@AuPipeFSOp
$LN12@AuPipeFSOp:

; 273  : 				break;

	jmp	SHORT $LN5@AuPipeFSOp
$LN11@AuPipeFSOp:

; 274  : 			pathname[i] = next[i];

	movsxd	rax, DWORD PTR i$2[rbp]
	movsxd	rcx, DWORD PTR i$2[rbp]
	mov	rdx, QWORD PTR next$[rbp]
	movzx	eax, BYTE PTR [rdx+rax]
	mov	BYTE PTR pathname$1[rbp+rcx], al

; 275  : 		}

	jmp	SHORT $LN4@AuPipeFSOp
$LN5@AuPipeFSOp:

; 276  : 		pathname[i] = 0;

	movsxd	rax, DWORD PTR i$2[rbp]
	mov	BYTE PTR pathname$1[rbp+rax], 0

; 277  : 
; 278  : 		for (int j = 0; j < first_list->childs->pointer; j++) {

	mov	DWORD PTR j$3[rbp], 0
	jmp	SHORT $LN9@AuPipeFSOp
$LN7@AuPipeFSOp:
	mov	eax, DWORD PTR j$3[rbp]
	inc	eax
	mov	DWORD PTR j$3[rbp], eax
$LN9@AuPipeFSOp:
	mov	rax, QWORD PTR first_list$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	eax, DWORD PTR [rax]
	cmp	DWORD PTR j$3[rbp], eax
	jae	SHORT $LN8@AuPipeFSOp

; 279  : 			AuVFSNode* node_ = (AuVFSNode*)list_get_at(first_list->childs, j);

	mov	edx, DWORD PTR j$3[rbp]
	mov	rax, QWORD PTR first_list$[rbp]
	mov	rcx, QWORD PTR [rax]
	call	list_get_at
	mov	QWORD PTR node_$4[rbp], rax

; 280  : 			if (strcmp(node_->filename, pathname) == 0) {

	mov	rax, QWORD PTR node_$4[rbp]
	lea	rdx, QWORD PTR pathname$1[rbp]
	mov	rcx, rax
	call	strcmp
	test	eax, eax
	jne	SHORT $LN13@AuPipeFSOp

; 281  : 				if (node_->flags & FS_FLAG_DIRECTORY)

	mov	rax, QWORD PTR node_$4[rbp]
	movzx	eax, WORD PTR [rax+61]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN14@AuPipeFSOp

; 282  : 					first_list = (AuVFSContainer*)node_->device;

	mov	rax, QWORD PTR node_$4[rbp]
	mov	rax, QWORD PTR [rax+64]
	mov	QWORD PTR first_list$[rbp], rax
	jmp	SHORT $LN15@AuPipeFSOp
$LN14@AuPipeFSOp:

; 283  : 				else if (node_->flags & FS_FLAG_PIPE)

	mov	rax, QWORD PTR node_$4[rbp]
	movzx	eax, WORD PTR [rax+61]
	and	eax, 128				; 00000080H
	test	eax, eax
	je	SHORT $LN16@AuPipeFSOp

; 284  : 					node_to_ret = node_;

	mov	rax, QWORD PTR node_$4[rbp]
	mov	QWORD PTR node_to_ret$[rbp], rax
$LN16@AuPipeFSOp:
$LN15@AuPipeFSOp:
$LN13@AuPipeFSOp:

; 285  : 			}
; 286  : 		}

	jmp	SHORT $LN7@AuPipeFSOp
$LN8@AuPipeFSOp:

; 287  : 
; 288  : 		next = strchr(next + 1, '/');

	mov	rax, QWORD PTR next$[rbp]
	inc	rax
	mov	edx, 47					; 0000002fH
	mov	rcx, rax
	call	strchr
	mov	QWORD PTR next$[rbp], rax

; 289  : 		if (next)

	cmp	QWORD PTR next$[rbp], 0
	je	SHORT $LN17@AuPipeFSOp

; 290  : 			next++;

	mov	rax, QWORD PTR next$[rbp]
	inc	rax
	mov	QWORD PTR next$[rbp], rax
$LN17@AuPipeFSOp:

; 291  : 	}

	jmp	$LN2@AuPipeFSOp
$LN3@AuPipeFSOp:

; 292  : 
; 293  : 	if (node_to_ret)

	cmp	QWORD PTR node_to_ret$[rbp], 0
	je	SHORT $LN18@AuPipeFSOp

; 294  : 		return node_to_ret;

	mov	rax, QWORD PTR node_to_ret$[rbp]
	jmp	SHORT $LN1@AuPipeFSOp
	jmp	SHORT $LN19@AuPipeFSOp
$LN18@AuPipeFSOp:

; 295  : 	else
; 296  : 		return NULL;

	xor	eax, eax
$LN19@AuPipeFSOp:
$LN1@AuPipeFSOp:

; 297  : }

	lea	rsp, QWORD PTR [rbp+128]
	pop	rbp
	ret	0
?AuPipeFSOpen@@YAPEAU__VFS_NODE__@@PEAU1@PEAD@Z ENDP	; AuPipeFSOpen
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Fs\pipe.cpp
;	COMDAT ?AuPipeClose@@YAHPEAU__VFS_NODE__@@0@Z
_TEXT	SEGMENT
pipe$ = 0
fs$ = 96
file$ = 104
?AuPipeClose@@YAHPEAU__VFS_NODE__@@0@Z PROC		; AuPipeClose, COMDAT

; 143  : int AuPipeClose(AuVFSNode* fs, AuVFSNode* file) {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__AA583385_pipe@cpp
	call	__CheckForDebuggerJustMyCode

; 144  : 	AuPipe* pipe = (AuPipe*)fs->device;

	mov	rax, QWORD PTR fs$[rbp]
	mov	rax, QWORD PTR [rax+64]
	mov	QWORD PTR pipe$[rbp], rax

; 145  : 	pipe->refcount--;

	mov	rax, QWORD PTR pipe$[rbp]
	mov	rax, QWORD PTR [rax+32]
	dec	rax
	mov	rcx, QWORD PTR pipe$[rbp]
	mov	QWORD PTR [rcx+32], rax

; 146  : 	if (pipe->refcount == 0) {

	mov	rax, QWORD PTR pipe$[rbp]
	cmp	QWORD PTR [rax+32], 0
	jne	SHORT $LN2@AuPipeClos

; 147  : 		kfree(pipe->buffer);

	mov	rax, QWORD PTR pipe$[rbp]
	mov	rcx, QWORD PTR [rax]
	call	kfree

; 148  : 		kfree(pipe->readers_wait_queue);

	mov	rax, QWORD PTR pipe$[rbp]
	mov	rcx, QWORD PTR [rax+40]
	call	kfree

; 149  : 		kfree(pipe->writers_wait_queue);

	mov	rax, QWORD PTR pipe$[rbp]
	mov	rcx, QWORD PTR [rax+48]
	call	kfree

; 150  : 		kfree(pipe);

	mov	rcx, QWORD PTR pipe$[rbp]
	call	kfree

; 151  : 		fs->device = NULL;

	mov	rax, QWORD PTR fs$[rbp]
	mov	QWORD PTR [rax+64], 0
$LN2@AuPipeClos:

; 152  : 	}
; 153  : 	return 1;

	mov	eax, 1

; 154  : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
?AuPipeClose@@YAHPEAU__VFS_NODE__@@0@Z ENDP		; AuPipeClose
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Fs\pipe.cpp
;	COMDAT ?AuPipeOpen@@YAPEAU__VFS_NODE__@@PEAU1@PEAD@Z
_TEXT	SEGMENT
pipe$ = 0
node$ = 96
path$ = 104
?AuPipeOpen@@YAPEAU__VFS_NODE__@@PEAU1@PEAD@Z PROC	; AuPipeOpen, COMDAT

; 132  : AuVFSNode* AuPipeOpen(AuVFSNode *node, char* path){

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__AA583385_pipe@cpp
	call	__CheckForDebuggerJustMyCode

; 133  : 	AuPipe* pipe = (AuPipe*)node->device;

	mov	rax, QWORD PTR node$[rbp]
	mov	rax, QWORD PTR [rax+64]
	mov	QWORD PTR pipe$[rbp], rax

; 134  : 	pipe->refcount++;

	mov	rax, QWORD PTR pipe$[rbp]
	mov	rax, QWORD PTR [rax+32]
	inc	rax
	mov	rcx, QWORD PTR pipe$[rbp]
	mov	QWORD PTR [rcx+32], rax

; 135  : 	return node;

	mov	rax, QWORD PTR node$[rbp]

; 136  : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
?AuPipeOpen@@YAPEAU__VFS_NODE__@@PEAU1@PEAD@Z ENDP	; AuPipeOpen
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Fs\pipe.cpp
;	COMDAT ?AuPipeWrite@@YA_KPEAU__VFS_NODE__@@0PEA_KI@Z
_TEXT	SEGMENT
aligned_buff$ = 0
pipe$ = 8
written$ = 16
fs$ = 112
file$ = 120
buffer$ = 128
length$ = 136
?AuPipeWrite@@YA_KPEAU__VFS_NODE__@@0PEA_KI@Z PROC	; AuPipeWrite, COMDAT

; 116  : size_t AuPipeWrite(AuVFSNode *fs, AuVFSNode *file, uint64_t* buffer, uint32_t length) {

$LN8:
	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 128				; 00000080H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__AA583385_pipe@cpp
	call	__CheckForDebuggerJustMyCode

; 117  : 	uint8_t* aligned_buff = (uint8_t*)buffer;

	mov	rax, QWORD PTR buffer$[rbp]
	mov	QWORD PTR aligned_buff$[rbp], rax

; 118  : 	AuPipe* pipe = (AuPipe*)fs->device;

	mov	rax, QWORD PTR fs$[rbp]
	mov	rax, QWORD PTR [rax+64]
	mov	QWORD PTR pipe$[rbp], rax

; 119  : 	size_t written = 0;

	mov	QWORD PTR written$[rbp], 0
$LN2@AuPipeWrit:

; 120  : 	while (written < length) {

	mov	eax, DWORD PTR length$[rbp]
	cmp	QWORD PTR written$[rbp], rax
	jae	SHORT $LN3@AuPipeWrit

; 121  : 		if (AuPipeGetAvailableBytes(pipe) > length) {

	mov	rcx, QWORD PTR pipe$[rbp]
	call	?AuPipeGetAvailableBytes@@YA_KPEAU_pipe_@@@Z ; AuPipeGetAvailableBytes
	mov	ecx, DWORD PTR length$[rbp]
	cmp	rax, rcx
	jbe	SHORT $LN6@AuPipeWrit
$LN4@AuPipeWrit:

; 122  : 			while (AuPipeGetAvailableBytes(pipe) > 0 && written < length) {

	mov	rcx, QWORD PTR pipe$[rbp]
	call	?AuPipeGetAvailableBytes@@YA_KPEAU_pipe_@@@Z ; AuPipeGetAvailableBytes
	test	rax, rax
	jbe	SHORT $LN5@AuPipeWrit
	mov	eax, DWORD PTR length$[rbp]
	cmp	QWORD PTR written$[rbp], rax
	jae	SHORT $LN5@AuPipeWrit

; 123  : 				pipe->buffer[pipe->write_ptr] = aligned_buff[written];

	mov	rax, QWORD PTR pipe$[rbp]
	mov	rax, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR pipe$[rbp]
	mov	rcx, QWORD PTR [rcx]
	mov	rdx, QWORD PTR written$[rbp]
	mov	r8, QWORD PTR aligned_buff$[rbp]
	add	r8, rdx
	mov	rdx, r8
	movzx	edx, BYTE PTR [rdx]
	mov	BYTE PTR [rcx+rax], dl

; 124  : 				AuPipeIncrementWrite(pipe);

	mov	rcx, QWORD PTR pipe$[rbp]
	call	?AuPipeIncrementWrite@@YAXPEAU_pipe_@@@Z ; AuPipeIncrementWrite

; 125  : 				written++;

	mov	rax, QWORD PTR written$[rbp]
	inc	rax
	mov	QWORD PTR written$[rbp], rax

; 126  : 			}

	jmp	SHORT $LN4@AuPipeWrit
$LN5@AuPipeWrit:
$LN6@AuPipeWrit:

; 127  : 		}
; 128  : 	}

	jmp	SHORT $LN2@AuPipeWrit
$LN3@AuPipeWrit:

; 129  : 	return written;

	mov	rax, QWORD PTR written$[rbp]

; 130  : }

	lea	rsp, QWORD PTR [rbp+96]
	pop	rbp
	ret	0
?AuPipeWrite@@YA_KPEAU__VFS_NODE__@@0PEA_KI@Z ENDP	; AuPipeWrite
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Fs\pipe.cpp
;	COMDAT ?AuPipeRead@@YA_KPEAU__VFS_NODE__@@0PEA_KI@Z
_TEXT	SEGMENT
aligned_buff$ = 0
pipe$ = 8
collected$ = 16
fs$ = 112
file$ = 120
buffer$ = 128
length$ = 136
?AuPipeRead@@YA_KPEAU__VFS_NODE__@@0PEA_KI@Z PROC	; AuPipeRead, COMDAT

; 89   : size_t AuPipeRead(AuVFSNode *fs, AuVFSNode *file, uint64_t* buffer, uint32_t length) {

$LN9:
	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 128				; 00000080H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__AA583385_pipe@cpp
	call	__CheckForDebuggerJustMyCode

; 90   : 	uint8_t* aligned_buff = (uint8_t*)buffer;

	mov	rax, QWORD PTR buffer$[rbp]
	mov	QWORD PTR aligned_buff$[rbp], rax

; 91   : 	AuPipe *pipe = (AuPipe*)fs->device;

	mov	rax, QWORD PTR fs$[rbp]
	mov	rax, QWORD PTR [rax+64]
	mov	QWORD PTR pipe$[rbp], rax

; 92   : 	size_t collected = 0;

	mov	QWORD PTR collected$[rbp], 0
$LN2@AuPipeRead:

; 93   : 	while (collected == 0) {

	cmp	QWORD PTR collected$[rbp], 0
	jne	SHORT $LN3@AuPipeRead

; 94   : 		if (AuPipeUnread(pipe) > 0) {

	mov	rcx, QWORD PTR pipe$[rbp]
	call	?AuPipeUnread@@YA_KPEAU_pipe_@@@Z	; AuPipeUnread
	test	rax, rax
	jbe	SHORT $LN6@AuPipeRead
$LN4@AuPipeRead:

; 95   : 			while (AuPipeUnread(pipe) > 0 && collected < length) {

	mov	rcx, QWORD PTR pipe$[rbp]
	call	?AuPipeUnread@@YA_KPEAU_pipe_@@@Z	; AuPipeUnread
	test	rax, rax
	jbe	SHORT $LN5@AuPipeRead
	mov	eax, DWORD PTR length$[rbp]
	cmp	QWORD PTR collected$[rbp], rax
	jae	SHORT $LN5@AuPipeRead

; 96   : 				aligned_buff[collected] = pipe->buffer[pipe->read_ptr];

	mov	rax, QWORD PTR pipe$[rbp]
	mov	rax, QWORD PTR [rax+16]
	mov	rcx, QWORD PTR pipe$[rbp]
	mov	rcx, QWORD PTR [rcx]
	mov	rdx, QWORD PTR collected$[rbp]
	mov	r8, QWORD PTR aligned_buff$[rbp]
	add	r8, rdx
	mov	rdx, r8
	movzx	eax, BYTE PTR [rcx+rax]
	mov	BYTE PTR [rdx], al

; 97   : 				AuPipeIncrementRead(pipe);

	mov	rcx, QWORD PTR pipe$[rbp]
	call	?AuPipeIncrementRead@@YAXPEAU_pipe_@@@Z	; AuPipeIncrementRead

; 98   : 				collected++;

	mov	rax, QWORD PTR collected$[rbp]
	inc	rax
	mov	QWORD PTR collected$[rbp], rax

; 99   : 			}

	jmp	SHORT $LN4@AuPipeRead
$LN5@AuPipeRead:

; 100  : 			
; 101  : 		}

	jmp	SHORT $LN7@AuPipeRead
$LN6@AuPipeRead:

; 102  : 		else 
; 103  : 			break;

	jmp	SHORT $LN3@AuPipeRead
$LN7@AuPipeRead:

; 104  : 	}

	jmp	SHORT $LN2@AuPipeRead
$LN3@AuPipeRead:

; 105  : 
; 106  : 	return collected;

	mov	rax, QWORD PTR collected$[rbp]

; 107  : }

	lea	rsp, QWORD PTR [rbp+96]
	pop	rbp
	ret	0
?AuPipeRead@@YA_KPEAU__VFS_NODE__@@0PEA_KI@Z ENDP	; AuPipeRead
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Fs\pipe.cpp
;	COMDAT ?AuPipeIncrementWriteAmount@@YAXPEAU_pipe_@@_K@Z
_TEXT	SEGMENT
pipe$ = 80
amount$ = 88
?AuPipeIncrementWriteAmount@@YAXPEAU_pipe_@@_K@Z PROC	; AuPipeIncrementWriteAmount, COMDAT

; 78   : void AuPipeIncrementWriteAmount(AuPipe* pipe, size_t amount) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__AA583385_pipe@cpp
	call	__CheckForDebuggerJustMyCode

; 79   : 	pipe->write_ptr = (pipe->write_ptr + amount) & pipe->size;

	mov	rax, QWORD PTR pipe$[rbp]
	mov	rax, QWORD PTR [rax+8]
	add	rax, QWORD PTR amount$[rbp]
	mov	rcx, QWORD PTR pipe$[rbp]
	and	rax, QWORD PTR [rcx+24]
	mov	rcx, QWORD PTR pipe$[rbp]
	mov	QWORD PTR [rcx+8], rax

; 80   : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
?AuPipeIncrementWriteAmount@@YAXPEAU_pipe_@@_K@Z ENDP	; AuPipeIncrementWriteAmount
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Fs\pipe.cpp
;	COMDAT ?AuPipeIncrementWrite@@YAXPEAU_pipe_@@@Z
_TEXT	SEGMENT
pipe$ = 80
?AuPipeIncrementWrite@@YAXPEAU_pipe_@@@Z PROC		; AuPipeIncrementWrite, COMDAT

; 66   : void AuPipeIncrementWrite(AuPipe* pipe) {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__AA583385_pipe@cpp
	call	__CheckForDebuggerJustMyCode

; 67   : 	pipe->write_ptr++;

	mov	rax, QWORD PTR pipe$[rbp]
	mov	rax, QWORD PTR [rax+8]
	inc	rax
	mov	rcx, QWORD PTR pipe$[rbp]
	mov	QWORD PTR [rcx+8], rax

; 68   : 	if (pipe->write_ptr == pipe->size)

	mov	rax, QWORD PTR pipe$[rbp]
	mov	rcx, QWORD PTR pipe$[rbp]
	mov	rcx, QWORD PTR [rcx+24]
	cmp	QWORD PTR [rax+8], rcx
	jne	SHORT $LN2@AuPipeIncr

; 69   : 		pipe->write_ptr = 0;

	mov	rax, QWORD PTR pipe$[rbp]
	mov	QWORD PTR [rax+8], 0
$LN2@AuPipeIncr:

; 70   : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
?AuPipeIncrementWrite@@YAXPEAU_pipe_@@@Z ENDP		; AuPipeIncrementWrite
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Fs\pipe.cpp
;	COMDAT ?AuPipeIncrementRead@@YAXPEAU_pipe_@@@Z
_TEXT	SEGMENT
pipe$ = 80
?AuPipeIncrementRead@@YAXPEAU_pipe_@@@Z PROC		; AuPipeIncrementRead, COMDAT

; 60   : void AuPipeIncrementRead(AuPipe* pipe) {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__AA583385_pipe@cpp
	call	__CheckForDebuggerJustMyCode

; 61   : 	pipe->read_ptr++;

	mov	rax, QWORD PTR pipe$[rbp]
	mov	rax, QWORD PTR [rax+16]
	inc	rax
	mov	rcx, QWORD PTR pipe$[rbp]
	mov	QWORD PTR [rcx+16], rax

; 62   : 	if (pipe->read_ptr == pipe->size)

	mov	rax, QWORD PTR pipe$[rbp]
	mov	rcx, QWORD PTR pipe$[rbp]
	mov	rcx, QWORD PTR [rcx+24]
	cmp	QWORD PTR [rax+16], rcx
	jne	SHORT $LN2@AuPipeIncr

; 63   : 		pipe->read_ptr = 0;

	mov	rax, QWORD PTR pipe$[rbp]
	mov	QWORD PTR [rax+16], 0
$LN2@AuPipeIncr:

; 64   : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
?AuPipeIncrementRead@@YAXPEAU_pipe_@@@Z ENDP		; AuPipeIncrementRead
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Fs\pipe.cpp
;	COMDAT ?AuPipeGetAvailableBytes@@YA_KPEAU_pipe_@@@Z
_TEXT	SEGMENT
pipe$ = 80
?AuPipeGetAvailableBytes@@YA_KPEAU_pipe_@@@Z PROC	; AuPipeGetAvailableBytes, COMDAT

; 49   : size_t AuPipeGetAvailableBytes(AuPipe *pipe) {

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__AA583385_pipe@cpp
	call	__CheckForDebuggerJustMyCode

; 50   : 	if (pipe->read_ptr == pipe->write_ptr) 

	mov	rax, QWORD PTR pipe$[rbp]
	mov	rcx, QWORD PTR pipe$[rbp]
	mov	rcx, QWORD PTR [rcx+8]
	cmp	QWORD PTR [rax+16], rcx
	jne	SHORT $LN2@AuPipeGetA

; 51   : 		return pipe->size - 1;

	mov	rax, QWORD PTR pipe$[rbp]
	mov	rax, QWORD PTR [rax+24]
	dec	rax
	jmp	SHORT $LN1@AuPipeGetA
$LN2@AuPipeGetA:

; 52   : 
; 53   : 	if (pipe->read_ptr > pipe->write_ptr)

	mov	rax, QWORD PTR pipe$[rbp]
	mov	rcx, QWORD PTR pipe$[rbp]
	mov	rcx, QWORD PTR [rcx+8]
	cmp	QWORD PTR [rax+16], rcx
	jbe	SHORT $LN3@AuPipeGetA

; 54   : 		return pipe->read_ptr - pipe->write_ptr - 1;

	mov	rax, QWORD PTR pipe$[rbp]
	mov	rcx, QWORD PTR pipe$[rbp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	rax, QWORD PTR [rax+16]
	sub	rax, rcx
	dec	rax
	jmp	SHORT $LN1@AuPipeGetA
	jmp	SHORT $LN4@AuPipeGetA
$LN3@AuPipeGetA:

; 55   : 	else
; 56   : 		return (pipe->size - pipe->write_ptr) + pipe->read_ptr - 1;

	mov	rax, QWORD PTR pipe$[rbp]
	mov	rcx, QWORD PTR pipe$[rbp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	rax, QWORD PTR [rax+24]
	sub	rax, rcx
	mov	rcx, QWORD PTR pipe$[rbp]
	mov	rcx, QWORD PTR [rcx+16]
	lea	rax, QWORD PTR [rax+rcx-1]
$LN4@AuPipeGetA:
$LN1@AuPipeGetA:

; 57   : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
?AuPipeGetAvailableBytes@@YA_KPEAU_pipe_@@@Z ENDP	; AuPipeGetAvailableBytes
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Fs\pipe.cpp
;	COMDAT ?AuPipeFSInitialise@@YAXXZ
_TEXT	SEGMENT
entries$ = 0
node$ = 8
?AuPipeFSInitialise@@YAXXZ PROC				; AuPipeFSInitialise, COMDAT

; 302  : void AuPipeFSInitialise() {

$LN3:
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__AA583385_pipe@cpp
	call	__CheckForDebuggerJustMyCode

; 303  : 	AuVFSContainer* entries = (AuVFSContainer*)kmalloc(sizeof(AuVFSContainer));

	mov	ecx, 8
	call	kmalloc
	mov	QWORD PTR entries$[rbp], rax

; 304  : 	entries->childs = initialize_list();

	call	initialize_list
	mov	rcx, QWORD PTR entries$[rbp]
	mov	QWORD PTR [rcx], rax

; 305  : 
; 306  : 	AuVFSNode* node = (AuVFSNode*)kmalloc(sizeof(AuVFSNode));

	mov	ecx, 178				; 000000b2H
	call	kmalloc
	mov	QWORD PTR node$[rbp], rax

; 307  : 	memset(node, 0, sizeof(AuVFSNode));

	mov	r8d, 178				; 000000b2H
	xor	edx, edx
	mov	rcx, QWORD PTR node$[rbp]
	call	memset

; 308  : 	strcpy(node->filename, "pipe");

	mov	rax, QWORD PTR node$[rbp]
	lea	rdx, OFFSET FLAT:??_C@_04MKFKKHBG@pipe@
	mov	rcx, rax
	call	strcpy

; 309  : 	node->device = entries;

	mov	rax, QWORD PTR node$[rbp]
	mov	rcx, QWORD PTR entries$[rbp]
	mov	QWORD PTR [rax+64], rcx

; 310  : 	node->flags |= FS_FLAG_FILE_SYSTEM;

	mov	rax, QWORD PTR node$[rbp]
	movzx	eax, WORD PTR [rax+61]
	or	eax, 64					; 00000040H
	mov	rcx, QWORD PTR node$[rbp]
	mov	WORD PTR [rcx+61], ax

; 311  : 	node->open = AuPipeFSOpen;

	mov	rax, QWORD PTR node$[rbp]
	lea	rcx, OFFSET FLAT:?AuPipeFSOpen@@YAPEAU__VFS_NODE__@@PEAU1@PEAD@Z ; AuPipeFSOpen
	mov	QWORD PTR [rax+74], rcx

; 312  : 	AuVFSAddFileSystem(node);

	mov	rcx, QWORD PTR node$[rbp]
	call	AuVFSAddFileSystem

; 313  : 
; 314  : 	pipeFS = node;

	mov	rax, QWORD PTR node$[rbp]
	mov	QWORD PTR ?pipeFS@@3PEAU__VFS_NODE__@@EA, rax ; pipeFS

; 315  : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
?AuPipeFSInitialise@@YAXXZ ENDP				; AuPipeFSInitialise
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Fs\pipe.cpp
;	COMDAT ?AuPipeFSAddFile@@YAHPEAU__VFS_NODE__@@PEAD0@Z
_TEXT	SEGMENT
entries$ = 0
next$ = 8
first_list$ = 16
pathname$ = 24
i$1 = 40
j$2 = 44
node_$3 = 48
fs$ = 144
path$ = 152
file$ = 160
?AuPipeFSAddFile@@YAHPEAU__VFS_NODE__@@PEAD0@Z PROC	; AuPipeFSAddFile, COMDAT

; 162  : int AuPipeFSAddFile(AuVFSNode* fs, char* path, AuVFSNode* file) {

$LN18:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 160				; 000000a0H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__AA583385_pipe@cpp
	call	__CheckForDebuggerJustMyCode

; 163  : 	AuVFSContainer* entries = (AuVFSContainer*)fs->device;

	mov	rax, QWORD PTR fs$[rbp]
	mov	rax, QWORD PTR [rax+64]
	mov	QWORD PTR entries$[rbp], rax

; 164  : 	if (!entries)

	cmp	QWORD PTR entries$[rbp], 0
	jne	SHORT $LN10@AuPipeFSAd

; 165  : 		return -1;

	mov	eax, -1
	jmp	$LN1@AuPipeFSAd
$LN10@AuPipeFSAd:

; 166  : 
; 167  : 	char* next = strchr(path, '/');

	mov	edx, 47					; 0000002fH
	mov	rcx, QWORD PTR path$[rbp]
	call	strchr
	mov	QWORD PTR next$[rbp], rax

; 168  : 	if (next)

	cmp	QWORD PTR next$[rbp], 0
	je	SHORT $LN11@AuPipeFSAd

; 169  : 		next++;

	mov	rax, QWORD PTR next$[rbp]
	inc	rax
	mov	QWORD PTR next$[rbp], rax
$LN11@AuPipeFSAd:

; 170  : 
; 171  : 	AuVFSContainer* first_list = entries;

	mov	rax, QWORD PTR entries$[rbp]
	mov	QWORD PTR first_list$[rbp], rax
$LN2@AuPipeFSAd:

; 172  : 	char pathname[16];
; 173  : 	while (next) {

	cmp	QWORD PTR next$[rbp], 0
	je	$LN3@AuPipeFSAd

; 174  : 		int i;
; 175  : 		for (i = 0; i < 16; i++) {

	mov	DWORD PTR i$1[rbp], 0
	jmp	SHORT $LN6@AuPipeFSAd
$LN4@AuPipeFSAd:
	mov	eax, DWORD PTR i$1[rbp]
	inc	eax
	mov	DWORD PTR i$1[rbp], eax
$LN6@AuPipeFSAd:
	cmp	DWORD PTR i$1[rbp], 16
	jge	SHORT $LN5@AuPipeFSAd

; 176  : 			if (next[i] == '/' || next[i] == '\0')

	movsxd	rax, DWORD PTR i$1[rbp]
	mov	rcx, QWORD PTR next$[rbp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 47					; 0000002fH
	je	SHORT $LN13@AuPipeFSAd
	movsxd	rax, DWORD PTR i$1[rbp]
	mov	rcx, QWORD PTR next$[rbp]
	movsx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	jne	SHORT $LN12@AuPipeFSAd
$LN13@AuPipeFSAd:

; 177  : 				break;

	jmp	SHORT $LN5@AuPipeFSAd
$LN12@AuPipeFSAd:

; 178  : 			pathname[i] = next[i];

	movsxd	rax, DWORD PTR i$1[rbp]
	movsxd	rcx, DWORD PTR i$1[rbp]
	mov	rdx, QWORD PTR next$[rbp]
	movzx	eax, BYTE PTR [rdx+rax]
	mov	BYTE PTR pathname$[rbp+rcx], al

; 179  : 		}

	jmp	SHORT $LN4@AuPipeFSAd
$LN5@AuPipeFSAd:

; 180  : 		pathname[i] = 0;

	movsxd	rax, DWORD PTR i$1[rbp]
	mov	BYTE PTR pathname$[rbp+rax], 0

; 181  : 
; 182  : 		for (int j = 0; j < first_list->childs->pointer; j++) {

	mov	DWORD PTR j$2[rbp], 0
	jmp	SHORT $LN9@AuPipeFSAd
$LN7@AuPipeFSAd:
	mov	eax, DWORD PTR j$2[rbp]
	inc	eax
	mov	DWORD PTR j$2[rbp], eax
$LN9@AuPipeFSAd:
	mov	rax, QWORD PTR first_list$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	eax, DWORD PTR [rax]
	cmp	DWORD PTR j$2[rbp], eax
	jae	SHORT $LN8@AuPipeFSAd

; 183  : 			AuVFSNode* node_ = (AuVFSNode*)list_get_at(first_list->childs, j);

	mov	edx, DWORD PTR j$2[rbp]
	mov	rax, QWORD PTR first_list$[rbp]
	mov	rcx, QWORD PTR [rax]
	call	list_get_at
	mov	QWORD PTR node_$3[rbp], rax

; 184  : 			if (strcmp(node_->filename, pathname) == 0) {

	mov	rax, QWORD PTR node_$3[rbp]
	lea	rdx, QWORD PTR pathname$[rbp]
	mov	rcx, rax
	call	strcmp
	test	eax, eax
	jne	SHORT $LN14@AuPipeFSAd

; 185  : 				if (node_->flags & FS_FLAG_DIRECTORY)

	mov	rax, QWORD PTR node_$3[rbp]
	movzx	eax, WORD PTR [rax+61]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN15@AuPipeFSAd

; 186  : 					first_list = (AuVFSContainer*)node_->device;

	mov	rax, QWORD PTR node_$3[rbp]
	mov	rax, QWORD PTR [rax+64]
	mov	QWORD PTR first_list$[rbp], rax
$LN15@AuPipeFSAd:
$LN14@AuPipeFSAd:

; 187  : 			}
; 188  : 		}

	jmp	SHORT $LN7@AuPipeFSAd
$LN8@AuPipeFSAd:

; 189  : 
; 190  : 		next = strchr(next + 1, '/');

	mov	rax, QWORD PTR next$[rbp]
	inc	rax
	mov	edx, 47					; 0000002fH
	mov	rcx, rax
	call	strchr
	mov	QWORD PTR next$[rbp], rax

; 191  : 		if (next)

	cmp	QWORD PTR next$[rbp], 0
	je	SHORT $LN16@AuPipeFSAd

; 192  : 			next++;

	mov	rax, QWORD PTR next$[rbp]
	inc	rax
	mov	QWORD PTR next$[rbp], rax
$LN16@AuPipeFSAd:

; 193  : 	}

	jmp	$LN2@AuPipeFSAd
$LN3@AuPipeFSAd:

; 194  : 
; 195  : 	list_add(first_list->childs, file);

	mov	rdx, QWORD PTR file$[rbp]
	mov	rax, QWORD PTR first_list$[rbp]
	mov	rcx, QWORD PTR [rax]
	call	list_add

; 196  : 
; 197  : 	return 1;

	mov	eax, 1
$LN1@AuPipeFSAd:

; 198  : }

	lea	rsp, QWORD PTR [rbp+128]
	pop	rbp
	ret	0
?AuPipeFSAddFile@@YAHPEAU__VFS_NODE__@@PEAD0@Z ENDP	; AuPipeFSAddFile
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Fs\pipe.cpp
;	COMDAT ?AuCreatePipe@@YAHPEAD_K@Z
_TEXT	SEGMENT
currentThr$ = 0
proc$ = 8
fd$ = 16
node$ = 24
pipe$ = 32
name$ = 128
sz$ = 136
?AuCreatePipe@@YAHPEAD_K@Z PROC				; AuCreatePipe, COMDAT

; 205  : int AuCreatePipe(char* name, size_t sz) {

$LN7:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 144				; 00000090H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__AA583385_pipe@cpp
	call	__CheckForDebuggerJustMyCode

; 206  : 	x64_cli();

	call	x64_cli

; 207  : 
; 208  : 	AuThread* currentThr = AuGetCurrentThread();

	call	AuGetCurrentThread
	mov	QWORD PTR currentThr$[rbp], rax

; 209  : 	if (!currentThr)

	cmp	QWORD PTR currentThr$[rbp], 0
	jne	SHORT $LN2@AuCreatePi

; 210  : 		return -1;

	mov	eax, -1
	jmp	$LN1@AuCreatePi
$LN2@AuCreatePi:

; 211  : 	AuProcess* proc = AuProcessFindThread(currentThr);

	mov	rcx, QWORD PTR currentThr$[rbp]
	call	?AuProcessFindThread@@YAPEAU_au_proc_@@PEAU_au_thread_@@@Z ; AuProcessFindThread
	mov	QWORD PTR proc$[rbp], rax

; 212  : 	if (!proc) {

	cmp	QWORD PTR proc$[rbp], 0
	jne	SHORT $LN3@AuCreatePi

; 213  : 		proc = AuProcessFindSubThread(currentThr);

	mov	rcx, QWORD PTR currentThr$[rbp]
	call	?AuProcessFindSubThread@@YAPEAU_au_proc_@@PEAU_au_thread_@@@Z ; AuProcessFindSubThread
	mov	QWORD PTR proc$[rbp], rax

; 214  : 		if (!proc)

	cmp	QWORD PTR proc$[rbp], 0
	jne	SHORT $LN4@AuCreatePi

; 215  : 			return -1;

	mov	eax, -1
	jmp	$LN1@AuCreatePi
$LN4@AuCreatePi:
$LN3@AuCreatePi:

; 216  : 	}
; 217  : 
; 218  : 	if (sz == 0)

	cmp	QWORD PTR sz$[rbp], 0
	jne	SHORT $LN5@AuCreatePi

; 219  : 		return -1;

	mov	eax, -1
	jmp	$LN1@AuCreatePi
$LN5@AuCreatePi:

; 220  : 
; 221  : 	int fd = AuProcessGetFileDesc(proc);

	mov	rcx, QWORD PTR proc$[rbp]
	call	?AuProcessGetFileDesc@@YAHPEAU_au_proc_@@@Z ; AuProcessGetFileDesc
	mov	DWORD PTR fd$[rbp], eax

; 222  : 
; 223  : 
; 224  : 	AuVFSNode* node = (AuVFSNode*)kmalloc(sizeof(AuVFSNode));

	mov	ecx, 178				; 000000b2H
	call	kmalloc
	mov	QWORD PTR node$[rbp], rax

; 225  : 	AuPipe *pipe = (AuPipe*)kmalloc(sizeof(AuPipe));

	mov	ecx, 56					; 00000038H
	call	kmalloc
	mov	QWORD PTR pipe$[rbp], rax

; 226  : 	memset(node, 0, sizeof(AuVFSNode));

	mov	r8d, 178				; 000000b2H
	xor	edx, edx
	mov	rcx, QWORD PTR node$[rbp]
	call	memset

; 227  : 	memset(pipe, 0, sizeof(AuPipe));

	mov	r8d, 56					; 00000038H
	xor	edx, edx
	mov	rcx, QWORD PTR pipe$[rbp]
	call	memset

; 228  : 
; 229  : 	pipe->buffer = (uint8_t*)kmalloc(sz);

	mov	ecx, DWORD PTR sz$[rbp]
	call	kmalloc
	mov	rcx, QWORD PTR pipe$[rbp]
	mov	QWORD PTR [rcx], rax

; 230  : 	pipe->readers_wait_queue = initialize_list();

	call	initialize_list
	mov	rcx, QWORD PTR pipe$[rbp]
	mov	QWORD PTR [rcx+40], rax

; 231  : 	pipe->writers_wait_queue = initialize_list();

	call	initialize_list
	mov	rcx, QWORD PTR pipe$[rbp]
	mov	QWORD PTR [rcx+48], rax

; 232  : 	pipe->size = sz;

	mov	rax, QWORD PTR pipe$[rbp]
	mov	rcx, QWORD PTR sz$[rbp]
	mov	QWORD PTR [rax+24], rcx

; 233  : 
; 234  : 	strcpy(node->filename, name);

	mov	rax, QWORD PTR node$[rbp]
	mov	rdx, QWORD PTR name$[rbp]
	mov	rcx, rax
	call	strcpy

; 235  : 	node->flags = FS_FLAG_PIPE;

	mov	eax, 128				; 00000080H
	mov	rcx, QWORD PTR node$[rbp]
	mov	WORD PTR [rcx+61], ax

; 236  : 	node->size = sz;

	mov	rax, QWORD PTR node$[rbp]
	mov	ecx, DWORD PTR sz$[rbp]
	mov	DWORD PTR [rax+32], ecx

; 237  : 	node->device = pipe; // pipe;

	mov	rax, QWORD PTR node$[rbp]
	mov	rcx, QWORD PTR pipe$[rbp]
	mov	QWORD PTR [rax+64], rcx

; 238  : 	node->read = AuPipeRead;

	mov	rax, QWORD PTR node$[rbp]
	lea	rcx, OFFSET FLAT:?AuPipeRead@@YA_KPEAU__VFS_NODE__@@0PEA_KI@Z ; AuPipeRead
	mov	QWORD PTR [rax+90], rcx

; 239  : 	node->write = AuPipeWrite;

	mov	rax, QWORD PTR node$[rbp]
	lea	rcx, OFFSET FLAT:?AuPipeWrite@@YA_KPEAU__VFS_NODE__@@0PEA_KI@Z ; AuPipeWrite
	mov	QWORD PTR [rax+98], rcx

; 240  : 	node->open = AuPipeOpen;

	mov	rax, QWORD PTR node$[rbp]
	lea	rcx, OFFSET FLAT:?AuPipeOpen@@YAPEAU__VFS_NODE__@@PEAU1@PEAD@Z ; AuPipeOpen
	mov	QWORD PTR [rax+74], rcx

; 241  : 	node->close = AuPipeClose;

	mov	rax, QWORD PTR node$[rbp]
	lea	rcx, OFFSET FLAT:?AuPipeClose@@YAHPEAU__VFS_NODE__@@0@Z ; AuPipeClose
	mov	QWORD PTR [rax+138], rcx

; 242  : 	node->iocontrol = NULL;

	mov	rax, QWORD PTR node$[rbp]
	mov	QWORD PTR [rax+170], 0

; 243  : 
; 244  : 	proc->fds[fd] = node;

	movsxd	rax, DWORD PTR fd$[rbp]
	mov	rcx, QWORD PTR proc$[rbp]
	mov	rdx, QWORD PTR node$[rbp]
	mov	QWORD PTR [rcx+rax*8+567], rdx

; 245  : 
; 246  : 	SeTextOut("Pipe proc -> %s \r\n", proc->name);

	mov	rax, QWORD PTR proc$[rbp]
	add	rax, 4
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:??_C@_0BD@LACECMDD@Pipe?5proc?5?9?$DO?5?$CFs?5?$AN?6@
	call	SeTextOut

; 247  : 	AuPipeFSAddFile(pipeFS, "/", node);

	mov	r8, QWORD PTR node$[rbp]
	lea	rdx, OFFSET FLAT:??_C@_01KMDKNFGN@?1@
	mov	rcx, QWORD PTR ?pipeFS@@3PEAU__VFS_NODE__@@EA ; pipeFS
	call	?AuPipeFSAddFile@@YAHPEAU__VFS_NODE__@@PEAD0@Z ; AuPipeFSAddFile

; 248  : 	SeTextOut("Pipe Created -> %d %s\r\n", fd, proc->fds[fd]->filename);

	movsxd	rax, DWORD PTR fd$[rbp]
	mov	rcx, QWORD PTR proc$[rbp]
	mov	rax, QWORD PTR [rcx+rax*8+567]
	mov	r8, rax
	mov	edx, DWORD PTR fd$[rbp]
	lea	rcx, OFFSET FLAT:??_C@_0BI@BEIFGIPP@Pipe?5Created?5?9?$DO?5?$CFd?5?$CFs?$AN?6@
	call	SeTextOut

; 249  : 	//AuForceScheduler();
; 250  : 	return fd;

	mov	eax, DWORD PTR fd$[rbp]
$LN1@AuCreatePi:

; 251  : }

	lea	rsp, QWORD PTR [rbp+112]
	pop	rbp
	ret	0
?AuCreatePipe@@YAHPEAD_K@Z ENDP				; AuCreatePipe
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Fs\pipe.cpp
;	COMDAT ?AuPipeUnread@@YA_KPEAU_pipe_@@@Z
_TEXT	SEGMENT
pipe$ = 80
?AuPipeUnread@@YA_KPEAU_pipe_@@@Z PROC			; AuPipeUnread, COMDAT

; 40   : size_t AuPipeUnread(AuPipe* pipe) {

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__AA583385_pipe@cpp
	call	__CheckForDebuggerJustMyCode

; 41   : 	if (pipe->read_ptr == pipe->write_ptr)

	mov	rax, QWORD PTR pipe$[rbp]
	mov	rcx, QWORD PTR pipe$[rbp]
	mov	rcx, QWORD PTR [rcx+8]
	cmp	QWORD PTR [rax+16], rcx
	jne	SHORT $LN2@AuPipeUnre

; 42   : 		return 0; //0 bytes difference

	xor	eax, eax
	jmp	SHORT $LN1@AuPipeUnre
$LN2@AuPipeUnre:

; 43   : 	if (pipe->read_ptr > pipe->write_ptr)

	mov	rax, QWORD PTR pipe$[rbp]
	mov	rcx, QWORD PTR pipe$[rbp]
	mov	rcx, QWORD PTR [rcx+8]
	cmp	QWORD PTR [rax+16], rcx
	jbe	SHORT $LN3@AuPipeUnre

; 44   : 		return (pipe->size - pipe->read_ptr) + pipe->write_ptr;

	mov	rax, QWORD PTR pipe$[rbp]
	mov	rcx, QWORD PTR pipe$[rbp]
	mov	rcx, QWORD PTR [rcx+16]
	mov	rax, QWORD PTR [rax+24]
	sub	rax, rcx
	mov	rcx, QWORD PTR pipe$[rbp]
	add	rax, QWORD PTR [rcx+8]
	jmp	SHORT $LN1@AuPipeUnre
	jmp	SHORT $LN4@AuPipeUnre
$LN3@AuPipeUnre:

; 45   : 	else
; 46   : 		return (pipe->write_ptr - pipe->read_ptr);

	mov	rax, QWORD PTR pipe$[rbp]
	mov	rcx, QWORD PTR pipe$[rbp]
	mov	rcx, QWORD PTR [rcx+16]
	mov	rax, QWORD PTR [rax+8]
	sub	rax, rcx
$LN4@AuPipeUnre:
$LN1@AuPipeUnre:

; 47   : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
?AuPipeUnread@@YA_KPEAU_pipe_@@@Z ENDP			; AuPipeUnread
_TEXT	ENDS
END
