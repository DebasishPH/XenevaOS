; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30154.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

msvcjmc	SEGMENT
__EA11CB0B_acpiosl@cpp DB 01H
msvcjmc	ENDS
PUBLIC	AcpiOsAcquireGlobalLock
PUBLIC	AcpiOsReleaseGlobalLock
PUBLIC	AcpiOsInitialize
PUBLIC	AcpiOsTerminate
PUBLIC	AcpiOsGetRootPointer
PUBLIC	AcpiOsPredefinedOverride
PUBLIC	AcpiOsTableOverride
PUBLIC	AcpiOsPhysicalTableOverride
PUBLIC	AcpiOsCreateLock
PUBLIC	AcpiOsDeleteLock
PUBLIC	AcpiOsAcquireLock
PUBLIC	AcpiOsReleaseLock
PUBLIC	AcpiOsCreateSemaphore
PUBLIC	AcpiOsDeleteSemaphore
PUBLIC	AcpiOsWaitSemaphore
PUBLIC	AcpiOsSignalSemaphore
PUBLIC	AcpiOsCreateMutex
PUBLIC	AcpiOsDeleteMutex
PUBLIC	AcpiOsAcquireMutex
PUBLIC	AcpiOsReleaseMutex
PUBLIC	AcpiOsAllocate
PUBLIC	AcpiOsFree
PUBLIC	AcpiOsMapMemory
PUBLIC	AcpiOsUnmapMemory
PUBLIC	AcpiOsGetPhysicalAddress
PUBLIC	AcpiOsInstallInterruptHandler
PUBLIC	AcpiOsRemoveInterruptHandler
PUBLIC	AcpiOsGetThreadId
PUBLIC	AcpiOsExecute
PUBLIC	AcpiOsWaitEventsComplete
PUBLIC	AcpiOsSleep
PUBLIC	AcpiOsStall
PUBLIC	AcpiOsReadPort
PUBLIC	AcpiOsWritePort
PUBLIC	AcpiOsReadMemory
PUBLIC	AcpiOsWriteMemory
PUBLIC	AcpiOsReadPciConfiguration
PUBLIC	AcpiOsWritePciConfiguration
PUBLIC	AcpiOsReadable
PUBLIC	AcpiOsWritable
PUBLIC	AcpiOsGetTimer
PUBLIC	AcpiOsSignal
PUBLIC	AcpiOsEnterSleep
PUBLIC	AcpiOsPrintf
PUBLIC	AcpiOsVprintf
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_0N@NHGMIOEM@Freeing?5up?5?6@		; `string'
PUBLIC	??_C@_09ELJDMPBG@read?5mem?6@			; `string'
PUBLIC	??_C@_0L@OGADBJME@Write?5mem?6@			; `string'
PUBLIC	??_C@_0L@KNJNMFGD@read?5port?6@			; `string'
PUBLIC	??_C@_0M@MFONOGEN@Write?5port?6@		; `string'
EXTRN	AuMapPage:PROC
EXTRN	AuGetFreePage:PROC
EXTRN	AuFreePages:PROC
EXTRN	AuGetPhysicalAddress:PROC
EXTRN	kmalloc:PROC
EXTRN	kfree:PROC
EXTRN	?AuACPIGetRSDP@@YAPEAXXZ:PROC			; AuACPIGetRSDP
EXTRN	AuPCIEWrite:PROC
EXTRN	AuPCIERead:PROC
EXTRN	AuTextOut:PROC
EXTRN	x64_inportd:PROC
EXTRN	x64_outportd:PROC
EXTRN	__CheckForDebuggerJustMyCode:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$AcpiOsAcquireGlobalLock DD imagerel $LN3
	DD	imagerel $LN3+35
	DD	imagerel $unwind$AcpiOsAcquireGlobalLock
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AcpiOsReleaseGlobalLock DD imagerel $LN3
	DD	imagerel $LN3+35
	DD	imagerel $unwind$AcpiOsReleaseGlobalLock
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AcpiOsInitialize DD imagerel $LN3
	DD	imagerel $LN3+31
	DD	imagerel $unwind$AcpiOsInitialize
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AcpiOsTerminate DD imagerel $LN3
	DD	imagerel $LN3+31
	DD	imagerel $unwind$AcpiOsTerminate
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AcpiOsGetRootPointer DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$AcpiOsGetRootPointer
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AcpiOsPredefinedOverride DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$AcpiOsPredefinedOverride
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AcpiOsTableOverride DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$AcpiOsTableOverride
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AcpiOsPhysicalTableOverride DD imagerel $LN3
	DD	imagerel $LN3+66
	DD	imagerel $unwind$AcpiOsPhysicalTableOverride
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AcpiOsCreateLock DD imagerel $LN3
	DD	imagerel $LN3+67
	DD	imagerel $unwind$AcpiOsCreateLock
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AcpiOsDeleteLock DD imagerel $LN3
	DD	imagerel $LN3+33
	DD	imagerel $unwind$AcpiOsDeleteLock
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AcpiOsAcquireLock DD imagerel $LN3
	DD	imagerel $LN3+35
	DD	imagerel $unwind$AcpiOsAcquireLock
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AcpiOsReleaseLock DD imagerel $LN3
	DD	imagerel $LN3+38
	DD	imagerel $unwind$AcpiOsReleaseLock
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AcpiOsCreateSemaphore DD imagerel $LN3
	DD	imagerel $LN3+43
	DD	imagerel $unwind$AcpiOsCreateSemaphore
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AcpiOsDeleteSemaphore DD imagerel $LN3
	DD	imagerel $LN3+35
	DD	imagerel $unwind$AcpiOsDeleteSemaphore
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AcpiOsWaitSemaphore DD imagerel $LN3
	DD	imagerel $LN3+45
	DD	imagerel $unwind$AcpiOsWaitSemaphore
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AcpiOsSignalSemaphore DD imagerel $LN3
	DD	imagerel $LN3+39
	DD	imagerel $unwind$AcpiOsSignalSemaphore
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AcpiOsCreateMutex DD imagerel $LN3
	DD	imagerel $LN3+67
	DD	imagerel $unwind$AcpiOsCreateMutex
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AcpiOsDeleteMutex DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$AcpiOsDeleteMutex
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AcpiOsAcquireMutex DD imagerel $LN3
	DD	imagerel $LN3+40
	DD	imagerel $unwind$AcpiOsAcquireMutex
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AcpiOsReleaseMutex DD imagerel $LN3
	DD	imagerel $LN3+33
	DD	imagerel $unwind$AcpiOsReleaseMutex
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AcpiOsAllocate DD imagerel $LN3
	DD	imagerel $LN3+41
	DD	imagerel $unwind$AcpiOsAllocate
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AcpiOsFree DD imagerel $LN3
	DD	imagerel $LN3+54
	DD	imagerel $unwind$AcpiOsFree
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AcpiOsMapMemory DD imagerel $LN6
	DD	imagerel $LN6+209
	DD	imagerel $unwind$AcpiOsMapMemory
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AcpiOsUnmapMemory DD imagerel $LN3
	DD	imagerel $LN3+53
	DD	imagerel $unwind$AcpiOsUnmapMemory
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AcpiOsGetPhysicalAddress DD imagerel $LN5
	DD	imagerel $LN5+84
	DD	imagerel $unwind$AcpiOsGetPhysicalAddress
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AcpiOsInstallInterruptHandler DD imagerel $LN3
	DD	imagerel $LN3+44
	DD	imagerel $unwind$AcpiOsInstallInterruptHandler
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AcpiOsRemoveInterruptHandler DD imagerel $LN3
	DD	imagerel $LN3+39
	DD	imagerel $unwind$AcpiOsRemoveInterruptHandler
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AcpiOsGetThreadId DD imagerel $LN3
	DD	imagerel $LN3+36
	DD	imagerel $unwind$AcpiOsGetThreadId
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AcpiOsExecute DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$AcpiOsExecute
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AcpiOsWaitEventsComplete DD imagerel $LN3
	DD	imagerel $LN3+29
	DD	imagerel $unwind$AcpiOsWaitEventsComplete
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AcpiOsSleep DD imagerel $LN6
	DD	imagerel $LN6+62
	DD	imagerel $unwind$AcpiOsSleep
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AcpiOsStall DD imagerel $LN6
	DD	imagerel $LN6+59
	DD	imagerel $unwind$AcpiOsStall
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AcpiOsReadPort DD imagerel $LN9
	DD	imagerel $LN9+107
	DD	imagerel $unwind$AcpiOsReadPort
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AcpiOsWritePort DD imagerel $LN9
	DD	imagerel $LN9+103
	DD	imagerel $unwind$AcpiOsWritePort
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AcpiOsReadMemory DD imagerel $LN10
	DD	imagerel $LN10+159
	DD	imagerel $unwind$AcpiOsReadMemory
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AcpiOsWriteMemory DD imagerel $LN10
	DD	imagerel $LN10+145
	DD	imagerel $unwind$AcpiOsWriteMemory
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AcpiOsReadPciConfiguration DD imagerel $LN4
	DD	imagerel $LN4+147
	DD	imagerel $unwind$AcpiOsReadPciConfiguration
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AcpiOsWritePciConfiguration DD imagerel $LN3
	DD	imagerel $LN3+119
	DD	imagerel $unwind$AcpiOsWritePciConfiguration
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AcpiOsReadable DD imagerel $LN3
	DD	imagerel $LN3+40
	DD	imagerel $unwind$AcpiOsReadable
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AcpiOsWritable DD imagerel $LN3
	DD	imagerel $LN3+40
	DD	imagerel $unwind$AcpiOsWritable
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AcpiOsGetTimer DD imagerel $LN3
	DD	imagerel $LN3+31
	DD	imagerel $unwind$AcpiOsGetTimer
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AcpiOsSignal DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$AcpiOsSignal
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AcpiOsEnterSleep DD imagerel $LN3
	DD	imagerel $LN3+46
	DD	imagerel $unwind$AcpiOsEnterSleep
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AcpiOsPrintf DD imagerel $LN3
	DD	imagerel $LN3+65
	DD	imagerel $unwind$AcpiOsPrintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AcpiOsVprintf DD imagerel $LN3
	DD	imagerel $LN3+47
	DD	imagerel $unwind$AcpiOsVprintf
pdata	ENDS
;	COMDAT ??_C@_0M@MFONOGEN@Write?5port?6@
CONST	SEGMENT
??_C@_0M@MFONOGEN@Write?5port?6@ DB 'Write port', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@KNJNMFGD@read?5port?6@
CONST	SEGMENT
??_C@_0L@KNJNMFGD@read?5port?6@ DB 'read port', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@OGADBJME@Write?5mem?6@
CONST	SEGMENT
??_C@_0L@OGADBJME@Write?5mem?6@ DB 'Write mem', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09ELJDMPBG@read?5mem?6@
CONST	SEGMENT
??_C@_09ELJDMPBG@read?5mem?6@ DB 'read mem', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@NHGMIOEM@Freeing?5up?5?6@
CONST	SEGMENT
??_C@_0N@NHGMIOEM@Freeing?5up?5?6@ DB 'Freeing up ', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AcpiOsVprintf DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AcpiOsPrintf DD 025031e01H
	DD	0d219231eH
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AcpiOsEnterSleep DD 025031701H
	DD	0b2122317H
	DD	0500eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AcpiOsSignal DD 025031301H
	DD	0b20e2313H
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AcpiOsGetTimer DD 025030b01H
	DD	0b206230bH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AcpiOsWritable DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AcpiOsReadable DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AcpiOsWritePciConfiguration DD 035032001H
	DD	0f21b3320H
	DD	05014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AcpiOsReadPciConfiguration DD 035032001H
	DD	0f21b3320H
	DD	05014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AcpiOsWriteMemory DD 025031901H
	DD	0d2142319H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AcpiOsReadMemory DD 025031901H
	DD	0d2142319H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AcpiOsWritePort DD 025031801H
	DD	0d2132318H
	DD	0500fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AcpiOsReadPort DD 025031901H
	DD	0d2142319H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AcpiOsStall DD 025030e01H
	DD	0d209230eH
	DD	05005H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AcpiOsSleep DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AcpiOsWaitEventsComplete DD 025030b01H
	DD	0b206230bH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AcpiOsExecute DD 025031801H
	DD	0b2132318H
	DD	0500fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AcpiOsGetThreadId DD 025030b01H
	DD	0b206230bH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AcpiOsRemoveInterruptHandler DD 025031301H
	DD	0b20e2313H
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AcpiOsInstallInterruptHandler DD 025031801H
	DD	0b2132318H
	DD	0500fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AcpiOsGetPhysicalAddress DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AcpiOsUnmapMemory DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AcpiOsMapMemory DD 025041701H
	DD	01122317H
	DD	0500b0012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AcpiOsFree DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AcpiOsAllocate DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AcpiOsReleaseMutex DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AcpiOsAcquireMutex DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AcpiOsDeleteMutex DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AcpiOsCreateMutex DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AcpiOsSignalSemaphore DD 025031301H
	DD	0b20e2313H
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AcpiOsWaitSemaphore DD 025031901H
	DD	0b2142319H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AcpiOsDeleteSemaphore DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AcpiOsCreateSemaphore DD 025031701H
	DD	0b2122317H
	DD	0500eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AcpiOsReleaseLock DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AcpiOsAcquireLock DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AcpiOsDeleteLock DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AcpiOsCreateLock DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AcpiOsPhysicalTableOverride DD 025031901H
	DD	0b2142319H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AcpiOsTableOverride DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AcpiOsPredefinedOverride DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AcpiOsGetRootPointer DD 025030b01H
	DD	0d206230bH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AcpiOsTerminate DD 025030b01H
	DD	0b206230bH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AcpiOsInitialize DD 025030b01H
	DD	0b206230bH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AcpiOsReleaseGlobalLock DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AcpiOsAcquireGlobalLock DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\acpiosl.cpp
;	COMDAT AcpiOsVprintf
_TEXT	SEGMENT
Format$ = 80
Args$ = 88
AcpiOsVprintf PROC					; COMDAT

; 233  : {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__EA11CB0B_acpiosl@cpp
	call	__CheckForDebuggerJustMyCode

; 234  : 	AuTextOut(Format);

	mov	rcx, QWORD PTR Format$[rbp]
	call	AuTextOut

; 235  : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
AcpiOsVprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\acpiosl.cpp
;	COMDAT AcpiOsPrintf
_TEXT	SEGMENT
args$ = 0
Format$ = 96
AcpiOsPrintf PROC					; COMDAT

; 225  : {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__EA11CB0B_acpiosl@cpp
	call	__CheckForDebuggerJustMyCode

; 226  : 	va_list args;
; 227  : 	va_start(args, Format);

	lea	rax, QWORD PTR Format$[rbp+8]
	mov	QWORD PTR args$[rbp], rax

; 228  : 	AuTextOut(Format);

	mov	rcx, QWORD PTR Format$[rbp]
	call	AuTextOut

; 229  : 	va_end(args);
; 230  : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
AcpiOsPrintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\acpiosl.cpp
;	COMDAT AcpiOsEnterSleep
_TEXT	SEGMENT
SleepState$ = 80
RegaValue$ = 88
RegbValue$ = 96
AcpiOsEnterSleep PROC					; COMDAT

; 256  : {

$LN3:
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	BYTE PTR [rsp+8], cl
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__EA11CB0B_acpiosl@cpp
	call	__CheckForDebuggerJustMyCode

; 257  : 	return AE_NOT_IMPLEMENTED;

	mov	eax, 14

; 258  : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
AcpiOsEnterSleep ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\acpiosl.cpp
;	COMDAT AcpiOsSignal
_TEXT	SEGMENT
Function$ = 80
Info$ = 88
AcpiOsSignal PROC					; COMDAT

; 247  : {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__EA11CB0B_acpiosl@cpp
	call	__CheckForDebuggerJustMyCode

; 248  : 	return AE_NOT_FOUND;

	mov	eax, 5

; 249  : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
AcpiOsSignal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\acpiosl.cpp
;	COMDAT AcpiOsGetTimer
_TEXT	SEGMENT
AcpiOsGetTimer PROC					; COMDAT

; 355  : {

$LN3:
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__EA11CB0B_acpiosl@cpp
	call	__CheckForDebuggerJustMyCode

; 356  : 	return 0; // sys_timer() * 10000;

	xor	eax, eax

; 357  : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
AcpiOsGetTimer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\acpiosl.cpp
;	COMDAT AcpiOsWritable
_TEXT	SEGMENT
memory$ = 80
Length$ = 88
AcpiOsWritable PROC					; COMDAT

; 107  : AU_EXTERN AU_FUNC BOOLEAN AcpiOsWritable(void* memory, ACPI_SIZE Length) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__EA11CB0B_acpiosl@cpp
	call	__CheckForDebuggerJustMyCode

; 108  : 	return TRUE;

	mov	al, 1

; 109  : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
AcpiOsWritable ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\acpiosl.cpp
;	COMDAT AcpiOsReadable
_TEXT	SEGMENT
memory$ = 80
Length$ = 88
AcpiOsReadable PROC					; COMDAT

; 103  : AU_EXTERN AU_FUNC BOOLEAN AcpiOsReadable(void *memory, ACPI_SIZE Length) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__EA11CB0B_acpiosl@cpp
	call	__CheckForDebuggerJustMyCode

; 104  : 	return TRUE;

	mov	al, 1

; 105  : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
AcpiOsReadable ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\acpiosl.cpp
;	COMDAT AcpiOsWritePciConfiguration
_TEXT	SEGMENT
tv76 = 64
PciId$ = 96
Reg$ = 104
Value$ = 112
Width$ = 120
AcpiOsWritePciConfiguration PROC			; COMDAT

; 384  : {

$LN3:
	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 128				; 00000080H
	lea	rbp, QWORD PTR [rsp+48]
	lea	rcx, OFFSET FLAT:__EA11CB0B_acpiosl@cpp
	call	__CheckForDebuggerJustMyCode

; 385  : 	AuPCIEWrite(PciId->Device, Reg, Value, PciId->Bus, PciId->Device, PciId->Function);

	mov	rax, QWORD PTR PciId$[rbp]
	movzx	eax, WORD PTR [rax+6]
	mov	rcx, QWORD PTR PciId$[rbp]
	movzx	ecx, WORD PTR [rcx+4]
	mov	rdx, QWORD PTR PciId$[rbp]
	movzx	edx, WORD PTR [rdx+2]
	mov	r8, QWORD PTR PciId$[rbp]
	movzx	r8d, WORD PTR [r8+4]
	mov	QWORD PTR tv76[rbp], r8
	mov	DWORD PTR [rsp+40], eax
	mov	DWORD PTR [rsp+32], ecx
	mov	r9d, edx
	mov	r8d, DWORD PTR Value$[rbp]
	mov	edx, DWORD PTR Reg$[rbp]
	mov	rax, QWORD PTR tv76[rbp]
	mov	rcx, rax
	call	AuPCIEWrite

; 386  : 	return AE_OK;

	xor	eax, eax

; 387  : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
AcpiOsWritePciConfiguration ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\acpiosl.cpp
;	COMDAT AcpiOsReadPciConfiguration
_TEXT	SEGMENT
result$ = 0
tv76 = 72
PciId$ = 96
Reg$ = 104
Value$ = 112
Width$ = 120
AcpiOsReadPciConfiguration PROC				; COMDAT

; 369  : {

$LN4:
	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 128				; 00000080H
	lea	rbp, QWORD PTR [rsp+48]
	lea	rcx, OFFSET FLAT:__EA11CB0B_acpiosl@cpp
	call	__CheckForDebuggerJustMyCode

; 370  : 	uint32_t result = 0;

	mov	DWORD PTR result$[rbp], 0

; 371  : 	result = AuPCIERead(PciId->Device, Reg, PciId->Bus, PciId->Device, PciId->Function);

	mov	rax, QWORD PTR PciId$[rbp]
	movzx	eax, WORD PTR [rax+6]
	mov	rcx, QWORD PTR PciId$[rbp]
	movzx	ecx, WORD PTR [rcx+4]
	mov	rdx, QWORD PTR PciId$[rbp]
	movzx	edx, WORD PTR [rdx+2]
	mov	r8, QWORD PTR PciId$[rbp]
	movzx	r8d, WORD PTR [r8+4]
	mov	QWORD PTR tv76[rbp], r8
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, ecx
	mov	r8d, edx
	mov	edx, DWORD PTR Reg$[rbp]
	mov	rax, QWORD PTR tv76[rbp]
	mov	rcx, rax
	call	AuPCIERead
	mov	DWORD PTR result$[rbp], eax

; 372  : 	*Value = result;

	mov	eax, DWORD PTR result$[rbp]
	mov	rcx, QWORD PTR Value$[rbp]
	mov	QWORD PTR [rcx], rax

; 373  : 	if (!result)

	cmp	DWORD PTR result$[rbp], 0
	jne	SHORT $LN2@AcpiOsRead

; 374  : 		return AE_NOT_IMPLEMENTED;

	mov	eax, 14
	jmp	SHORT $LN1@AcpiOsRead
$LN2@AcpiOsRead:

; 375  : 	return AE_OK;

	xor	eax, eax
$LN1@AcpiOsRead:

; 376  : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
AcpiOsReadPciConfiguration ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\acpiosl.cpp
;	COMDAT AcpiOsWriteMemory
_TEXT	SEGMENT
tv65 = 64
Address$ = 96
Value$ = 104
Width$ = 112
AcpiOsWriteMemory PROC					; COMDAT

; 292  : {

$LN10:
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__EA11CB0B_acpiosl@cpp
	call	__CheckForDebuggerJustMyCode

; 293  : 	AuTextOut("Write mem\n");

	lea	rcx, OFFSET FLAT:??_C@_0L@OGADBJME@Write?5mem?6@
	call	AuTextOut

; 294  : 	switch (Width)

	mov	eax, DWORD PTR Width$[rbp]
	mov	DWORD PTR tv65[rbp], eax
	cmp	DWORD PTR tv65[rbp], 8
	je	SHORT $LN4@AcpiOsWrit
	cmp	DWORD PTR tv65[rbp], 16
	je	SHORT $LN5@AcpiOsWrit
	cmp	DWORD PTR tv65[rbp], 32			; 00000020H
	je	SHORT $LN6@AcpiOsWrit
	cmp	DWORD PTR tv65[rbp], 64			; 00000040H
	je	SHORT $LN7@AcpiOsWrit
	jmp	SHORT $LN8@AcpiOsWrit
$LN4@AcpiOsWrit:

; 295  : 	{
; 296  : 	case 8:
; 297  : 		*(UINT8*)Address = Value;

	mov	rax, QWORD PTR Address$[rbp]
	movzx	ecx, BYTE PTR Value$[rbp]
	mov	BYTE PTR [rax], cl

; 298  : 		break;

	jmp	SHORT $LN2@AcpiOsWrit
$LN5@AcpiOsWrit:

; 299  : 	case 16:
; 300  : 		*(UINT16*)Address = Value;

	mov	rax, QWORD PTR Address$[rbp]
	movzx	ecx, WORD PTR Value$[rbp]
	mov	WORD PTR [rax], cx

; 301  : 		break;

	jmp	SHORT $LN2@AcpiOsWrit
$LN6@AcpiOsWrit:

; 302  : 	case 32:
; 303  : 		*(UINT32*)Address = Value;

	mov	rax, QWORD PTR Address$[rbp]
	mov	ecx, DWORD PTR Value$[rbp]
	mov	DWORD PTR [rax], ecx

; 304  : 		break;

	jmp	SHORT $LN2@AcpiOsWrit
$LN7@AcpiOsWrit:

; 305  : 	case 64:
; 306  : 		*(UINT64*)Address = Value;

	mov	rax, QWORD PTR Address$[rbp]
	mov	rcx, QWORD PTR Value$[rbp]
	mov	QWORD PTR [rax], rcx

; 307  : 		break;

	jmp	SHORT $LN2@AcpiOsWrit
$LN8@AcpiOsWrit:

; 308  : 	default:
; 309  : 		return AE_BAD_VALUE;

	mov	eax, 8196				; 00002004H
	jmp	SHORT $LN1@AcpiOsWrit
$LN2@AcpiOsWrit:

; 310  : 	}
; 311  : 	return AE_OK;

	xor	eax, eax
$LN1@AcpiOsWrit:

; 312  : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
AcpiOsWriteMemory ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\acpiosl.cpp
;	COMDAT AcpiOsReadMemory
_TEXT	SEGMENT
tv65 = 64
Address$ = 96
Value$ = 104
Width$ = 112
AcpiOsReadMemory PROC					; COMDAT

; 265  : {

$LN10:
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__EA11CB0B_acpiosl@cpp
	call	__CheckForDebuggerJustMyCode

; 266  : 	AuTextOut("read mem\n");

	lea	rcx, OFFSET FLAT:??_C@_09ELJDMPBG@read?5mem?6@
	call	AuTextOut

; 267  : 	switch (Width)

	mov	eax, DWORD PTR Width$[rbp]
	mov	DWORD PTR tv65[rbp], eax
	cmp	DWORD PTR tv65[rbp], 8
	je	SHORT $LN4@AcpiOsRead
	cmp	DWORD PTR tv65[rbp], 16
	je	SHORT $LN5@AcpiOsRead
	cmp	DWORD PTR tv65[rbp], 32			; 00000020H
	je	SHORT $LN6@AcpiOsRead
	cmp	DWORD PTR tv65[rbp], 64			; 00000040H
	je	SHORT $LN7@AcpiOsRead
	jmp	SHORT $LN8@AcpiOsRead
$LN4@AcpiOsRead:

; 268  : 	{
; 269  : 	case 8:
; 270  : 		*Value = *(UINT8*)Address;

	mov	rax, QWORD PTR Address$[rbp]
	movzx	eax, BYTE PTR [rax]
	mov	rcx, QWORD PTR Value$[rbp]
	mov	QWORD PTR [rcx], rax

; 271  : 		break;

	jmp	SHORT $LN2@AcpiOsRead
$LN5@AcpiOsRead:

; 272  : 	case 16:
; 273  : 		*Value = *(UINT16*)Address;

	mov	rax, QWORD PTR Address$[rbp]
	movzx	eax, WORD PTR [rax]
	mov	rcx, QWORD PTR Value$[rbp]
	mov	QWORD PTR [rcx], rax

; 274  : 		break;

	jmp	SHORT $LN2@AcpiOsRead
$LN6@AcpiOsRead:

; 275  : 	case 32:
; 276  : 		*Value = *(UINT32*)Address;

	mov	rax, QWORD PTR Address$[rbp]
	mov	eax, DWORD PTR [rax]
	mov	rcx, QWORD PTR Value$[rbp]
	mov	QWORD PTR [rcx], rax

; 277  : 		break;

	jmp	SHORT $LN2@AcpiOsRead
$LN7@AcpiOsRead:

; 278  : 	case 64:
; 279  : 		*Value = *(UINT64*)Address;

	mov	rax, QWORD PTR Value$[rbp]
	mov	rcx, QWORD PTR Address$[rbp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax], rcx

; 280  : 		break;

	jmp	SHORT $LN2@AcpiOsRead
$LN8@AcpiOsRead:

; 281  : 	default:
; 282  : 		return AE_BAD_VALUE;

	mov	eax, 8196				; 00002004H
	jmp	SHORT $LN1@AcpiOsRead
$LN2@AcpiOsRead:

; 283  : 	}
; 284  : 	return AE_OK;

	xor	eax, eax
$LN1@AcpiOsRead:

; 285  : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
AcpiOsReadMemory ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\acpiosl.cpp
;	COMDAT AcpiOsWritePort
_TEXT	SEGMENT
tv65 = 64
Address$ = 96
Value$ = 104
Width$ = 112
AcpiOsWritePort PROC					; COMDAT

; 339  : {

$LN9:
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__EA11CB0B_acpiosl@cpp
	call	__CheckForDebuggerJustMyCode

; 340  : 	AuTextOut("Write port\n");

	lea	rcx, OFFSET FLAT:??_C@_0M@MFONOGEN@Write?5port?6@
	call	AuTextOut

; 341  : 	switch (Width)

	mov	eax, DWORD PTR Width$[rbp]
	mov	DWORD PTR tv65[rbp], eax
	cmp	DWORD PTR tv65[rbp], 8
	je	SHORT $LN4@AcpiOsWrit
	cmp	DWORD PTR tv65[rbp], 16
	je	SHORT $LN5@AcpiOsWrit
	cmp	DWORD PTR tv65[rbp], 32			; 00000020H
	je	SHORT $LN6@AcpiOsWrit
	jmp	SHORT $LN7@AcpiOsWrit
$LN4@AcpiOsWrit:
$LN5@AcpiOsWrit:
$LN6@AcpiOsWrit:

; 342  : 	{
; 343  : 	case 8:
; 344  : 	case 16:
; 345  : 	case 32:
; 346  : 		x64_outportd(Address, Value);

	mov	edx, DWORD PTR Value$[rbp]
	movzx	ecx, WORD PTR Address$[rbp]
	call	x64_outportd

; 347  : 		break;

	jmp	SHORT $LN2@AcpiOsWrit
$LN7@AcpiOsWrit:

; 348  : 	default:
; 349  : 		return AE_BAD_VALUE;

	mov	eax, 8196				; 00002004H
	jmp	SHORT $LN1@AcpiOsWrit
$LN2@AcpiOsWrit:

; 350  : 	}
; 351  : 	return AE_OK;

	xor	eax, eax
$LN1@AcpiOsWrit:

; 352  : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
AcpiOsWritePort ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\acpiosl.cpp
;	COMDAT AcpiOsReadPort
_TEXT	SEGMENT
tv65 = 64
Address$ = 96
Value$ = 104
Width$ = 112
AcpiOsReadPort PROC					; COMDAT

; 319  : {

$LN9:
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__EA11CB0B_acpiosl@cpp
	call	__CheckForDebuggerJustMyCode

; 320  : 	AuTextOut("read port\n");

	lea	rcx, OFFSET FLAT:??_C@_0L@KNJNMFGD@read?5port?6@
	call	AuTextOut

; 321  : 	switch (Width)

	mov	eax, DWORD PTR Width$[rbp]
	mov	DWORD PTR tv65[rbp], eax
	cmp	DWORD PTR tv65[rbp], 8
	je	SHORT $LN4@AcpiOsRead
	cmp	DWORD PTR tv65[rbp], 16
	je	SHORT $LN5@AcpiOsRead
	cmp	DWORD PTR tv65[rbp], 32			; 00000020H
	je	SHORT $LN6@AcpiOsRead
	jmp	SHORT $LN7@AcpiOsRead
$LN4@AcpiOsRead:
$LN5@AcpiOsRead:
$LN6@AcpiOsRead:

; 322  : 	{
; 323  : 	case 8:
; 324  : 	case 16:
; 325  : 	case 32:
; 326  : 		*Value = x64_inportd(Address);

	movzx	ecx, WORD PTR Address$[rbp]
	call	x64_inportd
	mov	rcx, QWORD PTR Value$[rbp]
	mov	DWORD PTR [rcx], eax

; 327  : 		break;

	jmp	SHORT $LN2@AcpiOsRead
$LN7@AcpiOsRead:

; 328  : 	default:
; 329  : 		return AE_BAD_VALUE;

	mov	eax, 8196				; 00002004H
	jmp	SHORT $LN1@AcpiOsRead
$LN2@AcpiOsRead:

; 330  : 	}
; 331  : 	return AE_OK;

	xor	eax, eax
$LN1@AcpiOsRead:

; 332  : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
AcpiOsReadPort ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\acpiosl.cpp
;	COMDAT AcpiOsStall
_TEXT	SEGMENT
i$1 = 0
Micros$ = 96
AcpiOsStall PROC					; COMDAT

; 126  : AU_EXTERN AU_FUNC void AcpiOsStall(UINT32 Micros) {

$LN6:
	mov	DWORD PTR [rsp+8], ecx
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__EA11CB0B_acpiosl@cpp
	call	__CheckForDebuggerJustMyCode

; 127  : 	for (int i = 0; i < Micros; i++)

	mov	DWORD PTR i$1[rbp], 0
	jmp	SHORT $LN4@AcpiOsStal
$LN2@AcpiOsStal:
	mov	eax, DWORD PTR i$1[rbp]
	inc	eax
	mov	DWORD PTR i$1[rbp], eax
$LN4@AcpiOsStal:
	mov	eax, DWORD PTR Micros$[rbp]
	cmp	DWORD PTR i$1[rbp], eax
	jae	SHORT $LN3@AcpiOsStal

; 128  : 		;

	jmp	SHORT $LN2@AcpiOsStal
$LN3@AcpiOsStal:

; 129  : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
AcpiOsStall ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\acpiosl.cpp
;	COMDAT AcpiOsSleep
_TEXT	SEGMENT
i$1 = 0
Millis$ = 96
AcpiOsSleep PROC					; COMDAT

; 121  : AU_EXTERN AU_FUNC void AcpiOsSleep(UINT64 Millis) {

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__EA11CB0B_acpiosl@cpp
	call	__CheckForDebuggerJustMyCode

; 122  : 	for (int i = 0; i < Millis; i++)

	mov	DWORD PTR i$1[rbp], 0
	jmp	SHORT $LN4@AcpiOsSlee
$LN2@AcpiOsSlee:
	mov	eax, DWORD PTR i$1[rbp]
	inc	eax
	mov	DWORD PTR i$1[rbp], eax
$LN4@AcpiOsSlee:
	movsxd	rax, DWORD PTR i$1[rbp]
	cmp	rax, QWORD PTR Millis$[rbp]
	jae	SHORT $LN3@AcpiOsSlee

; 123  : 		;

	jmp	SHORT $LN2@AcpiOsSlee
$LN3@AcpiOsSlee:

; 124  : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
AcpiOsSleep ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\acpiosl.cpp
;	COMDAT AcpiOsWaitEventsComplete
_TEXT	SEGMENT
AcpiOsWaitEventsComplete PROC				; COMDAT

; 360  : {

$LN3:
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__EA11CB0B_acpiosl@cpp
	call	__CheckForDebuggerJustMyCode

; 361  : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
AcpiOsWaitEventsComplete ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\acpiosl.cpp
;	COMDAT AcpiOsExecute
_TEXT	SEGMENT
Type$ = 80
Function$ = 88
Context$ = 96
AcpiOsExecute PROC					; COMDAT

; 115  : AU_EXTERN AU_FUNC ACPI_STATUS AcpiOsExecute(ACPI_EXECUTE_TYPE Type, ACPI_OSD_EXEC_CALLBACK Function, void* Context) {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__EA11CB0B_acpiosl@cpp
	call	__CheckForDebuggerJustMyCode

; 116  : 	Function(Context);

	mov	rcx, QWORD PTR Context$[rbp]
	call	QWORD PTR Function$[rbp]

; 117  : 	/* here we need scheduler to execute threads */
; 118  : 	return AE_OK;

	xor	eax, eax

; 119  : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
AcpiOsExecute ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\acpiosl.cpp
;	COMDAT AcpiOsGetThreadId
_TEXT	SEGMENT
AcpiOsGetThreadId PROC					; COMDAT

; 111  : AU_EXTERN AU_FUNC ACPI_THREAD_ID AcpiOsGetThreadId() {

$LN3:
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__EA11CB0B_acpiosl@cpp
	call	__CheckForDebuggerJustMyCode

; 112  : 	return (ACPI_THREAD_ID)-1;

	mov	rax, -1

; 113  : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
AcpiOsGetThreadId ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\acpiosl.cpp
;	COMDAT AcpiOsRemoveInterruptHandler
_TEXT	SEGMENT
InterruptNumber$ = 80
Handler$ = 88
AcpiOsRemoveInterruptHandler PROC			; COMDAT

; 220  : {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__EA11CB0B_acpiosl@cpp
	call	__CheckForDebuggerJustMyCode

; 221  : 	return AE_OK;

	xor	eax, eax

; 222  : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
AcpiOsRemoveInterruptHandler ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\acpiosl.cpp
;	COMDAT AcpiOsInstallInterruptHandler
_TEXT	SEGMENT
InterruptLevel$ = 80
Handler$ = 88
Context$ = 96
AcpiOsInstallInterruptHandler PROC			; COMDAT

; 215  : AU_EXTERN AU_FUNC ACPI_STATUS AcpiOsInstallInterruptHandler(UINT32 InterruptLevel, ACPI_OSD_HANDLER Handler, void *Context){

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__EA11CB0B_acpiosl@cpp
	call	__CheckForDebuggerJustMyCode

; 216  : 	return AE_OK;

	xor	eax, eax

; 217  : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
AcpiOsInstallInterruptHandler ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\acpiosl.cpp
;	COMDAT AcpiOsGetPhysicalAddress
_TEXT	SEGMENT
phys$ = 0
logicalAddress$ = 96
PhysicalAddress$ = 104
AcpiOsGetPhysicalAddress PROC				; COMDAT

; 84   : AU_EXTERN AU_FUNC ACPI_STATUS AcpiOsGetPhysicalAddress(void* logicalAddress, ACPI_PHYSICAL_ADDRESS *PhysicalAddress) {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__EA11CB0B_acpiosl@cpp
	call	__CheckForDebuggerJustMyCode

; 85   : 	void* phys = AuGetPhysicalAddress((uint64_t)logicalAddress);

	mov	rcx, QWORD PTR logicalAddress$[rbp]
	call	AuGetPhysicalAddress
	mov	QWORD PTR phys$[rbp], rax

; 86   : 	if (phys)

	cmp	QWORD PTR phys$[rbp], 0
	je	SHORT $LN2@AcpiOsGetP

; 87   : 		*PhysicalAddress = (ACPI_PHYSICAL_ADDRESS)phys;

	mov	rax, QWORD PTR PhysicalAddress$[rbp]
	mov	rcx, QWORD PTR phys$[rbp]
	mov	QWORD PTR [rax], rcx
	jmp	SHORT $LN3@AcpiOsGetP
$LN2@AcpiOsGetP:

; 88   : 	else
; 89   : 		*PhysicalAddress = (ACPI_PHYSICAL_ADDRESS)logicalAddress;

	mov	rax, QWORD PTR PhysicalAddress$[rbp]
	mov	rcx, QWORD PTR logicalAddress$[rbp]
	mov	QWORD PTR [rax], rcx
$LN3@AcpiOsGetP:

; 90   : 
; 91   : 	return AE_OK;

	xor	eax, eax

; 92   : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
AcpiOsGetPhysicalAddress ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\acpiosl.cpp
;	COMDAT AcpiOsUnmapMemory
_TEXT	SEGMENT
where$ = 80
length$ = 88
AcpiOsUnmapMemory PROC					; COMDAT

; 80   : AU_EXTERN AU_FUNC void AcpiOsUnmapMemory(void* where, ACPI_SIZE length) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__EA11CB0B_acpiosl@cpp
	call	__CheckForDebuggerJustMyCode

; 81   : 	AuFreePages((uint64_t)where, true, length);

	mov	r8, QWORD PTR length$[rbp]
	mov	dl, 1
	mov	rcx, QWORD PTR where$[rbp]
	call	AuFreePages

; 82   : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
AcpiOsUnmapMemory ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\acpiosl.cpp
;	COMDAT AcpiOsMapMemory
_TEXT	SEGMENT
align_off$ = 0
loc$ = 8
virt$ = 16
phys$ = 24
i$1 = 32
PhysicalAddress$ = 128
Length$ = 136
AcpiOsMapMemory PROC					; COMDAT

; 70   : AU_EXTERN AU_FUNC void* AcpiOsMapMemory(ACPI_PHYSICAL_ADDRESS PhysicalAddress, ACPI_SIZE Length) {

$LN6:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 144				; 00000090H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__EA11CB0B_acpiosl@cpp
	call	__CheckForDebuggerJustMyCode

; 71   : 	size_t align_off = PhysicalAddress & (PAGE_SIZE - 1);

	mov	rax, QWORD PTR PhysicalAddress$[rbp]
	and	rax, 4095				; 00000fffH
	mov	QWORD PTR align_off$[rbp], rax

; 72   : 	uint64_t* loc = AuGetFreePage(false, NULL);

	xor	edx, edx
	xor	ecx, ecx
	call	AuGetFreePage
	mov	QWORD PTR loc$[rbp], rax

; 73   : 	uint64_t virt = (uint64_t)loc;

	mov	rax, QWORD PTR loc$[rbp]
	mov	QWORD PTR virt$[rbp], rax

; 74   : 	uint64_t phys = PhysicalAddress - align_off;

	mov	rax, QWORD PTR align_off$[rbp]
	mov	rcx, QWORD PTR PhysicalAddress$[rbp]
	sub	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR phys$[rbp], rax

; 75   : 	for (int i = 0; i < Length + align_off; i++)

	mov	DWORD PTR i$1[rbp], 0
	jmp	SHORT $LN4@AcpiOsMapM
$LN2@AcpiOsMapM:
	mov	eax, DWORD PTR i$1[rbp]
	inc	eax
	mov	DWORD PTR i$1[rbp], eax
$LN4@AcpiOsMapM:
	movsxd	rax, DWORD PTR i$1[rbp]
	mov	rcx, QWORD PTR align_off$[rbp]
	mov	rdx, QWORD PTR Length$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	cmp	rax, rcx
	jae	SHORT $LN3@AcpiOsMapM

; 76   : 		AuMapPage(phys + i * 4096, virt + i * 4096, 0);

	imul	eax, DWORD PTR i$1[rbp], 4096		; 00001000H
	cdqe
	mov	rcx, QWORD PTR virt$[rbp]
	add	rcx, rax
	mov	rax, rcx
	imul	ecx, DWORD PTR i$1[rbp], 4096		; 00001000H
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR phys$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	xor	r8d, r8d
	mov	rdx, rax
	call	AuMapPage
	jmp	SHORT $LN2@AcpiOsMapM
$LN3@AcpiOsMapM:

; 77   : 	return (void*)(virt + align_off);

	mov	rax, QWORD PTR align_off$[rbp]
	mov	rcx, QWORD PTR virt$[rbp]
	add	rcx, rax
	mov	rax, rcx

; 78   : }

	lea	rsp, QWORD PTR [rbp+112]
	pop	rbp
	ret	0
AcpiOsMapMemory ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\acpiosl.cpp
;	COMDAT AcpiOsFree
_TEXT	SEGMENT
memory$ = 80
AcpiOsFree PROC						; COMDAT

; 98   : AU_EXTERN AU_FUNC void AcpiOsFree(void* memory) {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__EA11CB0B_acpiosl@cpp
	call	__CheckForDebuggerJustMyCode

; 99   : 	AuTextOut("Freeing up \n");

	lea	rcx, OFFSET FLAT:??_C@_0N@NHGMIOEM@Freeing?5up?5?6@
	call	AuTextOut

; 100  : 	return kfree(memory);

	mov	rcx, QWORD PTR memory$[rbp]
	call	kfree

; 101  : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
AcpiOsFree ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\acpiosl.cpp
;	COMDAT AcpiOsAllocate
_TEXT	SEGMENT
Size$ = 80
AcpiOsAllocate PROC					; COMDAT

; 94   : AU_EXTERN AU_FUNC void* AcpiOsAllocate(ACPI_SIZE Size) {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__EA11CB0B_acpiosl@cpp
	call	__CheckForDebuggerJustMyCode

; 95   : 	return kmalloc(Size);

	mov	ecx, DWORD PTR Size$[rbp]
	call	kmalloc

; 96   : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
AcpiOsAllocate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\acpiosl.cpp
;	COMDAT AcpiOsReleaseMutex
_TEXT	SEGMENT
Handle$ = 80
AcpiOsReleaseMutex PROC					; COMDAT

; 155  : {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__EA11CB0B_acpiosl@cpp
	call	__CheckForDebuggerJustMyCode

; 156  : 	/*mutex_t* mut = (mutex_t*)Handle;
; 157  : 	mut->locked = 0;*/
; 158  : 	//AcpiOsSignalSemaphore(Handle, 1);
; 159  : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
AcpiOsReleaseMutex ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\acpiosl.cpp
;	COMDAT AcpiOsAcquireMutex
_TEXT	SEGMENT
Handle$ = 80
Timeout$ = 88
AcpiOsAcquireMutex PROC					; COMDAT

; 149  : {

$LN3:
	mov	WORD PTR [rsp+16], dx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__EA11CB0B_acpiosl@cpp
	call	__CheckForDebuggerJustMyCode

; 150  : 	/*mutex_t* mut = (mutex_t*)Handle;
; 151  : 	mut->locked = 1;*/
; 152  : 	return AE_OK;//AcpiOsWaitSemaphore(Handle, 1, Timeout);

	xor	eax, eax

; 153  : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
AcpiOsAcquireMutex ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\acpiosl.cpp
;	COMDAT AcpiOsDeleteMutex
_TEXT	SEGMENT
Handle$ = 80
AcpiOsDeleteMutex PROC					; COMDAT

; 143  : AU_EXTERN AU_FUNC void AcpiOsDeleteMutex(ACPI_MUTEX Handle) {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__EA11CB0B_acpiosl@cpp
	call	__CheckForDebuggerJustMyCode

; 144  : 	kfree(Handle);

	mov	rcx, QWORD PTR Handle$[rbp]
	call	kfree

; 145  : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
AcpiOsDeleteMutex ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\acpiosl.cpp
;	COMDAT AcpiOsCreateMutex
_TEXT	SEGMENT
mut$ = 0
OutHandle$ = 96
AcpiOsCreateMutex PROC					; COMDAT

; 135  : AU_EXTERN AU_FUNC ACPI_STATUS AcpiOsCreateMutex(ACPI_MUTEX *OutHandle) {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__EA11CB0B_acpiosl@cpp
	call	__CheckForDebuggerJustMyCode

; 136  : 	
; 137  : 	mutex_t *mut = (mutex_t*)kmalloc(sizeof(mutex_t));

	mov	ecx, 1
	call	kmalloc
	mov	QWORD PTR mut$[rbp], rax

; 138  : 	mut->locked = 0;

	mov	rax, QWORD PTR mut$[rbp]
	mov	BYTE PTR [rax], 0

; 139  : 	*OutHandle = mut;

	mov	rax, QWORD PTR OutHandle$[rbp]
	mov	rcx, QWORD PTR mut$[rbp]
	mov	QWORD PTR [rax], rcx

; 140  : 	return AE_OK;//AcpiOsCreateSemaphore(1, 1, OutHandle);

	xor	eax, eax

; 141  : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
AcpiOsCreateMutex ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\acpiosl.cpp
;	COMDAT AcpiOsSignalSemaphore
_TEXT	SEGMENT
Handle$ = 80
Units$ = 88
AcpiOsSignalSemaphore PROC				; COMDAT

; 177  : {

$LN3:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__EA11CB0B_acpiosl@cpp
	call	__CheckForDebuggerJustMyCode

; 178  : 	return AE_OK;

	xor	eax, eax

; 179  : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
AcpiOsSignalSemaphore ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\acpiosl.cpp
;	COMDAT AcpiOsWaitSemaphore
_TEXT	SEGMENT
Handle$ = 80
Units$ = 88
Timeout$ = 96
AcpiOsWaitSemaphore PROC				; COMDAT

; 172  : {

$LN3:
	mov	WORD PTR [rsp+24], r8w
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__EA11CB0B_acpiosl@cpp
	call	__CheckForDebuggerJustMyCode

; 173  : 	return AE_OK;

	xor	eax, eax

; 174  : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
AcpiOsWaitSemaphore ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\acpiosl.cpp
;	COMDAT AcpiOsDeleteSemaphore
_TEXT	SEGMENT
Handle$ = 80
AcpiOsDeleteSemaphore PROC				; COMDAT

; 167  : {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__EA11CB0B_acpiosl@cpp
	call	__CheckForDebuggerJustMyCode

; 168  : 	return AE_OK;

	xor	eax, eax

; 169  : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
AcpiOsDeleteSemaphore ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\acpiosl.cpp
;	COMDAT AcpiOsCreateSemaphore
_TEXT	SEGMENT
MaxUnits$ = 80
InitialUnits$ = 88
OutHandle$ = 96
AcpiOsCreateSemaphore PROC				; COMDAT

; 162  : {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__EA11CB0B_acpiosl@cpp
	call	__CheckForDebuggerJustMyCode

; 163  : 	return AE_OK;

	xor	eax, eax

; 164  : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
AcpiOsCreateSemaphore ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\acpiosl.cpp
;	COMDAT AcpiOsReleaseLock
_TEXT	SEGMENT
Handle$ = 80
Flags$ = 88
AcpiOsReleaseLock PROC					; COMDAT

; 199  : {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__EA11CB0B_acpiosl@cpp
	call	__CheckForDebuggerJustMyCode

; 200  : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
AcpiOsReleaseLock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\acpiosl.cpp
;	COMDAT AcpiOsAcquireLock
_TEXT	SEGMENT
Handle$ = 80
AcpiOsAcquireLock PROC					; COMDAT

; 194  : {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__EA11CB0B_acpiosl@cpp
	call	__CheckForDebuggerJustMyCode

; 195  : 	return AE_OK;

	xor	eax, eax

; 196  : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
AcpiOsAcquireLock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\acpiosl.cpp
;	COMDAT AcpiOsDeleteLock
_TEXT	SEGMENT
Handle$ = 80
AcpiOsDeleteLock PROC					; COMDAT

; 190  : {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__EA11CB0B_acpiosl@cpp
	call	__CheckForDebuggerJustMyCode

; 191  : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
AcpiOsDeleteLock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\acpiosl.cpp
;	COMDAT AcpiOsCreateLock
_TEXT	SEGMENT
mut$ = 0
OutHandle$ = 96
AcpiOsCreateLock PROC					; COMDAT

; 182  : {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__EA11CB0B_acpiosl@cpp
	call	__CheckForDebuggerJustMyCode

; 183  : 	mutex_t *mut = (mutex_t*)kmalloc(sizeof(mutex_t));

	mov	ecx, 1
	call	kmalloc
	mov	QWORD PTR mut$[rbp], rax

; 184  : 	mut->locked = 0;

	mov	rax, QWORD PTR mut$[rbp]
	mov	BYTE PTR [rax], 0

; 185  : 	*OutHandle = mut;

	mov	rax, QWORD PTR OutHandle$[rbp]
	mov	rcx, QWORD PTR mut$[rbp]
	mov	QWORD PTR [rax], rcx

; 186  : 	return AE_OK;

	xor	eax, eax

; 187  : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
AcpiOsCreateLock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\acpiosl.cpp
;	COMDAT AcpiOsPhysicalTableOverride
_TEXT	SEGMENT
ExistingTable$ = 80
NewAddress$ = 88
NewTableLength$ = 96
AcpiOsPhysicalTableOverride PROC			; COMDAT

; 64   : 	UINT32 *NewTableLength) {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__EA11CB0B_acpiosl@cpp
	call	__CheckForDebuggerJustMyCode

; 65   : 	*NewAddress = 0;

	mov	rax, QWORD PTR NewAddress$[rbp]
	mov	QWORD PTR [rax], 0

; 66   : 	*NewTableLength = 0;

	mov	rax, QWORD PTR NewTableLength$[rbp]
	mov	DWORD PTR [rax], 0

; 67   : 	return AE_OK;

	xor	eax, eax

; 68   : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
AcpiOsPhysicalTableOverride ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\acpiosl.cpp
;	COMDAT AcpiOsTableOverride
_TEXT	SEGMENT
ExistingTable$ = 80
NewTable$ = 88
AcpiOsTableOverride PROC				; COMDAT

; 58   : AU_EXTERN AU_EXTERN AU_FUNC ACPI_STATUS AcpiOsTableOverride(ACPI_TABLE_HEADER* ExistingTable, ACPI_TABLE_HEADER **NewTable) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__EA11CB0B_acpiosl@cpp
	call	__CheckForDebuggerJustMyCode

; 59   : 	*NewTable = 0;

	mov	rax, QWORD PTR NewTable$[rbp]
	mov	QWORD PTR [rax], 0

; 60   : 	return AE_OK;

	xor	eax, eax

; 61   : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
AcpiOsTableOverride ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\acpiosl.cpp
;	COMDAT AcpiOsPredefinedOverride
_TEXT	SEGMENT
PredefinedObject$ = 80
NewValue$ = 88
AcpiOsPredefinedOverride PROC				; COMDAT

; 53   : AU_EXTERN AU_FUNC ACPI_STATUS AcpiOsPredefinedOverride(const ACPI_PREDEFINED_NAMES *PredefinedObject, ACPI_STRING *NewValue) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__EA11CB0B_acpiosl@cpp
	call	__CheckForDebuggerJustMyCode

; 54   : 	*NewValue = 0;

	mov	rax, QWORD PTR NewValue$[rbp]
	mov	QWORD PTR [rax], 0

; 55   : 	return AE_OK;

	xor	eax, eax

; 56   : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
AcpiOsPredefinedOverride ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\acpiosl.cpp
;	COMDAT AcpiOsGetRootPointer
_TEXT	SEGMENT
rsdp$ = 0
AcpiOsGetRootPointer PROC				; COMDAT

; 48   : AU_EXTERN AU_FUNC ACPI_PHYSICAL_ADDRESS AcpiOsGetRootPointer() {

$LN3:
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__EA11CB0B_acpiosl@cpp
	call	__CheckForDebuggerJustMyCode

; 49   : 	void* rsdp = AuACPIGetRSDP();

	call	?AuACPIGetRSDP@@YAPEAXXZ		; AuACPIGetRSDP
	mov	QWORD PTR rsdp$[rbp], rax

; 50   : 	return (ACPI_PHYSICAL_ADDRESS)rsdp;

	mov	rax, QWORD PTR rsdp$[rbp]

; 51   : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
AcpiOsGetRootPointer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\acpiosl.cpp
;	COMDAT AcpiOsTerminate
_TEXT	SEGMENT
AcpiOsTerminate PROC					; COMDAT

; 44   : AU_EXTERN AU_FUNC ACPI_STATUS AcpiOsTerminate() {

$LN3:
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__EA11CB0B_acpiosl@cpp
	call	__CheckForDebuggerJustMyCode

; 45   : 	return AE_OK;

	xor	eax, eax

; 46   : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
AcpiOsTerminate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\acpiosl.cpp
;	COMDAT AcpiOsInitialize
_TEXT	SEGMENT
AcpiOsInitialize PROC					; COMDAT

; 40   : AU_EXTERN AU_FUNC ACPI_STATUS AcpiOsInitialize() {

$LN3:
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__EA11CB0B_acpiosl@cpp
	call	__CheckForDebuggerJustMyCode

; 41   : 	return AE_OK;

	xor	eax, eax

; 42   : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
AcpiOsInitialize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\acpiosl.cpp
;	COMDAT AcpiOsReleaseGlobalLock
_TEXT	SEGMENT
lock$ = 80
AcpiOsReleaseGlobalLock PROC				; COMDAT

; 242  : {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__EA11CB0B_acpiosl@cpp
	call	__CheckForDebuggerJustMyCode

; 243  : 	return AE_OK;

	xor	eax, eax

; 244  : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
AcpiOsReleaseGlobalLock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\acpiosl.cpp
;	COMDAT AcpiOsAcquireGlobalLock
_TEXT	SEGMENT
lock$ = 80
AcpiOsAcquireGlobalLock PROC				; COMDAT

; 238  : {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__EA11CB0B_acpiosl@cpp
	call	__CheckForDebuggerJustMyCode

; 239  : 	return AE_OK;

	xor	eax, eax

; 240  : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
AcpiOsAcquireGlobalLock ENDP
_TEXT	ENDS
END
