; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30154.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?HBABar@@3PEAXEA				; HBABar
_BSS	SEGMENT
?HBABar@@3PEAXEA DQ 01H DUP (?)				; HBABar
_BSS	ENDS
msvcjmc	SEGMENT
__22E58447_ahci@cpp DB 01H
msvcjmc	ENDS
PUBLIC	?AuAHCIInitialise@@YAXXZ			; AuAHCIInitialise
PUBLIC	?AHCIInterruptHandler@@YAX_KPEAX@Z		; AHCIInterruptHandler
PUBLIC	?AuAHCICheckType@@YAHPEAU_hba_port_@@@Z		; AuAHCICheckType
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_0CI@CILLCAMD@AHCI?5bus?5?9?$DO?5?$CFd?0?5dev?5?9?$DO?5?$CFd?0?5func@ ; `string'
PUBLIC	??_C@_0BG@ELEJDLJH@ahci?1sata?5not?5found?5?6@	; `string'
PUBLIC	??_C@_0BK@JGHJMPLA@AHCI?5PCIe?5MSI?5allocated?5?6@ ; `string'
PUBLIC	??_C@_0CA@ENIJEJNM@ahci?1sata?5version?5?$CFd?4?$CFd?5found?5?6@ ; `string'
PUBLIC	??_C@_0CC@BJMEDIGF@ahci?5sata?5drive?5found?5at?5port?5?$CF@ ; `string'
PUBLIC	??_C@_0CE@JJODIKEB@ahci?5satapi?5drive?5found?5at?5port@ ; `string'
PUBLIC	??_C@_0CC@BPDOEHHH@ahci?5semb?5drive?5found?5at?5port?5?$CF@ ; `string'
PUBLIC	??_C@_0CA@JLCKCBKI@ahci?5pm?5drive?5found?5at?5port?5?$CFd?6@ ; `string'
EXTRN	AuTextOut:PROC
EXTRN	AuInterruptEnd:PROC
EXTRN	AuDisableInterrupt:PROC
EXTRN	AuEnableInterrupt:PROC
EXTRN	AuPCIEAllocMSI:PROC
EXTRN	AuPCIEScanClass:PROC
EXTRN	AuPCIEWrite:PROC
EXTRN	AuPCIERead:PROC
EXTRN	setvect:PROC
EXTRN	?APICTimerSleep@@YAXI@Z:PROC			; APICTimerSleep
EXTRN	AuMapMMIO:PROC
EXTRN	?AuAHCIDiskInitialise@@YAXPEAU_hba_port_@@@Z:PROC ; AuAHCIDiskInitialise
EXTRN	__CheckForDebuggerJustMyCode:PROC
_BSS	SEGMENT
?__IsAHCI64Bit@@3_NA DB 01H DUP (?)			; __IsAHCI64Bit
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuAHCIInitialise@@YAXXZ DD imagerel $LN18
	DD	imagerel $LN18+966
	DD	imagerel $unwind$?AuAHCIInitialise@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AHCIInterruptHandler@@YAX_KPEAX@Z DD imagerel $LN7
	DD	imagerel $LN7+200
	DD	imagerel $unwind$?AHCIInterruptHandler@@YAX_KPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuAHCICheckType@@YAHPEAU_hba_port_@@@Z DD imagerel $LN11
	DD	imagerel $LN11+155
	DD	imagerel $unwind$?AuAHCICheckType@@YAHPEAU_hba_port_@@@Z
pdata	ENDS
;	COMDAT ??_C@_0CA@JLCKCBKI@ahci?5pm?5drive?5found?5at?5port?5?$CFd?6@
CONST	SEGMENT
??_C@_0CA@JLCKCBKI@ahci?5pm?5drive?5found?5at?5port?5?$CFd?6@ DB 'ahci pm'
	DB	' drive found at port %d', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@BPDOEHHH@ahci?5semb?5drive?5found?5at?5port?5?$CF@
CONST	SEGMENT
??_C@_0CC@BPDOEHHH@ahci?5semb?5drive?5found?5at?5port?5?$CF@ DB 'ahci sem'
	DB	'b drive found at port %d', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@JJODIKEB@ahci?5satapi?5drive?5found?5at?5port@
CONST	SEGMENT
??_C@_0CE@JJODIKEB@ahci?5satapi?5drive?5found?5at?5port@ DB 'ahci satapi '
	DB	'drive found at port %d', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@BJMEDIGF@ahci?5sata?5drive?5found?5at?5port?5?$CF@
CONST	SEGMENT
??_C@_0CC@BJMEDIGF@ahci?5sata?5drive?5found?5at?5port?5?$CF@ DB 'ahci sat'
	DB	'a drive found at port %d', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@ENIJEJNM@ahci?1sata?5version?5?$CFd?4?$CFd?5found?5?6@
CONST	SEGMENT
??_C@_0CA@ENIJEJNM@ahci?1sata?5version?5?$CFd?4?$CFd?5found?5?6@ DB 'ahci'
	DB	'/sata version %d.%d found ', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@JGHJMPLA@AHCI?5PCIe?5MSI?5allocated?5?6@
CONST	SEGMENT
??_C@_0BK@JGHJMPLA@AHCI?5PCIe?5MSI?5allocated?5?6@ DB 'AHCI PCIe MSI allo'
	DB	'cated ', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@ELEJDLJH@ahci?1sata?5not?5found?5?6@
CONST	SEGMENT
??_C@_0BG@ELEJDLJH@ahci?1sata?5not?5found?5?6@ DB 'ahci/sata not found ', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@CILLCAMD@AHCI?5bus?5?9?$DO?5?$CFd?0?5dev?5?9?$DO?5?$CFd?0?5func@
CONST	SEGMENT
??_C@_0CI@CILLCAMD@AHCI?5bus?5?9?$DO?5?$CFd?0?5dev?5?9?$DO?5?$CFd?0?5func@ DB 'A'
	DB	'HCI bus -> %d, dev -> %d, func -> %d ', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuAHCICheckType@@YAHPEAU_hba_port_@@@Z DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AHCIInterruptHandler@@YAX_KPEAX@Z DD 025031701H
	DD	0f2122317H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuAHCIInitialise@@YAXXZ DD 035040e01H
	DD	0109330eH
	DD	05002001aH
xdata	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\ahci.cpp
;	COMDAT ?AuAHCICheckType@@YAHPEAU_hba_port_@@@Z
_TEXT	SEGMENT
ssts$ = 0
ipm$ = 4
det$ = 5
tv75 = 72
port$ = 96
?AuAHCICheckType@@YAHPEAU_hba_port_@@@Z PROC		; AuAHCICheckType, COMDAT

; 79   : int AuAHCICheckType(HBA_PORT *port) {

$LN11:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__22E58447_ahci@cpp
	call	__CheckForDebuggerJustMyCode

; 80   : 	uint32_t ssts = port->ssts;

	mov	rax, QWORD PTR port$[rbp]
	mov	eax, DWORD PTR [rax+40]
	mov	DWORD PTR ssts$[rbp], eax

; 81   : 	uint8_t ipm = (ssts >> 8) & 0x0F;

	mov	eax, DWORD PTR ssts$[rbp]
	shr	eax, 8
	and	eax, 15
	mov	BYTE PTR ipm$[rbp], al

; 82   : 	uint8_t det = ssts & 0x0F;

	mov	eax, DWORD PTR ssts$[rbp]
	and	eax, 15
	mov	BYTE PTR det$[rbp], al

; 83   : 
; 84   : 	if (det != HBA_PORT_DET_PRESENT)

	movzx	eax, BYTE PTR det$[rbp]
	cmp	eax, 3
	je	SHORT $LN4@AuAHCIChec

; 85   : 		return AHCI_DEV_NULL;

	xor	eax, eax
	jmp	SHORT $LN1@AuAHCIChec
$LN4@AuAHCIChec:

; 86   : 	if (ipm != HBA_PORT_IPM_ACTIVE)

	movzx	eax, BYTE PTR ipm$[rbp]
	cmp	eax, 1
	je	SHORT $LN5@AuAHCIChec

; 87   : 		return AHCI_DEV_NULL;

	xor	eax, eax
	jmp	SHORT $LN1@AuAHCIChec
$LN5@AuAHCIChec:

; 88   : 
; 89   : 	switch (port->sig) {

	mov	rax, QWORD PTR port$[rbp]
	mov	eax, DWORD PTR [rax+36]
	mov	DWORD PTR tv75[rbp], eax
	cmp	DWORD PTR tv75[rbp], -1771503359	; 96690101H
	je	SHORT $LN8@AuAHCIChec
	cmp	DWORD PTR tv75[rbp], -1019477759	; c33c0101H
	je	SHORT $LN7@AuAHCIChec
	cmp	DWORD PTR tv75[rbp], -351010559		; eb140101H
	je	SHORT $LN6@AuAHCIChec
	jmp	SHORT $LN9@AuAHCIChec
$LN6@AuAHCIChec:

; 90   : 	case SATA_SIG_ATAPI:
; 91   : 		return AHCI_DEV_SATAPI;

	mov	eax, 4
	jmp	SHORT $LN1@AuAHCIChec
$LN7@AuAHCIChec:

; 92   : 	case SATA_SIG_SEMB:
; 93   : 		return AHCI_DEV_SEMB;

	mov	eax, 2
	jmp	SHORT $LN1@AuAHCIChec
$LN8@AuAHCIChec:

; 94   : 	case SATA_SIG_PM:
; 95   : 		return AHCI_DEV_PM;

	mov	eax, 3
	jmp	SHORT $LN1@AuAHCIChec
$LN9@AuAHCIChec:

; 96   : 	default:
; 97   : 		return AHCI_DEV_SATA;

	mov	eax, 1
$LN1@AuAHCIChec:

; 98   : 	}
; 99   : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
?AuAHCICheckType@@YAHPEAU_hba_port_@@@Z ENDP		; AuAHCICheckType
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\ahci.cpp
;	COMDAT ?AHCIInterruptHandler@@YAX_KPEAX@Z
_TEXT	SEGMENT
hba$ = 0
is$ = 8
i$1 = 12
port_is$2 = 16
v$ = 112
p$ = 120
?AHCIInterruptHandler@@YAX_KPEAX@Z PROC			; AHCIInterruptHandler, COMDAT

; 57   : void AHCIInterruptHandler(size_t v, void* p){

$LN7:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 128				; 00000080H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__22E58447_ahci@cpp
	call	__CheckForDebuggerJustMyCode

; 58   : 	AuDisableInterrupt();

	call	AuDisableInterrupt

; 59   : 	HBA_MEM* hba = (HBA_MEM*)HBABar;

	mov	rax, QWORD PTR ?HBABar@@3PEAXEA		; HBABar
	mov	QWORD PTR hba$[rbp], rax

; 60   : 	uint32_t is = hba->is;

	mov	rax, QWORD PTR hba$[rbp]
	mov	eax, DWORD PTR [rax+8]
	mov	DWORD PTR is$[rbp], eax

; 61   : 	for (int i = 0; i < 32; i++) {

	mov	DWORD PTR i$1[rbp], 0
	jmp	SHORT $LN4@AHCIInterr
$LN2@AHCIInterr:
	mov	eax, DWORD PTR i$1[rbp]
	inc	eax
	mov	DWORD PTR i$1[rbp], eax
$LN4@AHCIInterr:
	cmp	DWORD PTR i$1[rbp], 32			; 00000020H
	jge	SHORT $LN3@AHCIInterr

; 62   : 		if ((hba->is & hba->pi & (1 << i))) {

	mov	rax, QWORD PTR hba$[rbp]
	mov	rcx, QWORD PTR hba$[rbp]
	mov	ecx, DWORD PTR [rcx+12]
	mov	eax, DWORD PTR [rax+8]
	and	eax, ecx
	mov	ecx, DWORD PTR i$1[rbp]
	mov	edx, 1
	shl	edx, cl
	mov	ecx, edx
	and	eax, ecx
	test	eax, eax
	je	SHORT $LN5@AHCIInterr

; 63   : 			uint32_t port_is = hba->port[i].is;

	movsxd	rax, DWORD PTR i$1[rbp]
	imul	rax, rax, 128				; 00000080H
	mov	rcx, QWORD PTR hba$[rbp]
	mov	eax, DWORD PTR [rcx+rax+272]
	mov	DWORD PTR port_is$2[rbp], eax

; 64   : 			hba->port[i].is = port_is;

	movsxd	rax, DWORD PTR i$1[rbp]
	imul	rax, rax, 128				; 00000080H
	mov	rcx, QWORD PTR hba$[rbp]
	mov	edx, DWORD PTR port_is$2[rbp]
	mov	DWORD PTR [rcx+rax+272], edx

; 65   : 			break;

	jmp	SHORT $LN3@AHCIInterr
$LN5@AHCIInterr:

; 66   : 		}
; 67   : 	}

	jmp	SHORT $LN2@AHCIInterr
$LN3@AHCIInterr:

; 68   : 
; 69   : 	hba->is = is;

	mov	rax, QWORD PTR hba$[rbp]
	mov	ecx, DWORD PTR is$[rbp]
	mov	DWORD PTR [rax+8], ecx

; 70   : 	AuEnableInterrupt();

	call	AuEnableInterrupt

; 71   : 	AuInterruptEnd(0);

	xor	ecx, ecx
	call	AuInterruptEnd

; 72   : }

	lea	rsp, QWORD PTR [rbp+96]
	pop	rbp
	ret	0
?AHCIInterruptHandler@@YAX_KPEAX@Z ENDP			; AHCIInterruptHandler
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\ahci.cpp
;	COMDAT ?AuAHCIInitialise@@YAXXZ
_TEXT	SEGMENT
bus$ = 0
dev$ = 4
func$ = 8
AhciNotFound$ = 12
device$ = 16
int_line$ = 24
baseAddr$ = 28
cmd$ = 32
hba_phys$ = 40
MMIO$ = 48
hba$ = 56
version_major$ = 64
version_minor$ = 68
_bit$ = 72
num_cmd_slots$ = 76
support_spin$ = 80
pi$ = 84
i$ = 88
dt$1 = 92
?AuAHCIInitialise@@YAXXZ PROC				; AuAHCIInitialise, COMDAT

; 104  : void AuAHCIInitialise() {

$LN18:
	push	rbp
	sub	rsp, 208				; 000000d0H
	lea	rbp, QWORD PTR [rsp+48]
	lea	rcx, OFFSET FLAT:__22E58447_ahci@cpp
	call	__CheckForDebuggerJustMyCode

; 105  : 	int bus, dev, func = 0;

	mov	DWORD PTR func$[rbp], 0

; 106  : 	bool AhciNotFound = false;

	mov	BYTE PTR AhciNotFound$[rbp], 0

; 107  : 
; 108  : 	uint64_t device = AuPCIEScanClass(0x01, 0x06, &bus, &dev, &func);

	lea	rax, QWORD PTR func$[rbp]
	mov	QWORD PTR [rsp+32], rax
	lea	r9, QWORD PTR dev$[rbp]
	lea	r8, QWORD PTR bus$[rbp]
	mov	dl, 6
	mov	cl, 1
	call	AuPCIEScanClass
	mov	QWORD PTR device$[rbp], rax

; 109  : 	if (device == UINT32_MAX)

	mov	eax, -1					; ffffffffH
	cmp	QWORD PTR device$[rbp], rax
	jne	SHORT $LN4@AuAHCIInit

; 110  : 		AhciNotFound = true;

	mov	BYTE PTR AhciNotFound$[rbp], 1
$LN4@AuAHCIInit:

; 111  : 
; 112  : 	AuTextOut("AHCI bus -> %d, dev -> %d, func -> %d \n", bus, dev, func);

	mov	r9d, DWORD PTR func$[rbp]
	mov	r8d, DWORD PTR dev$[rbp]
	mov	edx, DWORD PTR bus$[rbp]
	lea	rcx, OFFSET FLAT:??_C@_0CI@CILLCAMD@AHCI?5bus?5?9?$DO?5?$CFd?0?5dev?5?9?$DO?5?$CFd?0?5func@
	call	AuTextOut

; 113  : 	if (AhciNotFound) {

	movzx	eax, BYTE PTR AhciNotFound$[rbp]
	test	eax, eax
	je	SHORT $LN5@AuAHCIInit

; 114  : 		device = AuPCIEScanClass(0x01, 0x04, &bus, &dev, &func);

	lea	rax, QWORD PTR func$[rbp]
	mov	QWORD PTR [rsp+32], rax
	lea	r9, QWORD PTR dev$[rbp]
	lea	r8, QWORD PTR bus$[rbp]
	mov	dl, 4
	mov	cl, 1
	call	AuPCIEScanClass
	mov	QWORD PTR device$[rbp], rax

; 115  : 		if (device == UINT32_MAX) {

	mov	eax, -1					; ffffffffH
	cmp	QWORD PTR device$[rbp], rax
	jne	SHORT $LN6@AuAHCIInit

; 116  : 			AuTextOut("ahci/sata not found \n");

	lea	rcx, OFFSET FLAT:??_C@_0BG@ELEJDLJH@ahci?1sata?5not?5found?5?6@
	call	AuTextOut

; 117  : 			return;

	jmp	$LN1@AuAHCIInit
$LN6@AuAHCIInit:
$LN5@AuAHCIInit:

; 118  : 		}
; 119  : 	}
; 120  : 
; 121  : 	uint32_t int_line = AuPCIERead(device, PCI_INTERRUPT_LINE, bus, dev, func);

	mov	eax, DWORD PTR func$[rbp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR dev$[rbp]
	mov	r8d, DWORD PTR bus$[rbp]
	mov	edx, 60					; 0000003cH
	mov	rcx, QWORD PTR device$[rbp]
	call	AuPCIERead
	mov	DWORD PTR int_line$[rbp], eax

; 122  : 	uint32_t baseAddr = AuPCIERead(device, PCI_BAR5, bus, dev, func);

	mov	eax, DWORD PTR func$[rbp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR dev$[rbp]
	mov	r8d, DWORD PTR bus$[rbp]
	mov	edx, 36					; 00000024H
	mov	rcx, QWORD PTR device$[rbp]
	call	AuPCIERead
	mov	DWORD PTR baseAddr$[rbp], eax

; 123  : 
; 124  : 	uint64_t cmd = AuPCIERead(device, PCI_COMMAND, bus, dev, func);

	mov	eax, DWORD PTR func$[rbp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR dev$[rbp]
	mov	r8d, DWORD PTR bus$[rbp]
	mov	edx, 4
	mov	rcx, QWORD PTR device$[rbp]
	call	AuPCIERead
	mov	eax, eax
	mov	QWORD PTR cmd$[rbp], rax

; 125  : 	cmd |= (1 << 1);

	mov	rax, QWORD PTR cmd$[rbp]
	or	rax, 2
	mov	QWORD PTR cmd$[rbp], rax

; 126  : 	cmd |= (1 << 2);

	mov	rax, QWORD PTR cmd$[rbp]
	or	rax, 4
	mov	QWORD PTR cmd$[rbp], rax

; 127  : 	cmd |= (1 << 10);

	mov	rax, QWORD PTR cmd$[rbp]
	bts	rax, 10
	mov	QWORD PTR cmd$[rbp], rax

; 128  : 	AuPCIEWrite(device, PCI_COMMAND, cmd, bus, dev, func);

	mov	eax, DWORD PTR func$[rbp]
	mov	DWORD PTR [rsp+40], eax
	mov	eax, DWORD PTR dev$[rbp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR bus$[rbp]
	mov	r8d, DWORD PTR cmd$[rbp]
	mov	edx, 4
	mov	rcx, QWORD PTR device$[rbp]
	call	AuPCIEWrite

; 129  : 
; 130  : 	if (AuPCIEAllocMSI(device, 36, bus, dev, func))

	mov	eax, DWORD PTR func$[rbp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR dev$[rbp]
	mov	r8d, DWORD PTR bus$[rbp]
	mov	edx, 36					; 00000024H
	mov	rcx, QWORD PTR device$[rbp]
	call	AuPCIEAllocMSI
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN7@AuAHCIInit

; 131  : 		AuTextOut("AHCI PCIe MSI allocated \n");

	lea	rcx, OFFSET FLAT:??_C@_0BK@JGHJMPLA@AHCI?5PCIe?5MSI?5allocated?5?6@
	call	AuTextOut
$LN7@AuAHCIInit:

; 132  : 	setvect(36, AHCIInterruptHandler);

	lea	rdx, OFFSET FLAT:?AHCIInterruptHandler@@YAX_KPEAX@Z ; AHCIInterruptHandler
	mov	ecx, 36					; 00000024H
	call	setvect

; 133  : 
; 134  : 	uint32_t hba_phys = baseAddr & 0xFFFFFFF0;

	mov	eax, DWORD PTR baseAddr$[rbp]
	and	eax, -16				; fffffff0H
	mov	DWORD PTR hba_phys$[rbp], eax

; 135  : 	void* MMIO = AuMapMMIO(hba_phys, 3);

	mov	eax, DWORD PTR hba_phys$[rbp]
	mov	edx, 3
	mov	ecx, eax
	call	AuMapMMIO
	mov	QWORD PTR MMIO$[rbp], rax

; 136  : 	HBA_MEM* hba = (HBA_MEM*)MMIO;

	mov	rax, QWORD PTR MMIO$[rbp]
	mov	QWORD PTR hba$[rbp], rax

; 137  : 	HBABar = MMIO;

	mov	rax, QWORD PTR MMIO$[rbp]
	mov	QWORD PTR ?HBABar@@3PEAXEA, rax		; HBABar

; 138  : 	hba->ghc = 1;

	mov	rax, QWORD PTR hba$[rbp]
	mov	DWORD PTR [rax+4], 1

; 139  : 
; 140  : 	APICTimerSleep(1);

	mov	ecx, 1
	call	?APICTimerSleep@@YAXI@Z			; APICTimerSleep

; 141  : 	hba->ghc = (1 << 31);

	mov	rax, QWORD PTR hba$[rbp]
	mov	DWORD PTR [rax+4], -2147483648		; 80000000H

; 142  : 	APICTimerSleep(1);

	mov	ecx, 1
	call	?APICTimerSleep@@YAXI@Z			; APICTimerSleep

; 143  : 
; 144  : 	uint32_t version_major = hba->vs >> 16 & 0xff;

	mov	rax, QWORD PTR hba$[rbp]
	mov	eax, DWORD PTR [rax+16]
	shr	eax, 16
	and	eax, 255				; 000000ffH
	mov	DWORD PTR version_major$[rbp], eax

; 145  : 	uint32_t version_minor = hba->vs & 0xff;

	mov	rax, QWORD PTR hba$[rbp]
	mov	eax, DWORD PTR [rax+16]
	and	eax, 255				; 000000ffH
	mov	DWORD PTR version_minor$[rbp], eax

; 146  : 
; 147  : 	AuTextOut("ahci/sata version %d.%d found \n", version_major, version_minor);

	mov	r8d, DWORD PTR version_minor$[rbp]
	mov	edx, DWORD PTR version_major$[rbp]
	lea	rcx, OFFSET FLAT:??_C@_0CA@ENIJEJNM@ahci?1sata?5version?5?$CFd?4?$CFd?5found?5?6@
	call	AuTextOut

; 148  : 
; 149  : 	uint32_t _bit = hba->cap >> 31 & 0xff;

	mov	rax, QWORD PTR hba$[rbp]
	mov	eax, DWORD PTR [rax]
	shr	eax, 31
	and	eax, 255				; 000000ffH
	mov	DWORD PTR _bit$[rbp], eax

; 150  : 	if (_bit)

	cmp	DWORD PTR _bit$[rbp], 0
	je	SHORT $LN8@AuAHCIInit

; 151  : 		__IsAHCI64Bit = true;

	mov	BYTE PTR ?__IsAHCI64Bit@@3_NA, 1
$LN8@AuAHCIInit:

; 152  : 
; 153  : 	hba->is = UINT32_MAX;

	mov	rax, QWORD PTR hba$[rbp]
	mov	DWORD PTR [rax+8], -1			; ffffffffH

; 154  : 	hba->ghc |= 0x2;

	mov	rax, QWORD PTR hba$[rbp]
	mov	eax, DWORD PTR [rax+4]
	or	eax, 2
	mov	rcx, QWORD PTR hba$[rbp]
	mov	DWORD PTR [rcx+4], eax

; 155  : 
; 156  : 	uint32_t num_cmd_slots = hba->cap >> 8 & 0xff;

	mov	rax, QWORD PTR hba$[rbp]
	mov	eax, DWORD PTR [rax]
	shr	eax, 8
	and	eax, 255				; 000000ffH
	mov	DWORD PTR num_cmd_slots$[rbp], eax

; 157  : 	uint8_t support_spin = hba->cap & (1 << 27);

	mov	rax, QWORD PTR hba$[rbp]
	mov	eax, DWORD PTR [rax]
	and	eax, 134217728				; 08000000H
	mov	BYTE PTR support_spin$[rbp], al

; 158  : 
; 159  : 
; 160  : 	uint32_t pi = hba->pi;

	mov	rax, QWORD PTR hba$[rbp]
	mov	eax, DWORD PTR [rax+12]
	mov	DWORD PTR pi$[rbp], eax

; 161  : 	int i = 0;

	mov	DWORD PTR i$[rbp], 0
$LN2@AuAHCIInit:

; 162  : 	while (i < 32) {

	cmp	DWORD PTR i$[rbp], 32			; 00000020H
	jge	$LN3@AuAHCIInit

; 163  : 		if (pi & 1) {

	mov	eax, DWORD PTR pi$[rbp]
	and	eax, 1
	test	eax, eax
	je	$LN9@AuAHCIInit

; 164  : 			int dt = AuAHCICheckType(&hba->port[i]);

	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 128				; 00000080H
	mov	rcx, QWORD PTR hba$[rbp]
	lea	rax, QWORD PTR [rcx+rax+256]
	mov	rcx, rax
	call	?AuAHCICheckType@@YAHPEAU_hba_port_@@@Z	; AuAHCICheckType
	mov	DWORD PTR dt$1[rbp], eax

; 165  : 			if (dt == AHCI_DEV_SATA) {

	cmp	DWORD PTR dt$1[rbp], 1
	jne	$LN10@AuAHCIInit

; 166  : 				AuTextOut("ahci sata drive found at port %d\n", i);

	mov	edx, DWORD PTR i$[rbp]
	lea	rcx, OFFSET FLAT:??_C@_0CC@BJMEDIGF@ahci?5sata?5drive?5found?5at?5port?5?$CF@
	call	AuTextOut

; 167  : 				hba->port[i].sctl &= ~PX_SCTL_IPM_MASK;

	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 128				; 00000080H
	mov	rcx, QWORD PTR hba$[rbp]
	mov	eax, DWORD PTR [rcx+rax+300]
	and	eax, -4096				; fffff000H
	movsxd	rcx, DWORD PTR i$[rbp]
	imul	rcx, rcx, 128				; 00000080H
	mov	rdx, QWORD PTR hba$[rbp]
	mov	DWORD PTR [rdx+rcx+300], eax

; 168  : 				hba->port[i].sctl |= PX_SCTL_IPM_NONE;

	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 128				; 00000080H
	mov	rcx, QWORD PTR hba$[rbp]
	mov	eax, DWORD PTR [rcx+rax+300]
	or	eax, 768				; 00000300H
	movsxd	rcx, DWORD PTR i$[rbp]
	imul	rcx, rcx, 128				; 00000080H
	mov	rdx, QWORD PTR hba$[rbp]
	mov	DWORD PTR [rdx+rcx+300], eax

; 169  : 				AuAHCIDiskInitialise(&hba->port[i]);

	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 128				; 00000080H
	mov	rcx, QWORD PTR hba$[rbp]
	lea	rax, QWORD PTR [rcx+rax+256]
	mov	rcx, rax
	call	?AuAHCIDiskInitialise@@YAXPEAU_hba_port_@@@Z ; AuAHCIDiskInitialise

; 170  : 			}

	jmp	SHORT $LN11@AuAHCIInit
$LN10@AuAHCIInit:

; 171  : 			else if (dt == AHCI_DEV_SATAPI) {

	cmp	DWORD PTR dt$1[rbp], 4
	jne	SHORT $LN12@AuAHCIInit

; 172  : 				AuTextOut("ahci satapi drive found at port %d\n", i);

	mov	edx, DWORD PTR i$[rbp]
	lea	rcx, OFFSET FLAT:??_C@_0CE@JJODIKEB@ahci?5satapi?5drive?5found?5at?5port@
	call	AuTextOut

; 173  : 			}

	jmp	SHORT $LN13@AuAHCIInit
$LN12@AuAHCIInit:

; 174  : 			else if (dt == AHCI_DEV_SEMB) {

	cmp	DWORD PTR dt$1[rbp], 2
	jne	SHORT $LN14@AuAHCIInit

; 175  : 				AuTextOut("ahci semb drive found at port %d\n", i);

	mov	edx, DWORD PTR i$[rbp]
	lea	rcx, OFFSET FLAT:??_C@_0CC@BPDOEHHH@ahci?5semb?5drive?5found?5at?5port?5?$CF@
	call	AuTextOut

; 176  : 			}

	jmp	SHORT $LN15@AuAHCIInit
$LN14@AuAHCIInit:

; 177  : 			else if (dt == AHCI_DEV_PM) {

	cmp	DWORD PTR dt$1[rbp], 3
	jne	SHORT $LN16@AuAHCIInit

; 178  : 				AuTextOut("ahci pm drive found at port %d\n", i);

	mov	edx, DWORD PTR i$[rbp]
	lea	rcx, OFFSET FLAT:??_C@_0CA@JLCKCBKI@ahci?5pm?5drive?5found?5at?5port?5?$CFd?6@
	call	AuTextOut
$LN16@AuAHCIInit:
$LN15@AuAHCIInit:
$LN13@AuAHCIInit:
$LN11@AuAHCIInit:
$LN9@AuAHCIInit:

; 179  : 			}
; 180  : 		}
; 181  : 		pi >>= 1;

	mov	eax, DWORD PTR pi$[rbp]
	shr	eax, 1
	mov	DWORD PTR pi$[rbp], eax

; 182  : 		i++;

	mov	eax, DWORD PTR i$[rbp]
	inc	eax
	mov	DWORD PTR i$[rbp], eax

; 183  : 	}

	jmp	$LN2@AuAHCIInit
$LN3@AuAHCIInit:
$LN1@AuAHCIInit:

; 184  : }

	lea	rsp, QWORD PTR [rbp+160]
	pop	rbp
	ret	0
?AuAHCIInitialise@@YAXXZ ENDP				; AuAHCIInitialise
_TEXT	ENDS
END
