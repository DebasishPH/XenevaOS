; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30154.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

msvcjmc	SEGMENT
__E3FE814C_devfs@cpp DB 01H
msvcjmc	ENDS
PUBLIC	?AuDeviceFsInitialize@@YAXXZ			; AuDeviceFsInitialize
PUBLIC	?AuDevFSCreateFile@@YAHPEAU__VFS_NODE__@@PEADE@Z ; AuDevFSCreateFile
PUBLIC	AuDevFSAddFile
PUBLIC	?AuDevFSOpen@@YAPEAU__VFS_NODE__@@PEAU1@PEAD@Z	; AuDevFSOpen
PUBLIC	?AuDevFSList@@YAXPEAU__VFS_NODE__@@@Z		; AuDevFSList
PUBLIC	AuDevFSRemoveFile
PUBLIC	?AuDevFSListDir@@YAXPEAU__VFS_NODE__@@0@Z	; AuDevFSListDir
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_03FNIGJHAM@dev@				; `string'
PUBLIC	??_C@_0BL@OENOBNFE@Listing?5Directory?5?9?$DO?5?$CFs?5?$AN?6@ ; `string'
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_C@_06OIEJKIHP@Device@			; `string'
PUBLIC	??_C@_09EOAFACM@Directory@			; `string'
PUBLIC	??_C@_07NBCGADJA@Unknown@			; `string'
PUBLIC	??_C@_0BJ@ENJNFDOI@File?5?9?$DO?5?5?$CFs?5mode?5?9?5?$CFs?5?$AN?6@ ; `string'
PUBLIC	??_C@_0BF@OJGGANOJ@Listing?5device?5fs?5?$AN?6@	; `string'
PUBLIC	??_C@_04LJLIIBC@Pipe@				; `string'
PUBLIC	??_C@_0BA@PEJEKPNO@?$CFs?5mode?5?9?5?$CFs?5?$AN?6@ ; `string'
EXTRN	initialize_list:PROC
EXTRN	list_add:PROC
EXTRN	list_remove:PROC
EXTRN	list_get_at:PROC
EXTRN	AuVFSAddFileSystem:PROC
EXTRN	?AuDevInputInitialise@@YAXXZ:PROC		; AuDevInputInitialise
EXTRN	kmalloc:PROC
EXTRN	kfree:PROC
EXTRN	strcmp:PROC
EXTRN	strcpy:PROC
EXTRN	strchr:PROC
EXTRN	memset:PROC
EXTRN	SeTextOut:PROC
EXTRN	__CheckForDebuggerJustMyCode:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuDeviceFsInitialize@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+165
	DD	imagerel $unwind$?AuDeviceFsInitialize@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuDevFSCreateFile@@YAHPEAU__VFS_NODE__@@PEADE@Z DD imagerel $LN20
	DD	imagerel $LN20+543
	DD	imagerel $unwind$?AuDevFSCreateFile@@YAHPEAU__VFS_NODE__@@PEADE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AuDevFSAddFile DD imagerel $LN18
	DD	imagerel $LN18+398
	DD	imagerel $unwind$AuDevFSAddFile
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuDevFSOpen@@YAPEAU__VFS_NODE__@@PEAU1@PEAD@Z DD imagerel $LN21
	DD	imagerel $LN21+402
	DD	imagerel $unwind$?AuDevFSOpen@@YAPEAU__VFS_NODE__@@PEAU1@PEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuDevFSList@@YAXPEAU__VFS_NODE__@@@Z DD imagerel $LN13
	DD	imagerel $LN13+278
	DD	imagerel $unwind$?AuDevFSList@@YAXPEAU__VFS_NODE__@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AuDevFSRemoveFile DD imagerel $LN22
	DD	imagerel $LN22+515
	DD	imagerel $unwind$AuDevFSRemoveFile
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuDevFSListDir@@YAXPEAU__VFS_NODE__@@0@Z DD imagerel $LN10
	DD	imagerel $LN10+228
	DD	imagerel $unwind$?AuDevFSListDir@@YAXPEAU__VFS_NODE__@@0@Z
pdata	ENDS
;	COMDAT ??_C@_0BA@PEJEKPNO@?$CFs?5mode?5?9?5?$CFs?5?$AN?6@
CONST	SEGMENT
??_C@_0BA@PEJEKPNO@?$CFs?5mode?5?9?5?$CFs?5?$AN?6@ DB '%s mode - %s ', 0dH
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_04LJLIIBC@Pipe@
CONST	SEGMENT
??_C@_04LJLIIBC@Pipe@ DB 'Pipe', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@OJGGANOJ@Listing?5device?5fs?5?$AN?6@
CONST	SEGMENT
??_C@_0BF@OJGGANOJ@Listing?5device?5fs?5?$AN?6@ DB 'Listing device fs ', 0dH
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@ENJNFDOI@File?5?9?$DO?5?5?$CFs?5mode?5?9?5?$CFs?5?$AN?6@
CONST	SEGMENT
??_C@_0BJ@ENJNFDOI@File?5?9?$DO?5?5?$CFs?5mode?5?9?5?$CFs?5?$AN?6@ DB 'Fi'
	DB	'le ->  %s mode - %s ', 0dH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07NBCGADJA@Unknown@
CONST	SEGMENT
??_C@_07NBCGADJA@Unknown@ DB 'Unknown', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09EOAFACM@Directory@
CONST	SEGMENT
??_C@_09EOAFACM@Directory@ DB 'Directory', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06OIEJKIHP@Device@
CONST	SEGMENT
??_C@_06OIEJKIHP@Device@ DB 'Device', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@OENOBNFE@Listing?5Directory?5?9?$DO?5?$CFs?5?$AN?6@
CONST	SEGMENT
??_C@_0BL@OENOBNFE@Listing?5Directory?5?9?$DO?5?$CFs?5?$AN?6@ DB 'Listing'
	DB	' Directory -> %s ', 0dH, 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03FNIGJHAM@dev@
CONST	SEGMENT
??_C@_03FNIGJHAM@dev@ DB 'dev', 00H			; `string'
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuDevFSListDir@@YAXPEAU__VFS_NODE__@@0@Z DD 025031701H
	DD	0f2122317H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AuDevFSRemoveFile DD 025041701H
	DD	01122317H
	DD	0500b0016H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuDevFSList@@YAXPEAU__VFS_NODE__@@@Z DD 025031201H
	DD	0f20d2312H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuDevFSOpen@@YAPEAU__VFS_NODE__@@PEAU1@PEAD@Z DD 025041701H
	DD	01122317H
	DD	0500b0014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AuDevFSAddFile DD 025041c01H
	DD	0117231cH
	DD	050100014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuDevFSCreateFile@@YAHPEAU__VFS_NODE__@@PEADE@Z DD 025041c01H
	DD	0117231cH
	DD	050100016H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuDeviceFsInitialize@@YAXXZ DD 025030b01H
	DD	0d206230bH
	DD	05002H
xdata	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Fs\Dev\devfs.cpp
;	COMDAT ?AuDevFSListDir@@YAXPEAU__VFS_NODE__@@0@Z
_TEXT	SEGMENT
entries$ = 0
i$1 = 8
node_$2 = 16
mode$3 = 24
fs$ = 112
dir$ = 120
?AuDevFSListDir@@YAXPEAU__VFS_NODE__@@0@Z PROC		; AuDevFSListDir, COMDAT

; 163  : void AuDevFSListDir(AuVFSNode* fs, AuVFSNode* dir) {

$LN10:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 128				; 00000080H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__E3FE814C_devfs@cpp
	call	__CheckForDebuggerJustMyCode

; 164  : 	AuVFSContainer* entries = (AuVFSContainer*)dir->device;

	mov	rax, QWORD PTR dir$[rbp]
	mov	rax, QWORD PTR [rax+64]
	mov	QWORD PTR entries$[rbp], rax

; 165  : 	SeTextOut("Listing Directory -> %s \r\n", dir->filename);

	mov	rax, QWORD PTR dir$[rbp]
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:??_C@_0BL@OENOBNFE@Listing?5Directory?5?9?$DO?5?$CFs?5?$AN?6@
	call	SeTextOut

; 166  : 	for (int i = 0; i < entries->childs->pointer; i++) {

	mov	DWORD PTR i$1[rbp], 0
	jmp	SHORT $LN4@AuDevFSLis
$LN2@AuDevFSLis:
	mov	eax, DWORD PTR i$1[rbp]
	inc	eax
	mov	DWORD PTR i$1[rbp], eax
$LN4@AuDevFSLis:
	mov	rax, QWORD PTR entries$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	eax, DWORD PTR [rax]
	cmp	DWORD PTR i$1[rbp], eax
	jae	SHORT $LN3@AuDevFSLis

; 167  : 		AuVFSNode* node_ = (AuVFSNode*)list_get_at(entries->childs, i);

	mov	edx, DWORD PTR i$1[rbp]
	mov	rax, QWORD PTR entries$[rbp]
	mov	rcx, QWORD PTR [rax]
	call	list_get_at
	mov	QWORD PTR node_$2[rbp], rax

; 168  : 		char* mode = "";

	lea	rax, OFFSET FLAT:??_C@_00CNPNBAHC@@
	mov	QWORD PTR mode$3[rbp], rax

; 169  : 		if (node_->flags & FS_FLAG_DEVICE)

	mov	rax, QWORD PTR node_$2[rbp]
	movzx	eax, WORD PTR [rax+61]
	and	eax, 8
	test	eax, eax
	je	SHORT $LN5@AuDevFSLis

; 170  : 			mode = "Device";

	lea	rax, OFFSET FLAT:??_C@_06OIEJKIHP@Device@
	mov	QWORD PTR mode$3[rbp], rax
	jmp	SHORT $LN6@AuDevFSLis
$LN5@AuDevFSLis:

; 171  : 		else if (node_->flags & FS_FLAG_DIRECTORY)

	mov	rax, QWORD PTR node_$2[rbp]
	movzx	eax, WORD PTR [rax+61]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN7@AuDevFSLis

; 172  : 			mode = "Directory";

	lea	rax, OFFSET FLAT:??_C@_09EOAFACM@Directory@
	mov	QWORD PTR mode$3[rbp], rax
	jmp	SHORT $LN8@AuDevFSLis
$LN7@AuDevFSLis:

; 173  : 		else
; 174  : 			mode = "Unknown";

	lea	rax, OFFSET FLAT:??_C@_07NBCGADJA@Unknown@
	mov	QWORD PTR mode$3[rbp], rax
$LN8@AuDevFSLis:
$LN6@AuDevFSLis:

; 175  : 		SeTextOut("File ->  %s mode - %s \r\n", node_->filename, mode);

	mov	rax, QWORD PTR node_$2[rbp]
	mov	r8, QWORD PTR mode$3[rbp]
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:??_C@_0BJ@ENJNFDOI@File?5?9?$DO?5?5?$CFs?5mode?5?9?5?$CFs?5?$AN?6@
	call	SeTextOut

; 176  : 	}

	jmp	$LN2@AuDevFSLis
$LN3@AuDevFSLis:

; 177  : }

	lea	rsp, QWORD PTR [rbp+96]
	pop	rbp
	ret	0
?AuDevFSListDir@@YAXPEAU__VFS_NODE__@@0@Z ENDP		; AuDevFSListDir
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Fs\Dev\devfs.cpp
;	COMDAT AuDevFSRemoveFile
_TEXT	SEGMENT
entries$ = 0
next$ = 8
first_list$ = 16
node_to_rem$ = 24
index$ = 32
pathname$1 = 40
i$2 = 56
j$3 = 60
node_$4 = 64
fs$ = 160
path$ = 168
AuDevFSRemoveFile PROC					; COMDAT

; 251  : int AuDevFSRemoveFile(AuVFSNode* fs,char* path) {

$LN22:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 176				; 000000b0H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__E3FE814C_devfs@cpp
	call	__CheckForDebuggerJustMyCode

; 252  : 	AuVFSContainer* entries = (AuVFSContainer*)fs->device;

	mov	rax, QWORD PTR fs$[rbp]
	mov	rax, QWORD PTR [rax+64]
	mov	QWORD PTR entries$[rbp], rax

; 253  : 	/* now verify the path and add the directory to the list */
; 254  : 	char* next = strchr(path, '/');

	mov	edx, 47					; 0000002fH
	mov	rcx, QWORD PTR path$[rbp]
	call	strchr
	mov	QWORD PTR next$[rbp], rax

; 255  : 	if (next)

	cmp	QWORD PTR next$[rbp], 0
	je	SHORT $LN10@AuDevFSRem

; 256  : 		next++;

	mov	rax, QWORD PTR next$[rbp]
	inc	rax
	mov	QWORD PTR next$[rbp], rax
$LN10@AuDevFSRem:

; 257  : 
; 258  : 	AuVFSContainer *first_list = entries;

	mov	rax, QWORD PTR entries$[rbp]
	mov	QWORD PTR first_list$[rbp], rax

; 259  : 	AuVFSNode *node_to_rem = NULL;

	mov	QWORD PTR node_to_rem$[rbp], 0

; 260  : 	int index = 0;

	mov	DWORD PTR index$[rbp], 0
$LN2@AuDevFSRem:

; 261  : 	while (next) {

	cmp	QWORD PTR next$[rbp], 0
	je	$LN3@AuDevFSRem

; 262  : 		char pathname[16];
; 263  : 		int i;
; 264  : 		for (i = 0; i < 16; i++) {

	mov	DWORD PTR i$2[rbp], 0
	jmp	SHORT $LN6@AuDevFSRem
$LN4@AuDevFSRem:
	mov	eax, DWORD PTR i$2[rbp]
	inc	eax
	mov	DWORD PTR i$2[rbp], eax
$LN6@AuDevFSRem:
	cmp	DWORD PTR i$2[rbp], 16
	jge	SHORT $LN5@AuDevFSRem

; 265  : 			if (next[i] == '/' || next[i] == '\0')

	movsxd	rax, DWORD PTR i$2[rbp]
	mov	rcx, QWORD PTR next$[rbp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 47					; 0000002fH
	je	SHORT $LN12@AuDevFSRem
	movsxd	rax, DWORD PTR i$2[rbp]
	mov	rcx, QWORD PTR next$[rbp]
	movsx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	jne	SHORT $LN11@AuDevFSRem
$LN12@AuDevFSRem:

; 266  : 				break;

	jmp	SHORT $LN5@AuDevFSRem
$LN11@AuDevFSRem:

; 267  : 			pathname[i] = next[i];

	movsxd	rax, DWORD PTR i$2[rbp]
	movsxd	rcx, DWORD PTR i$2[rbp]
	mov	rdx, QWORD PTR next$[rbp]
	movzx	eax, BYTE PTR [rdx+rax]
	mov	BYTE PTR pathname$1[rbp+rcx], al

; 268  : 		}

	jmp	SHORT $LN4@AuDevFSRem
$LN5@AuDevFSRem:

; 269  : 		pathname[i] = 0;

	movsxd	rax, DWORD PTR i$2[rbp]
	mov	BYTE PTR pathname$1[rbp+rax], 0

; 270  : 
; 271  : 		for (int j = 0; j < first_list->childs->pointer; j++) {

	mov	DWORD PTR j$3[rbp], 0
	jmp	SHORT $LN9@AuDevFSRem
$LN7@AuDevFSRem:
	mov	eax, DWORD PTR j$3[rbp]
	inc	eax
	mov	DWORD PTR j$3[rbp], eax
$LN9@AuDevFSRem:
	mov	rax, QWORD PTR first_list$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	eax, DWORD PTR [rax]
	cmp	DWORD PTR j$3[rbp], eax
	jae	SHORT $LN8@AuDevFSRem

; 272  : 			AuVFSNode* node_ = (AuVFSNode*)list_get_at(first_list->childs, j);

	mov	edx, DWORD PTR j$3[rbp]
	mov	rax, QWORD PTR first_list$[rbp]
	mov	rcx, QWORD PTR [rax]
	call	list_get_at
	mov	QWORD PTR node_$4[rbp], rax

; 273  : 			if (strcmp(node_->filename, pathname) == 0) {

	mov	rax, QWORD PTR node_$4[rbp]
	lea	rdx, QWORD PTR pathname$1[rbp]
	mov	rcx, rax
	call	strcmp
	test	eax, eax
	jne	SHORT $LN13@AuDevFSRem

; 274  : 				if (node_->flags & FS_FLAG_DIRECTORY)

	mov	rax, QWORD PTR node_$4[rbp]
	movzx	eax, WORD PTR [rax+61]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN14@AuDevFSRem

; 275  : 					first_list = (AuVFSContainer*)node_->device;

	mov	rax, QWORD PTR node_$4[rbp]
	mov	rax, QWORD PTR [rax+64]
	mov	QWORD PTR first_list$[rbp], rax
	jmp	SHORT $LN15@AuDevFSRem
$LN14@AuDevFSRem:

; 276  : 				else if (node_->flags & FS_FLAG_DEVICE) {

	mov	rax, QWORD PTR node_$4[rbp]
	movzx	eax, WORD PTR [rax+61]
	and	eax, 8
	test	eax, eax
	je	SHORT $LN16@AuDevFSRem

; 277  : 					node_to_rem = node_;

	mov	rax, QWORD PTR node_$4[rbp]
	mov	QWORD PTR node_to_rem$[rbp], rax

; 278  : 					index = j;

	mov	eax, DWORD PTR j$3[rbp]
	mov	DWORD PTR index$[rbp], eax
$LN16@AuDevFSRem:
$LN15@AuDevFSRem:
$LN13@AuDevFSRem:

; 279  : 				}
; 280  : 			}
; 281  : 		}

	jmp	SHORT $LN7@AuDevFSRem
$LN8@AuDevFSRem:

; 282  : 
; 283  : 		next = strchr(next + 1, '/');

	mov	rax, QWORD PTR next$[rbp]
	inc	rax
	mov	edx, 47					; 0000002fH
	mov	rcx, rax
	call	strchr
	mov	QWORD PTR next$[rbp], rax

; 284  : 		if (next)

	cmp	QWORD PTR next$[rbp], 0
	je	SHORT $LN17@AuDevFSRem

; 285  : 			next++;

	mov	rax, QWORD PTR next$[rbp]
	inc	rax
	mov	QWORD PTR next$[rbp], rax
$LN17@AuDevFSRem:

; 286  : 	}

	jmp	$LN2@AuDevFSRem
$LN3@AuDevFSRem:

; 287  : 
; 288  : 	/* only files can be removed */
; 289  : 	if (node_to_rem && node_to_rem->flags & FS_FLAG_DIRECTORY)

	cmp	QWORD PTR node_to_rem$[rbp], 0
	je	SHORT $LN18@AuDevFSRem
	mov	rax, QWORD PTR node_to_rem$[rbp]
	movzx	eax, WORD PTR [rax+61]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN18@AuDevFSRem

; 290  : 		return -1;

	mov	eax, -1
	jmp	SHORT $LN1@AuDevFSRem
$LN18@AuDevFSRem:

; 291  : 
; 292  : 	if (node_to_rem && (node_to_rem->flags & FS_FLAG_DEVICE)){

	cmp	QWORD PTR node_to_rem$[rbp], 0
	je	SHORT $LN19@AuDevFSRem
	mov	rax, QWORD PTR node_to_rem$[rbp]
	movzx	eax, WORD PTR [rax+61]
	and	eax, 8
	test	eax, eax
	je	SHORT $LN19@AuDevFSRem

; 293  : 		list_remove(first_list->childs, index);

	mov	edx, DWORD PTR index$[rbp]
	mov	rax, QWORD PTR first_list$[rbp]
	mov	rcx, QWORD PTR [rax]
	call	list_remove

; 294  : 		/* here, call node_to_rem->close(node_to_rem) in order
; 295  : 		 * to inform the device to shutdown itself */
; 296  : 		if (node_to_rem->close)

	mov	rax, QWORD PTR node_to_rem$[rbp]
	cmp	QWORD PTR [rax+138], 0
	je	SHORT $LN20@AuDevFSRem

; 297  : 			node_to_rem->close(node_to_rem, NULL);

	xor	edx, edx
	mov	rcx, QWORD PTR node_to_rem$[rbp]
	mov	rax, QWORD PTR node_to_rem$[rbp]
	call	QWORD PTR [rax+138]
$LN20@AuDevFSRem:

; 298  : 		kfree(node_to_rem);

	mov	rcx, QWORD PTR node_to_rem$[rbp]
	call	kfree

; 299  : 		return 1;

	mov	eax, 1
	jmp	SHORT $LN1@AuDevFSRem
$LN19@AuDevFSRem:

; 300  : 	}
; 301  : 
; 302  : 	return -1;

	mov	eax, -1
$LN1@AuDevFSRem:

; 303  : }

	lea	rsp, QWORD PTR [rbp+144]
	pop	rbp
	ret	0
AuDevFSRemoveFile ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Fs\Dev\devfs.cpp
;	COMDAT ?AuDevFSList@@YAXPEAU__VFS_NODE__@@@Z
_TEXT	SEGMENT
entries$ = 0
i$1 = 8
node_$2 = 16
mode$3 = 24
fs$ = 112
?AuDevFSList@@YAXPEAU__VFS_NODE__@@@Z PROC		; AuDevFSList, COMDAT

; 179  : void AuDevFSList(AuVFSNode* fs) {

$LN13:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 128				; 00000080H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__E3FE814C_devfs@cpp
	call	__CheckForDebuggerJustMyCode

; 180  : 	AuVFSContainer* entries = (AuVFSContainer*)fs->device;

	mov	rax, QWORD PTR fs$[rbp]
	mov	rax, QWORD PTR [rax+64]
	mov	QWORD PTR entries$[rbp], rax

; 181  : 	SeTextOut("Listing device fs \r\n");

	lea	rcx, OFFSET FLAT:??_C@_0BF@OJGGANOJ@Listing?5device?5fs?5?$AN?6@
	call	SeTextOut

; 182  : 	for (int i = 0; i < entries->childs->pointer; i++) {

	mov	DWORD PTR i$1[rbp], 0
	jmp	SHORT $LN4@AuDevFSLis
$LN2@AuDevFSLis:
	mov	eax, DWORD PTR i$1[rbp]
	inc	eax
	mov	DWORD PTR i$1[rbp], eax
$LN4@AuDevFSLis:
	mov	rax, QWORD PTR entries$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	eax, DWORD PTR [rax]
	cmp	DWORD PTR i$1[rbp], eax
	jae	$LN3@AuDevFSLis

; 183  : 		AuVFSNode* node_ = (AuVFSNode*)list_get_at(entries->childs, i);

	mov	edx, DWORD PTR i$1[rbp]
	mov	rax, QWORD PTR entries$[rbp]
	mov	rcx, QWORD PTR [rax]
	call	list_get_at
	mov	QWORD PTR node_$2[rbp], rax

; 184  : 		char* mode = "";

	lea	rax, OFFSET FLAT:??_C@_00CNPNBAHC@@
	mov	QWORD PTR mode$3[rbp], rax

; 185  : 		if (node_->flags & FS_FLAG_DEVICE)

	mov	rax, QWORD PTR node_$2[rbp]
	movzx	eax, WORD PTR [rax+61]
	and	eax, 8
	test	eax, eax
	je	SHORT $LN5@AuDevFSLis

; 186  : 			mode = "Device";

	lea	rax, OFFSET FLAT:??_C@_06OIEJKIHP@Device@
	mov	QWORD PTR mode$3[rbp], rax
	jmp	SHORT $LN6@AuDevFSLis
$LN5@AuDevFSLis:

; 187  : 		else if (node_->flags & FS_FLAG_DIRECTORY)

	mov	rax, QWORD PTR node_$2[rbp]
	movzx	eax, WORD PTR [rax+61]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN7@AuDevFSLis

; 188  : 			mode = "Directory";

	lea	rax, OFFSET FLAT:??_C@_09EOAFACM@Directory@
	mov	QWORD PTR mode$3[rbp], rax
	jmp	SHORT $LN8@AuDevFSLis
$LN7@AuDevFSLis:

; 189  : 		else if (node_->flags & FS_FLAG_PIPE)

	mov	rax, QWORD PTR node_$2[rbp]
	movzx	eax, WORD PTR [rax+61]
	and	eax, 128				; 00000080H
	test	eax, eax
	je	SHORT $LN9@AuDevFSLis

; 190  : 			mode = "Pipe";

	lea	rax, OFFSET FLAT:??_C@_04LJLIIBC@Pipe@
	mov	QWORD PTR mode$3[rbp], rax
	jmp	SHORT $LN10@AuDevFSLis
$LN9@AuDevFSLis:

; 191  : 		else
; 192  : 			mode = "Unknown";

	lea	rax, OFFSET FLAT:??_C@_07NBCGADJA@Unknown@
	mov	QWORD PTR mode$3[rbp], rax
$LN10@AuDevFSLis:
$LN8@AuDevFSLis:
$LN6@AuDevFSLis:

; 193  : 		SeTextOut("\%s mode - %s \r\n", node_->filename, mode);

	mov	rax, QWORD PTR node_$2[rbp]
	mov	r8, QWORD PTR mode$3[rbp]
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:??_C@_0BA@PEJEKPNO@?$CFs?5mode?5?9?5?$CFs?5?$AN?6@
	call	SeTextOut

; 194  : 		if (node_->flags & FS_FLAG_DIRECTORY)

	mov	rax, QWORD PTR node_$2[rbp]
	movzx	eax, WORD PTR [rax+61]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN11@AuDevFSLis

; 195  : 			AuDevFSListDir(fs, node_);

	mov	rdx, QWORD PTR node_$2[rbp]
	mov	rcx, QWORD PTR fs$[rbp]
	call	?AuDevFSListDir@@YAXPEAU__VFS_NODE__@@0@Z ; AuDevFSListDir
$LN11@AuDevFSLis:

; 196  : 	}

	jmp	$LN2@AuDevFSLis
$LN3@AuDevFSLis:

; 197  : }

	lea	rsp, QWORD PTR [rbp+96]
	pop	rbp
	ret	0
?AuDevFSList@@YAXPEAU__VFS_NODE__@@@Z ENDP		; AuDevFSList
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Fs\Dev\devfs.cpp
;	COMDAT ?AuDevFSOpen@@YAPEAU__VFS_NODE__@@PEAU1@PEAD@Z
_TEXT	SEGMENT
entries$ = 0
next$ = 8
first_list$ = 16
node_to_ret$ = 24
pathname$1 = 32
i$2 = 48
j$3 = 52
node_$4 = 56
fs$ = 144
path$ = 152
?AuDevFSOpen@@YAPEAU__VFS_NODE__@@PEAU1@PEAD@Z PROC	; AuDevFSOpen, COMDAT

; 205  : AuVFSNode* AuDevFSOpen(AuVFSNode* fs, char* path) {

$LN21:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 160				; 000000a0H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__E3FE814C_devfs@cpp
	call	__CheckForDebuggerJustMyCode

; 206  : 	AuVFSContainer* entries = (AuVFSContainer*)fs->device;

	mov	rax, QWORD PTR fs$[rbp]
	mov	rax, QWORD PTR [rax+64]
	mov	QWORD PTR entries$[rbp], rax

; 207  : 	/* now verify the path and add the directory to the list */
; 208  : 	char* next = strchr(path, '/');

	mov	edx, 47					; 0000002fH
	mov	rcx, QWORD PTR path$[rbp]
	call	strchr
	mov	QWORD PTR next$[rbp], rax

; 209  : 	if (next)

	cmp	QWORD PTR next$[rbp], 0
	je	SHORT $LN10@AuDevFSOpe

; 210  : 		next++;

	mov	rax, QWORD PTR next$[rbp]
	inc	rax
	mov	QWORD PTR next$[rbp], rax
$LN10@AuDevFSOpe:

; 211  : 
; 212  : 	AuVFSContainer *first_list = entries;

	mov	rax, QWORD PTR entries$[rbp]
	mov	QWORD PTR first_list$[rbp], rax

; 213  : 	AuVFSNode *node_to_ret = NULL;

	mov	QWORD PTR node_to_ret$[rbp], 0
$LN2@AuDevFSOpe:

; 214  : 	while (next) {

	cmp	QWORD PTR next$[rbp], 0
	je	$LN3@AuDevFSOpe

; 215  : 		char pathname[16];
; 216  : 		int i;
; 217  : 		for (i = 0; i < 16; i++) {

	mov	DWORD PTR i$2[rbp], 0
	jmp	SHORT $LN6@AuDevFSOpe
$LN4@AuDevFSOpe:
	mov	eax, DWORD PTR i$2[rbp]
	inc	eax
	mov	DWORD PTR i$2[rbp], eax
$LN6@AuDevFSOpe:
	cmp	DWORD PTR i$2[rbp], 16
	jge	SHORT $LN5@AuDevFSOpe

; 218  : 			if (next[i] == '/' || next[i] == '\0')

	movsxd	rax, DWORD PTR i$2[rbp]
	mov	rcx, QWORD PTR next$[rbp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 47					; 0000002fH
	je	SHORT $LN12@AuDevFSOpe
	movsxd	rax, DWORD PTR i$2[rbp]
	mov	rcx, QWORD PTR next$[rbp]
	movsx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	jne	SHORT $LN11@AuDevFSOpe
$LN12@AuDevFSOpe:

; 219  : 				break;

	jmp	SHORT $LN5@AuDevFSOpe
$LN11@AuDevFSOpe:

; 220  : 			pathname[i] = next[i];

	movsxd	rax, DWORD PTR i$2[rbp]
	movsxd	rcx, DWORD PTR i$2[rbp]
	mov	rdx, QWORD PTR next$[rbp]
	movzx	eax, BYTE PTR [rdx+rax]
	mov	BYTE PTR pathname$1[rbp+rcx], al

; 221  : 		}

	jmp	SHORT $LN4@AuDevFSOpe
$LN5@AuDevFSOpe:

; 222  : 		pathname[i] = 0;

	movsxd	rax, DWORD PTR i$2[rbp]
	mov	BYTE PTR pathname$1[rbp+rax], 0

; 223  : 
; 224  : 		for (int j = 0; j < first_list->childs->pointer; j++) {

	mov	DWORD PTR j$3[rbp], 0
	jmp	SHORT $LN9@AuDevFSOpe
$LN7@AuDevFSOpe:
	mov	eax, DWORD PTR j$3[rbp]
	inc	eax
	mov	DWORD PTR j$3[rbp], eax
$LN9@AuDevFSOpe:
	mov	rax, QWORD PTR first_list$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	eax, DWORD PTR [rax]
	cmp	DWORD PTR j$3[rbp], eax
	jae	SHORT $LN8@AuDevFSOpe

; 225  : 			AuVFSNode* node_ = (AuVFSNode*)list_get_at(first_list->childs, j);

	mov	edx, DWORD PTR j$3[rbp]
	mov	rax, QWORD PTR first_list$[rbp]
	mov	rcx, QWORD PTR [rax]
	call	list_get_at
	mov	QWORD PTR node_$4[rbp], rax

; 226  : 			if (strcmp(node_->filename, pathname) == 0) {

	mov	rax, QWORD PTR node_$4[rbp]
	lea	rdx, QWORD PTR pathname$1[rbp]
	mov	rcx, rax
	call	strcmp
	test	eax, eax
	jne	SHORT $LN13@AuDevFSOpe

; 227  : 				if (node_->flags & FS_FLAG_DIRECTORY)

	mov	rax, QWORD PTR node_$4[rbp]
	movzx	eax, WORD PTR [rax+61]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN14@AuDevFSOpe

; 228  : 					first_list = (AuVFSContainer*)node_->device;

	mov	rax, QWORD PTR node_$4[rbp]
	mov	rax, QWORD PTR [rax+64]
	mov	QWORD PTR first_list$[rbp], rax
	jmp	SHORT $LN15@AuDevFSOpe
$LN14@AuDevFSOpe:

; 229  : 				else if (node_->flags & FS_FLAG_DEVICE)

	mov	rax, QWORD PTR node_$4[rbp]
	movzx	eax, WORD PTR [rax+61]
	and	eax, 8
	test	eax, eax
	je	SHORT $LN16@AuDevFSOpe

; 230  : 					node_to_ret = node_;

	mov	rax, QWORD PTR node_$4[rbp]
	mov	QWORD PTR node_to_ret$[rbp], rax
$LN16@AuDevFSOpe:
$LN15@AuDevFSOpe:
$LN13@AuDevFSOpe:

; 231  : 			}
; 232  : 		}

	jmp	SHORT $LN7@AuDevFSOpe
$LN8@AuDevFSOpe:

; 233  : 
; 234  : 		next = strchr(next + 1, '/');

	mov	rax, QWORD PTR next$[rbp]
	inc	rax
	mov	edx, 47					; 0000002fH
	mov	rcx, rax
	call	strchr
	mov	QWORD PTR next$[rbp], rax

; 235  : 		if (next)

	cmp	QWORD PTR next$[rbp], 0
	je	SHORT $LN17@AuDevFSOpe

; 236  : 			next++;

	mov	rax, QWORD PTR next$[rbp]
	inc	rax
	mov	QWORD PTR next$[rbp], rax
$LN17@AuDevFSOpe:

; 237  : 	}

	jmp	$LN2@AuDevFSOpe
$LN3@AuDevFSOpe:

; 238  : 
; 239  : 	if (node_to_ret)

	cmp	QWORD PTR node_to_ret$[rbp], 0
	je	SHORT $LN18@AuDevFSOpe

; 240  : 		return node_to_ret;

	mov	rax, QWORD PTR node_to_ret$[rbp]
	jmp	SHORT $LN1@AuDevFSOpe
	jmp	SHORT $LN19@AuDevFSOpe
$LN18@AuDevFSOpe:

; 241  : 	else
; 242  : 		return NULL;

	xor	eax, eax
$LN19@AuDevFSOpe:
$LN1@AuDevFSOpe:

; 243  : }

	lea	rsp, QWORD PTR [rbp+128]
	pop	rbp
	ret	0
?AuDevFSOpen@@YAPEAU__VFS_NODE__@@PEAU1@PEAD@Z ENDP	; AuDevFSOpen
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Fs\Dev\devfs.cpp
;	COMDAT AuDevFSAddFile
_TEXT	SEGMENT
entries$ = 0
next$ = 8
first_list$ = 16
pathname$ = 24
i$1 = 40
j$2 = 44
node_$3 = 48
fs$ = 144
path$ = 152
file$ = 160
AuDevFSAddFile PROC					; COMDAT

; 124  : int AuDevFSAddFile(AuVFSNode* fs, char* path, AuVFSNode* file) {

$LN18:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 160				; 000000a0H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__E3FE814C_devfs@cpp
	call	__CheckForDebuggerJustMyCode

; 125  : 	AuVFSContainer* entries = (AuVFSContainer*)fs->device;

	mov	rax, QWORD PTR fs$[rbp]
	mov	rax, QWORD PTR [rax+64]
	mov	QWORD PTR entries$[rbp], rax

; 126  : 	if (!entries)

	cmp	QWORD PTR entries$[rbp], 0
	jne	SHORT $LN10@AuDevFSAdd

; 127  : 		return -1;

	mov	eax, -1
	jmp	$LN1@AuDevFSAdd
$LN10@AuDevFSAdd:

; 128  : 
; 129  : 	char* next = strchr(path, '/');

	mov	edx, 47					; 0000002fH
	mov	rcx, QWORD PTR path$[rbp]
	call	strchr
	mov	QWORD PTR next$[rbp], rax

; 130  : 	if (next)

	cmp	QWORD PTR next$[rbp], 0
	je	SHORT $LN11@AuDevFSAdd

; 131  : 		next++;

	mov	rax, QWORD PTR next$[rbp]
	inc	rax
	mov	QWORD PTR next$[rbp], rax
$LN11@AuDevFSAdd:

; 132  : 
; 133  : 	AuVFSContainer* first_list = entries;

	mov	rax, QWORD PTR entries$[rbp]
	mov	QWORD PTR first_list$[rbp], rax
$LN2@AuDevFSAdd:

; 134  : 	char pathname[16];
; 135  : 	while (next) {

	cmp	QWORD PTR next$[rbp], 0
	je	$LN3@AuDevFSAdd

; 136  : 		int i;
; 137  : 		for (i = 0; i < 16; i++) {

	mov	DWORD PTR i$1[rbp], 0
	jmp	SHORT $LN6@AuDevFSAdd
$LN4@AuDevFSAdd:
	mov	eax, DWORD PTR i$1[rbp]
	inc	eax
	mov	DWORD PTR i$1[rbp], eax
$LN6@AuDevFSAdd:
	cmp	DWORD PTR i$1[rbp], 16
	jge	SHORT $LN5@AuDevFSAdd

; 138  : 			if (next[i] == '/' || next[i] == '\0')

	movsxd	rax, DWORD PTR i$1[rbp]
	mov	rcx, QWORD PTR next$[rbp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 47					; 0000002fH
	je	SHORT $LN13@AuDevFSAdd
	movsxd	rax, DWORD PTR i$1[rbp]
	mov	rcx, QWORD PTR next$[rbp]
	movsx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	jne	SHORT $LN12@AuDevFSAdd
$LN13@AuDevFSAdd:

; 139  : 				break;

	jmp	SHORT $LN5@AuDevFSAdd
$LN12@AuDevFSAdd:

; 140  : 			pathname[i] = next[i];

	movsxd	rax, DWORD PTR i$1[rbp]
	movsxd	rcx, DWORD PTR i$1[rbp]
	mov	rdx, QWORD PTR next$[rbp]
	movzx	eax, BYTE PTR [rdx+rax]
	mov	BYTE PTR pathname$[rbp+rcx], al

; 141  : 		}

	jmp	SHORT $LN4@AuDevFSAdd
$LN5@AuDevFSAdd:

; 142  : 		pathname[i] = 0;

	movsxd	rax, DWORD PTR i$1[rbp]
	mov	BYTE PTR pathname$[rbp+rax], 0

; 143  : 
; 144  : 		for (int j = 0; j < first_list->childs->pointer; j++) {

	mov	DWORD PTR j$2[rbp], 0
	jmp	SHORT $LN9@AuDevFSAdd
$LN7@AuDevFSAdd:
	mov	eax, DWORD PTR j$2[rbp]
	inc	eax
	mov	DWORD PTR j$2[rbp], eax
$LN9@AuDevFSAdd:
	mov	rax, QWORD PTR first_list$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	eax, DWORD PTR [rax]
	cmp	DWORD PTR j$2[rbp], eax
	jae	SHORT $LN8@AuDevFSAdd

; 145  : 			AuVFSNode* node_ = (AuVFSNode*)list_get_at(first_list->childs, j);

	mov	edx, DWORD PTR j$2[rbp]
	mov	rax, QWORD PTR first_list$[rbp]
	mov	rcx, QWORD PTR [rax]
	call	list_get_at
	mov	QWORD PTR node_$3[rbp], rax

; 146  : 			if (strcmp(node_->filename, pathname) == 0) {

	mov	rax, QWORD PTR node_$3[rbp]
	lea	rdx, QWORD PTR pathname$[rbp]
	mov	rcx, rax
	call	strcmp
	test	eax, eax
	jne	SHORT $LN14@AuDevFSAdd

; 147  : 				if (node_->flags & FS_FLAG_DIRECTORY)

	mov	rax, QWORD PTR node_$3[rbp]
	movzx	eax, WORD PTR [rax+61]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN15@AuDevFSAdd

; 148  : 					first_list = (AuVFSContainer*)node_->device;

	mov	rax, QWORD PTR node_$3[rbp]
	mov	rax, QWORD PTR [rax+64]
	mov	QWORD PTR first_list$[rbp], rax
$LN15@AuDevFSAdd:
$LN14@AuDevFSAdd:

; 149  : 			}
; 150  : 		}

	jmp	SHORT $LN7@AuDevFSAdd
$LN8@AuDevFSAdd:

; 151  : 
; 152  : 		next = strchr(next + 1, '/');

	mov	rax, QWORD PTR next$[rbp]
	inc	rax
	mov	edx, 47					; 0000002fH
	mov	rcx, rax
	call	strchr
	mov	QWORD PTR next$[rbp], rax

; 153  : 		if (next)

	cmp	QWORD PTR next$[rbp], 0
	je	SHORT $LN16@AuDevFSAdd

; 154  : 			next++;

	mov	rax, QWORD PTR next$[rbp]
	inc	rax
	mov	QWORD PTR next$[rbp], rax
$LN16@AuDevFSAdd:

; 155  : 	}

	jmp	$LN2@AuDevFSAdd
$LN3@AuDevFSAdd:

; 156  : 	
; 157  : 	list_add(first_list->childs, file);

	mov	rdx, QWORD PTR file$[rbp]
	mov	rax, QWORD PTR first_list$[rbp]
	mov	rcx, QWORD PTR [rax]
	call	list_add

; 158  : 
; 159  : 	return 1;

	mov	eax, 1
$LN1@AuDevFSAdd:

; 160  : }

	lea	rsp, QWORD PTR [rbp+128]
	pop	rbp
	ret	0
AuDevFSAddFile ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Fs\Dev\devfs.cpp
;	COMDAT ?AuDevFSCreateFile@@YAHPEAU__VFS_NODE__@@PEADE@Z
_TEXT	SEGMENT
entries$ = 0
file$ = 8
list$1 = 16
next$ = 24
first_list$ = 32
pathname$ = 40
i$2 = 56
j$3 = 60
node_$4 = 64
fs$ = 160
path$ = 168
mode$ = 176
?AuDevFSCreateFile@@YAHPEAU__VFS_NODE__@@PEADE@Z PROC	; AuDevFSCreateFile, COMDAT

; 65   : int AuDevFSCreateFile(AuVFSNode* fs, char* path, uint8_t mode) {

$LN20:
	mov	BYTE PTR [rsp+24], r8b
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 176				; 000000b0H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__E3FE814C_devfs@cpp
	call	__CheckForDebuggerJustMyCode

; 66   : 	AuVFSContainer* entries = (AuVFSContainer*)fs->device;

	mov	rax, QWORD PTR fs$[rbp]
	mov	rax, QWORD PTR [rax+64]
	mov	QWORD PTR entries$[rbp], rax

; 67   : 	if (!entries)

	cmp	QWORD PTR entries$[rbp], 0
	jne	SHORT $LN10@AuDevFSCre

; 68   : 		return -1;

	mov	eax, -1
	jmp	$LN1@AuDevFSCre
$LN10@AuDevFSCre:

; 69   : 
; 70   : 	AuVFSNode* file = (AuVFSNode*)kmalloc(sizeof(AuVFSNode));

	mov	ecx, 178				; 000000b2H
	call	kmalloc
	mov	QWORD PTR file$[rbp], rax

; 71   : 	memset(file, 0, sizeof(AuVFSNode));

	mov	r8d, 178				; 000000b2H
	xor	edx, edx
	mov	rcx, QWORD PTR file$[rbp]
	call	memset

; 72   : 
; 73   : 	if (mode & FS_FLAG_DIRECTORY) {

	movzx	eax, BYTE PTR mode$[rbp]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN11@AuDevFSCre

; 74   : 		AuVFSContainer* list = (AuVFSContainer*)kmalloc(sizeof(AuVFSContainer));

	mov	ecx, 8
	call	kmalloc
	mov	QWORD PTR list$1[rbp], rax

; 75   : 		list->childs = initialize_list();

	call	initialize_list
	mov	rcx, QWORD PTR list$1[rbp]
	mov	QWORD PTR [rcx], rax

; 76   : 		file->flags |= FS_FLAG_DIRECTORY;

	mov	rax, QWORD PTR file$[rbp]
	movzx	eax, WORD PTR [rax+61]
	or	eax, 2
	mov	rcx, QWORD PTR file$[rbp]
	mov	WORD PTR [rcx+61], ax

; 77   : 		file->device = list;

	mov	rax, QWORD PTR file$[rbp]
	mov	rcx, QWORD PTR list$1[rbp]
	mov	QWORD PTR [rax+64], rcx

; 78   : 	}

	jmp	SHORT $LN12@AuDevFSCre
$LN11@AuDevFSCre:

; 79   : 	else {
; 80   : 		file->flags = FS_FLAG_GENERAL | FS_FLAG_DEVICE;

	mov	eax, 12
	mov	rcx, QWORD PTR file$[rbp]
	mov	WORD PTR [rcx+61], ax

; 81   : 		file->device = fs;

	mov	rax, QWORD PTR file$[rbp]
	mov	rcx, QWORD PTR fs$[rbp]
	mov	QWORD PTR [rax+64], rcx
$LN12@AuDevFSCre:

; 82   : 	}
; 83   : 
; 84   : 
; 85   : 	char* next = strchr(path, '/');

	mov	edx, 47					; 0000002fH
	mov	rcx, QWORD PTR path$[rbp]
	call	strchr
	mov	QWORD PTR next$[rbp], rax

; 86   : 	if (next)

	cmp	QWORD PTR next$[rbp], 0
	je	SHORT $LN13@AuDevFSCre

; 87   : 		next++;

	mov	rax, QWORD PTR next$[rbp]
	inc	rax
	mov	QWORD PTR next$[rbp], rax
$LN13@AuDevFSCre:

; 88   : 
; 89   : 	AuVFSContainer* first_list = entries;

	mov	rax, QWORD PTR entries$[rbp]
	mov	QWORD PTR first_list$[rbp], rax
$LN2@AuDevFSCre:

; 90   : 	char pathname[16];
; 91   : 	while (next) {

	cmp	QWORD PTR next$[rbp], 0
	je	$LN3@AuDevFSCre

; 92   : 		int i;
; 93   : 		for (i = 0; i < 16; i++) {

	mov	DWORD PTR i$2[rbp], 0
	jmp	SHORT $LN6@AuDevFSCre
$LN4@AuDevFSCre:
	mov	eax, DWORD PTR i$2[rbp]
	inc	eax
	mov	DWORD PTR i$2[rbp], eax
$LN6@AuDevFSCre:
	cmp	DWORD PTR i$2[rbp], 16
	jge	SHORT $LN5@AuDevFSCre

; 94   : 			if (next[i] == '/' || next[i] == '\0')

	movsxd	rax, DWORD PTR i$2[rbp]
	mov	rcx, QWORD PTR next$[rbp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 47					; 0000002fH
	je	SHORT $LN15@AuDevFSCre
	movsxd	rax, DWORD PTR i$2[rbp]
	mov	rcx, QWORD PTR next$[rbp]
	movsx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	jne	SHORT $LN14@AuDevFSCre
$LN15@AuDevFSCre:

; 95   : 				break;

	jmp	SHORT $LN5@AuDevFSCre
$LN14@AuDevFSCre:

; 96   : 			pathname[i] = next[i];

	movsxd	rax, DWORD PTR i$2[rbp]
	movsxd	rcx, DWORD PTR i$2[rbp]
	mov	rdx, QWORD PTR next$[rbp]
	movzx	eax, BYTE PTR [rdx+rax]
	mov	BYTE PTR pathname$[rbp+rcx], al

; 97   : 		}

	jmp	SHORT $LN4@AuDevFSCre
$LN5@AuDevFSCre:

; 98   : 		pathname[i] = 0;

	movsxd	rax, DWORD PTR i$2[rbp]
	mov	BYTE PTR pathname$[rbp+rax], 0

; 99   : 
; 100  : 		for (int j = 0; j < first_list->childs->pointer; j++) {

	mov	DWORD PTR j$3[rbp], 0
	jmp	SHORT $LN9@AuDevFSCre
$LN7@AuDevFSCre:
	mov	eax, DWORD PTR j$3[rbp]
	inc	eax
	mov	DWORD PTR j$3[rbp], eax
$LN9@AuDevFSCre:
	mov	rax, QWORD PTR first_list$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	eax, DWORD PTR [rax]
	cmp	DWORD PTR j$3[rbp], eax
	jae	SHORT $LN8@AuDevFSCre

; 101  : 			AuVFSNode* node_ = (AuVFSNode*)list_get_at(first_list->childs, j);

	mov	edx, DWORD PTR j$3[rbp]
	mov	rax, QWORD PTR first_list$[rbp]
	mov	rcx, QWORD PTR [rax]
	call	list_get_at
	mov	QWORD PTR node_$4[rbp], rax

; 102  : 			if (strcmp(node_->filename, pathname) == 0) {

	mov	rax, QWORD PTR node_$4[rbp]
	lea	rdx, QWORD PTR pathname$[rbp]
	mov	rcx, rax
	call	strcmp
	test	eax, eax
	jne	SHORT $LN16@AuDevFSCre

; 103  : 				if (node_->flags & FS_FLAG_DIRECTORY)

	mov	rax, QWORD PTR node_$4[rbp]
	movzx	eax, WORD PTR [rax+61]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN17@AuDevFSCre

; 104  : 					first_list = (AuVFSContainer*)node_->device;

	mov	rax, QWORD PTR node_$4[rbp]
	mov	rax, QWORD PTR [rax+64]
	mov	QWORD PTR first_list$[rbp], rax
$LN17@AuDevFSCre:
$LN16@AuDevFSCre:

; 105  : 			}
; 106  : 		}

	jmp	SHORT $LN7@AuDevFSCre
$LN8@AuDevFSCre:

; 107  : 
; 108  : 		next = strchr(next + 1, '/');

	mov	rax, QWORD PTR next$[rbp]
	inc	rax
	mov	edx, 47					; 0000002fH
	mov	rcx, rax
	call	strchr
	mov	QWORD PTR next$[rbp], rax

; 109  : 		if (next)

	cmp	QWORD PTR next$[rbp], 0
	je	SHORT $LN18@AuDevFSCre

; 110  : 			next++;

	mov	rax, QWORD PTR next$[rbp]
	inc	rax
	mov	QWORD PTR next$[rbp], rax
$LN18@AuDevFSCre:

; 111  : 	}

	jmp	$LN2@AuDevFSCre
$LN3@AuDevFSCre:

; 112  : 	strcpy(file->filename, pathname);

	mov	rax, QWORD PTR file$[rbp]
	lea	rdx, QWORD PTR pathname$[rbp]
	mov	rcx, rax
	call	strcpy

; 113  : 	list_add(first_list->childs, file);

	mov	rdx, QWORD PTR file$[rbp]
	mov	rax, QWORD PTR first_list$[rbp]
	mov	rcx, QWORD PTR [rax]
	call	list_add

; 114  : 
; 115  : 	return 1;

	mov	eax, 1
$LN1@AuDevFSCre:

; 116  : }

	lea	rsp, QWORD PTR [rbp+144]
	pop	rbp
	ret	0
?AuDevFSCreateFile@@YAHPEAU__VFS_NODE__@@PEADE@Z ENDP	; AuDevFSCreateFile
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Fs\Dev\devfs.cpp
;	COMDAT ?AuDeviceFsInitialize@@YAXXZ
_TEXT	SEGMENT
entries$ = 0
node$ = 8
?AuDeviceFsInitialize@@YAXXZ PROC			; AuDeviceFsInitialize, COMDAT

; 43   : void AuDeviceFsInitialize() {

$LN3:
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__E3FE814C_devfs@cpp
	call	__CheckForDebuggerJustMyCode

; 44   : 	AuVFSContainer *entries = (AuVFSContainer*)kmalloc(sizeof(AuVFSContainer));

	mov	ecx, 8
	call	kmalloc
	mov	QWORD PTR entries$[rbp], rax

; 45   : 	entries->childs = initialize_list();

	call	initialize_list
	mov	rcx, QWORD PTR entries$[rbp]
	mov	QWORD PTR [rcx], rax

; 46   : 
; 47   : 	AuVFSNode *node = (AuVFSNode*)kmalloc(sizeof(AuVFSNode));

	mov	ecx, 178				; 000000b2H
	call	kmalloc
	mov	QWORD PTR node$[rbp], rax

; 48   : 	memset(node, 0, sizeof(AuVFSNode));

	mov	r8d, 178				; 000000b2H
	xor	edx, edx
	mov	rcx, QWORD PTR node$[rbp]
	call	memset

; 49   : 	strcpy(node->filename, "dev");

	mov	rax, QWORD PTR node$[rbp]
	lea	rdx, OFFSET FLAT:??_C@_03FNIGJHAM@dev@
	mov	rcx, rax
	call	strcpy

; 50   : 	node->device = entries;

	mov	rax, QWORD PTR node$[rbp]
	mov	rcx, QWORD PTR entries$[rbp]
	mov	QWORD PTR [rax+64], rcx

; 51   : 	node->flags |= FS_FLAG_FILE_SYSTEM;

	mov	rax, QWORD PTR node$[rbp]
	movzx	eax, WORD PTR [rax+61]
	or	eax, 64					; 00000040H
	mov	rcx, QWORD PTR node$[rbp]
	mov	WORD PTR [rcx+61], ax

; 52   : 	node->open = AuDevFSOpen;

	mov	rax, QWORD PTR node$[rbp]
	lea	rcx, OFFSET FLAT:?AuDevFSOpen@@YAPEAU__VFS_NODE__@@PEAU1@PEAD@Z ; AuDevFSOpen
	mov	QWORD PTR [rax+74], rcx

; 53   : 	AuVFSAddFileSystem(node);

	mov	rcx, QWORD PTR node$[rbp]
	call	AuVFSAddFileSystem

; 54   : 
; 55   : 	AuDevInputInitialise();

	call	?AuDevInputInitialise@@YAXXZ		; AuDevInputInitialise

; 56   : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
?AuDeviceFsInitialize@@YAXXZ ENDP			; AuDeviceFsInitialize
_TEXT	ENDS
END
