; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30154.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

msvcjmc	SEGMENT
__5DFC7571_fileserv@cpp DB 01H
msvcjmc	ENDS
PUBLIC	?OpenFile@@YAHPEADH@Z				; OpenFile
PUBLIC	?FileSetOffset@@YAHH_K@Z			; FileSetOffset
PUBLIC	?ReadFile@@YA_KHPEAX_K@Z			; ReadFile
PUBLIC	?WriteFile@@YA_KHPEAX_K@Z			; WriteFile
PUBLIC	?CreateDir@@YAHPEAD@Z				; CreateDir
PUBLIC	?RemoveFile@@YAHPEAD@Z				; RemoveFile
PUBLIC	?CloseFile@@YAHH@Z				; CloseFile
PUBLIC	?FileIoControl@@YAHHHPEAX@Z			; FileIoControl
PUBLIC	?FileStat@@YAHHPEAX@Z				; FileStat
PUBLIC	?OpenDir@@YAHPEAD@Z				; OpenDir
PUBLIC	?ReadDir@@YAHHPEAX@Z				; ReadDir
PUBLIC	?ProcessGetFileDesc@@YAHPEBD@Z			; ProcessGetFileDesc
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_0BG@NKGJFMOM@Opening?5file?5?9?$DO?5?$CFs?5?$AN?6@ ; `string'
PUBLIC	??_C@_01KMDKNFGN@?1@				; `string'
PUBLIC	??_C@_0BE@KOBNHDHJ@Closing?5fs?5?9?$DO?5?$CFs?5?$AN?6@ ; `string'
PUBLIC	??_C@_0BK@LJOPCOLI@dir?5opening?5?9?$DO?5?$CFs?5?0?5?$CFx?5?$AN?6@ ; `string'
EXTRN	AuVFSOpen:PROC
EXTRN	AuVFSNodeIOControl:PROC
EXTRN	AuVFSFind:PROC
EXTRN	AuVFSNodeRead:PROC
EXTRN	AuVFSCreateDir:PROC
EXTRN	AuVFSCreateFile:PROC
EXTRN	?AuVFSRemoveFile@@YAHPEAU__VFS_NODE__@@0@Z:PROC	; AuVFSRemoveFile
EXTRN	?AuVFSRemoveDir@@YAHPEAU__VFS_NODE__@@0@Z:PROC	; AuVFSRemoveDir
EXTRN	AuVFSNodeWrite:PROC
EXTRN	AuVFSGetBlockFor:PROC
EXTRN	AuGetCurrentThread:PROC
EXTRN	AuPmmngrAlloc:PROC
EXTRN	AuPmmngrFree:PROC
EXTRN	P2V:PROC
EXTRN	V2P:PROC
EXTRN	kfree:PROC
EXTRN	?AuProcessFindThread@@YAPEAU_au_proc_@@PEAU_au_thread_@@@Z:PROC ; AuProcessFindThread
EXTRN	?AuProcessFindSubThread@@YAPEAU_au_proc_@@PEAU_au_thread_@@@Z:PROC ; AuProcessFindSubThread
EXTRN	?AuProcessGetFileDesc@@YAHPEAU_au_proc_@@@Z:PROC ; AuProcessGetFileDesc
EXTRN	strcmp:PROC
EXTRN	memset:PROC
EXTRN	memcpy:PROC
EXTRN	SeTextOut:PROC
EXTRN	x64_cli:PROC
EXTRN	__CheckForDebuggerJustMyCode:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$?OpenFile@@YAHPEADH@Z DD imagerel $LN14
	DD	imagerel $LN14+337
	DD	imagerel $unwind$?OpenFile@@YAHPEADH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?FileSetOffset@@YAHH_K@Z DD imagerel $LN9
	DD	imagerel $LN9+312
	DD	imagerel $unwind$?FileSetOffset@@YAHH_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ReadFile@@YA_KHPEAX_K@Z DD imagerel $LN17
	DD	imagerel $LN17+478
	DD	imagerel $unwind$?ReadFile@@YA_KHPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?WriteFile@@YA_KHPEAX_K@Z DD imagerel $LN17
	DD	imagerel $LN17+540
	DD	imagerel $unwind$?WriteFile@@YA_KHPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?CreateDir@@YAHPEAD@Z DD imagerel $LN9
	DD	imagerel $LN9+184
	DD	imagerel $unwind$?CreateDir@@YAHPEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?RemoveFile@@YAHPEAD@Z DD imagerel $LN6
	DD	imagerel $LN6+117
	DD	imagerel $unwind$?RemoveFile@@YAHPEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?CloseFile@@YAHH@Z DD imagerel $LN12
	DD	imagerel $LN12+323
	DD	imagerel $unwind$?CloseFile@@YAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?FileIoControl@@YAHHHPEAX@Z DD imagerel $LN8
	DD	imagerel $LN8+195
	DD	imagerel $unwind$?FileIoControl@@YAHHHPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?FileStat@@YAHHPEAX@Z DD imagerel $LN8
	DD	imagerel $LN8+269
	DD	imagerel $unwind$?FileStat@@YAHHPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?OpenDir@@YAHPEAD@Z DD imagerel $LN10
	DD	imagerel $LN10+273
	DD	imagerel $unwind$?OpenDir@@YAHPEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ReadDir@@YAHHPEAX@Z DD imagerel $LN11
	DD	imagerel $LN11+261
	DD	imagerel $unwind$?ReadDir@@YAHHPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ProcessGetFileDesc@@YAHPEBD@Z DD imagerel $LN11
	DD	imagerel $LN11+196
	DD	imagerel $unwind$?ProcessGetFileDesc@@YAHPEBD@Z
pdata	ENDS
;	COMDAT ??_C@_0BK@LJOPCOLI@dir?5opening?5?9?$DO?5?$CFs?5?0?5?$CFx?5?$AN?6@
CONST	SEGMENT
??_C@_0BK@LJOPCOLI@dir?5opening?5?9?$DO?5?$CFs?5?0?5?$CFx?5?$AN?6@ DB 'di'
	DB	'r opening -> %s , %x ', 0dH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@KOBNHDHJ@Closing?5fs?5?9?$DO?5?$CFs?5?$AN?6@
CONST	SEGMENT
??_C@_0BE@KOBNHDHJ@Closing?5fs?5?9?$DO?5?$CFs?5?$AN?6@ DB 'Closing fs -> '
	DB	'%s ', 0dH, 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01KMDKNFGN@?1@
CONST	SEGMENT
??_C@_01KMDKNFGN@?1@ DB '/', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@NKGJFMOM@Opening?5file?5?9?$DO?5?$CFs?5?$AN?6@
CONST	SEGMENT
??_C@_0BG@NKGJFMOM@Opening?5file?5?9?$DO?5?$CFs?5?$AN?6@ DB 'Opening file'
	DB	' -> %s ', 0dH, 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ProcessGetFileDesc@@YAHPEBD@Z DD 025031201H
	DD	0f20d2312H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ReadDir@@YAHHPEAX@Z DD 025041601H
	DD	01112316H
	DD	0500a0012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?OpenDir@@YAHPEAD@Z DD 025041201H
	DD	010d2312H
	DD	050060012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?FileStat@@YAHHPEAX@Z DD 025031601H
	DD	0f2112316H
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?FileIoControl@@YAHHHPEAX@Z DD 025031a01H
	DD	0f215231aH
	DD	0500eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?CloseFile@@YAHH@Z DD 025031101H
	DD	0f20c2311H
	DD	05005H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?RemoveFile@@YAHPEAD@Z DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?CreateDir@@YAHPEAD@Z DD 025031201H
	DD	0f20d2312H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?WriteFile@@YA_KHPEAX_K@Z DD 025041b01H
	DD	0116231bH
	DD	0500f0014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ReadFile@@YA_KHPEAX_K@Z DD 025041b01H
	DD	0116231bH
	DD	0500f0012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?FileSetOffset@@YAHH_K@Z DD 025041601H
	DD	01112316H
	DD	0500a0012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?OpenFile@@YAHPEADH@Z DD 025041601H
	DD	01112316H
	DD	0500a0012H
xdata	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Serv\fileserv.cpp
;	COMDAT ?ProcessGetFileDesc@@YAHPEBD@Z
_TEXT	SEGMENT
thr$ = 0
currproc$ = 8
i$1 = 16
file$2 = 24
filename$ = 112
?ProcessGetFileDesc@@YAHPEBD@Z PROC			; ProcessGetFileDesc, COMDAT

; 466  : int ProcessGetFileDesc(const char* filename) {

$LN11:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 128				; 00000080H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__5DFC7571_fileserv@cpp
	call	__CheckForDebuggerJustMyCode

; 467  : 	x64_cli();

	call	x64_cli

; 468  : 	AuThread* thr = AuGetCurrentThread();

	call	AuGetCurrentThread
	mov	QWORD PTR thr$[rbp], rax

; 469  : 	if (!thr)

	cmp	QWORD PTR thr$[rbp], 0
	jne	SHORT $LN5@ProcessGet

; 470  : 		return -1;

	mov	eax, -1
	jmp	$LN1@ProcessGet
$LN5@ProcessGet:

; 471  : 	AuProcess* currproc = AuProcessFindThread(thr);

	mov	rcx, QWORD PTR thr$[rbp]
	call	?AuProcessFindThread@@YAPEAU_au_proc_@@PEAU_au_thread_@@@Z ; AuProcessFindThread
	mov	QWORD PTR currproc$[rbp], rax

; 472  : 	if (!currproc){

	cmp	QWORD PTR currproc$[rbp], 0
	jne	SHORT $LN6@ProcessGet

; 473  : 		currproc = AuProcessFindSubThread(thr);

	mov	rcx, QWORD PTR thr$[rbp]
	call	?AuProcessFindSubThread@@YAPEAU_au_proc_@@PEAU_au_thread_@@@Z ; AuProcessFindSubThread
	mov	QWORD PTR currproc$[rbp], rax

; 474  : 		if (!currproc)

	cmp	QWORD PTR currproc$[rbp], 0
	jne	SHORT $LN7@ProcessGet

; 475  : 			return -1;

	mov	eax, -1
	jmp	SHORT $LN1@ProcessGet
$LN7@ProcessGet:
$LN6@ProcessGet:

; 476  : 	}
; 477  : 	for (int i = 0; i < FILE_DESC_PER_PROCESS; i++) {

	mov	DWORD PTR i$1[rbp], 0
	jmp	SHORT $LN4@ProcessGet
$LN2@ProcessGet:
	mov	eax, DWORD PTR i$1[rbp]
	inc	eax
	mov	DWORD PTR i$1[rbp], eax
$LN4@ProcessGet:
	cmp	DWORD PTR i$1[rbp], 60			; 0000003cH
	jge	SHORT $LN3@ProcessGet

; 478  : 		AuVFSNode* file = currproc->fds[i];

	movsxd	rax, DWORD PTR i$1[rbp]
	mov	rcx, QWORD PTR currproc$[rbp]
	mov	rax, QWORD PTR [rcx+rax*8+567]
	mov	QWORD PTR file$2[rbp], rax

; 479  : 		if (file) {

	cmp	QWORD PTR file$2[rbp], 0
	je	SHORT $LN8@ProcessGet

; 480  : 			if (strcmp(filename, file->filename) == 0) {

	mov	rax, QWORD PTR file$2[rbp]
	mov	rdx, rax
	mov	rcx, QWORD PTR filename$[rbp]
	call	strcmp
	test	eax, eax
	jne	SHORT $LN9@ProcessGet

; 481  : 				return i;

	mov	eax, DWORD PTR i$1[rbp]
	jmp	SHORT $LN1@ProcessGet
$LN9@ProcessGet:
$LN8@ProcessGet:

; 482  : 			}
; 483  : 		}
; 484  : 	}

	jmp	SHORT $LN2@ProcessGet
$LN3@ProcessGet:

; 485  : 
; 486  : 	return -1;

	mov	eax, -1
$LN1@ProcessGet:

; 487  : }

	lea	rsp, QWORD PTR [rbp+96]
	pop	rbp
	ret	0
?ProcessGetFileDesc@@YAHPEBD@Z ENDP			; ProcessGetFileDesc
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Serv\fileserv.cpp
;	COMDAT ?ReadDir@@YAHHPEAX@Z
_TEXT	SEGMENT
current_thr$ = 0
current_proc$ = 8
dire_$ = 16
dirfile$ = 24
fsys$ = 32
dirfd$ = 128
dirent$ = 136
?ReadDir@@YAHHPEAX@Z PROC				; ReadDir, COMDAT

; 431  : int ReadDir(int dirfd, void* dirent) {

$LN11:
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	push	rbp
	sub	rsp, 144				; 00000090H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__5DFC7571_fileserv@cpp
	call	__CheckForDebuggerJustMyCode

; 432  : 	x64_cli();

	call	x64_cli

; 433  : 	if (!dirent)

	cmp	QWORD PTR dirent$[rbp], 0
	jne	SHORT $LN2@ReadDir

; 434  : 		return -1;

	mov	eax, -1
	jmp	$LN1@ReadDir
$LN2@ReadDir:

; 435  : 	if (dirfd == -1)

	cmp	DWORD PTR dirfd$[rbp], -1
	jne	SHORT $LN3@ReadDir

; 436  : 		return -1;

	mov	eax, -1
	jmp	$LN1@ReadDir
$LN3@ReadDir:

; 437  : 
; 438  : 	AuThread* current_thr = AuGetCurrentThread();

	call	AuGetCurrentThread
	mov	QWORD PTR current_thr$[rbp], rax

; 439  : 	if (!current_thr){

	cmp	QWORD PTR current_thr$[rbp], 0
	jne	SHORT $LN4@ReadDir

; 440  : 		return 0;

	xor	eax, eax
	jmp	$LN1@ReadDir
$LN4@ReadDir:

; 441  : 	}
; 442  : 	AuProcess* current_proc = AuProcessFindThread(current_thr);

	mov	rcx, QWORD PTR current_thr$[rbp]
	call	?AuProcessFindThread@@YAPEAU_au_proc_@@PEAU_au_thread_@@@Z ; AuProcessFindThread
	mov	QWORD PTR current_proc$[rbp], rax

; 443  : 	if (!current_proc) {

	cmp	QWORD PTR current_proc$[rbp], 0
	jne	SHORT $LN5@ReadDir

; 444  : 		current_proc = AuProcessFindSubThread(current_thr);

	mov	rcx, QWORD PTR current_thr$[rbp]
	call	?AuProcessFindSubThread@@YAPEAU_au_proc_@@PEAU_au_thread_@@@Z ; AuProcessFindSubThread
	mov	QWORD PTR current_proc$[rbp], rax

; 445  : 		if (!current_proc)

	cmp	QWORD PTR current_proc$[rbp], 0
	jne	SHORT $LN6@ReadDir

; 446  : 			return 0;

	xor	eax, eax
	jmp	SHORT $LN1@ReadDir
$LN6@ReadDir:
$LN5@ReadDir:

; 447  : 	}
; 448  : 
; 449  : 	AuDirectoryEntry* dire_ = (AuDirectoryEntry*)dirent;

	mov	rax, QWORD PTR dirent$[rbp]
	mov	QWORD PTR dire_$[rbp], rax

; 450  : 
; 451  : 	AuVFSNode* dirfile = current_proc->fds[dirfd];

	movsxd	rax, DWORD PTR dirfd$[rbp]
	mov	rcx, QWORD PTR current_proc$[rbp]
	mov	rax, QWORD PTR [rcx+rax*8+567]
	mov	QWORD PTR dirfile$[rbp], rax

; 452  : 	if (!dirfile)

	cmp	QWORD PTR dirfile$[rbp], 0
	jne	SHORT $LN7@ReadDir

; 453  : 		return -1;

	mov	eax, -1
	jmp	SHORT $LN1@ReadDir
$LN7@ReadDir:

; 454  : 	AuVFSNode* fsys = (AuVFSNode*)dirfile->device;

	mov	rax, QWORD PTR dirfile$[rbp]
	mov	rax, QWORD PTR [rax+64]
	mov	QWORD PTR fsys$[rbp], rax

; 455  : 	if (!fsys)

	cmp	QWORD PTR fsys$[rbp], 0
	jne	SHORT $LN8@ReadDir

; 456  : 		return -1;

	mov	eax, -1
	jmp	SHORT $LN1@ReadDir
$LN8@ReadDir:

; 457  : 	if (fsys->read_dir)

	mov	rax, QWORD PTR fsys$[rbp]
	cmp	QWORD PTR [rax+154], 0
	je	SHORT $LN9@ReadDir

; 458  : 		return fsys->read_dir(fsys, dirfile, dire_);

	mov	r8, QWORD PTR dire_$[rbp]
	mov	rdx, QWORD PTR dirfile$[rbp]
	mov	rcx, QWORD PTR fsys$[rbp]
	mov	rax, QWORD PTR fsys$[rbp]
	call	QWORD PTR [rax+154]
$LN9@ReadDir:
$LN1@ReadDir:

; 459  : }

	lea	rsp, QWORD PTR [rbp+112]
	pop	rbp
	ret	0
?ReadDir@@YAHHPEAX@Z ENDP				; ReadDir
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Serv\fileserv.cpp
;	COMDAT ?OpenDir@@YAHPEAD@Z
_TEXT	SEGMENT
current_thr$ = 0
current_proc$ = 8
fsys$ = 16
dirfile$ = 24
fd$ = 32
filename$ = 128
?OpenDir@@YAHPEAD@Z PROC				; OpenDir, COMDAT

; 394  : int OpenDir(char* filename) {

$LN10:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 144				; 00000090H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__5DFC7571_fileserv@cpp
	call	__CheckForDebuggerJustMyCode

; 395  : 	x64_cli();

	call	x64_cli

; 396  : 	AuThread* current_thr = AuGetCurrentThread();

	call	AuGetCurrentThread
	mov	QWORD PTR current_thr$[rbp], rax

; 397  : 	if (!current_thr){

	cmp	QWORD PTR current_thr$[rbp], 0
	jne	SHORT $LN2@OpenDir

; 398  : 		return -1;

	mov	eax, -1
	jmp	$LN1@OpenDir
$LN2@OpenDir:

; 399  : 	}
; 400  : 	AuProcess* current_proc = AuProcessFindThread(current_thr);

	mov	rcx, QWORD PTR current_thr$[rbp]
	call	?AuProcessFindThread@@YAPEAU_au_proc_@@PEAU_au_thread_@@@Z ; AuProcessFindThread
	mov	QWORD PTR current_proc$[rbp], rax

; 401  : 	if (!current_proc) {

	cmp	QWORD PTR current_proc$[rbp], 0
	jne	SHORT $LN3@OpenDir

; 402  : 		current_proc = AuProcessFindSubThread(current_thr);

	mov	rcx, QWORD PTR current_thr$[rbp]
	call	?AuProcessFindSubThread@@YAPEAU_au_proc_@@PEAU_au_thread_@@@Z ; AuProcessFindSubThread
	mov	QWORD PTR current_proc$[rbp], rax

; 403  : 		if (!current_proc)

	cmp	QWORD PTR current_proc$[rbp], 0
	jne	SHORT $LN4@OpenDir

; 404  : 			return -1;

	mov	eax, -1
	jmp	$LN1@OpenDir
$LN4@OpenDir:
$LN3@OpenDir:

; 405  : 	}
; 406  : 
; 407  : 	AuVFSNode *fsys = AuVFSFind(filename);

	mov	rcx, QWORD PTR filename$[rbp]
	call	AuVFSFind
	mov	QWORD PTR fsys$[rbp], rax

; 408  : 	AuVFSNode* dirfile = NULL;

	mov	QWORD PTR dirfile$[rbp], 0

; 409  : 	if (!fsys)

	cmp	QWORD PTR fsys$[rbp], 0
	jne	SHORT $LN5@OpenDir

; 410  : 		return -1;

	mov	eax, -1
	jmp	SHORT $LN1@OpenDir
$LN5@OpenDir:

; 411  : 	if (fsys->opendir)

	mov	rax, QWORD PTR fsys$[rbp]
	cmp	QWORD PTR [rax+82], 0
	je	SHORT $LN6@OpenDir

; 412  : 		dirfile = fsys->opendir(fsys, filename);

	mov	rdx, QWORD PTR filename$[rbp]
	mov	rcx, QWORD PTR fsys$[rbp]
	mov	rax, QWORD PTR fsys$[rbp]
	call	QWORD PTR [rax+82]
	mov	QWORD PTR dirfile$[rbp], rax
$LN6@OpenDir:

; 413  : 
; 414  : 	if (!dirfile)

	cmp	QWORD PTR dirfile$[rbp], 0
	jne	SHORT $LN7@OpenDir

; 415  : 		return -1;

	mov	eax, -1
	jmp	SHORT $LN1@OpenDir
$LN7@OpenDir:

; 416  : 
; 417  : 	int fd = AuProcessGetFileDesc(current_proc);

	mov	rcx, QWORD PTR current_proc$[rbp]
	call	?AuProcessGetFileDesc@@YAHPEAU_au_proc_@@@Z ; AuProcessGetFileDesc
	mov	DWORD PTR fd$[rbp], eax

; 418  : 	if (fd == -1)

	cmp	DWORD PTR fd$[rbp], -1
	jne	SHORT $LN8@OpenDir

; 419  : 		return -1;

	mov	eax, -1
	jmp	SHORT $LN1@OpenDir
$LN8@OpenDir:

; 420  : 
; 421  : 	current_proc->fds[fd] = dirfile;

	movsxd	rax, DWORD PTR fd$[rbp]
	mov	rcx, QWORD PTR current_proc$[rbp]
	mov	rdx, QWORD PTR dirfile$[rbp]
	mov	QWORD PTR [rcx+rax*8+567], rdx

; 422  : 	SeTextOut("dir opening -> %s , %x \r\n", dirfile->filename, dirfile);

	mov	rax, QWORD PTR dirfile$[rbp]
	mov	r8, QWORD PTR dirfile$[rbp]
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:??_C@_0BK@LJOPCOLI@dir?5opening?5?9?$DO?5?$CFs?5?0?5?$CFx?5?$AN?6@
	call	SeTextOut

; 423  : 	return fd;

	mov	eax, DWORD PTR fd$[rbp]
$LN1@OpenDir:

; 424  : }

	lea	rsp, QWORD PTR [rbp+112]
	pop	rbp
	ret	0
?OpenDir@@YAHPEAD@Z ENDP				; OpenDir
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Serv\fileserv.cpp
;	COMDAT ?FileStat@@YAHHPEAX@Z
_TEXT	SEGMENT
current_thr$ = 0
current_proc$ = 8
file$ = 16
status$ = 24
fd$ = 112
buf$ = 120
?FileStat@@YAHHPEAX@Z PROC				; FileStat, COMDAT

; 361  : int FileStat(int fd, void* buf) {

$LN8:
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	push	rbp
	sub	rsp, 128				; 00000080H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__5DFC7571_fileserv@cpp
	call	__CheckForDebuggerJustMyCode

; 362  : 	x64_cli();

	call	x64_cli

; 363  : 	if (fd == -1)

	cmp	DWORD PTR fd$[rbp], -1
	jne	SHORT $LN2@FileStat

; 364  : 		return -1;

	mov	eax, -1
	jmp	$LN1@FileStat
$LN2@FileStat:

; 365  : 	AuThread* current_thr = AuGetCurrentThread();

	call	AuGetCurrentThread
	mov	QWORD PTR current_thr$[rbp], rax

; 366  : 	if (!current_thr){

	cmp	QWORD PTR current_thr$[rbp], 0
	jne	SHORT $LN3@FileStat

; 367  : 		return 0;

	xor	eax, eax
	jmp	$LN1@FileStat
$LN3@FileStat:

; 368  : 	}
; 369  : 	AuProcess* current_proc = AuProcessFindThread(current_thr);

	mov	rcx, QWORD PTR current_thr$[rbp]
	call	?AuProcessFindThread@@YAPEAU_au_proc_@@PEAU_au_thread_@@@Z ; AuProcessFindThread
	mov	QWORD PTR current_proc$[rbp], rax

; 370  : 	if (!current_proc) {

	cmp	QWORD PTR current_proc$[rbp], 0
	jne	SHORT $LN4@FileStat

; 371  : 		current_proc = AuProcessFindSubThread(current_thr);

	mov	rcx, QWORD PTR current_thr$[rbp]
	call	?AuProcessFindSubThread@@YAPEAU_au_proc_@@PEAU_au_thread_@@@Z ; AuProcessFindSubThread
	mov	QWORD PTR current_proc$[rbp], rax

; 372  : 		if (!current_proc)

	cmp	QWORD PTR current_proc$[rbp], 0
	jne	SHORT $LN5@FileStat

; 373  : 			return 0;

	xor	eax, eax
	jmp	$LN1@FileStat
$LN5@FileStat:
$LN4@FileStat:

; 374  : 	}
; 375  : 	AuVFSNode* file = current_proc->fds[fd];

	movsxd	rax, DWORD PTR fd$[rbp]
	mov	rcx, QWORD PTR current_proc$[rbp]
	mov	rax, QWORD PTR [rcx+rax*8+567]
	mov	QWORD PTR file$[rbp], rax

; 376  : 	if (!file)

	cmp	QWORD PTR file$[rbp], 0
	jne	SHORT $LN6@FileStat

; 377  : 		return -1;

	mov	eax, -1
	jmp	SHORT $LN1@FileStat
$LN6@FileStat:

; 378  : 
; 379  : 	AuFileStatus *status = (AuFileStatus*)buf;

	mov	rax, QWORD PTR buf$[rbp]
	mov	QWORD PTR status$[rbp], rax

; 380  : 	status->current_block = file->current;

	mov	rax, QWORD PTR status$[rbp]
	mov	rcx, QWORD PTR file$[rbp]
	mov	ecx, DWORD PTR [rcx+53]
	mov	DWORD PTR [rax+9], ecx

; 381  : 	status->size = file->size;

	mov	rax, QWORD PTR file$[rbp]
	mov	eax, DWORD PTR [rax+32]
	mov	rcx, QWORD PTR status$[rbp]
	mov	QWORD PTR [rcx+1], rax

; 382  : 	status->filemode = file->flags;

	mov	rax, QWORD PTR status$[rbp]
	mov	rcx, QWORD PTR file$[rbp]
	movzx	ecx, BYTE PTR [rcx+61]
	mov	BYTE PTR [rax], cl

; 383  : 	status->eof = file->eof;

	mov	rax, QWORD PTR status$[rbp]
	mov	rcx, QWORD PTR file$[rbp]
	movzx	ecx, BYTE PTR [rcx+36]
	mov	BYTE PTR [rax+29], cl

; 384  : 	status->start_block = file->first_block;

	mov	rax, QWORD PTR status$[rbp]
	mov	rcx, QWORD PTR file$[rbp]
	mov	ecx, DWORD PTR [rcx+45]
	mov	DWORD PTR [rax+13], ecx

; 385  : 	status->user_id = 0;

	mov	rax, QWORD PTR status$[rbp]
	mov	DWORD PTR [rax+17], 0

; 386  : 	status->group_id = 0;

	mov	rax, QWORD PTR status$[rbp]
	mov	DWORD PTR [rax+21], 0

; 387  : 	return 0;

	xor	eax, eax
$LN1@FileStat:

; 388  : }

	lea	rsp, QWORD PTR [rbp+96]
	pop	rbp
	ret	0
?FileStat@@YAHHPEAX@Z ENDP				; FileStat
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Serv\fileserv.cpp
;	COMDAT ?FileIoControl@@YAHHHPEAX@Z
_TEXT	SEGMENT
current_thr$ = 0
current_proc$ = 8
file$ = 16
ret$ = 24
fd$ = 112
code$ = 120
arg$ = 128
?FileIoControl@@YAHHHPEAX@Z PROC			; FileIoControl, COMDAT

; 332  : int FileIoControl(int fd, int code, void* arg) {

$LN8:
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	push	rbp
	sub	rsp, 128				; 00000080H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__5DFC7571_fileserv@cpp
	call	__CheckForDebuggerJustMyCode

; 333  : 	x64_cli();

	call	x64_cli

; 334  : 	if (fd == -1)

	cmp	DWORD PTR fd$[rbp], -1
	jne	SHORT $LN2@FileIoCont

; 335  : 		return -1;

	mov	eax, -1
	jmp	$LN1@FileIoCont
$LN2@FileIoCont:

; 336  : 	AuThread* current_thr = AuGetCurrentThread();

	call	AuGetCurrentThread
	mov	QWORD PTR current_thr$[rbp], rax

; 337  : 	if (!current_thr)

	cmp	QWORD PTR current_thr$[rbp], 0
	jne	SHORT $LN3@FileIoCont

; 338  : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@FileIoCont
$LN3@FileIoCont:

; 339  : 	AuProcess* current_proc = AuProcessFindThread(current_thr);

	mov	rcx, QWORD PTR current_thr$[rbp]
	call	?AuProcessFindThread@@YAPEAU_au_proc_@@PEAU_au_thread_@@@Z ; AuProcessFindThread
	mov	QWORD PTR current_proc$[rbp], rax

; 340  : 	if (!current_proc) {

	cmp	QWORD PTR current_proc$[rbp], 0
	jne	SHORT $LN4@FileIoCont

; 341  : 		current_proc = AuProcessFindSubThread(current_thr);

	mov	rcx, QWORD PTR current_thr$[rbp]
	call	?AuProcessFindSubThread@@YAPEAU_au_proc_@@PEAU_au_thread_@@@Z ; AuProcessFindSubThread
	mov	QWORD PTR current_proc$[rbp], rax

; 342  : 		if (!current_proc)

	cmp	QWORD PTR current_proc$[rbp], 0
	jne	SHORT $LN5@FileIoCont

; 343  : 			return 0;

	xor	eax, eax
	jmp	SHORT $LN1@FileIoCont
$LN5@FileIoCont:
$LN4@FileIoCont:

; 344  : 	}
; 345  : 	AuVFSNode* file = current_proc->fds[fd];

	movsxd	rax, DWORD PTR fd$[rbp]
	mov	rcx, QWORD PTR current_proc$[rbp]
	mov	rax, QWORD PTR [rcx+rax*8+567]
	mov	QWORD PTR file$[rbp], rax

; 346  : 
; 347  : 	if (!file)

	cmp	QWORD PTR file$[rbp], 0
	jne	SHORT $LN6@FileIoCont

; 348  : 		return -1;

	mov	eax, -1
	jmp	SHORT $LN1@FileIoCont
$LN6@FileIoCont:

; 349  : 
; 350  : 	int ret = 0;

	mov	DWORD PTR ret$[rbp], 0

; 351  : 	ret = AuVFSNodeIOControl(file, code, arg);

	mov	r8, QWORD PTR arg$[rbp]
	mov	edx, DWORD PTR code$[rbp]
	mov	rcx, QWORD PTR file$[rbp]
	call	AuVFSNodeIOControl
	mov	DWORD PTR ret$[rbp], eax

; 352  : 	return ret;

	mov	eax, DWORD PTR ret$[rbp]
$LN1@FileIoCont:

; 353  : }

	lea	rsp, QWORD PTR [rbp+96]
	pop	rbp
	ret	0
?FileIoControl@@YAHHHPEAX@Z ENDP			; FileIoControl
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Serv\fileserv.cpp
;	COMDAT ?CloseFile@@YAHH@Z
_TEXT	SEGMENT
current_thr$ = 0
current_proc$ = 8
file$ = 16
fd$ = 112
?CloseFile@@YAHH@Z PROC					; CloseFile, COMDAT

; 288  : int CloseFile(int fd) {

$LN12:
	mov	DWORD PTR [rsp+8], ecx
	push	rbp
	sub	rsp, 128				; 00000080H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__5DFC7571_fileserv@cpp
	call	__CheckForDebuggerJustMyCode

; 289  : 	x64_cli();

	call	x64_cli

; 290  : 	if (fd == -1)

	cmp	DWORD PTR fd$[rbp], -1
	jne	SHORT $LN2@CloseFile

; 291  : 		return 0;

	xor	eax, eax
	jmp	$LN1@CloseFile
$LN2@CloseFile:

; 292  : 	AuThread* current_thr = AuGetCurrentThread();

	call	AuGetCurrentThread
	mov	QWORD PTR current_thr$[rbp], rax

; 293  : 	if (!current_thr)

	cmp	QWORD PTR current_thr$[rbp], 0
	jne	SHORT $LN3@CloseFile

; 294  : 		return 0;

	xor	eax, eax
	jmp	$LN1@CloseFile
$LN3@CloseFile:

; 295  : 	AuProcess* current_proc = AuProcessFindThread(current_thr);

	mov	rcx, QWORD PTR current_thr$[rbp]
	call	?AuProcessFindThread@@YAPEAU_au_proc_@@PEAU_au_thread_@@@Z ; AuProcessFindThread
	mov	QWORD PTR current_proc$[rbp], rax

; 296  : 	if (!current_proc) {

	cmp	QWORD PTR current_proc$[rbp], 0
	jne	SHORT $LN4@CloseFile

; 297  : 		current_proc = AuProcessFindSubThread(current_thr);

	mov	rcx, QWORD PTR current_thr$[rbp]
	call	?AuProcessFindSubThread@@YAPEAU_au_proc_@@PEAU_au_thread_@@@Z ; AuProcessFindSubThread
	mov	QWORD PTR current_proc$[rbp], rax

; 298  : 		if (!current_proc)

	cmp	QWORD PTR current_proc$[rbp], 0
	jne	SHORT $LN5@CloseFile

; 299  : 			return 0;

	xor	eax, eax
	jmp	$LN1@CloseFile
$LN5@CloseFile:
$LN4@CloseFile:

; 300  : 	}
; 301  : 
; 302  : 	AuVFSNode* file = current_proc->fds[fd];

	movsxd	rax, DWORD PTR fd$[rbp]
	mov	rcx, QWORD PTR current_proc$[rbp]
	mov	rax, QWORD PTR [rcx+rax*8+567]
	mov	QWORD PTR file$[rbp], rax

; 303  : 	if (file->flags & FS_FLAG_FILE_SYSTEM){

	mov	rax, QWORD PTR file$[rbp]
	movzx	eax, WORD PTR [rax+61]
	and	eax, 64					; 00000040H
	test	eax, eax
	je	SHORT $LN6@CloseFile

; 304  : 		SeTextOut("Closing fs -> %s \r\n", file->filename);

	mov	rax, QWORD PTR file$[rbp]
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:??_C@_0BE@KOBNHDHJ@Closing?5fs?5?9?$DO?5?$CFs?5?$AN?6@
	call	SeTextOut

; 305  : 		current_proc->fds[fd] = 0;

	movsxd	rax, DWORD PTR fd$[rbp]
	mov	rcx, QWORD PTR current_proc$[rbp]
	mov	QWORD PTR [rcx+rax*8+567], 0

; 306  : 		return -1;

	mov	eax, -1
	jmp	SHORT $LN1@CloseFile
$LN6@CloseFile:

; 307  : 	}
; 308  : 	if (file->flags & FS_FLAG_GENERAL){

	mov	rax, QWORD PTR file$[rbp]
	movzx	eax, WORD PTR [rax+61]
	and	eax, 4
	test	eax, eax
	je	SHORT $LN7@CloseFile

; 309  : 		kfree(file);

	mov	rcx, QWORD PTR file$[rbp]
	call	kfree
$LN7@CloseFile:

; 310  : 	}
; 311  : 	
; 312  : 
; 313  : 	if (file->flags & FS_FLAG_DIRECTORY){

	mov	rax, QWORD PTR file$[rbp]
	movzx	eax, WORD PTR [rax+61]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN8@CloseFile

; 314  : 		kfree(file);

	mov	rcx, QWORD PTR file$[rbp]
	call	kfree
$LN8@CloseFile:

; 315  : 	}
; 316  : 
; 317  : 	if (file->flags & FS_FLAG_PIPE) {

	mov	rax, QWORD PTR file$[rbp]
	movzx	eax, WORD PTR [rax+61]
	and	eax, 128				; 00000080H
	test	eax, eax
	je	SHORT $LN9@CloseFile

; 318  : 		if (file->close)

	mov	rax, QWORD PTR file$[rbp]
	cmp	QWORD PTR [rax+138], 0
	je	SHORT $LN10@CloseFile

; 319  : 			file->close(file, file);

	mov	rdx, QWORD PTR file$[rbp]
	mov	rcx, QWORD PTR file$[rbp]
	mov	rax, QWORD PTR file$[rbp]
	call	QWORD PTR [rax+138]
$LN10@CloseFile:
$LN9@CloseFile:

; 320  : 	}
; 321  : 
; 322  : 	current_proc->fds[fd] = 0;

	movsxd	rax, DWORD PTR fd$[rbp]
	mov	rcx, QWORD PTR current_proc$[rbp]
	mov	QWORD PTR [rcx+rax*8+567], 0

; 323  : 	return 0;

	xor	eax, eax
$LN1@CloseFile:

; 324  : }

	lea	rsp, QWORD PTR [rbp+96]
	pop	rbp
	ret	0
?CloseFile@@YAHH@Z ENDP					; CloseFile
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Serv\fileserv.cpp
;	COMDAT ?RemoveFile@@YAHPEAD@Z
_TEXT	SEGMENT
dir$ = 0
fsys$ = 8
pathname$ = 96
?RemoveFile@@YAHPEAD@Z PROC				; RemoveFile, COMDAT

; 273  : int RemoveFile(char* pathname) {

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__5DFC7571_fileserv@cpp
	call	__CheckForDebuggerJustMyCode

; 274  : 	AuVFSNode* dir = AuVFSOpen(pathname);

	mov	rcx, QWORD PTR pathname$[rbp]
	call	AuVFSOpen
	mov	QWORD PTR dir$[rbp], rax

; 275  : 	if (!dir)

	cmp	QWORD PTR dir$[rbp], 0
	jne	SHORT $LN2@RemoveFile

; 276  : 		return -1;

	mov	eax, -1
	jmp	SHORT $LN1@RemoveFile
$LN2@RemoveFile:

; 277  : 	AuVFSNode* fsys = (AuVFSNode*)dir->device;

	mov	rax, QWORD PTR dir$[rbp]
	mov	rax, QWORD PTR [rax+64]
	mov	QWORD PTR fsys$[rbp], rax

; 278  : 	if (fsys->flags & FS_FLAG_DIRECTORY)

	mov	rax, QWORD PTR fsys$[rbp]
	movzx	eax, WORD PTR [rax+61]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN3@RemoveFile

; 279  : 		return AuVFSRemoveDir(fsys, dir);

	mov	rdx, QWORD PTR dir$[rbp]
	mov	rcx, QWORD PTR fsys$[rbp]
	call	?AuVFSRemoveDir@@YAHPEAU__VFS_NODE__@@0@Z ; AuVFSRemoveDir
	jmp	SHORT $LN1@RemoveFile
	jmp	SHORT $LN4@RemoveFile
$LN3@RemoveFile:

; 280  : 	else
; 281  : 		return AuVFSRemoveFile(fsys, dir);

	mov	rdx, QWORD PTR dir$[rbp]
	mov	rcx, QWORD PTR fsys$[rbp]
	call	?AuVFSRemoveFile@@YAHPEAU__VFS_NODE__@@0@Z ; AuVFSRemoveFile
$LN4@RemoveFile:
$LN1@RemoveFile:

; 282  : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
?RemoveFile@@YAHPEAD@Z ENDP				; RemoveFile
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Serv\fileserv.cpp
;	COMDAT ?CreateDir@@YAHPEAD@Z
_TEXT	SEGMENT
current_thr$ = 0
current_proc$ = 8
fsys$ = 16
dirfile$ = 24
filename$ = 112
?CreateDir@@YAHPEAD@Z PROC				; CreateDir, COMDAT

; 239  : int CreateDir(char* filename) {

$LN9:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 128				; 00000080H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__5DFC7571_fileserv@cpp
	call	__CheckForDebuggerJustMyCode

; 240  : 	x64_cli();

	call	x64_cli

; 241  : 	AuThread* current_thr = AuGetCurrentThread();

	call	AuGetCurrentThread
	mov	QWORD PTR current_thr$[rbp], rax

; 242  : 	if (!current_thr){

	cmp	QWORD PTR current_thr$[rbp], 0
	jne	SHORT $LN2@CreateDir

; 243  : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@CreateDir
$LN2@CreateDir:

; 244  : 	}
; 245  : 	AuProcess* current_proc = AuProcessFindThread(current_thr);

	mov	rcx, QWORD PTR current_thr$[rbp]
	call	?AuProcessFindThread@@YAPEAU_au_proc_@@PEAU_au_thread_@@@Z ; AuProcessFindThread
	mov	QWORD PTR current_proc$[rbp], rax

; 246  : 	if (!current_proc) {

	cmp	QWORD PTR current_proc$[rbp], 0
	jne	SHORT $LN3@CreateDir

; 247  : 		current_proc = AuProcessFindSubThread(current_thr);

	mov	rcx, QWORD PTR current_thr$[rbp]
	call	?AuProcessFindSubThread@@YAPEAU_au_proc_@@PEAU_au_thread_@@@Z ; AuProcessFindSubThread
	mov	QWORD PTR current_proc$[rbp], rax

; 248  : 		if (!current_proc)

	cmp	QWORD PTR current_proc$[rbp], 0
	jne	SHORT $LN4@CreateDir

; 249  : 			return 0;

	xor	eax, eax
	jmp	SHORT $LN1@CreateDir
$LN4@CreateDir:
$LN3@CreateDir:

; 250  : 	}
; 251  : 
; 252  : 	AuVFSNode *fsys = AuVFSFind(filename);

	mov	rcx, QWORD PTR filename$[rbp]
	call	AuVFSFind
	mov	QWORD PTR fsys$[rbp], rax

; 253  : 	AuVFSNode* dirfile = NULL;

	mov	QWORD PTR dirfile$[rbp], 0

; 254  : 	if (fsys){

	cmp	QWORD PTR fsys$[rbp], 0
	je	SHORT $LN5@CreateDir

; 255  : 		dirfile = AuVFSCreateDir(fsys, filename);

	mov	rdx, QWORD PTR filename$[rbp]
	mov	rcx, QWORD PTR fsys$[rbp]
	call	AuVFSCreateDir
	mov	QWORD PTR dirfile$[rbp], rax

; 256  : 	}

	jmp	SHORT $LN6@CreateDir
$LN5@CreateDir:

; 257  : 	else {
; 258  : 		return -1;

	mov	eax, -1
	jmp	SHORT $LN1@CreateDir
$LN6@CreateDir:

; 259  : 	}
; 260  : 
; 261  : 	if (dirfile) {

	cmp	QWORD PTR dirfile$[rbp], 0
	je	SHORT $LN7@CreateDir

; 262  : 		kfree(dirfile);

	mov	rcx, QWORD PTR dirfile$[rbp]
	call	kfree

; 263  : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@CreateDir
$LN7@CreateDir:

; 264  : 	}
; 265  : 
; 266  : 	return -1;

	mov	eax, -1
$LN1@CreateDir:

; 267  : }

	lea	rsp, QWORD PTR [rbp+96]
	pop	rbp
	ret	0
?CreateDir@@YAHPEAD@Z ENDP				; CreateDir
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Serv\fileserv.cpp
;	COMDAT ?WriteFile@@YA_KHPEAX_K@Z
_TEXT	SEGMENT
current_thr$ = 0
current_proc$ = 8
file$ = 16
aligned_buffer$ = 24
write_bytes$ = 32
fsys$ = 48
buff$1 = 56
fd$ = 144
buffer$ = 152
length$ = 160
?WriteFile@@YA_KHPEAX_K@Z PROC				; WriteFile, COMDAT

; 183  : size_t WriteFile(int fd, void* buffer, size_t length) {

$LN17:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	push	rbp
	sub	rsp, 160				; 000000a0H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__5DFC7571_fileserv@cpp
	call	__CheckForDebuggerJustMyCode

; 184  : 	x64_cli();

	call	x64_cli

; 185  : 	if (fd == -1)

	cmp	DWORD PTR fd$[rbp], -1
	jne	SHORT $LN2@WriteFile

; 186  : 		return 0;

	xor	eax, eax
	jmp	$LN1@WriteFile
$LN2@WriteFile:

; 187  : 	if (!buffer)

	cmp	QWORD PTR buffer$[rbp], 0
	jne	SHORT $LN3@WriteFile

; 188  : 		return 0;

	xor	eax, eax
	jmp	$LN1@WriteFile
$LN3@WriteFile:

; 189  : 	if (!length)

	cmp	QWORD PTR length$[rbp], 0
	jne	SHORT $LN4@WriteFile

; 190  : 		return 0;

	xor	eax, eax
	jmp	$LN1@WriteFile
$LN4@WriteFile:

; 191  : 	AuThread* current_thr = AuGetCurrentThread();

	call	AuGetCurrentThread
	mov	QWORD PTR current_thr$[rbp], rax

; 192  : 	if (!current_thr)

	cmp	QWORD PTR current_thr$[rbp], 0
	jne	SHORT $LN5@WriteFile

; 193  : 		return 0;

	xor	eax, eax
	jmp	$LN1@WriteFile
$LN5@WriteFile:

; 194  : 	AuProcess* current_proc = AuProcessFindThread(current_thr);

	mov	rcx, QWORD PTR current_thr$[rbp]
	call	?AuProcessFindThread@@YAPEAU_au_proc_@@PEAU_au_thread_@@@Z ; AuProcessFindThread
	mov	QWORD PTR current_proc$[rbp], rax

; 195  : 	if (!current_proc) {

	cmp	QWORD PTR current_proc$[rbp], 0
	jne	SHORT $LN6@WriteFile

; 196  : 		current_proc = AuProcessFindSubThread(current_thr);

	mov	rcx, QWORD PTR current_thr$[rbp]
	call	?AuProcessFindSubThread@@YAPEAU_au_proc_@@PEAU_au_thread_@@@Z ; AuProcessFindSubThread
	mov	QWORD PTR current_proc$[rbp], rax

; 197  : 		if (!current_proc) 

	cmp	QWORD PTR current_proc$[rbp], 0
	jne	SHORT $LN7@WriteFile

; 198  : 			return 0;

	xor	eax, eax
	jmp	$LN1@WriteFile
$LN7@WriteFile:
$LN6@WriteFile:

; 199  : 	}
; 200  : 	AuVFSNode* file = current_proc->fds[fd];

	movsxd	rax, DWORD PTR fd$[rbp]
	mov	rcx, QWORD PTR current_proc$[rbp]
	mov	rax, QWORD PTR [rcx+rax*8+567]
	mov	QWORD PTR file$[rbp], rax

; 201  : 	uint8_t* aligned_buffer = (uint8_t*)buffer;

	mov	rax, QWORD PTR buffer$[rbp]
	mov	QWORD PTR aligned_buffer$[rbp], rax

; 202  : 	if (!file)

	cmp	QWORD PTR file$[rbp], 0
	jne	SHORT $LN8@WriteFile

; 203  : 		return 0;

	xor	eax, eax
	jmp	$LN1@WriteFile
$LN8@WriteFile:

; 204  : 	size_t write_bytes = 0;

	mov	QWORD PTR write_bytes$[rbp], 0

; 205  : 	size_t ret_bytes;
; 206  : 	/* every general file will contain its
; 207  : 	* file system node as device */
; 208  : 	AuVFSNode* fsys = (AuVFSNode*)file->device;

	mov	rax, QWORD PTR file$[rbp]
	mov	rax, QWORD PTR [rax+64]
	mov	QWORD PTR fsys$[rbp], rax

; 209  : 
; 210  : 	if (file->flags & FS_FLAG_GENERAL && !(file->flags & FS_FLAG_TTY)) {

	mov	rax, QWORD PTR file$[rbp]
	movzx	eax, WORD PTR [rax+61]
	and	eax, 4
	test	eax, eax
	je	SHORT $LN9@WriteFile
	mov	rax, QWORD PTR file$[rbp]
	movzx	eax, WORD PTR [rax+61]
	and	eax, 256				; 00000100H
	test	eax, eax
	jne	SHORT $LN9@WriteFile

; 211  : 		uint64_t* buff = (uint64_t*)P2V((size_t)AuPmmngrAlloc());

	call	AuPmmngrAlloc
	mov	rcx, rax
	call	P2V
	mov	QWORD PTR buff$1[rbp], rax

; 212  : 		memset(buff, 0, PAGE_SIZE);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR buff$1[rbp]
	call	memset

; 213  : 		memcpy(buff,aligned_buffer, PAGE_SIZE);

	mov	r8d, 4096				; 00001000H
	mov	rdx, QWORD PTR aligned_buffer$[rbp]
	mov	rcx, QWORD PTR buff$1[rbp]
	call	memcpy

; 214  : 		AuVFSNodeWrite(fsys, file, buff, length);

	mov	r9d, DWORD PTR length$[rbp]
	mov	r8, QWORD PTR buff$1[rbp]
	mov	rdx, QWORD PTR file$[rbp]
	mov	rcx, QWORD PTR fsys$[rbp]
	call	AuVFSNodeWrite

; 215  : 		AuPmmngrFree((void*)V2P((size_t)buff));

	mov	rcx, QWORD PTR buff$1[rbp]
	call	V2P
	mov	rcx, rax
	call	AuPmmngrFree
$LN9@WriteFile:

; 216  : 	}
; 217  : 
; 218  : 	if (file->flags & FS_FLAG_TTY) {

	mov	rax, QWORD PTR file$[rbp]
	movzx	eax, WORD PTR [rax+61]
	and	eax, 256				; 00000100H
	test	eax, eax
	je	SHORT $LN10@WriteFile

; 219  : 		if (file->write)

	mov	rax, QWORD PTR file$[rbp]
	cmp	QWORD PTR [rax+98], 0
	je	SHORT $LN11@WriteFile

; 220  : 			return file->write(file, file, (uint64_t*)buffer, length);

	mov	r9d, DWORD PTR length$[rbp]
	mov	r8, QWORD PTR buffer$[rbp]
	mov	rdx, QWORD PTR file$[rbp]
	mov	rcx, QWORD PTR file$[rbp]
	mov	rax, QWORD PTR file$[rbp]
	call	QWORD PTR [rax+98]
	jmp	SHORT $LN1@WriteFile
$LN11@WriteFile:
$LN10@WriteFile:

; 221  : 	}
; 222  : 
; 223  : 	if (file->flags & FS_FLAG_DEVICE) {

	mov	rax, QWORD PTR file$[rbp]
	movzx	eax, WORD PTR [rax+61]
	and	eax, 8
	test	eax, eax
	je	SHORT $LN12@WriteFile

; 224  : 		if (file->write) {

	mov	rax, QWORD PTR file$[rbp]
	cmp	QWORD PTR [rax+98], 0
	je	SHORT $LN13@WriteFile

; 225  : 			return file->write(fsys, file, (uint64_t*)buffer, length);

	mov	r9d, DWORD PTR length$[rbp]
	mov	r8, QWORD PTR buffer$[rbp]
	mov	rdx, QWORD PTR file$[rbp]
	mov	rcx, QWORD PTR fsys$[rbp]
	mov	rax, QWORD PTR file$[rbp]
	call	QWORD PTR [rax+98]
	jmp	SHORT $LN1@WriteFile
$LN13@WriteFile:
$LN12@WriteFile:

; 226  : 		}
; 227  : 	}
; 228  : 
; 229  : 	if (file->flags & FS_FLAG_PIPE) {

	mov	rax, QWORD PTR file$[rbp]
	movzx	eax, WORD PTR [rax+61]
	and	eax, 128				; 00000080H
	test	eax, eax
	je	SHORT $LN14@WriteFile

; 230  : 		if (file->write)

	mov	rax, QWORD PTR file$[rbp]
	cmp	QWORD PTR [rax+98], 0
	je	SHORT $LN15@WriteFile

; 231  : 			return file->write(file, file, (uint64_t*)buffer, length);

	mov	r9d, DWORD PTR length$[rbp]
	mov	r8, QWORD PTR buffer$[rbp]
	mov	rdx, QWORD PTR file$[rbp]
	mov	rcx, QWORD PTR file$[rbp]
	mov	rax, QWORD PTR file$[rbp]
	call	QWORD PTR [rax+98]
$LN15@WriteFile:
$LN14@WriteFile:
$LN1@WriteFile:

; 232  : 	}
; 233  : }

	lea	rsp, QWORD PTR [rbp+128]
	pop	rbp
	ret	0
?WriteFile@@YA_KHPEAX_K@Z ENDP				; WriteFile
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Serv\fileserv.cpp
;	COMDAT ?ReadFile@@YA_KHPEAX_K@Z
_TEXT	SEGMENT
current_thr$ = 0
current_proc$ = 8
file$ = 16
aligned_buffer$ = 24
ret_bytes$ = 32
fsys$ = 40
fd$ = 128
buffer$ = 136
length$ = 144
?ReadFile@@YA_KHPEAX_K@Z PROC				; ReadFile, COMDAT

; 125  : size_t ReadFile(int fd, void* buffer, size_t length) {

$LN17:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	push	rbp
	sub	rsp, 144				; 00000090H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__5DFC7571_fileserv@cpp
	call	__CheckForDebuggerJustMyCode

; 126  : 	x64_cli();

	call	x64_cli

; 127  : 	if (fd == -1)

	cmp	DWORD PTR fd$[rbp], -1
	jne	SHORT $LN2@ReadFile

; 128  : 		return 0;

	xor	eax, eax
	jmp	$LN1@ReadFile
$LN2@ReadFile:

; 129  : 	if (!buffer)

	cmp	QWORD PTR buffer$[rbp], 0
	jne	SHORT $LN3@ReadFile

; 130  : 		return 0;

	xor	eax, eax
	jmp	$LN1@ReadFile
$LN3@ReadFile:

; 131  : 	if (!length)

	cmp	QWORD PTR length$[rbp], 0
	jne	SHORT $LN4@ReadFile

; 132  : 		return 0;

	xor	eax, eax
	jmp	$LN1@ReadFile
$LN4@ReadFile:

; 133  : 	AuThread* current_thr = AuGetCurrentThread();

	call	AuGetCurrentThread
	mov	QWORD PTR current_thr$[rbp], rax

; 134  : 	if (!current_thr)

	cmp	QWORD PTR current_thr$[rbp], 0
	jne	SHORT $LN5@ReadFile

; 135  : 		return 0;

	xor	eax, eax
	jmp	$LN1@ReadFile
$LN5@ReadFile:

; 136  : 	AuProcess* current_proc = AuProcessFindThread(current_thr);

	mov	rcx, QWORD PTR current_thr$[rbp]
	call	?AuProcessFindThread@@YAPEAU_au_proc_@@PEAU_au_thread_@@@Z ; AuProcessFindThread
	mov	QWORD PTR current_proc$[rbp], rax

; 137  : 	if (!current_proc){

	cmp	QWORD PTR current_proc$[rbp], 0
	jne	SHORT $LN6@ReadFile

; 138  : 		current_proc = AuProcessFindSubThread(current_thr);

	mov	rcx, QWORD PTR current_thr$[rbp]
	call	?AuProcessFindSubThread@@YAPEAU_au_proc_@@PEAU_au_thread_@@@Z ; AuProcessFindSubThread
	mov	QWORD PTR current_proc$[rbp], rax

; 139  : 		if (!current_proc)

	cmp	QWORD PTR current_proc$[rbp], 0
	jne	SHORT $LN7@ReadFile

; 140  : 			return 0;

	xor	eax, eax
	jmp	$LN1@ReadFile
$LN7@ReadFile:
$LN6@ReadFile:

; 141  : 	}
; 142  : 	
; 143  : 	AuVFSNode* file = current_proc->fds[fd];

	movsxd	rax, DWORD PTR fd$[rbp]
	mov	rcx, QWORD PTR current_proc$[rbp]
	mov	rax, QWORD PTR [rcx+rax*8+567]
	mov	QWORD PTR file$[rbp], rax

; 144  : 	uint64_t* aligned_buffer = (uint64_t*)buffer;

	mov	rax, QWORD PTR buffer$[rbp]
	mov	QWORD PTR aligned_buffer$[rbp], rax

; 145  : 
; 146  : 	//SeTextOut("Reading from file -> %d -> %x \r\n", fd, file);
; 147  : 	if (!file)

	cmp	QWORD PTR file$[rbp], 0
	jne	SHORT $LN8@ReadFile

; 148  : 		return 0;

	xor	eax, eax
	jmp	$LN1@ReadFile
$LN8@ReadFile:

; 149  : 	size_t ret_bytes = 0;

	mov	QWORD PTR ret_bytes$[rbp], 0

; 150  : 	
; 151  : 	/* every general file will contain its
; 152  : 	 * file system node as device */
; 153  : 	AuVFSNode* fsys = (AuVFSNode*)file->device;

	mov	rax, QWORD PTR file$[rbp]
	mov	rax, QWORD PTR [rax+64]
	mov	QWORD PTR fsys$[rbp], rax

; 154  : 	if (file->flags & FS_FLAG_GENERAL && !(file->flags & FS_FLAG_TTY)) {

	mov	rax, QWORD PTR file$[rbp]
	movzx	eax, WORD PTR [rax+61]
	and	eax, 4
	test	eax, eax
	je	SHORT $LN9@ReadFile
	mov	rax, QWORD PTR file$[rbp]
	movzx	eax, WORD PTR [rax+61]
	and	eax, 256				; 00000100H
	test	eax, eax
	jne	SHORT $LN9@ReadFile

; 155  : 		ret_bytes = AuVFSNodeRead(fsys, file,aligned_buffer, length);

	mov	r9d, DWORD PTR length$[rbp]
	mov	r8, QWORD PTR aligned_buffer$[rbp]
	mov	rdx, QWORD PTR file$[rbp]
	mov	rcx, QWORD PTR fsys$[rbp]
	call	AuVFSNodeRead
	mov	QWORD PTR ret_bytes$[rbp], rax
$LN9@ReadFile:

; 156  : 	}
; 157  : 	if (file->flags & FS_FLAG_DEVICE){

	mov	rax, QWORD PTR file$[rbp]
	movzx	eax, WORD PTR [rax+61]
	and	eax, 8
	test	eax, eax
	je	SHORT $LN10@ReadFile

; 158  : 		/* devfs will handle*/
; 159  : 		if (file->read)

	mov	rax, QWORD PTR file$[rbp]
	cmp	QWORD PTR [rax+90], 0
	je	SHORT $LN11@ReadFile

; 160  : 			ret_bytes = file->read(file, file, (uint64_t*)buffer, length);

	mov	r9d, DWORD PTR length$[rbp]
	mov	r8, QWORD PTR buffer$[rbp]
	mov	rdx, QWORD PTR file$[rbp]
	mov	rcx, QWORD PTR file$[rbp]
	mov	rax, QWORD PTR file$[rbp]
	call	QWORD PTR [rax+90]
	mov	QWORD PTR ret_bytes$[rbp], rax
$LN11@ReadFile:
$LN10@ReadFile:

; 161  : 	}
; 162  : 
; 163  : 	if (file->flags & FS_FLAG_TTY) {

	mov	rax, QWORD PTR file$[rbp]
	movzx	eax, WORD PTR [rax+61]
	and	eax, 256				; 00000100H
	test	eax, eax
	je	SHORT $LN12@ReadFile

; 164  : 		if (file->read)

	mov	rax, QWORD PTR file$[rbp]
	cmp	QWORD PTR [rax+90], 0
	je	SHORT $LN13@ReadFile

; 165  : 			ret_bytes = file->read(file, file, (uint64_t*)aligned_buffer, length);

	mov	r9d, DWORD PTR length$[rbp]
	mov	r8, QWORD PTR aligned_buffer$[rbp]
	mov	rdx, QWORD PTR file$[rbp]
	mov	rcx, QWORD PTR file$[rbp]
	mov	rax, QWORD PTR file$[rbp]
	call	QWORD PTR [rax+90]
	mov	QWORD PTR ret_bytes$[rbp], rax
$LN13@ReadFile:
$LN12@ReadFile:

; 166  : 	}
; 167  : 	if (file->flags == FS_FLAG_PIPE) {

	mov	rax, QWORD PTR file$[rbp]
	movzx	eax, WORD PTR [rax+61]
	cmp	eax, 128				; 00000080H
	jne	SHORT $LN14@ReadFile

; 168  : 		/* ofcourse, pipe subsystem will handle */
; 169  : 		if (file->read)

	mov	rax, QWORD PTR file$[rbp]
	cmp	QWORD PTR [rax+90], 0
	je	SHORT $LN15@ReadFile

; 170  : 			ret_bytes = file->read(file, file, (uint64_t*)buffer, length);

	mov	r9d, DWORD PTR length$[rbp]
	mov	r8, QWORD PTR buffer$[rbp]
	mov	rdx, QWORD PTR file$[rbp]
	mov	rcx, QWORD PTR file$[rbp]
	mov	rax, QWORD PTR file$[rbp]
	call	QWORD PTR [rax+90]
	mov	QWORD PTR ret_bytes$[rbp], rax
$LN15@ReadFile:
$LN14@ReadFile:

; 171  : 	}
; 172  : 
; 173  : 	return ret_bytes;

	mov	rax, QWORD PTR ret_bytes$[rbp]
$LN1@ReadFile:

; 174  : }

	lea	rsp, QWORD PTR [rbp+112]
	pop	rbp
	ret	0
?ReadFile@@YA_KHPEAX_K@Z ENDP				; ReadFile
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Serv\fileserv.cpp
;	COMDAT ?FileSetOffset@@YAHH_K@Z
_TEXT	SEGMENT
current_thr$ = 0
current_proc$ = 8
file$ = 16
fsys$1 = 24
block$2 = 32
fd$ = 128
offset$ = 136
?FileSetOffset@@YAHH_K@Z PROC				; FileSetOffset, COMDAT

; 94   : int FileSetOffset(int fd, size_t offset) {

$LN9:
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	push	rbp
	sub	rsp, 144				; 00000090H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__5DFC7571_fileserv@cpp
	call	__CheckForDebuggerJustMyCode

; 95   : 	x64_cli();

	call	x64_cli

; 96   : 	AuThread* current_thr = AuGetCurrentThread();

	call	AuGetCurrentThread
	mov	QWORD PTR current_thr$[rbp], rax

; 97   : 	if (!current_thr)

	cmp	QWORD PTR current_thr$[rbp], 0
	jne	SHORT $LN2@FileSetOff

; 98   : 		return -1;

	mov	eax, -1
	jmp	$LN1@FileSetOff
$LN2@FileSetOff:

; 99   : 	AuProcess* current_proc = AuProcessFindThread(current_thr);

	mov	rcx, QWORD PTR current_thr$[rbp]
	call	?AuProcessFindThread@@YAPEAU_au_proc_@@PEAU_au_thread_@@@Z ; AuProcessFindThread
	mov	QWORD PTR current_proc$[rbp], rax

; 100  : 	if (!current_proc) {

	cmp	QWORD PTR current_proc$[rbp], 0
	jne	SHORT $LN3@FileSetOff

; 101  : 		current_proc = AuProcessFindSubThread(current_thr);

	mov	rcx, QWORD PTR current_thr$[rbp]
	call	?AuProcessFindSubThread@@YAPEAU_au_proc_@@PEAU_au_thread_@@@Z ; AuProcessFindSubThread
	mov	QWORD PTR current_proc$[rbp], rax

; 102  : 		if (!current_proc)

	cmp	QWORD PTR current_proc$[rbp], 0
	jne	SHORT $LN4@FileSetOff

; 103  : 			return -1;

	mov	eax, -1
	jmp	$LN1@FileSetOff
$LN4@FileSetOff:
$LN3@FileSetOff:

; 104  : 	}
; 105  : 
; 106  : 	AuVFSNode* file = current_proc->fds[fd];

	movsxd	rax, DWORD PTR fd$[rbp]
	mov	rcx, QWORD PTR current_proc$[rbp]
	mov	rax, QWORD PTR [rcx+rax*8+567]
	mov	QWORD PTR file$[rbp], rax

; 107  : 	if (!file)

	cmp	QWORD PTR file$[rbp], 0
	jne	SHORT $LN5@FileSetOff

; 108  : 		return -1;

	mov	eax, -1
	jmp	$LN1@FileSetOff
$LN5@FileSetOff:

; 109  : 	if (!((file->flags & FS_FLAG_FILE_SYSTEM) || (file->flags & FS_FLAG_DEVICE) || (file->flags & FS_FLAG_PIPE)

	mov	rax, QWORD PTR file$[rbp]
	movzx	eax, WORD PTR [rax+61]
	and	eax, 64					; 00000040H
	test	eax, eax
	jne	$LN6@FileSetOff
	mov	rax, QWORD PTR file$[rbp]
	movzx	eax, WORD PTR [rax+61]
	and	eax, 8
	test	eax, eax
	jne	SHORT $LN6@FileSetOff
	mov	rax, QWORD PTR file$[rbp]
	movzx	eax, WORD PTR [rax+61]
	and	eax, 128				; 00000080H
	test	eax, eax
	jne	SHORT $LN6@FileSetOff
	mov	rax, QWORD PTR file$[rbp]
	movzx	eax, WORD PTR [rax+61]
	and	eax, 2
	test	eax, eax
	jne	SHORT $LN6@FileSetOff
	mov	rax, QWORD PTR file$[rbp]
	movzx	eax, WORD PTR [rax+61]
	and	eax, 256				; 00000100H
	test	eax, eax
	jne	SHORT $LN6@FileSetOff

; 110  : 		|| (file->flags & FS_FLAG_DIRECTORY) || (file->flags & FS_FLAG_TTY))){
; 111  : 		AuVFSNode* fsys = AuVFSFind("/");

	lea	rcx, OFFSET FLAT:??_C@_01KMDKNFGN@?1@
	call	AuVFSFind
	mov	QWORD PTR fsys$1[rbp], rax

; 112  : 		if (!fsys)

	cmp	QWORD PTR fsys$1[rbp], 0
	jne	SHORT $LN7@FileSetOff

; 113  : 			return -1;

	mov	eax, -1
	jmp	SHORT $LN1@FileSetOff
$LN7@FileSetOff:

; 114  : 		size_t block = AuVFSGetBlockFor(fsys, file, offset);

	mov	r8, QWORD PTR offset$[rbp]
	mov	rdx, QWORD PTR file$[rbp]
	mov	rcx, QWORD PTR fsys$1[rbp]
	call	AuVFSGetBlockFor
	mov	QWORD PTR block$2[rbp], rax

; 115  : 		file->current = block;

	mov	rax, QWORD PTR file$[rbp]
	mov	rcx, QWORD PTR block$2[rbp]
	mov	QWORD PTR [rax+53], rcx
$LN6@FileSetOff:

; 116  : 	}
; 117  : 	return 0;

	xor	eax, eax
$LN1@FileSetOff:

; 118  : }

	lea	rsp, QWORD PTR [rbp+112]
	pop	rbp
	ret	0
?FileSetOffset@@YAHH_K@Z ENDP				; FileSetOffset
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Serv\fileserv.cpp
;	COMDAT ?OpenFile@@YAHPEADH@Z
_TEXT	SEGMENT
current_thr$ = 0
current_proc$ = 8
fsys$ = 16
file$ = 24
fd$ = 32
filename$ = 128
mode$ = 136
?OpenFile@@YAHPEADH@Z PROC				; OpenFile, COMDAT

; 48   : int OpenFile(char* filename, int mode) {

$LN14:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 144				; 00000090H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__5DFC7571_fileserv@cpp
	call	__CheckForDebuggerJustMyCode

; 49   : 	x64_cli();

	call	x64_cli

; 50   : 	AuThread* current_thr = AuGetCurrentThread();

	call	AuGetCurrentThread
	mov	QWORD PTR current_thr$[rbp], rax

; 51   : 	if (!current_thr)

	cmp	QWORD PTR current_thr$[rbp], 0
	jne	SHORT $LN2@OpenFile

; 52   : 		return -1;

	mov	eax, -1
	jmp	$LN1@OpenFile
$LN2@OpenFile:

; 53   : 	AuProcess* current_proc = AuProcessFindThread(current_thr);

	mov	rcx, QWORD PTR current_thr$[rbp]
	call	?AuProcessFindThread@@YAPEAU_au_proc_@@PEAU_au_thread_@@@Z ; AuProcessFindThread
	mov	QWORD PTR current_proc$[rbp], rax

; 54   : 	if (!current_proc) {

	cmp	QWORD PTR current_proc$[rbp], 0
	jne	SHORT $LN3@OpenFile

; 55   : 		current_proc = AuProcessFindSubThread(current_thr);

	mov	rcx, QWORD PTR current_thr$[rbp]
	call	?AuProcessFindSubThread@@YAPEAU_au_proc_@@PEAU_au_thread_@@@Z ; AuProcessFindSubThread
	mov	QWORD PTR current_proc$[rbp], rax

; 56   : 		if (!current_proc)

	cmp	QWORD PTR current_proc$[rbp], 0
	jne	SHORT $LN4@OpenFile

; 57   : 			return -1;

	mov	eax, -1
	jmp	$LN1@OpenFile
$LN4@OpenFile:
$LN3@OpenFile:

; 58   : 	}
; 59   : 
; 60   : 	AuVFSNode *fsys = AuVFSFind(filename);

	mov	rcx, QWORD PTR filename$[rbp]
	call	AuVFSFind
	mov	QWORD PTR fsys$[rbp], rax

; 61   : 	AuVFSNode* file = AuVFSOpen(filename);

	mov	rcx, QWORD PTR filename$[rbp]
	call	AuVFSOpen
	mov	QWORD PTR file$[rbp], rax

; 62   : 	if (!file) {

	cmp	QWORD PTR file$[rbp], 0
	jne	SHORT $LN5@OpenFile

; 63   : 		if (mode & FILE_OPEN_CREAT || mode & FILE_OPEN_WRITE) {

	mov	eax, DWORD PTR mode$[rbp]
	and	eax, 8
	test	eax, eax
	jne	SHORT $LN8@OpenFile
	mov	eax, DWORD PTR mode$[rbp]
	and	eax, 4
	test	eax, eax
	je	SHORT $LN6@OpenFile
$LN8@OpenFile:

; 64   : 			file = AuVFSCreateFile(fsys, filename);

	mov	rdx, QWORD PTR filename$[rbp]
	mov	rcx, QWORD PTR fsys$[rbp]
	call	AuVFSCreateFile
	mov	QWORD PTR file$[rbp], rax

; 65   : 		}

	jmp	SHORT $LN7@OpenFile
$LN6@OpenFile:

; 66   : 		else 
; 67   : 			return -1;

	mov	eax, -1
	jmp	SHORT $LN1@OpenFile
$LN7@OpenFile:
$LN5@OpenFile:

; 68   : 	}
; 69   : 
; 70   : 	/* check for last time, if any error occured */
; 71   : 	if (!file)

	cmp	QWORD PTR file$[rbp], 0
	jne	SHORT $LN9@OpenFile

; 72   : 		return -1;

	mov	eax, -1
	jmp	SHORT $LN1@OpenFile
$LN9@OpenFile:

; 73   : 
; 74   : 	int fd = AuProcessGetFileDesc(current_proc);

	mov	rcx, QWORD PTR current_proc$[rbp]
	call	?AuProcessGetFileDesc@@YAHPEAU_au_proc_@@@Z ; AuProcessGetFileDesc
	mov	DWORD PTR fd$[rbp], eax

; 75   : 	if (fd == -1)

	cmp	DWORD PTR fd$[rbp], -1
	jne	SHORT $LN10@OpenFile

; 76   : 		return -1;

	mov	eax, -1
	jmp	SHORT $LN1@OpenFile
$LN10@OpenFile:

; 77   : 
; 78   : 	/* just to increase the reference count */
; 79   : 	if (file->flags & FS_FLAG_PIPE)

	mov	rax, QWORD PTR file$[rbp]
	movzx	eax, WORD PTR [rax+61]
	and	eax, 128				; 00000080H
	test	eax, eax
	je	SHORT $LN11@OpenFile

; 80   : 		SeTextOut("Opening file -> %s \r\n", file->filename);

	mov	rax, QWORD PTR file$[rbp]
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:??_C@_0BG@NKGJFMOM@Opening?5file?5?9?$DO?5?$CFs?5?$AN?6@
	call	SeTextOut
$LN11@OpenFile:

; 81   : 		if (file->open)

	mov	rax, QWORD PTR file$[rbp]
	cmp	QWORD PTR [rax+74], 0
	je	SHORT $LN12@OpenFile

; 82   : 			file->open(file, NULL);

	xor	edx, edx
	mov	rcx, QWORD PTR file$[rbp]
	mov	rax, QWORD PTR file$[rbp]
	call	QWORD PTR [rax+74]
$LN12@OpenFile:

; 83   : 
; 84   : 	current_proc->fds[fd] = file;

	movsxd	rax, DWORD PTR fd$[rbp]
	mov	rcx, QWORD PTR current_proc$[rbp]
	mov	rdx, QWORD PTR file$[rbp]
	mov	QWORD PTR [rcx+rax*8+567], rdx

; 85   : 	return fd;

	mov	eax, DWORD PTR fd$[rbp]
$LN1@OpenFile:

; 86   : }

	lea	rsp, QWORD PTR [rbp+112]
	pop	rbp
	ret	0
?OpenFile@@YAHPEADH@Z ENDP				; OpenFile
_TEXT	ENDS
END
