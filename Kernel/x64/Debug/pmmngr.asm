; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30154.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?_FreeMemory@@3_KA				; _FreeMemory
PUBLIC	?_ReservedMemory@@3_KA				; _ReservedMemory
PUBLIC	?_UsedMemory@@3_KA				; _UsedMemory
PUBLIC	?_RamBitmapIndex@@3_KA				; _RamBitmapIndex
PUBLIC	?_TotalRam@@3_KA				; _TotalRam
PUBLIC	?_BitmapSize@@3_KA				; _BitmapSize
PUBLIC	?_HigherHalf@@3_NA				; _HigherHalf
PUBLIC	?RamBitmap@@3VBitmap@@A				; RamBitmap
_BSS	SEGMENT
?_FreeMemory@@3_KA DQ 01H DUP (?)			; _FreeMemory
?_ReservedMemory@@3_KA DQ 01H DUP (?)			; _ReservedMemory
?_UsedMemory@@3_KA DQ 01H DUP (?)			; _UsedMemory
?_RamBitmapIndex@@3_KA DQ 01H DUP (?)			; _RamBitmapIndex
?_TotalRam@@3_KA DQ 01H DUP (?)				; _TotalRam
?_BitmapSize@@3_KA DQ 01H DUP (?)			; _BitmapSize
?_HigherHalf@@3_NA DB 01H DUP (?)			; _HigherHalf
	ALIGN	4

?RamBitmap@@3VBitmap@@A DB 010H DUP (?)			; RamBitmap
_BSS	ENDS
msvcjmc	SEGMENT
__7CCE8FE9_pmmngr@cpp DB 01H
msvcjmc	ENDS
PUBLIC	?AuPmmngrInitialize@@YAXPEAU_KERNEL_BOOT_INFO_@@@Z ; AuPmmngrInitialize
PUBLIC	AuPmmngrAlloc
PUBLIC	AuPmmngrAllocBlocks
PUBLIC	AuPmmngrFree
PUBLIC	AuPmmngrFreeBlocks
PUBLIC	P2V
PUBLIC	V2P
PUBLIC	?AuPmmngrMoveHigher@@YAXXZ			; AuPmmngrMoveHigher
PUBLIC	?AuPmmngrGetFreeMem@@YA_KXZ			; AuPmmngrGetFreeMem
PUBLIC	?AuPmmngrGetTotalMem@@YA_KXZ			; AuPmmngrGetTotalMem
PUBLIC	??ABitmap@@QEAA_N_K@Z				; Bitmap::operator[]
PUBLIC	?Set@Bitmap@@QEAA_N_K_N@Z			; Bitmap::Set
PUBLIC	?AuPmmngrInitBitmap@@YAX_KPEAX@Z		; AuPmmngrInitBitmap
PUBLIC	?AuPmmngrLockPage@@YAX_K@Z			; AuPmmngrLockPage
PUBLIC	?AuPmmngrLockPages@@YAXPEAX_K@Z			; AuPmmngrLockPages
PUBLIC	?AuPmmngrUnreservePage@@YAXPEAX@Z		; AuPmmngrUnreservePage
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_0CK@FIICNEML@Kernel?5Panic?$CB?$CB?$CB?5No?5more?5physica@ ; `string'
EXTRN	x64_cli:PROC
EXTRN	AuTextOut:PROC
EXTRN	memset:PROC
EXTRN	memcpy:PROC
EXTRN	__CheckForDebuggerJustMyCode:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuPmmngrInitialize@@YAXPEAU_KERNEL_BOOT_INFO_@@@Z DD imagerel $LN20
	DD	imagerel $LN20+686
	DD	imagerel $unwind$?AuPmmngrInitialize@@YAXPEAU_KERNEL_BOOT_INFO_@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AuPmmngrAlloc DD imagerel $LN10
	DD	imagerel $LN10+167
	DD	imagerel $unwind$AuPmmngrAlloc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AuPmmngrAllocBlocks DD imagerel $LN6
	DD	imagerel $LN6+77
	DD	imagerel $unwind$AuPmmngrAllocBlocks
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AuPmmngrFree DD imagerel $LN6
	DD	imagerel $LN6+160
	DD	imagerel $unwind$AuPmmngrFree
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AuPmmngrFreeBlocks DD imagerel $LN6
	DD	imagerel $LN6+95
	DD	imagerel $unwind$AuPmmngrFreeBlocks
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$P2V DD	imagerel $LN5
	DD	imagerel $LN5+72
	DD	imagerel $unwind$P2V
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$V2P DD	imagerel $LN5
	DD	imagerel $LN5+72
	DD	imagerel $unwind$V2P
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuPmmngrMoveHigher@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+55
	DD	imagerel $unwind$?AuPmmngrMoveHigher@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuPmmngrGetFreeMem@@YA_KXZ DD imagerel $LN3
	DD	imagerel $LN3+36
	DD	imagerel $unwind$?AuPmmngrGetFreeMem@@YA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuPmmngrGetTotalMem@@YA_KXZ DD imagerel $LN3
	DD	imagerel $LN3+36
	DD	imagerel $unwind$?AuPmmngrGetTotalMem@@YA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??ABitmap@@QEAA_N_K@Z DD imagerel $LN5
	DD	imagerel $LN5+156
	DD	imagerel $unwind$??ABitmap@@QEAA_N_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Set@Bitmap@@QEAA_N_K_N@Z DD imagerel $LN5
	DD	imagerel $LN5+214
	DD	imagerel $unwind$?Set@Bitmap@@QEAA_N_K_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuPmmngrInitBitmap@@YAX_KPEAX@Z DD imagerel $LN6
	DD	imagerel $LN6+104
	DD	imagerel $unwind$?AuPmmngrInitBitmap@@YAX_KPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuPmmngrLockPage@@YAX_K@Z DD imagerel $LN5
	DD	imagerel $LN5+137
	DD	imagerel $unwind$?AuPmmngrLockPage@@YAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuPmmngrLockPages@@YAXPEAX_K@Z DD imagerel $LN6
	DD	imagerel $LN6+102
	DD	imagerel $unwind$?AuPmmngrLockPages@@YAXPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuPmmngrUnreservePage@@YAXPEAX@Z DD imagerel $LN6
	DD	imagerel $LN6+160
	DD	imagerel $unwind$?AuPmmngrUnreservePage@@YAXPEAX@Z
pdata	ENDS
;	COMDAT ??_C@_0CK@FIICNEML@Kernel?5Panic?$CB?$CB?$CB?5No?5more?5physica@
CONST	SEGMENT
??_C@_0CK@FIICNEML@Kernel?5Panic?$CB?$CB?$CB?5No?5more?5physica@ DB 'Kern'
	DB	'el Panic!!! No more physical memory ', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuPmmngrUnreservePage@@YAXPEAX@Z DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuPmmngrLockPages@@YAXPEAX_K@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuPmmngrLockPage@@YAX_K@Z DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuPmmngrInitBitmap@@YAX_KPEAX@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Set@Bitmap@@QEAA_N_K_N@Z DD 025031901H
	DD	0d2142319H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??ABitmap@@QEAA_N_K@Z DD 025031701H
	DD	0f2122317H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuPmmngrGetTotalMem@@YA_KXZ DD 025030b01H
	DD	0b206230bH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuPmmngrGetFreeMem@@YA_KXZ DD 025030b01H
	DD	0b206230bH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuPmmngrMoveHigher@@YAXXZ DD 025030b01H
	DD	0b206230bH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$V2P DD	025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$P2V DD	025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AuPmmngrFreeBlocks DD 025031301H
	DD	0d20e2313H
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AuPmmngrFree DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AuPmmngrAllocBlocks DD 025030e01H
	DD	0d209230eH
	DD	05005H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AuPmmngrAlloc DD 025030b01H
	DD	0b206230bH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuPmmngrInitialize@@YAXPEAU_KERNEL_BOOT_INFO_@@@Z DD 025041201H
	DD	010d2312H
	DD	05006001aH
xdata	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Mm\pmmngr.cpp
;	COMDAT ?AuPmmngrUnreservePage@@YAXPEAX@Z
_TEXT	SEGMENT
Index$ = 0
Address$ = 96
?AuPmmngrUnreservePage@@YAXPEAX@Z PROC			; AuPmmngrUnreservePage, COMDAT

; 126  : void AuPmmngrUnreservePage(void* Address) {

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__7CCE8FE9_pmmngr@cpp
	call	__CheckForDebuggerJustMyCode

; 127  : 	uint64_t Index = (uint64_t)Address / 4096;

	xor	edx, edx
	mov	rax, QWORD PTR Address$[rbp]
	mov	ecx, 4096				; 00001000H
	div	rcx
	mov	QWORD PTR Index$[rbp], rax

; 128  : 	if (RamBitmap[Index] == false) return;

	mov	rdx, QWORD PTR Index$[rbp]
	lea	rcx, OFFSET FLAT:?RamBitmap@@3VBitmap@@A ; RamBitmap
	call	??ABitmap@@QEAA_N_K@Z			; Bitmap::operator[]
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@AuPmmngrUn
	jmp	SHORT $LN1@AuPmmngrUn
$LN2@AuPmmngrUn:

; 129  : 	if (RamBitmap.Set(Index, false)) {

	xor	r8d, r8d
	mov	rdx, QWORD PTR Index$[rbp]
	lea	rcx, OFFSET FLAT:?RamBitmap@@3VBitmap@@A ; RamBitmap
	call	?Set@Bitmap@@QEAA_N_K_N@Z		; Bitmap::Set
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@AuPmmngrUn

; 130  : 		_FreeMemory++;

	mov	rax, QWORD PTR ?_FreeMemory@@3_KA	; _FreeMemory
	inc	rax
	mov	QWORD PTR ?_FreeMemory@@3_KA, rax	; _FreeMemory

; 131  : 		_ReservedMemory--;

	mov	rax, QWORD PTR ?_ReservedMemory@@3_KA	; _ReservedMemory
	dec	rax
	mov	QWORD PTR ?_ReservedMemory@@3_KA, rax	; _ReservedMemory

; 132  : 		if (_RamBitmapIndex > Index) _RamBitmapIndex = Index;

	mov	rax, QWORD PTR Index$[rbp]
	cmp	QWORD PTR ?_RamBitmapIndex@@3_KA, rax	; _RamBitmapIndex
	jbe	SHORT $LN4@AuPmmngrUn
	mov	rax, QWORD PTR Index$[rbp]
	mov	QWORD PTR ?_RamBitmapIndex@@3_KA, rax	; _RamBitmapIndex
$LN4@AuPmmngrUn:
$LN3@AuPmmngrUn:
$LN1@AuPmmngrUn:

; 133  : 	}
; 134  : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
?AuPmmngrUnreservePage@@YAXPEAX@Z ENDP			; AuPmmngrUnreservePage
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Mm\pmmngr.cpp
;	COMDAT ?AuPmmngrLockPages@@YAXPEAX_K@Z
_TEXT	SEGMENT
addr$ = 0
i$1 = 8
Address$ = 96
Size$ = 104
?AuPmmngrLockPages@@YAXPEAX_K@Z PROC			; AuPmmngrLockPages, COMDAT

; 116  : void AuPmmngrLockPages(void *Address, size_t Size) {

$LN6:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__7CCE8FE9_pmmngr@cpp
	call	__CheckForDebuggerJustMyCode

; 117  : 	uint64_t addr = (uint64_t)Address;

	mov	rax, QWORD PTR Address$[rbp]
	mov	QWORD PTR addr$[rbp], rax

; 118  : 	for (int i = 0; i < Size; i++)

	mov	DWORD PTR i$1[rbp], 0
	jmp	SHORT $LN4@AuPmmngrLo
$LN2@AuPmmngrLo:
	mov	eax, DWORD PTR i$1[rbp]
	inc	eax
	mov	DWORD PTR i$1[rbp], eax
$LN4@AuPmmngrLo:
	movsxd	rax, DWORD PTR i$1[rbp]
	cmp	rax, QWORD PTR Size$[rbp]
	jae	SHORT $LN3@AuPmmngrLo

; 119  : 		AuPmmngrLockPage(addr + i * 4096);

	imul	eax, DWORD PTR i$1[rbp], 4096		; 00001000H
	cdqe
	mov	rcx, QWORD PTR addr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	?AuPmmngrLockPage@@YAX_K@Z		; AuPmmngrLockPage
	jmp	SHORT $LN2@AuPmmngrLo
$LN3@AuPmmngrLo:

; 120  : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
?AuPmmngrLockPages@@YAXPEAX_K@Z ENDP			; AuPmmngrLockPages
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Mm\pmmngr.cpp
;	COMDAT ?AuPmmngrLockPage@@YAX_K@Z
_TEXT	SEGMENT
Index$ = 0
Address$ = 96
?AuPmmngrLockPage@@YAX_K@Z PROC				; AuPmmngrLockPage, COMDAT

; 102  : void AuPmmngrLockPage(uint64_t Address) {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__7CCE8FE9_pmmngr@cpp
	call	__CheckForDebuggerJustMyCode

; 103  : 	uint64_t Index = (Address / 4096);

	xor	edx, edx
	mov	rax, QWORD PTR Address$[rbp]
	mov	ecx, 4096				; 00001000H
	div	rcx
	mov	QWORD PTR Index$[rbp], rax

; 104  : 	if (RamBitmap[Index] == true) return;

	mov	rdx, QWORD PTR Index$[rbp]
	lea	rcx, OFFSET FLAT:?RamBitmap@@3VBitmap@@A ; RamBitmap
	call	??ABitmap@@QEAA_N_K@Z			; Bitmap::operator[]
	movzx	eax, al
	cmp	eax, 1
	jne	SHORT $LN2@AuPmmngrLo
	jmp	SHORT $LN1@AuPmmngrLo
$LN2@AuPmmngrLo:

; 105  : 	if (RamBitmap.Set(Index, true)) {

	mov	r8b, 1
	mov	rdx, QWORD PTR Index$[rbp]
	lea	rcx, OFFSET FLAT:?RamBitmap@@3VBitmap@@A ; RamBitmap
	call	?Set@Bitmap@@QEAA_N_K_N@Z		; Bitmap::Set
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@AuPmmngrLo

; 106  : 		_FreeMemory--;

	mov	rax, QWORD PTR ?_FreeMemory@@3_KA	; _FreeMemory
	dec	rax
	mov	QWORD PTR ?_FreeMemory@@3_KA, rax	; _FreeMemory

; 107  : 		_ReservedMemory++;

	mov	rax, QWORD PTR ?_ReservedMemory@@3_KA	; _ReservedMemory
	inc	rax
	mov	QWORD PTR ?_ReservedMemory@@3_KA, rax	; _ReservedMemory
$LN3@AuPmmngrLo:
$LN1@AuPmmngrLo:

; 108  : 	}
; 109  : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
?AuPmmngrLockPage@@YAX_K@Z ENDP				; AuPmmngrLockPage
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Mm\pmmngr.cpp
;	COMDAT ?AuPmmngrInitBitmap@@YAX_KPEAX@Z
_TEXT	SEGMENT
i$1 = 0
BitmapSize$ = 96
Buffer$ = 104
?AuPmmngrInitBitmap@@YAX_KPEAX@Z PROC			; AuPmmngrInitBitmap, COMDAT

; 89   : void AuPmmngrInitBitmap(size_t BitmapSize, void* Buffer) {

$LN6:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__7CCE8FE9_pmmngr@cpp
	call	__CheckForDebuggerJustMyCode

; 90   : 	RamBitmap.Size = BitmapSize;

	mov	rax, QWORD PTR BitmapSize$[rbp]
	mov	QWORD PTR ?RamBitmap@@3VBitmap@@A, rax

; 91   : 	RamBitmap.Buffer = (uint8_t*)Buffer;

	mov	rax, QWORD PTR Buffer$[rbp]
	mov	QWORD PTR ?RamBitmap@@3VBitmap@@A+8, rax

; 92   : 
; 93   : 	for (int i = 0; i < BitmapSize; i++)

	mov	DWORD PTR i$1[rbp], 0
	jmp	SHORT $LN4@AuPmmngrIn
$LN2@AuPmmngrIn:
	mov	eax, DWORD PTR i$1[rbp]
	inc	eax
	mov	DWORD PTR i$1[rbp], eax
$LN4@AuPmmngrIn:
	movsxd	rax, DWORD PTR i$1[rbp]
	cmp	rax, QWORD PTR BitmapSize$[rbp]
	jae	SHORT $LN3@AuPmmngrIn

; 94   : 		*(uint8_t*)(RamBitmap.Buffer + i) = 0;

	movsxd	rax, DWORD PTR i$1[rbp]
	mov	rcx, QWORD PTR ?RamBitmap@@3VBitmap@@A+8
	mov	BYTE PTR [rcx+rax], 0
	jmp	SHORT $LN2@AuPmmngrIn
$LN3@AuPmmngrIn:

; 95   : 
; 96   : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
?AuPmmngrInitBitmap@@YAX_KPEAX@Z ENDP			; AuPmmngrInitBitmap
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Mm\pmmngr.cpp
;	COMDAT ?Set@Bitmap@@QEAA_N_K_N@Z
_TEXT	SEGMENT
ByteIndex$ = 0
BitIndex$ = 8
BitIndexer$ = 9
tv146 = 76
this$ = 96
index$ = 104
value$ = 112
?Set@Bitmap@@QEAA_N_K_N@Z PROC				; Bitmap::Set, COMDAT

; 67   : 	bool Set(uint64_t index, bool value) {

$LN5:
	mov	BYTE PTR [rsp+24], r8b
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__7CCE8FE9_pmmngr@cpp
	call	__CheckForDebuggerJustMyCode

; 68   : 		if (index > Size * 8) return false;

	mov	rax, QWORD PTR this$[rbp]
	mov	rax, QWORD PTR [rax]
	shl	rax, 3
	cmp	QWORD PTR index$[rbp], rax
	jbe	SHORT $LN2@Set
	xor	al, al
	jmp	$LN1@Set
$LN2@Set:

; 69   : 		uint64_t ByteIndex = index / 8;

	xor	edx, edx
	mov	rax, QWORD PTR index$[rbp]
	mov	ecx, 8
	div	rcx
	mov	QWORD PTR ByteIndex$[rbp], rax

; 70   : 		uint8_t BitIndex = index % 8;

	xor	edx, edx
	mov	rax, QWORD PTR index$[rbp]
	mov	ecx, 8
	div	rcx
	mov	rax, rdx
	mov	BYTE PTR BitIndex$[rbp], al

; 71   : 		uint8_t BitIndexer = 0x80 >> BitIndex;

	movzx	eax, BYTE PTR BitIndex$[rbp]
	mov	ecx, 128				; 00000080H
	mov	DWORD PTR tv146[rbp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv146[rbp]
	sar	eax, cl
	mov	BYTE PTR BitIndexer$[rbp], al

; 72   : 
; 73   : 		Buffer[ByteIndex] &= ~BitIndexer;

	mov	rax, QWORD PTR this$[rbp]
	mov	rax, QWORD PTR [rax+8]
	movzx	ecx, BYTE PTR BitIndexer$[rbp]
	not	ecx
	mov	rdx, QWORD PTR ByteIndex$[rbp]
	movzx	eax, BYTE PTR [rax+rdx]
	and	eax, ecx
	mov	rcx, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	rdx, QWORD PTR ByteIndex$[rbp]
	mov	BYTE PTR [rcx+rdx], al

; 74   : 		if (value)

	movzx	eax, BYTE PTR value$[rbp]
	test	eax, eax
	je	SHORT $LN3@Set

; 75   : 			Buffer[ByteIndex] |= BitIndexer;

	mov	rax, QWORD PTR this$[rbp]
	mov	rax, QWORD PTR [rax+8]
	movzx	ecx, BYTE PTR BitIndexer$[rbp]
	mov	rdx, QWORD PTR ByteIndex$[rbp]
	movzx	eax, BYTE PTR [rax+rdx]
	or	eax, ecx
	mov	rcx, QWORD PTR this$[rbp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	rdx, QWORD PTR ByteIndex$[rbp]
	mov	BYTE PTR [rcx+rdx], al
$LN3@Set:

; 76   : 
; 77   : 		return true;

	mov	al, 1
$LN1@Set:

; 78   : 	}

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
?Set@Bitmap@@QEAA_N_K_N@Z ENDP				; Bitmap::Set
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Mm\pmmngr.cpp
;	COMDAT ??ABitmap@@QEAA_N_K@Z
_TEXT	SEGMENT
ByteIndex$ = 0
BitIndex$ = 8
BitIndexer$ = 16
tv93 = 84
this$ = 112
index$ = 120
??ABitmap@@QEAA_N_K@Z PROC				; Bitmap::operator[], COMDAT

; 54   : 	bool operator[] (uint64_t index) {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 128				; 00000080H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__7CCE8FE9_pmmngr@cpp
	call	__CheckForDebuggerJustMyCode

; 55   : 		if (index > Size * 8) return false;

	mov	rax, QWORD PTR this$[rbp]
	mov	rax, QWORD PTR [rax]
	shl	rax, 3
	cmp	QWORD PTR index$[rbp], rax
	jbe	SHORT $LN2@operator
	xor	al, al
	jmp	SHORT $LN1@operator
$LN2@operator:

; 56   : 		uint64_t ByteIndex = index / 8;

	xor	edx, edx
	mov	rax, QWORD PTR index$[rbp]
	mov	ecx, 8
	div	rcx
	mov	QWORD PTR ByteIndex$[rbp], rax

; 57   : 		uint64_t BitIndex = index % 8;

	xor	edx, edx
	mov	rax, QWORD PTR index$[rbp]
	mov	ecx, 8
	div	rcx
	mov	rax, rdx
	mov	QWORD PTR BitIndex$[rbp], rax

; 58   : 		uint8_t BitIndexer = 0x80 >> BitIndex;

	mov	rax, QWORD PTR BitIndex$[rbp]
	mov	ecx, 128				; 00000080H
	mov	DWORD PTR tv93[rbp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv93[rbp]
	sar	eax, cl
	mov	BYTE PTR BitIndexer$[rbp], al

; 59   : 
; 60   : 		if ((Buffer[ByteIndex] & BitIndexer) > 0) {

	mov	rax, QWORD PTR this$[rbp]
	mov	rax, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR ByteIndex$[rbp]
	movzx	eax, BYTE PTR [rax+rcx]
	movzx	ecx, BYTE PTR BitIndexer$[rbp]
	and	eax, ecx
	test	eax, eax
	jle	SHORT $LN3@operator

; 61   : 			return true;

	mov	al, 1
	jmp	SHORT $LN1@operator
$LN3@operator:

; 62   : 		}
; 63   : 
; 64   : 		return false;

	xor	al, al
$LN1@operator:

; 65   : 	}

	lea	rsp, QWORD PTR [rbp+96]
	pop	rbp
	ret	0
??ABitmap@@QEAA_N_K@Z ENDP				; Bitmap::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Mm\pmmngr.cpp
;	COMDAT ?AuPmmngrGetTotalMem@@YA_KXZ
_TEXT	SEGMENT
?AuPmmngrGetTotalMem@@YA_KXZ PROC			; AuPmmngrGetTotalMem, COMDAT

; 307  : uint64_t AuPmmngrGetTotalMem() {

$LN3:
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__7CCE8FE9_pmmngr@cpp
	call	__CheckForDebuggerJustMyCode

; 308  : 	return _TotalRam;

	mov	rax, QWORD PTR ?_TotalRam@@3_KA		; _TotalRam

; 309  : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
?AuPmmngrGetTotalMem@@YA_KXZ ENDP			; AuPmmngrGetTotalMem
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Mm\pmmngr.cpp
;	COMDAT ?AuPmmngrGetFreeMem@@YA_KXZ
_TEXT	SEGMENT
?AuPmmngrGetFreeMem@@YA_KXZ PROC			; AuPmmngrGetFreeMem, COMDAT

; 299  : uint64_t AuPmmngrGetFreeMem() {

$LN3:
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__7CCE8FE9_pmmngr@cpp
	call	__CheckForDebuggerJustMyCode

; 300  : 	return _FreeMemory;

	mov	rax, QWORD PTR ?_FreeMemory@@3_KA	; _FreeMemory

; 301  : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
?AuPmmngrGetFreeMem@@YA_KXZ ENDP			; AuPmmngrGetFreeMem
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Mm\pmmngr.cpp
;	COMDAT ?AuPmmngrMoveHigher@@YAXXZ
_TEXT	SEGMENT
?AuPmmngrMoveHigher@@YAXXZ PROC				; AuPmmngrMoveHigher, COMDAT

; 290  : void AuPmmngrMoveHigher() {

$LN3:
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__7CCE8FE9_pmmngr@cpp
	call	__CheckForDebuggerJustMyCode

; 291  : 	_HigherHalf = true;

	mov	BYTE PTR ?_HigherHalf@@3_NA, 1		; _HigherHalf

; 292  : 	RamBitmap.Buffer = (uint8_t*)P2V((uint64_t)RamBitmap.Buffer);

	mov	rcx, QWORD PTR ?RamBitmap@@3VBitmap@@A+8
	call	P2V
	mov	QWORD PTR ?RamBitmap@@3VBitmap@@A+8, rax

; 293  : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
?AuPmmngrMoveHigher@@YAXXZ ENDP				; AuPmmngrMoveHigher
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Mm\pmmngr.cpp
;	COMDAT V2P
_TEXT	SEGMENT
vaddr$ = 80
V2P	PROC						; COMDAT

; 279  : uint64_t V2P(uint64_t vaddr) {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__7CCE8FE9_pmmngr@cpp
	call	__CheckForDebuggerJustMyCode

; 280  : 	if (_HigherHalf)

	movzx	eax, BYTE PTR ?_HigherHalf@@3_NA	; _HigherHalf
	test	eax, eax
	je	SHORT $LN2@V2P

; 281  : 		return (vaddr - PHYSICAL_MEM_BASE);

	mov	rax, 140737488355328			; 0000800000000000H
	mov	rcx, QWORD PTR vaddr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	jmp	SHORT $LN1@V2P
	jmp	SHORT $LN3@V2P
$LN2@V2P:

; 282  : 	else
; 283  : 		return vaddr;

	mov	rax, QWORD PTR vaddr$[rbp]
$LN3@V2P:
$LN1@V2P:

; 284  : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
V2P	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Mm\pmmngr.cpp
;	COMDAT P2V
_TEXT	SEGMENT
addr$ = 80
P2V	PROC						; COMDAT

; 268  : uint64_t P2V(uint64_t addr) {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__7CCE8FE9_pmmngr@cpp
	call	__CheckForDebuggerJustMyCode

; 269  : 	if (_HigherHalf)

	movzx	eax, BYTE PTR ?_HigherHalf@@3_NA	; _HigherHalf
	test	eax, eax
	je	SHORT $LN2@P2V

; 270  : 		return (PHYSICAL_MEM_BASE + addr);

	mov	rax, 140737488355328			; 0000800000000000H
	mov	rcx, QWORD PTR addr$[rbp]
	sub	rcx, rax
	mov	rax, rcx
	jmp	SHORT $LN1@P2V
	jmp	SHORT $LN3@P2V
$LN2@P2V:

; 271  : 	else
; 272  : 		return addr;

	mov	rax, QWORD PTR addr$[rbp]
$LN3@P2V:
$LN1@P2V:

; 273  : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
P2V	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Mm\pmmngr.cpp
;	COMDAT AuPmmngrFreeBlocks
_TEXT	SEGMENT
Address$ = 0
i$1 = 8
Addr$ = 96
Count$ = 104
AuPmmngrFreeBlocks PROC					; COMDAT

; 256  : void AuPmmngrFreeBlocks(void* Addr, int Count) {

$LN6:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__7CCE8FE9_pmmngr@cpp
	call	__CheckForDebuggerJustMyCode

; 257  : 	uint64_t Address = (uint64_t)Addr;

	mov	rax, QWORD PTR Addr$[rbp]
	mov	QWORD PTR Address$[rbp], rax

; 258  : 	for (uint32_t i = 0; i < Count; i++) {

	mov	DWORD PTR i$1[rbp], 0
	jmp	SHORT $LN4@AuPmmngrFr
$LN2@AuPmmngrFr:
	mov	eax, DWORD PTR i$1[rbp]
	inc	eax
	mov	DWORD PTR i$1[rbp], eax
$LN4@AuPmmngrFr:
	mov	eax, DWORD PTR Count$[rbp]
	cmp	DWORD PTR i$1[rbp], eax
	jae	SHORT $LN3@AuPmmngrFr

; 259  : 		AuPmmngrFree((void*)Address);

	mov	rcx, QWORD PTR Address$[rbp]
	call	AuPmmngrFree

; 260  : 		Address += 0x1000;

	mov	rax, QWORD PTR Address$[rbp]
	add	rax, 4096				; 00001000H
	mov	QWORD PTR Address$[rbp], rax

; 261  : 	}

	jmp	SHORT $LN2@AuPmmngrFr
$LN3@AuPmmngrFr:

; 262  : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
AuPmmngrFreeBlocks ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Mm\pmmngr.cpp
;	COMDAT AuPmmngrFree
_TEXT	SEGMENT
Index$ = 0
Address$ = 96
AuPmmngrFree PROC					; COMDAT

; 239  : void AuPmmngrFree(void* Address) {

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__7CCE8FE9_pmmngr@cpp
	call	__CheckForDebuggerJustMyCode

; 240  : 	//uint64_t ShiftAddr = (uint64_t)Address >> PAGE_SHIFT;
; 241  : 	uint64_t Index = (uint64_t)Address / 4096;

	xor	edx, edx
	mov	rax, QWORD PTR Address$[rbp]
	mov	ecx, 4096				; 00001000H
	div	rcx
	mov	QWORD PTR Index$[rbp], rax

; 242  : 	if (RamBitmap[Index] == false) return;

	mov	rdx, QWORD PTR Index$[rbp]
	lea	rcx, OFFSET FLAT:?RamBitmap@@3VBitmap@@A ; RamBitmap
	call	??ABitmap@@QEAA_N_K@Z			; Bitmap::operator[]
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@AuPmmngrFr
	jmp	SHORT $LN1@AuPmmngrFr
$LN2@AuPmmngrFr:

; 243  : 	if (RamBitmap.Set(Index, false)) {

	xor	r8d, r8d
	mov	rdx, QWORD PTR Index$[rbp]
	lea	rcx, OFFSET FLAT:?RamBitmap@@3VBitmap@@A ; RamBitmap
	call	?Set@Bitmap@@QEAA_N_K_N@Z		; Bitmap::Set
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@AuPmmngrFr

; 244  : 		_FreeMemory++;

	mov	rax, QWORD PTR ?_FreeMemory@@3_KA	; _FreeMemory
	inc	rax
	mov	QWORD PTR ?_FreeMemory@@3_KA, rax	; _FreeMemory

; 245  : 		_UsedMemory--;

	mov	rax, QWORD PTR ?_UsedMemory@@3_KA	; _UsedMemory
	dec	rax
	mov	QWORD PTR ?_UsedMemory@@3_KA, rax	; _UsedMemory

; 246  : 		if (_RamBitmapIndex > Index)

	mov	rax, QWORD PTR Index$[rbp]
	cmp	QWORD PTR ?_RamBitmapIndex@@3_KA, rax	; _RamBitmapIndex
	jbe	SHORT $LN4@AuPmmngrFr

; 247  : 			_RamBitmapIndex = Index;

	mov	rax, QWORD PTR Index$[rbp]
	mov	QWORD PTR ?_RamBitmapIndex@@3_KA, rax	; _RamBitmapIndex
$LN4@AuPmmngrFr:
$LN3@AuPmmngrFr:
$LN1@AuPmmngrFr:

; 248  : 	}
; 249  : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
AuPmmngrFree ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Mm\pmmngr.cpp
;	COMDAT AuPmmngrAllocBlocks
_TEXT	SEGMENT
First$ = 0
i$1 = 8
num$ = 96
AuPmmngrAllocBlocks PROC				; COMDAT

; 227  : void* AuPmmngrAllocBlocks(int num) {

$LN6:
	mov	DWORD PTR [rsp+8], ecx
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__7CCE8FE9_pmmngr@cpp
	call	__CheckForDebuggerJustMyCode

; 228  : 	void* First = AuPmmngrAlloc();

	call	AuPmmngrAlloc
	mov	QWORD PTR First$[rbp], rax

; 229  : 	for (int i = 1; i < num; i++)

	mov	DWORD PTR i$1[rbp], 1
	jmp	SHORT $LN4@AuPmmngrAl
$LN2@AuPmmngrAl:
	mov	eax, DWORD PTR i$1[rbp]
	inc	eax
	mov	DWORD PTR i$1[rbp], eax
$LN4@AuPmmngrAl:
	mov	eax, DWORD PTR num$[rbp]
	cmp	DWORD PTR i$1[rbp], eax
	jge	SHORT $LN3@AuPmmngrAl

; 230  : 		AuPmmngrAlloc();

	call	AuPmmngrAlloc
	jmp	SHORT $LN2@AuPmmngrAl
$LN3@AuPmmngrAl:

; 231  : 
; 232  : 	return First;

	mov	rax, QWORD PTR First$[rbp]

; 233  : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
AuPmmngrAllocBlocks ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Mm\pmmngr.cpp
;	COMDAT AuPmmngrAlloc
_TEXT	SEGMENT
AuPmmngrAlloc PROC					; COMDAT

; 209  : void* AuPmmngrAlloc() {

$LN10:
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__7CCE8FE9_pmmngr@cpp
	call	__CheckForDebuggerJustMyCode

; 210  : 	for (; _RamBitmapIndex < RamBitmap.Size * 8; _RamBitmapIndex++) {

	jmp	SHORT $LN4@AuPmmngrAl
$LN2@AuPmmngrAl:
	mov	rax, QWORD PTR ?_RamBitmapIndex@@3_KA	; _RamBitmapIndex
	inc	rax
	mov	QWORD PTR ?_RamBitmapIndex@@3_KA, rax	; _RamBitmapIndex
$LN4@AuPmmngrAl:
	mov	rax, QWORD PTR ?RamBitmap@@3VBitmap@@A
	shl	rax, 3
	cmp	QWORD PTR ?_RamBitmapIndex@@3_KA, rax	; _RamBitmapIndex
	jae	SHORT $LN3@AuPmmngrAl

; 211  : 		if (RamBitmap[_RamBitmapIndex] == true) continue;

	mov	rdx, QWORD PTR ?_RamBitmapIndex@@3_KA	; _RamBitmapIndex
	lea	rcx, OFFSET FLAT:?RamBitmap@@3VBitmap@@A ; RamBitmap
	call	??ABitmap@@QEAA_N_K@Z			; Bitmap::operator[]
	movzx	eax, al
	cmp	eax, 1
	jne	SHORT $LN8@AuPmmngrAl
	jmp	SHORT $LN2@AuPmmngrAl
$LN8@AuPmmngrAl:

; 212  : 		AuPmmngrLockPage(_RamBitmapIndex * 4096);

	imul	rax, QWORD PTR ?_RamBitmapIndex@@3_KA, 4096 ; _RamBitmapIndex, 00001000H
	mov	rcx, rax
	call	?AuPmmngrLockPage@@YAX_K@Z		; AuPmmngrLockPage

; 213  : 		_UsedMemory++;

	mov	rax, QWORD PTR ?_UsedMemory@@3_KA	; _UsedMemory
	inc	rax
	mov	QWORD PTR ?_UsedMemory@@3_KA, rax	; _UsedMemory

; 214  : 		return (void*)(_RamBitmapIndex * 4096);

	imul	rax, QWORD PTR ?_RamBitmapIndex@@3_KA, 4096 ; _RamBitmapIndex, 00001000H
	jmp	SHORT $LN1@AuPmmngrAl

; 215  : 	}

	jmp	SHORT $LN2@AuPmmngrAl
$LN3@AuPmmngrAl:

; 216  : 
; 217  : 	x64_cli();

	call	x64_cli

; 218  : 	AuTextOut("Kernel Panic!!! No more physical memory \n");

	lea	rcx, OFFSET FLAT:??_C@_0CK@FIICNEML@Kernel?5Panic?$CB?$CB?$CB?5No?5more?5physica@
	call	AuTextOut
$LN5@AuPmmngrAl:

; 219  : 	for (;;);

	jmp	SHORT $LN5@AuPmmngrAl
$LN1@AuPmmngrAl:

; 220  : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
AuPmmngrAlloc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Mm\pmmngr.cpp
;	COMDAT ?AuPmmngrInitialize@@YAXPEAU_KERNEL_BOOT_INFO_@@@Z
_TEXT	SEGMENT
MemMapEntries$ = 0
BitmapArea$ = 8
i$1 = 16
EfiMem$2 = 24
BitmapSize$ = 32
i$3 = 40
EfiMem$4 = 48
PhysStart$5 = 56
j$6 = 64
i$7 = 72
AllocCount$ = 80
AllocStack$ = 88
Address$8 = 96
SMPAddress$ = 104
info$ = 192
?AuPmmngrInitialize@@YAXPEAU_KERNEL_BOOT_INFO_@@@Z PROC	; AuPmmngrInitialize, COMDAT

; 141  : void AuPmmngrInitialize(KERNEL_BOOT_INFO *info) {

$LN20:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 208				; 000000d0H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__7CCE8FE9_pmmngr@cpp
	call	__CheckForDebuggerJustMyCode

; 142  : 
; 143  : 	_FreeMemory = 0;

	mov	QWORD PTR ?_FreeMemory@@3_KA, 0		; _FreeMemory

; 144  : 	_BitmapSize = 0;

	mov	QWORD PTR ?_BitmapSize@@3_KA, 0		; _BitmapSize

; 145  : 	_TotalRam = 0;

	mov	QWORD PTR ?_TotalRam@@3_KA, 0		; _TotalRam

; 146  : 	_RamBitmapIndex = 0;

	mov	QWORD PTR ?_RamBitmapIndex@@3_KA, 0	; _RamBitmapIndex

; 147  : 
; 148  : 	uint64_t MemMapEntries = info->mem_map_size / info->descriptor_size;

	xor	edx, edx
	mov	rax, QWORD PTR info$[rbp]
	mov	rax, QWORD PTR [rax+36]
	mov	rcx, QWORD PTR info$[rbp]
	div	QWORD PTR [rcx+28]
	mov	QWORD PTR MemMapEntries$[rbp], rax

; 149  : 	void* BitmapArea = 0;

	mov	QWORD PTR BitmapArea$[rbp], 0

; 150  : 	/* Scan a suitable area for the bitmap */
; 151  : 	for (size_t i = 0; i < MemMapEntries; i++) {

	mov	QWORD PTR i$1[rbp], 0
	jmp	SHORT $LN4@AuPmmngrIn
$LN2@AuPmmngrIn:
	mov	rax, QWORD PTR i$1[rbp]
	inc	rax
	mov	QWORD PTR i$1[rbp], rax
$LN4@AuPmmngrIn:
	mov	rax, QWORD PTR MemMapEntries$[rbp]
	cmp	QWORD PTR i$1[rbp], rax
	jae	SHORT $LN3@AuPmmngrIn

; 152  : 		EFI_MEMORY_DESCRIPTOR *EfiMem = (EFI_MEMORY_DESCRIPTOR*)((uint64_t)info->map + i * info->descriptor_size);

	mov	rax, QWORD PTR info$[rbp]
	mov	rcx, QWORD PTR i$1[rbp]
	imul	rcx, QWORD PTR [rax+28]
	mov	rax, rcx
	mov	rcx, QWORD PTR info$[rbp]
	add	rax, QWORD PTR [rcx+20]
	mov	QWORD PTR EfiMem$2[rbp], rax

; 153  : 		_TotalRam += EfiMem->num_pages;

	mov	rax, QWORD PTR EfiMem$2[rbp]
	mov	rax, QWORD PTR [rax+24]
	mov	rcx, QWORD PTR ?_TotalRam@@3_KA		; _TotalRam
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR ?_TotalRam@@3_KA, rax		; _TotalRam

; 154  : 		if (EfiMem->type == 7)  {

	mov	rax, QWORD PTR EfiMem$2[rbp]
	cmp	DWORD PTR [rax], 7
	jne	SHORT $LN16@AuPmmngrIn

; 155  : 			if (((EfiMem->num_pages * 4096) > 0x100000) && BitmapArea == 0)  {

	mov	rax, QWORD PTR EfiMem$2[rbp]
	imul	rax, QWORD PTR [rax+24], 4096		; 00001000H
	cmp	rax, 1048576				; 00100000H
	jbe	SHORT $LN17@AuPmmngrIn
	cmp	QWORD PTR BitmapArea$[rbp], 0
	jne	SHORT $LN17@AuPmmngrIn

; 156  : 				BitmapArea = (void*)EfiMem->phys_start;

	mov	rax, QWORD PTR EfiMem$2[rbp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR BitmapArea$[rbp], rax
$LN17@AuPmmngrIn:
$LN16@AuPmmngrIn:

; 157  : 			}
; 158  : 		}
; 159  : 	}

	jmp	$LN2@AuPmmngrIn
$LN3@AuPmmngrIn:

; 160  : 
; 161  : 	_FreeMemory = _TotalRam;

	mov	rax, QWORD PTR ?_TotalRam@@3_KA		; _TotalRam
	mov	QWORD PTR ?_FreeMemory@@3_KA, rax	; _FreeMemory

; 162  : 	uint64_t BitmapSize = (_TotalRam * 4096) / 4096 / 8 + 1;

	imul	rax, QWORD PTR ?_TotalRam@@3_KA, 4096	; _TotalRam, 00001000H
	xor	edx, edx
	mov	ecx, 4096				; 00001000H
	div	rcx
	xor	edx, edx
	mov	ecx, 8
	div	rcx
	inc	rax
	mov	QWORD PTR BitmapSize$[rbp], rax

; 163  : 
; 164  : 	/* now initialise the bitmap */
; 165  : 	AuPmmngrInitBitmap(BitmapSize, BitmapArea);

	mov	rdx, QWORD PTR BitmapArea$[rbp]
	mov	rcx, QWORD PTR BitmapSize$[rbp]
	call	?AuPmmngrInitBitmap@@YAX_KPEAX@Z	; AuPmmngrInitBitmap

; 166  : 
; 167  : 	AuPmmngrLockPages((void*)BitmapArea, BitmapSize);

	mov	rdx, QWORD PTR BitmapSize$[rbp]
	mov	rcx, QWORD PTR BitmapArea$[rbp]
	call	?AuPmmngrLockPages@@YAXPEAX_K@Z		; AuPmmngrLockPages

; 168  : 
; 169  : 	for (size_t i = 0; i < MemMapEntries; i++) {

	mov	QWORD PTR i$3[rbp], 0
	jmp	SHORT $LN7@AuPmmngrIn
$LN5@AuPmmngrIn:
	mov	rax, QWORD PTR i$3[rbp]
	inc	rax
	mov	QWORD PTR i$3[rbp], rax
$LN7@AuPmmngrIn:
	mov	rax, QWORD PTR MemMapEntries$[rbp]
	cmp	QWORD PTR i$3[rbp], rax
	jae	SHORT $LN6@AuPmmngrIn

; 170  : 		EFI_MEMORY_DESCRIPTOR *EfiMem = (EFI_MEMORY_DESCRIPTOR*)((uint64_t)info->map + i * info->descriptor_size);

	mov	rax, QWORD PTR info$[rbp]
	mov	rcx, QWORD PTR i$3[rbp]
	imul	rcx, QWORD PTR [rax+28]
	mov	rax, rcx
	mov	rcx, QWORD PTR info$[rbp]
	add	rax, QWORD PTR [rcx+20]
	mov	QWORD PTR EfiMem$4[rbp], rax

; 171  : 		//_TotalRam += EfiMem->num_pages;
; 172  : 		if (EfiMem->type != 7) {

	mov	rax, QWORD PTR EfiMem$4[rbp]
	cmp	DWORD PTR [rax], 7
	je	SHORT $LN18@AuPmmngrIn

; 173  : 			uint64_t PhysStart = EfiMem->phys_start;

	mov	rax, QWORD PTR EfiMem$4[rbp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR PhysStart$5[rbp], rax

; 174  : 			for (size_t j = 0; j < EfiMem->num_pages; j++){

	mov	QWORD PTR j$6[rbp], 0
	jmp	SHORT $LN10@AuPmmngrIn
$LN8@AuPmmngrIn:
	mov	rax, QWORD PTR j$6[rbp]
	inc	rax
	mov	QWORD PTR j$6[rbp], rax
$LN10@AuPmmngrIn:
	mov	rax, QWORD PTR EfiMem$4[rbp]
	mov	rax, QWORD PTR [rax+24]
	cmp	QWORD PTR j$6[rbp], rax
	jae	SHORT $LN9@AuPmmngrIn

; 175  : 				AuPmmngrLockPage(PhysStart + j * 4096);

	imul	rax, QWORD PTR j$6[rbp], 4096		; 00001000H
	mov	rcx, QWORD PTR PhysStart$5[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	?AuPmmngrLockPage@@YAX_K@Z		; AuPmmngrLockPage

; 176  : 			}

	jmp	SHORT $LN8@AuPmmngrIn
$LN9@AuPmmngrIn:
$LN18@AuPmmngrIn:

; 177  : 		}
; 178  : 	}

	jmp	$LN5@AuPmmngrIn
$LN6@AuPmmngrIn:

; 179  : 
; 180  : 
; 181  : 	/* Lock addresses below 1MiB mark */
; 182  : 	for (size_t i = 0; i < (1 * 1024 * 1024)/ 4096; i++)

	mov	QWORD PTR i$7[rbp], 0
	jmp	SHORT $LN13@AuPmmngrIn
$LN11@AuPmmngrIn:
	mov	rax, QWORD PTR i$7[rbp]
	inc	rax
	mov	QWORD PTR i$7[rbp], rax
$LN13@AuPmmngrIn:
	cmp	QWORD PTR i$7[rbp], 256			; 00000100H
	jae	SHORT $LN12@AuPmmngrIn

; 183  : 		AuPmmngrLockPage(i * 4096);

	imul	rax, QWORD PTR i$7[rbp], 4096		; 00001000H
	mov	rcx, rax
	call	?AuPmmngrLockPage@@YAX_K@Z		; AuPmmngrLockPage
	jmp	SHORT $LN11@AuPmmngrIn
$LN12@AuPmmngrIn:

; 184  : 
; 185  : 	uint32_t AllocCount = info->reserved_mem_count;

	mov	rax, QWORD PTR info$[rbp]
	mov	eax, DWORD PTR [rax+12]
	mov	DWORD PTR AllocCount$[rbp], eax

; 186  : 	uint64_t* AllocStack = (uint64_t*)info->allocated_stack;

	mov	rax, QWORD PTR info$[rbp]
	mov	rax, QWORD PTR [rax+4]
	mov	QWORD PTR AllocStack$[rbp], rax
$LN14@AuPmmngrIn:

; 187  : 	while (AllocCount) {

	cmp	DWORD PTR AllocCount$[rbp], 0
	je	SHORT $LN15@AuPmmngrIn

; 188  : 		uint64_t Address = *AllocStack--;

	mov	rax, QWORD PTR AllocStack$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR Address$8[rbp], rax
	mov	rax, QWORD PTR AllocStack$[rbp]
	sub	rax, 8
	mov	QWORD PTR AllocStack$[rbp], rax

; 189  : 		AuPmmngrLockPage(Address);

	mov	rcx, QWORD PTR Address$8[rbp]
	call	?AuPmmngrLockPage@@YAX_K@Z		; AuPmmngrLockPage

; 190  : 		AllocCount--;

	mov	eax, DWORD PTR AllocCount$[rbp]
	dec	eax
	mov	DWORD PTR AllocCount$[rbp], eax

; 191  : 	}

	jmp	SHORT $LN14@AuPmmngrIn
$LN15@AuPmmngrIn:

; 192  : 
; 193  : 	/* Copy the SMP Code and mark that address
; 194  : 	* as unusable, [no doubt: this address is already
; 195  : 	* marked unusable above
; 196  : 	*/
; 197  : 	uint64_t* SMPAddress = (uint64_t*)0xA000;

	mov	QWORD PTR SMPAddress$[rbp], 40960	; 0000a000H

; 198  : 	AuPmmngrLockPage(0xA000);

	mov	ecx, 40960				; 0000a000H
	call	?AuPmmngrLockPage@@YAX_K@Z		; AuPmmngrLockPage

; 199  : 	memset(SMPAddress, 0, 4096);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR SMPAddress$[rbp]
	call	memset

; 200  : 	memcpy(SMPAddress, info->apcode, 4096);

	mov	r8d, 4096				; 00001000H
	mov	rax, QWORD PTR info$[rbp]
	mov	rdx, QWORD PTR [rax+162]
	mov	rcx, QWORD PTR SMPAddress$[rbp]
	call	memcpy

; 201  : 
; 202  : 
; 203  : }

	lea	rsp, QWORD PTR [rbp+176]
	pop	rbp
	ret	0
?AuPmmngrInitialize@@YAXPEAU_KERNEL_BOOT_INFO_@@@Z ENDP	; AuPmmngrInitialize
_TEXT	ENDS
END
