; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30154.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

msvcjmc	SEGMENT
__10BE5BC2_ahcidsk@cpp DB 01H
msvcjmc	ENDS
PUBLIC	?AuAHCIDiskInitialise@@YAXPEAU_hba_port_@@@Z	; AuAHCIDiskInitialise
PUBLIC	?AuAHCIStopCmd@@YAXPEAU_hba_port_@@@Z		; AuAHCIStopCmd
PUBLIC	?AuAHCIStartCmd@@YAXPEAU_hba_port_@@@Z		; AuAHCIStartCmd
PUBLIC	?AuAHCIDiskFindSlot@@YAIPEAU_hba_port_@@@Z	; AuAHCIDiskFindSlot
PUBLIC	?AuAHCIDiskRead@@YAXPEAU_hba_port_@@_KIPEA_K@Z	; AuAHCIDiskRead
PUBLIC	?AuAHCIDiskWrite@@YAXPEAU_hba_port_@@_KIPEA_K@Z	; AuAHCIDiskWrite
PUBLIC	?AuAHCIDiskIdentify@@YAXPEAU_hba_port_@@_KIPEA_K@Z ; AuAHCIDiskIdentify
PUBLIC	?AuAHCIVDiskRead@@YAHPEAU_VDISK_@@_KIPEA_K@Z	; AuAHCIVDiskRead
PUBLIC	?AuAHCIVDiskWrite@@YAHPEAU_VDISK_@@_KIPEA_K@Z	; AuAHCIVDiskWrite
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_0BC@CNFGKFKE@?$FLAHCI?$FN?3Port?5Hung?6@	; `string'
PUBLIC	??_C@_0BG@GCMHDICL@?$FLAHCI?$FN?3?5Port?5error?5?$AN?6@ ; `string'
PUBLIC	??_C@_0CF@GBFKBPNL@ahci?5Port?5Supports?5cold?5presenc@ ; `string'
EXTRN	AuPmmngrAlloc:PROC
EXTRN	P2V:PROC
EXTRN	AuTextOut:PROC
EXTRN	strcpy:PROC
EXTRN	memset:PROC
EXTRN	AuVDiskRegister:PROC
EXTRN	AuCreateVDisk:PROC
EXTRN	__CheckForDebuggerJustMyCode:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuAHCIDiskInitialise@@YAXPEAU_hba_port_@@@Z DD imagerel $LN12
	DD	imagerel $LN12+943
	DD	imagerel $unwind$?AuAHCIDiskInitialise@@YAXPEAU_hba_port_@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuAHCIStopCmd@@YAXPEAU_hba_port_@@@Z DD imagerel $LN8
	DD	imagerel $LN8+114
	DD	imagerel $unwind$?AuAHCIStopCmd@@YAXPEAU_hba_port_@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuAHCIStartCmd@@YAXPEAU_hba_port_@@@Z DD imagerel $LN5
	DD	imagerel $LN5+85
	DD	imagerel $unwind$?AuAHCIStartCmd@@YAXPEAU_hba_port_@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuAHCIDiskFindSlot@@YAIPEAU_hba_port_@@@Z DD imagerel $LN7
	DD	imagerel $LN7+100
	DD	imagerel $unwind$?AuAHCIDiskFindSlot@@YAIPEAU_hba_port_@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuAHCIDiskRead@@YAXPEAU_hba_port_@@_KIPEA_K@Z DD imagerel $LN11
	DD	imagerel $LN11+742
	DD	imagerel $unwind$?AuAHCIDiskRead@@YAXPEAU_hba_port_@@_KIPEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuAHCIDiskWrite@@YAXPEAU_hba_port_@@_KIPEA_K@Z DD imagerel $LN10
	DD	imagerel $LN10+755
	DD	imagerel $unwind$?AuAHCIDiskWrite@@YAXPEAU_hba_port_@@_KIPEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuAHCIDiskIdentify@@YAXPEAU_hba_port_@@_KIPEA_K@Z DD imagerel $LN13
	DD	imagerel $LN13+999
	DD	imagerel $unwind$?AuAHCIDiskIdentify@@YAXPEAU_hba_port_@@_KIPEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuAHCIVDiskRead@@YAHPEAU_VDISK_@@_KIPEA_K@Z DD imagerel $LN3
	DD	imagerel $LN3+84
	DD	imagerel $unwind$?AuAHCIVDiskRead@@YAHPEAU_VDISK_@@_KIPEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuAHCIVDiskWrite@@YAHPEAU_VDISK_@@_KIPEA_K@Z DD imagerel $LN3
	DD	imagerel $LN3+84
	DD	imagerel $unwind$?AuAHCIVDiskWrite@@YAHPEAU_VDISK_@@_KIPEA_K@Z
pdata	ENDS
;	COMDAT ??_C@_0CF@GBFKBPNL@ahci?5Port?5Supports?5cold?5presenc@
CONST	SEGMENT
??_C@_0CF@GBFKBPNL@ahci?5Port?5Supports?5cold?5presenc@ DB 'ahci Port Sup'
	DB	'ports cold presence %d', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@GCMHDICL@?$FLAHCI?$FN?3?5Port?5error?5?$AN?6@
CONST	SEGMENT
??_C@_0BG@GCMHDICL@?$FLAHCI?$FN?3?5Port?5error?5?$AN?6@ DB '[AHCI]: Port '
	DB	'error ', 0dH, 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@CNFGKFKE@?$FLAHCI?$FN?3Port?5Hung?6@
CONST	SEGMENT
??_C@_0BC@CNFGKFKE@?$FLAHCI?$FN?3Port?5Hung?6@ DB '[AHCI]:Port Hung', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuAHCIVDiskWrite@@YAHPEAU_VDISK_@@_KIPEA_K@Z DD 025031e01H
	DD	0d219231eH
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuAHCIVDiskRead@@YAHPEAU_VDISK_@@_KIPEA_K@Z DD 025031e01H
	DD	0d219231eH
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuAHCIDiskIdentify@@YAXPEAU_hba_port_@@_KIPEA_K@Z DD 025042101H
	DD	011c2321H
	DD	050150016H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuAHCIDiskWrite@@YAXPEAU_hba_port_@@_KIPEA_K@Z DD 025042101H
	DD	011c2321H
	DD	050150014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuAHCIDiskRead@@YAXPEAU_hba_port_@@_KIPEA_K@Z DD 025042101H
	DD	011c2321H
	DD	050150014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuAHCIDiskFindSlot@@YAIPEAU_hba_port_@@@Z DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuAHCIStartCmd@@YAXPEAU_hba_port_@@@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuAHCIStopCmd@@YAXPEAU_hba_port_@@@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuAHCIDiskInitialise@@YAXPEAU_hba_port_@@@Z DD 025041201H
	DD	010d2312H
	DD	05006001eH
xdata	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\ahcidsk.cpp
;	COMDAT ?AuAHCIVDiskWrite@@YAHPEAU_VDISK_@@_KIPEA_K@Z
_TEXT	SEGMENT
port$ = 0
disk$ = 96
lba$ = 104
count$ = 112
buffer$ = 120
?AuAHCIVDiskWrite@@YAHPEAU_VDISK_@@_KIPEA_K@Z PROC	; AuAHCIVDiskWrite, COMDAT

; 256  : int AuAHCIVDiskWrite(AuVDisk *disk, uint64_t lba, uint32_t count, uint64_t* buffer) {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__10BE5BC2_ahcidsk@cpp
	call	__CheckForDebuggerJustMyCode

; 257  : 	HBA_PORT* port = (HBA_PORT*)disk->data;

	mov	rax, QWORD PTR disk$[rbp]
	mov	rax, QWORD PTR [rax+60]
	mov	QWORD PTR port$[rbp], rax

; 258  : 	AuAHCIDiskWrite(port, lba, count, buffer);

	mov	r9, QWORD PTR buffer$[rbp]
	mov	r8d, DWORD PTR count$[rbp]
	mov	rdx, QWORD PTR lba$[rbp]
	mov	rcx, QWORD PTR port$[rbp]
	call	?AuAHCIDiskWrite@@YAXPEAU_hba_port_@@_KIPEA_K@Z ; AuAHCIDiskWrite

; 259  : 	return count;

	mov	eax, DWORD PTR count$[rbp]

; 260  : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
?AuAHCIVDiskWrite@@YAHPEAU_VDISK_@@_KIPEA_K@Z ENDP	; AuAHCIVDiskWrite
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\ahcidsk.cpp
;	COMDAT ?AuAHCIVDiskRead@@YAHPEAU_VDISK_@@_KIPEA_K@Z
_TEXT	SEGMENT
port$ = 0
disk$ = 96
lba$ = 104
count$ = 112
buffer$ = 120
?AuAHCIVDiskRead@@YAHPEAU_VDISK_@@_KIPEA_K@Z PROC	; AuAHCIVDiskRead, COMDAT

; 250  : int AuAHCIVDiskRead(AuVDisk *disk, uint64_t lba, uint32_t count, uint64_t* buffer) {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__10BE5BC2_ahcidsk@cpp
	call	__CheckForDebuggerJustMyCode

; 251  : 	HBA_PORT * port = (HBA_PORT*)disk->data;

	mov	rax, QWORD PTR disk$[rbp]
	mov	rax, QWORD PTR [rax+60]
	mov	QWORD PTR port$[rbp], rax

; 252  : 	AuAHCIDiskRead(port, lba, count, buffer);

	mov	r9, QWORD PTR buffer$[rbp]
	mov	r8d, DWORD PTR count$[rbp]
	mov	rdx, QWORD PTR lba$[rbp]
	mov	rcx, QWORD PTR port$[rbp]
	call	?AuAHCIDiskRead@@YAXPEAU_hba_port_@@_KIPEA_K@Z ; AuAHCIDiskRead

; 253  : 	return count;

	mov	eax, DWORD PTR count$[rbp]

; 254  : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
?AuAHCIVDiskRead@@YAHPEAU_VDISK_@@_KIPEA_K@Z ENDP	; AuAHCIVDiskRead
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\ahcidsk.cpp
;	COMDAT ?AuAHCIDiskIdentify@@YAXPEAU_hba_port_@@_KIPEA_K@Z
_TEXT	SEGMENT
spin$ = 0
cmd_list$ = 8
buffer_whole$ = 16
command_slot$ = 24
tbl$ = 32
i$ = 40
buffer_aligned$ = 48
fis$ = 56
tv350 = 128
tv345 = 128
port$ = 160
lba$ = 168
count$ = 176
buffer$ = 184
?AuAHCIDiskIdentify@@YAXPEAU_hba_port_@@_KIPEA_K@Z PROC	; AuAHCIDiskIdentify, COMDAT

; 193  : void AuAHCIDiskIdentify(HBA_PORT *port, uint64_t lba, uint32_t count, uint64_t *buffer) {

$LN13:
	mov	QWORD PTR [rsp+32], r9
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 176				; 000000b0H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__10BE5BC2_ahcidsk@cpp
	call	__CheckForDebuggerJustMyCode

; 194  : 	int spin = 0;

	mov	DWORD PTR spin$[rbp], 0

; 195  : 	HBA_CMD_HEADER *cmd_list = (HBA_CMD_HEADER*)port->clb;

	mov	rax, QWORD PTR port$[rbp]
	mov	eax, DWORD PTR [rax]
	mov	QWORD PTR cmd_list$[rbp], rax

; 196  : 	uint64_t buffer_whole = (uint64_t)buffer;

	mov	rax, QWORD PTR buffer$[rbp]
	mov	QWORD PTR buffer_whole$[rbp], rax

; 197  : 
; 198  : 	cmd_list->cfl = sizeof(FIS_REG_H2D) / sizeof(uint32_t);

	mov	rax, QWORD PTR cmd_list$[rbp]
	movzx	eax, BYTE PTR [rax]
	and	al, 224					; 000000e0H
	or	al, 5
	mov	rcx, QWORD PTR cmd_list$[rbp]
	mov	BYTE PTR [rcx], al

; 199  : 	cmd_list->w = 0;

	mov	rax, QWORD PTR cmd_list$[rbp]
	movzx	eax, BYTE PTR [rax]
	and	al, 191					; 000000bfH
	mov	rcx, QWORD PTR cmd_list$[rbp]
	mov	BYTE PTR [rcx], al

; 200  : 	cmd_list->prdtl = (uint16_t)((count - 1) >> 4) + 1;

	mov	eax, DWORD PTR count$[rbp]
	dec	eax
	shr	eax, 4
	movzx	eax, ax
	inc	eax
	mov	rcx, QWORD PTR cmd_list$[rbp]
	mov	WORD PTR [rcx+2], ax

; 201  : 
; 202  : 	uint32_t command_slot = AuAHCIDiskFindSlot(port);

	mov	rcx, QWORD PTR port$[rbp]
	call	?AuAHCIDiskFindSlot@@YAIPEAU_hba_port_@@@Z ; AuAHCIDiskFindSlot
	mov	DWORD PTR command_slot$[rbp], eax

; 203  : 
; 204  : 	HBA_CMD_TABLE *tbl = (HBA_CMD_TABLE*)cmd_list[command_slot].ctba;

	mov	eax, DWORD PTR command_slot$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR cmd_list$[rbp]
	mov	eax, DWORD PTR [rcx+rax+8]
	mov	QWORD PTR tbl$[rbp], rax

; 205  : 	int i = 0;

	mov	DWORD PTR i$[rbp], 0

; 206  : 	uint8_t* buffer_aligned = (uint8_t*)buffer;

	mov	rax, QWORD PTR buffer$[rbp]
	mov	QWORD PTR buffer_aligned$[rbp], rax

; 207  : 	for (i = 0; i < cmd_list->prdtl; i++){

	mov	DWORD PTR i$[rbp], 0
	jmp	SHORT $LN4@AuAHCIDisk
$LN2@AuAHCIDisk:
	mov	eax, DWORD PTR i$[rbp]
	inc	eax
	mov	DWORD PTR i$[rbp], eax
$LN4@AuAHCIDisk:
	mov	rax, QWORD PTR cmd_list$[rbp]
	movzx	eax, WORD PTR [rax+2]
	cmp	DWORD PTR i$[rbp], eax
	jge	$LN3@AuAHCIDisk

; 208  : 		tbl->prdt[i].data_base_address = buffer_whole & 0xffffffff;

	mov	eax, -1					; ffffffffH
	mov	rcx, QWORD PTR buffer_whole$[rbp]
	and	rcx, rax
	mov	rax, rcx
	movsxd	rcx, DWORD PTR i$[rbp]
	imul	rcx, rcx, 16
	mov	rdx, QWORD PTR tbl$[rbp]
	mov	DWORD PTR [rdx+rcx+128], eax

; 209  : 		tbl->prdt[i].dbau = buffer_whole >> 32;

	mov	rax, QWORD PTR buffer_whole$[rbp]
	shr	rax, 32					; 00000020H
	movsxd	rcx, DWORD PTR i$[rbp]
	imul	rcx, rcx, 16
	mov	rdx, QWORD PTR tbl$[rbp]
	mov	DWORD PTR [rdx+rcx+132], eax

; 210  : 		tbl->prdt[i].data_byte_count = (512 * count) - 1;

	imul	eax, DWORD PTR count$[rbp], 512		; 00000200H
	dec	eax
	movsxd	rcx, DWORD PTR i$[rbp]
	imul	rcx, rcx, 16
	and	eax, 4194303				; 003fffffH
	mov	rdx, QWORD PTR tbl$[rbp]
	mov	ecx, DWORD PTR [rdx+rcx+140]
	and	ecx, -4194304				; ffc00000H
	or	ecx, eax
	mov	eax, ecx
	movsxd	rcx, DWORD PTR i$[rbp]
	imul	rcx, rcx, 16
	mov	rdx, QWORD PTR tbl$[rbp]
	mov	DWORD PTR [rdx+rcx+140], eax

; 211  : 		tbl->prdt[i].i = 1;

	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 16
	mov	rcx, QWORD PTR tbl$[rbp]
	mov	eax, DWORD PTR [rcx+rax+140]
	bts	eax, 31
	movsxd	rcx, DWORD PTR i$[rbp]
	imul	rcx, rcx, 16
	mov	rdx, QWORD PTR tbl$[rbp]
	mov	DWORD PTR [rdx+rcx+140], eax

; 212  : 		buffer_aligned += 512 * static_cast<uint64_t>(count);

	mov	eax, DWORD PTR count$[rbp]
	imul	rax, rax, 512				; 00000200H
	mov	rcx, QWORD PTR buffer_aligned$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR buffer_aligned$[rbp], rax

; 213  : 		buffer_whole = (uint64_t)buffer_aligned;

	mov	rax, QWORD PTR buffer_aligned$[rbp]
	mov	QWORD PTR buffer_whole$[rbp], rax

; 214  : 	}

	jmp	$LN2@AuAHCIDisk
$LN3@AuAHCIDisk:

; 215  : 	tbl->prdt[i].data_base_address = buffer_whole & 0xffffffff;

	mov	eax, -1					; ffffffffH
	mov	rcx, QWORD PTR buffer_whole$[rbp]
	and	rcx, rax
	mov	rax, rcx
	movsxd	rcx, DWORD PTR i$[rbp]
	imul	rcx, rcx, 16
	mov	rdx, QWORD PTR tbl$[rbp]
	mov	DWORD PTR [rdx+rcx+128], eax

; 216  : 	tbl->prdt[i].dbau = buffer_whole >> 32;

	mov	rax, QWORD PTR buffer_whole$[rbp]
	shr	rax, 32					; 00000020H
	movsxd	rcx, DWORD PTR i$[rbp]
	imul	rcx, rcx, 16
	mov	rdx, QWORD PTR tbl$[rbp]
	mov	DWORD PTR [rdx+rcx+132], eax

; 217  : 	tbl->prdt[i].data_byte_count = (512 * count) - 1;

	imul	eax, DWORD PTR count$[rbp], 512		; 00000200H
	dec	eax
	movsxd	rcx, DWORD PTR i$[rbp]
	imul	rcx, rcx, 16
	and	eax, 4194303				; 003fffffH
	mov	rdx, QWORD PTR tbl$[rbp]
	mov	ecx, DWORD PTR [rdx+rcx+140]
	and	ecx, -4194304				; ffc00000H
	or	ecx, eax
	mov	eax, ecx
	movsxd	rcx, DWORD PTR i$[rbp]
	imul	rcx, rcx, 16
	mov	rdx, QWORD PTR tbl$[rbp]
	mov	DWORD PTR [rdx+rcx+140], eax

; 218  : 	tbl->prdt[i].i = 1;

	movsxd	rax, DWORD PTR i$[rbp]
	imul	rax, rax, 16
	mov	rcx, QWORD PTR tbl$[rbp]
	mov	eax, DWORD PTR [rcx+rax+140]
	bts	eax, 31
	movsxd	rcx, DWORD PTR i$[rbp]
	imul	rcx, rcx, 16
	mov	rdx, QWORD PTR tbl$[rbp]
	mov	DWORD PTR [rdx+rcx+140], eax

; 219  : 
; 220  : 	FIS_REG_H2D *fis = (FIS_REG_H2D*)tbl->cmd_fis;

	mov	rax, QWORD PTR tbl$[rbp]
	mov	QWORD PTR fis$[rbp], rax

; 221  : 	fis->fis_type = FIS_TYPE_REG_H2D;

	mov	rax, QWORD PTR fis$[rbp]
	mov	BYTE PTR [rax], 39			; 00000027H

; 222  : 	fis->c = 1;

	mov	rax, QWORD PTR fis$[rbp]
	movzx	eax, BYTE PTR [rax+1]
	or	al, 128					; 00000080H
	mov	rcx, QWORD PTR fis$[rbp]
	mov	BYTE PTR [rcx+1], al

; 223  : 	fis->command = ATA_CMD_IDENTIFY;

	mov	rax, QWORD PTR fis$[rbp]
	mov	BYTE PTR [rax+2], 236			; 000000ecH

; 224  : 	fis->lba0 = lba & 0xff;

	mov	rax, QWORD PTR lba$[rbp]
	and	rax, 255				; 000000ffH
	mov	rcx, QWORD PTR fis$[rbp]
	mov	BYTE PTR [rcx+4], al

; 225  : 	fis->lba1 = (lba >> 8) & 0xff;

	mov	rax, QWORD PTR lba$[rbp]
	shr	rax, 8
	and	rax, 255				; 000000ffH
	mov	rcx, QWORD PTR fis$[rbp]
	mov	BYTE PTR [rcx+5], al

; 226  : 	fis->lba2 = (lba >> 16) & 0xff;

	mov	rax, QWORD PTR lba$[rbp]
	shr	rax, 16
	and	rax, 255				; 000000ffH
	mov	rcx, QWORD PTR fis$[rbp]
	mov	BYTE PTR [rcx+6], al

; 227  : 	fis->device = 1 << 6;

	mov	rax, QWORD PTR fis$[rbp]
	mov	BYTE PTR [rax+7], 64			; 00000040H

; 228  : 	fis->lba3 = (lba >> 24) & 0xff;

	mov	rax, QWORD PTR lba$[rbp]
	shr	rax, 24
	and	rax, 255				; 000000ffH
	mov	rcx, QWORD PTR fis$[rbp]
	mov	BYTE PTR [rcx+8], al

; 229  : 	fis->lba4 = (lba >> 32) & 0xff;

	mov	rax, QWORD PTR lba$[rbp]
	shr	rax, 32					; 00000020H
	and	rax, 255				; 000000ffH
	mov	rcx, QWORD PTR fis$[rbp]
	mov	BYTE PTR [rcx+9], al

; 230  : 	fis->lba5 = (lba >> 40) & 0xff;

	mov	rax, QWORD PTR lba$[rbp]
	shr	rax, 40					; 00000028H
	and	rax, 255				; 000000ffH
	mov	rcx, QWORD PTR fis$[rbp]
	mov	BYTE PTR [rcx+10], al

; 231  : 	fis->countl = count & 0xff;

	mov	eax, DWORD PTR count$[rbp]
	and	eax, 255				; 000000ffH
	mov	rcx, QWORD PTR fis$[rbp]
	mov	BYTE PTR [rcx+12], al

; 232  : 	fis->counth = (count >> 8) & 0xff;

	mov	eax, DWORD PTR count$[rbp]
	shr	eax, 8
	and	eax, 255				; 000000ffH
	mov	rcx, QWORD PTR fis$[rbp]
	mov	BYTE PTR [rcx+13], al
$LN5@AuAHCIDisk:

; 233  : 
; 234  : 	while ((port->tfd & (ATA_SR_BSY | ATA_SR_DRQ)) && spin < 1000000) {

	mov	rax, QWORD PTR port$[rbp]
	mov	eax, DWORD PTR [rax+32]
	and	eax, 136				; 00000088H
	test	eax, eax
	je	SHORT $LN6@AuAHCIDisk
	cmp	DWORD PTR spin$[rbp], 1000000		; 000f4240H
	jge	SHORT $LN6@AuAHCIDisk

; 235  : 		spin++;

	mov	eax, DWORD PTR spin$[rbp]
	inc	eax
	mov	DWORD PTR spin$[rbp], eax

; 236  : 	}

	jmp	SHORT $LN5@AuAHCIDisk
$LN6@AuAHCIDisk:

; 237  : 	if (spin == 1000000)

	cmp	DWORD PTR spin$[rbp], 1000000		; 000f4240H
	jne	SHORT $LN9@AuAHCIDisk

; 238  : 		AuTextOut("[AHCI]:Port Hung\n");

	lea	rcx, OFFSET FLAT:??_C@_0BC@CNFGKFKE@?$FLAHCI?$FN?3Port?5Hung?6@
	call	AuTextOut
$LN9@AuAHCIDisk:

; 239  : 
; 240  : 	port->ci = 1 << command_slot;

	mov	eax, DWORD PTR command_slot$[rbp]
	mov	ecx, 1
	mov	DWORD PTR tv345[rbp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv345[rbp]
	shl	eax, cl
	mov	rcx, QWORD PTR port$[rbp]
	mov	DWORD PTR [rcx+56], eax
$LN7@AuAHCIDisk:

; 241  : 	while (1) {

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN8@AuAHCIDisk

; 242  : 		if ((port->ci & (1 << command_slot)) == 0)

	mov	eax, DWORD PTR command_slot$[rbp]
	mov	ecx, 1
	mov	DWORD PTR tv350[rbp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv350[rbp]
	shl	eax, cl
	mov	rcx, QWORD PTR port$[rbp]
	mov	ecx, DWORD PTR [rcx+56]
	and	ecx, eax
	mov	eax, ecx
	test	eax, eax
	jne	SHORT $LN10@AuAHCIDisk

; 243  : 			break;

	jmp	SHORT $LN8@AuAHCIDisk
$LN10@AuAHCIDisk:

; 244  : 		if (port->is & (1 << 30))

	mov	rax, QWORD PTR port$[rbp]
	mov	eax, DWORD PTR [rax+16]
	and	eax, 1073741824				; 40000000H
	test	eax, eax
	je	SHORT $LN11@AuAHCIDisk

; 245  : 			break;

	jmp	SHORT $LN8@AuAHCIDisk
$LN11@AuAHCIDisk:

; 246  : 	}

	jmp	SHORT $LN7@AuAHCIDisk
$LN8@AuAHCIDisk:

; 247  : }

	lea	rsp, QWORD PTR [rbp+144]
	pop	rbp
	ret	0
?AuAHCIDiskIdentify@@YAXPEAU_hba_port_@@_KIPEA_K@Z ENDP	; AuAHCIDiskIdentify
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\ahcidsk.cpp
;	COMDAT ?AuAHCIDiskWrite@@YAXPEAU_hba_port_@@_KIPEA_K@Z
_TEXT	SEGMENT
spin$ = 0
cmd_list$ = 8
buffer_whole$ = 16
command_slot$ = 24
tbl$ = 32
i$ = 40
fis$ = 48
tv284 = 120
tv279 = 120
port$ = 144
lba$ = 152
count$ = 160
buffer$ = 168
?AuAHCIDiskWrite@@YAXPEAU_hba_port_@@_KIPEA_K@Z PROC	; AuAHCIDiskWrite, COMDAT

; 134  : void AuAHCIDiskWrite(HBA_PORT *port, uint64_t lba, uint32_t count, uint64_t *buffer) {

$LN10:
	mov	QWORD PTR [rsp+32], r9
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 160				; 000000a0H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__10BE5BC2_ahcidsk@cpp
	call	__CheckForDebuggerJustMyCode

; 135  : 	int spin = 0;

	mov	DWORD PTR spin$[rbp], 0

; 136  : 	HBA_CMD_HEADER *cmd_list = (HBA_CMD_HEADER*)P2V(port->clb);

	mov	rax, QWORD PTR port$[rbp]
	mov	eax, DWORD PTR [rax]
	mov	ecx, eax
	call	P2V
	mov	QWORD PTR cmd_list$[rbp], rax

; 137  : 	uint64_t buffer_whole = (uint64_t)buffer;

	mov	rax, QWORD PTR buffer$[rbp]
	mov	QWORD PTR buffer_whole$[rbp], rax

; 138  : 
; 139  : 	cmd_list->cfl = sizeof(FIS_REG_H2D) / sizeof(uint32_t);

	mov	rax, QWORD PTR cmd_list$[rbp]
	movzx	eax, BYTE PTR [rax]
	and	al, 224					; 000000e0H
	or	al, 5
	mov	rcx, QWORD PTR cmd_list$[rbp]
	mov	BYTE PTR [rcx], al

; 140  : 	cmd_list->w = 1;

	mov	rax, QWORD PTR cmd_list$[rbp]
	movzx	eax, BYTE PTR [rax]
	or	al, 64					; 00000040H
	mov	rcx, QWORD PTR cmd_list$[rbp]
	mov	BYTE PTR [rcx], al

; 141  : 	cmd_list->prdtl = 1;

	mov	eax, 1
	mov	rcx, QWORD PTR cmd_list$[rbp]
	mov	WORD PTR [rcx+2], ax

; 142  : 
; 143  : 	uint32_t command_slot = AuAHCIDiskFindSlot(port);

	mov	rcx, QWORD PTR port$[rbp]
	call	?AuAHCIDiskFindSlot@@YAIPEAU_hba_port_@@@Z ; AuAHCIDiskFindSlot
	mov	DWORD PTR command_slot$[rbp], eax

; 144  : 
; 145  : 	HBA_CMD_TABLE *tbl = (HBA_CMD_TABLE*)P2V(cmd_list[command_slot].ctba);

	mov	eax, DWORD PTR command_slot$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR cmd_list$[rbp]
	mov	eax, DWORD PTR [rcx+rax+8]
	mov	ecx, eax
	call	P2V
	mov	QWORD PTR tbl$[rbp], rax

; 146  : 	
; 147  : 	int i = 0;

	mov	DWORD PTR i$[rbp], 0

; 148  : 	tbl->prdt[0].data_base_address = buffer_whole & 0xffffffff;

	mov	eax, -1					; ffffffffH
	mov	rcx, QWORD PTR buffer_whole$[rbp]
	and	rcx, rax
	mov	rax, rcx
	mov	ecx, 16
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR tbl$[rbp]
	mov	DWORD PTR [rdx+rcx+128], eax

; 149  : 	tbl->prdt[0].dbau = buffer_whole >> 32;

	mov	rax, QWORD PTR buffer_whole$[rbp]
	shr	rax, 32					; 00000020H
	mov	ecx, 16
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR tbl$[rbp]
	mov	DWORD PTR [rdx+rcx+132], eax

; 150  : 	tbl->prdt[0].data_byte_count = 512 * count - 1;

	imul	eax, DWORD PTR count$[rbp], 512		; 00000200H
	dec	eax
	mov	ecx, 16
	imul	rcx, rcx, 0
	and	eax, 4194303				; 003fffffH
	mov	rdx, QWORD PTR tbl$[rbp]
	mov	ecx, DWORD PTR [rdx+rcx+140]
	and	ecx, -4194304				; ffc00000H
	or	ecx, eax
	mov	eax, ecx
	mov	ecx, 16
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR tbl$[rbp]
	mov	DWORD PTR [rdx+rcx+140], eax

; 151  : 	tbl->prdt[0].i = 1;

	mov	eax, 16
	imul	rax, rax, 0
	mov	rcx, QWORD PTR tbl$[rbp]
	mov	eax, DWORD PTR [rcx+rax+140]
	bts	eax, 31
	mov	ecx, 16
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR tbl$[rbp]
	mov	DWORD PTR [rdx+rcx+140], eax

; 152  : 
; 153  : 	FIS_REG_H2D *fis = (FIS_REG_H2D*)tbl->cmd_fis;

	mov	rax, QWORD PTR tbl$[rbp]
	mov	QWORD PTR fis$[rbp], rax

; 154  : 	fis->fis_type = FIS_TYPE_REG_H2D;

	mov	rax, QWORD PTR fis$[rbp]
	mov	BYTE PTR [rax], 39			; 00000027H

; 155  : 	fis->c = 1;

	mov	rax, QWORD PTR fis$[rbp]
	movzx	eax, BYTE PTR [rax+1]
	or	al, 128					; 00000080H
	mov	rcx, QWORD PTR fis$[rbp]
	mov	BYTE PTR [rcx+1], al

; 156  : 	fis->command = ATA_CMD_WRITE_DMA_EXT;

	mov	rax, QWORD PTR fis$[rbp]
	mov	BYTE PTR [rax+2], 53			; 00000035H

; 157  : 	fis->lba0 = lba & 0xff;

	mov	rax, QWORD PTR lba$[rbp]
	and	rax, 255				; 000000ffH
	mov	rcx, QWORD PTR fis$[rbp]
	mov	BYTE PTR [rcx+4], al

; 158  : 	fis->lba1 = (lba >> 8) & 0xff;

	mov	rax, QWORD PTR lba$[rbp]
	shr	rax, 8
	and	rax, 255				; 000000ffH
	mov	rcx, QWORD PTR fis$[rbp]
	mov	BYTE PTR [rcx+5], al

; 159  : 	fis->lba2 = (lba >> 16) & 0xff;

	mov	rax, QWORD PTR lba$[rbp]
	shr	rax, 16
	and	rax, 255				; 000000ffH
	mov	rcx, QWORD PTR fis$[rbp]
	mov	BYTE PTR [rcx+6], al

; 160  : 	fis->device = 1 << 6;

	mov	rax, QWORD PTR fis$[rbp]
	mov	BYTE PTR [rax+7], 64			; 00000040H

; 161  : 	fis->lba3 = (lba >> 24) & 0xff;

	mov	rax, QWORD PTR lba$[rbp]
	shr	rax, 24
	and	rax, 255				; 000000ffH
	mov	rcx, QWORD PTR fis$[rbp]
	mov	BYTE PTR [rcx+8], al

; 162  : 	fis->lba4 = (lba >> 32) & 0xff;

	mov	rax, QWORD PTR lba$[rbp]
	shr	rax, 32					; 00000020H
	and	rax, 255				; 000000ffH
	mov	rcx, QWORD PTR fis$[rbp]
	mov	BYTE PTR [rcx+9], al

; 163  : 	fis->lba5 = (lba >> 40) & 0xff;

	mov	rax, QWORD PTR lba$[rbp]
	shr	rax, 40					; 00000028H
	and	rax, 255				; 000000ffH
	mov	rcx, QWORD PTR fis$[rbp]
	mov	BYTE PTR [rcx+10], al

; 164  : 	fis->countl = count & 0xff;

	mov	eax, DWORD PTR count$[rbp]
	and	eax, 255				; 000000ffH
	mov	rcx, QWORD PTR fis$[rbp]
	mov	BYTE PTR [rcx+12], al

; 165  : 	fis->counth = (count >> 8) & 0xff;

	mov	eax, DWORD PTR count$[rbp]
	shr	eax, 8
	and	eax, 255				; 000000ffH
	mov	rcx, QWORD PTR fis$[rbp]
	mov	BYTE PTR [rcx+13], al
$LN2@AuAHCIDisk:

; 166  : 
; 167  : 	while ((port->tfd & (ATA_SR_BSY | ATA_SR_DRQ)) && spin < 1000000) {

	mov	rax, QWORD PTR port$[rbp]
	mov	eax, DWORD PTR [rax+32]
	and	eax, 136				; 00000088H
	test	eax, eax
	je	SHORT $LN3@AuAHCIDisk
	cmp	DWORD PTR spin$[rbp], 1000000		; 000f4240H
	jge	SHORT $LN3@AuAHCIDisk

; 168  : 		spin++;

	mov	eax, DWORD PTR spin$[rbp]
	inc	eax
	mov	DWORD PTR spin$[rbp], eax

; 169  : 	}

	jmp	SHORT $LN2@AuAHCIDisk
$LN3@AuAHCIDisk:

; 170  : 	if (spin == 1000000)

	cmp	DWORD PTR spin$[rbp], 1000000		; 000f4240H
	jne	SHORT $LN6@AuAHCIDisk

; 171  : 		AuTextOut("[AHCI]:Port Hung\n");

	lea	rcx, OFFSET FLAT:??_C@_0BC@CNFGKFKE@?$FLAHCI?$FN?3Port?5Hung?6@
	call	AuTextOut
$LN6@AuAHCIDisk:

; 172  : 
; 173  : 	port->ci = 1 << command_slot;

	mov	eax, DWORD PTR command_slot$[rbp]
	mov	ecx, 1
	mov	DWORD PTR tv279[rbp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv279[rbp]
	shl	eax, cl
	mov	rcx, QWORD PTR port$[rbp]
	mov	DWORD PTR [rcx+56], eax
$LN4@AuAHCIDisk:

; 174  : 	while (1) {

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN5@AuAHCIDisk

; 175  : 		if ((port->ci & (1 << command_slot)) == 0)

	mov	eax, DWORD PTR command_slot$[rbp]
	mov	ecx, 1
	mov	DWORD PTR tv284[rbp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv284[rbp]
	shl	eax, cl
	mov	rcx, QWORD PTR port$[rbp]
	mov	ecx, DWORD PTR [rcx+56]
	and	ecx, eax
	mov	eax, ecx
	test	eax, eax
	jne	SHORT $LN7@AuAHCIDisk

; 176  : 			break;

	jmp	SHORT $LN5@AuAHCIDisk
$LN7@AuAHCIDisk:

; 177  : 		if (port->is & (1 << 30))  {

	mov	rax, QWORD PTR port$[rbp]
	mov	eax, DWORD PTR [rax+16]
	and	eax, 1073741824				; 40000000H
	test	eax, eax
	je	SHORT $LN8@AuAHCIDisk

; 178  : 			AuTextOut("[AHCI]: Port error \r\n");

	lea	rcx, OFFSET FLAT:??_C@_0BG@GCMHDICL@?$FLAHCI?$FN?3?5Port?5error?5?$AN?6@
	call	AuTextOut

; 179  : 			break;

	jmp	SHORT $LN5@AuAHCIDisk
$LN8@AuAHCIDisk:

; 180  : 		}
; 181  : 	}

	jmp	SHORT $LN4@AuAHCIDisk
$LN5@AuAHCIDisk:

; 182  : }

	lea	rsp, QWORD PTR [rbp+128]
	pop	rbp
	ret	0
?AuAHCIDiskWrite@@YAXPEAU_hba_port_@@_KIPEA_K@Z ENDP	; AuAHCIDiskWrite
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\ahcidsk.cpp
;	COMDAT ?AuAHCIDiskRead@@YAXPEAU_hba_port_@@_KIPEA_K@Z
_TEXT	SEGMENT
spin$ = 0
cmd_list$ = 8
buffer_while$ = 16
cmd_slot$ = 24
tbl$ = 32
i$ = 40
fis$ = 48
tv286 = 120
tv281 = 120
port$ = 144
lba$ = 152
count$ = 160
buffer$ = 168
?AuAHCIDiskRead@@YAXPEAU_hba_port_@@_KIPEA_K@Z PROC	; AuAHCIDiskRead, COMDAT

; 75   : void AuAHCIDiskRead(HBA_PORT* port, uint64_t lba, uint32_t count, uint64_t *buffer) {

$LN11:
	mov	QWORD PTR [rsp+32], r9
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 160				; 000000a0H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__10BE5BC2_ahcidsk@cpp
	call	__CheckForDebuggerJustMyCode

; 76   : 	int spin = 0;

	mov	DWORD PTR spin$[rbp], 0

; 77   : 	HBA_CMD_HEADER *cmd_list = (HBA_CMD_HEADER*)P2V(port->clb);

	mov	rax, QWORD PTR port$[rbp]
	mov	eax, DWORD PTR [rax]
	mov	ecx, eax
	call	P2V
	mov	QWORD PTR cmd_list$[rbp], rax

; 78   : 	uint64_t buffer_while = (uint64_t)buffer;

	mov	rax, QWORD PTR buffer$[rbp]
	mov	QWORD PTR buffer_while$[rbp], rax

; 79   : 
; 80   : 	cmd_list->cfl = sizeof(FIS_REG_H2D) / sizeof(uint32_t);

	mov	rax, QWORD PTR cmd_list$[rbp]
	movzx	eax, BYTE PTR [rax]
	and	al, 224					; 000000e0H
	or	al, 5
	mov	rcx, QWORD PTR cmd_list$[rbp]
	mov	BYTE PTR [rcx], al

; 81   : 	cmd_list->w = 0;

	mov	rax, QWORD PTR cmd_list$[rbp]
	movzx	eax, BYTE PTR [rax]
	and	al, 191					; 000000bfH
	mov	rcx, QWORD PTR cmd_list$[rbp]
	mov	BYTE PTR [rcx], al

; 82   : 	cmd_list->prdtl = 1;

	mov	eax, 1
	mov	rcx, QWORD PTR cmd_list$[rbp]
	mov	WORD PTR [rcx+2], ax

; 83   : 
; 84   : 	uint32_t cmd_slot = AuAHCIDiskFindSlot(port);

	mov	rcx, QWORD PTR port$[rbp]
	call	?AuAHCIDiskFindSlot@@YAIPEAU_hba_port_@@@Z ; AuAHCIDiskFindSlot
	mov	DWORD PTR cmd_slot$[rbp], eax

; 85   : 
; 86   : 	HBA_CMD_TABLE *tbl = (HBA_CMD_TABLE*)P2V(cmd_list[cmd_slot].ctba);

	mov	eax, DWORD PTR cmd_slot$[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR cmd_list$[rbp]
	mov	eax, DWORD PTR [rcx+rax+8]
	mov	ecx, eax
	call	P2V
	mov	QWORD PTR tbl$[rbp], rax

; 87   : 
; 88   : 	int i = 0;

	mov	DWORD PTR i$[rbp], 0

; 89   : 	tbl->prdt[0].data_base_address = buffer_while & UINT32_MAX;

	mov	eax, -1					; ffffffffH
	mov	rcx, QWORD PTR buffer_while$[rbp]
	and	rcx, rax
	mov	rax, rcx
	mov	ecx, 16
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR tbl$[rbp]
	mov	DWORD PTR [rdx+rcx+128], eax

; 90   : 	tbl->prdt[0].dbau = (buffer_while >> 32) & UINT32_MAX;

	mov	rax, QWORD PTR buffer_while$[rbp]
	shr	rax, 32					; 00000020H
	mov	ecx, -1					; ffffffffH
	and	rax, rcx
	mov	ecx, 16
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR tbl$[rbp]
	mov	DWORD PTR [rdx+rcx+132], eax

; 91   : 	tbl->prdt[0].data_byte_count = 512 * count - 1;

	imul	eax, DWORD PTR count$[rbp], 512		; 00000200H
	dec	eax
	mov	ecx, 16
	imul	rcx, rcx, 0
	and	eax, 4194303				; 003fffffH
	mov	rdx, QWORD PTR tbl$[rbp]
	mov	ecx, DWORD PTR [rdx+rcx+140]
	and	ecx, -4194304				; ffc00000H
	or	ecx, eax
	mov	eax, ecx
	mov	ecx, 16
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR tbl$[rbp]
	mov	DWORD PTR [rdx+rcx+140], eax

; 92   : 	tbl->prdt[0].i = 1;

	mov	eax, 16
	imul	rax, rax, 0
	mov	rcx, QWORD PTR tbl$[rbp]
	mov	eax, DWORD PTR [rcx+rax+140]
	bts	eax, 31
	mov	ecx, 16
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR tbl$[rbp]
	mov	DWORD PTR [rdx+rcx+140], eax

; 93   : 
; 94   : 	FIS_REG_H2D *fis = (FIS_REG_H2D*)tbl->cmd_fis;

	mov	rax, QWORD PTR tbl$[rbp]
	mov	QWORD PTR fis$[rbp], rax

; 95   : 	fis->fis_type = FIS_TYPE_REG_H2D;

	mov	rax, QWORD PTR fis$[rbp]
	mov	BYTE PTR [rax], 39			; 00000027H

; 96   : 	fis->c = 1;

	mov	rax, QWORD PTR fis$[rbp]
	movzx	eax, BYTE PTR [rax+1]
	or	al, 128					; 00000080H
	mov	rcx, QWORD PTR fis$[rbp]
	mov	BYTE PTR [rcx+1], al

; 97   : 	fis->command = ATA_CMD_READ_DMA_EXT;

	mov	rax, QWORD PTR fis$[rbp]
	mov	BYTE PTR [rax+2], 37			; 00000025H

; 98   : 	fis->lba0 = lba & 0xff;

	mov	rax, QWORD PTR lba$[rbp]
	and	rax, 255				; 000000ffH
	mov	rcx, QWORD PTR fis$[rbp]
	mov	BYTE PTR [rcx+4], al

; 99   : 	fis->lba1 = (lba >> 8) & 0xff;

	mov	rax, QWORD PTR lba$[rbp]
	shr	rax, 8
	and	rax, 255				; 000000ffH
	mov	rcx, QWORD PTR fis$[rbp]
	mov	BYTE PTR [rcx+5], al

; 100  : 	fis->lba2 = (lba >> 16) & 0xff;

	mov	rax, QWORD PTR lba$[rbp]
	shr	rax, 16
	and	rax, 255				; 000000ffH
	mov	rcx, QWORD PTR fis$[rbp]
	mov	BYTE PTR [rcx+6], al

; 101  : 	fis->device = 1 << 6;

	mov	rax, QWORD PTR fis$[rbp]
	mov	BYTE PTR [rax+7], 64			; 00000040H

; 102  : 	fis->lba3 = (lba >> 24) & 0xff;

	mov	rax, QWORD PTR lba$[rbp]
	shr	rax, 24
	and	rax, 255				; 000000ffH
	mov	rcx, QWORD PTR fis$[rbp]
	mov	BYTE PTR [rcx+8], al

; 103  : 	fis->lba4 = (lba >> 32) & 0xff;

	mov	rax, QWORD PTR lba$[rbp]
	shr	rax, 32					; 00000020H
	and	rax, 255				; 000000ffH
	mov	rcx, QWORD PTR fis$[rbp]
	mov	BYTE PTR [rcx+9], al

; 104  : 	fis->lba5 = (lba >> 40) & 0xff;

	mov	rax, QWORD PTR lba$[rbp]
	shr	rax, 40					; 00000028H
	and	rax, 255				; 000000ffH
	mov	rcx, QWORD PTR fis$[rbp]
	mov	BYTE PTR [rcx+10], al

; 105  : 	fis->countl = count & 0xff;

	mov	eax, DWORD PTR count$[rbp]
	and	eax, 255				; 000000ffH
	mov	rcx, QWORD PTR fis$[rbp]
	mov	BYTE PTR [rcx+12], al

; 106  : 	fis->counth = (count >> 8) & 0xff;

	mov	eax, DWORD PTR count$[rbp]
	shr	eax, 8
	and	eax, 255				; 000000ffH
	mov	rcx, QWORD PTR fis$[rbp]
	mov	BYTE PTR [rcx+13], al
$LN2@AuAHCIDisk:

; 107  : 
; 108  : 	while ((port->tfd & (ATA_SR_BSY | ATA_SR_DRQ))) {

	mov	rax, QWORD PTR port$[rbp]
	mov	eax, DWORD PTR [rax+32]
	and	eax, 136				; 00000088H
	test	eax, eax
	je	SHORT $LN3@AuAHCIDisk

; 109  : 		spin++;

	mov	eax, DWORD PTR spin$[rbp]
	inc	eax
	mov	DWORD PTR spin$[rbp], eax

; 110  : 	}

	jmp	SHORT $LN2@AuAHCIDisk
$LN3@AuAHCIDisk:

; 111  : 	
; 112  : 	port->ci = 1 << cmd_slot;

	mov	eax, DWORD PTR cmd_slot$[rbp]
	mov	ecx, 1
	mov	DWORD PTR tv281[rbp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv281[rbp]
	shl	eax, cl
	mov	rcx, QWORD PTR port$[rbp]
	mov	DWORD PTR [rcx+56], eax
$LN4@AuAHCIDisk:

; 113  : 	while (1) {

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN5@AuAHCIDisk

; 114  : 		if ((port->ci & (1 << cmd_slot)) == 0)

	mov	eax, DWORD PTR cmd_slot$[rbp]
	mov	ecx, 1
	mov	DWORD PTR tv286[rbp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv286[rbp]
	shl	eax, cl
	mov	rcx, QWORD PTR port$[rbp]
	mov	ecx, DWORD PTR [rcx+56]
	and	ecx, eax
	mov	eax, ecx
	test	eax, eax
	jne	SHORT $LN8@AuAHCIDisk

; 115  : 			break;

	jmp	SHORT $LN5@AuAHCIDisk
$LN8@AuAHCIDisk:

; 116  : 		if (port->is & (1 << 30))  {

	mov	rax, QWORD PTR port$[rbp]
	mov	eax, DWORD PTR [rax+16]
	and	eax, 1073741824				; 40000000H
	test	eax, eax
	je	SHORT $LN9@AuAHCIDisk

; 117  : 			break;

	jmp	SHORT $LN5@AuAHCIDisk
$LN9@AuAHCIDisk:

; 118  : 		}
; 119  : 	}

	jmp	SHORT $LN4@AuAHCIDisk
$LN5@AuAHCIDisk:
$LN6@AuAHCIDisk:

; 120  : 
; 121  : 	while (port->tfd & (ATA_SR_BSY | ATA_SR_DRQ))

	mov	rax, QWORD PTR port$[rbp]
	mov	eax, DWORD PTR [rax+32]
	and	eax, 136				; 00000088H
	test	eax, eax
	je	SHORT $LN7@AuAHCIDisk

; 122  : 		;

	jmp	SHORT $LN6@AuAHCIDisk
$LN7@AuAHCIDisk:

; 123  : 
; 124  : }

	lea	rsp, QWORD PTR [rbp+128]
	pop	rbp
	ret	0
?AuAHCIDiskRead@@YAXPEAU_hba_port_@@_KIPEA_K@Z ENDP	; AuAHCIDiskRead
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\ahcidsk.cpp
;	COMDAT ?AuAHCIDiskFindSlot@@YAIPEAU_hba_port_@@@Z
_TEXT	SEGMENT
slots$ = 0
i$1 = 4
port$ = 96
?AuAHCIDiskFindSlot@@YAIPEAU_hba_port_@@@Z PROC		; AuAHCIDiskFindSlot, COMDAT

; 66   : uint32_t AuAHCIDiskFindSlot(HBA_PORT* port) {

$LN7:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__10BE5BC2_ahcidsk@cpp
	call	__CheckForDebuggerJustMyCode

; 67   : 	uint32_t slots = (port->sact | port->ci);

	mov	rax, QWORD PTR port$[rbp]
	mov	rcx, QWORD PTR port$[rbp]
	mov	ecx, DWORD PTR [rcx+56]
	mov	eax, DWORD PTR [rax+52]
	or	eax, ecx
	mov	DWORD PTR slots$[rbp], eax

; 68   : 	for (int i = 0; i < 32; i++){

	mov	DWORD PTR i$1[rbp], 0
	jmp	SHORT $LN4@AuAHCIDisk
$LN2@AuAHCIDisk:
	mov	eax, DWORD PTR i$1[rbp]
	inc	eax
	mov	DWORD PTR i$1[rbp], eax
$LN4@AuAHCIDisk:
	cmp	DWORD PTR i$1[rbp], 32			; 00000020H
	jge	SHORT $LN3@AuAHCIDisk

; 69   : 		if ((slots & 1) == 0)

	mov	eax, DWORD PTR slots$[rbp]
	and	eax, 1
	test	eax, eax
	jne	SHORT $LN5@AuAHCIDisk

; 70   : 			return i;

	mov	eax, DWORD PTR i$1[rbp]
	jmp	SHORT $LN1@AuAHCIDisk
$LN5@AuAHCIDisk:

; 71   : 		slots >>= 1;

	mov	eax, DWORD PTR slots$[rbp]
	shr	eax, 1
	mov	DWORD PTR slots$[rbp], eax

; 72   : 	}

	jmp	SHORT $LN2@AuAHCIDisk
$LN3@AuAHCIDisk:
$LN1@AuAHCIDisk:

; 73   : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
?AuAHCIDiskFindSlot@@YAIPEAU_hba_port_@@@Z ENDP		; AuAHCIDiskFindSlot
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\ahcidsk.cpp
;	COMDAT ?AuAHCIStartCmd@@YAXPEAU_hba_port_@@@Z
_TEXT	SEGMENT
port$ = 80
?AuAHCIStartCmd@@YAXPEAU_hba_port_@@@Z PROC		; AuAHCIStartCmd, COMDAT

; 59   : void AuAHCIStartCmd(HBA_PORT* port) {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__10BE5BC2_ahcidsk@cpp
	call	__CheckForDebuggerJustMyCode
$LN2@AuAHCIStar:

; 60   : 	while (port->cmd & PX_CMD_CR)

	mov	rax, QWORD PTR port$[rbp]
	mov	eax, DWORD PTR [rax+24]
	and	eax, 32768				; 00008000H
	test	eax, eax
	je	SHORT $LN3@AuAHCIStar

; 61   : 		;

	jmp	SHORT $LN2@AuAHCIStar
$LN3@AuAHCIStar:

; 62   : 	port->cmd |= PX_CMD_FRE;

	mov	rax, QWORD PTR port$[rbp]
	mov	eax, DWORD PTR [rax+24]
	or	eax, 16
	mov	rcx, QWORD PTR port$[rbp]
	mov	DWORD PTR [rcx+24], eax

; 63   : 	port->cmd |= PX_CMD_START;

	mov	rax, QWORD PTR port$[rbp]
	mov	eax, DWORD PTR [rax+24]
	or	eax, 1
	mov	rcx, QWORD PTR port$[rbp]
	mov	DWORD PTR [rcx+24], eax

; 64   : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
?AuAHCIStartCmd@@YAXPEAU_hba_port_@@@Z ENDP		; AuAHCIStartCmd
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\ahcidsk.cpp
;	COMDAT ?AuAHCIStopCmd@@YAXPEAU_hba_port_@@@Z
_TEXT	SEGMENT
port$ = 80
?AuAHCIStopCmd@@YAXPEAU_hba_port_@@@Z PROC		; AuAHCIStopCmd, COMDAT

; 43   : void AuAHCIStopCmd(HBA_PORT* port) {

$LN8:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__10BE5BC2_ahcidsk@cpp
	call	__CheckForDebuggerJustMyCode

; 44   : 	port->cmd &= ~PX_CMD_START;

	mov	rax, QWORD PTR port$[rbp]
	mov	eax, DWORD PTR [rax+24]
	and	eax, -2					; fffffffeH
	mov	rcx, QWORD PTR port$[rbp]
	mov	DWORD PTR [rcx+24], eax

; 45   : 	port->cmd &= ~PX_CMD_FRE;

	mov	rax, QWORD PTR port$[rbp]
	mov	eax, DWORD PTR [rax+24]
	and	eax, -17				; ffffffefH
	mov	rcx, QWORD PTR port$[rbp]
	mov	DWORD PTR [rcx+24], eax
$LN7@AuAHCIStop:
$LN2@AuAHCIStop:

; 46   : 	while (1) {

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN3@AuAHCIStop

; 47   : 		if (port->cmd & PX_CMD_FR)

	mov	rax, QWORD PTR port$[rbp]
	mov	eax, DWORD PTR [rax+24]
	and	eax, 16384				; 00004000H
	test	eax, eax
	je	SHORT $LN4@AuAHCIStop

; 48   : 			continue;

	jmp	SHORT $LN2@AuAHCIStop
$LN4@AuAHCIStop:

; 49   : 		if (port->cmd & PX_CMD_CR)

	mov	rax, QWORD PTR port$[rbp]
	mov	eax, DWORD PTR [rax+24]
	and	eax, 32768				; 00008000H
	test	eax, eax
	je	SHORT $LN5@AuAHCIStop

; 50   : 			continue;

	jmp	SHORT $LN7@AuAHCIStop
$LN5@AuAHCIStop:

; 51   : 		break;

	jmp	SHORT $LN3@AuAHCIStop

; 52   : 	}

	jmp	SHORT $LN2@AuAHCIStop
$LN3@AuAHCIStop:

; 53   : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
?AuAHCIStopCmd@@YAXPEAU_hba_port_@@@Z ENDP		; AuAHCIStopCmd
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\ahcidsk.cpp
;	COMDAT ?AuAHCIDiskInitialise@@YAXPEAU_hba_port_@@@Z
_TEXT	SEGMENT
phys$ = 0
cmd_list$ = 8
fis_dev$ = 16
cold_presence$ = 24
i$1 = 28
current_slot$ = 32
addr$ = 40
ata_device_name$ = 48
ide_buf$ = 88
aligned_buf$ = 96
i$2 = 104
max_sectors$ = 112
offset_83$ = 120
disk$ = 128
port$ = 224
?AuAHCIDiskInitialise@@YAXPEAU_hba_port_@@@Z PROC	; AuAHCIDiskInitialise, COMDAT

; 267  : void AuAHCIDiskInitialise(HBA_PORT *port) {

$LN12:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 240				; 000000f0H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__10BE5BC2_ahcidsk@cpp
	call	__CheckForDebuggerJustMyCode

; 268  : 
; 269  : 	/* stop the DMA engine */
; 270  : 	AuAHCIStopCmd(port);

	mov	rcx, QWORD PTR port$[rbp]
	call	?AuAHCIStopCmd@@YAXPEAU_hba_port_@@@Z	; AuAHCIStopCmd

; 271  : 
; 272  : 	uint64_t phys;
; 273  : 
; 274  : 	/* Allocate command list */
; 275  : 	phys = (uint64_t)AuPmmngrAlloc();

	call	AuPmmngrAlloc
	mov	QWORD PTR phys$[rbp], rax

; 276  : 	port->clb = phys & 0xffffffff;

	mov	eax, -1					; ffffffffH
	mov	rcx, QWORD PTR phys$[rbp]
	and	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR port$[rbp]
	mov	DWORD PTR [rcx], eax

; 277  : 	port->clbu = phys >> 32;

	mov	rax, QWORD PTR phys$[rbp]
	shr	rax, 32					; 00000020H
	mov	rcx, QWORD PTR port$[rbp]
	mov	DWORD PTR [rcx+4], eax

; 278  : 
; 279  : 	HBA_CMD_HEADER *cmd_list = (HBA_CMD_HEADER*)phys;

	mov	rax, QWORD PTR phys$[rbp]
	mov	QWORD PTR cmd_list$[rbp], rax

; 280  : 	memset((void*)phys, 0, 4096);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR phys$[rbp]
	call	memset

; 281  : 
; 282  : 	/* Allocate FIS */
; 283  : 	phys = (uint64_t)AuPmmngrAlloc();

	call	AuPmmngrAlloc
	mov	QWORD PTR phys$[rbp], rax

; 284  : 	port->fb = phys & 0xffffffff;

	mov	eax, -1					; ffffffffH
	mov	rcx, QWORD PTR phys$[rbp]
	and	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR port$[rbp]
	mov	DWORD PTR [rcx+8], eax

; 285  : 	port->fbu = (phys >> 32);

	mov	rax, QWORD PTR phys$[rbp]
	shr	rax, 32					; 00000020H
	mov	rcx, QWORD PTR port$[rbp]
	mov	DWORD PTR [rcx+12], eax

; 286  : 
; 287  : 	HBA_FIS *fis_dev = (HBA_FIS*)phys;

	mov	rax, QWORD PTR phys$[rbp]
	mov	QWORD PTR fis_dev$[rbp], rax

; 288  : 	memset((void*)phys, 0, 4096);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR phys$[rbp]
	call	memset

; 289  : 
; 290  : 	uint8_t cold_presence = port->cmd & (1 << 20);

	mov	rax, QWORD PTR port$[rbp]
	mov	eax, DWORD PTR [rax+24]
	and	eax, 1048576				; 00100000H
	mov	BYTE PTR cold_presence$[rbp], al

; 291  : 	if (cold_presence) {

	movzx	eax, BYTE PTR cold_presence$[rbp]
	test	eax, eax
	je	SHORT $LN8@AuAHCIDisk

; 292  : 		AuTextOut("ahci Port Supports cold presence %d\n", cold_presence);

	movzx	eax, BYTE PTR cold_presence$[rbp]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:??_C@_0CF@GBFKBPNL@ahci?5Port?5Supports?5cold?5presenc@
	call	AuTextOut
$LN8@AuAHCIDisk:

; 293  : 	}
; 294  : 
; 295  : 	for (int i = 0; i < 31; i++) {

	mov	DWORD PTR i$1[rbp], 0
	jmp	SHORT $LN4@AuAHCIDisk
$LN2@AuAHCIDisk:
	mov	eax, DWORD PTR i$1[rbp]
	inc	eax
	mov	DWORD PTR i$1[rbp], eax
$LN4@AuAHCIDisk:
	cmp	DWORD PTR i$1[rbp], 31
	jge	$LN3@AuAHCIDisk

; 296  : 		cmd_list[i].prdtl = 1;

	movsxd	rax, DWORD PTR i$1[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	ecx, 1
	mov	rdx, QWORD PTR cmd_list$[rbp]
	mov	WORD PTR [rdx+rax+2], cx

; 297  : 		phys = (uint64_t)AuPmmngrAlloc();

	call	AuPmmngrAlloc
	mov	QWORD PTR phys$[rbp], rax

; 298  : 		cmd_list[i].ctba = phys & 0xffffffff;

	mov	eax, -1					; ffffffffH
	mov	rcx, QWORD PTR phys$[rbp]
	and	rcx, rax
	mov	rax, rcx
	movsxd	rcx, DWORD PTR i$1[rbp]
	imul	rcx, rcx, 32				; 00000020H
	mov	rdx, QWORD PTR cmd_list$[rbp]
	mov	DWORD PTR [rdx+rcx+8], eax

; 299  : 		cmd_list[i].ctbau = phys >> 32;

	mov	rax, QWORD PTR phys$[rbp]
	shr	rax, 32					; 00000020H
	movsxd	rcx, DWORD PTR i$1[rbp]
	imul	rcx, rcx, 32				; 00000020H
	mov	rdx, QWORD PTR cmd_list$[rbp]
	mov	DWORD PTR [rdx+rcx+12], eax

; 300  : 		cmd_list[i].p = 1;

	movsxd	rax, DWORD PTR i$1[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR cmd_list$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	or	al, 128					; 00000080H
	movsxd	rcx, DWORD PTR i$1[rbp]
	imul	rcx, rcx, 32				; 00000020H
	mov	rdx, QWORD PTR cmd_list$[rbp]
	mov	BYTE PTR [rdx+rcx], al

; 301  : 		cmd_list[i].cfl = 0x10;

	movsxd	rax, DWORD PTR i$1[rbp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR cmd_list$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	and	al, 224					; 000000e0H
	or	al, 16
	movsxd	rcx, DWORD PTR i$1[rbp]
	imul	rcx, rcx, 32				; 00000020H
	mov	rdx, QWORD PTR cmd_list$[rbp]
	mov	BYTE PTR [rdx+rcx], al

; 302  : 		memset((void*)phys, 0, 4096);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR phys$[rbp]
	call	memset

; 303  : 	}

	jmp	$LN2@AuAHCIDisk
$LN3@AuAHCIDisk:

; 304  : 
; 305  : 	port->serr = 0xffffffff;

	mov	rax, QWORD PTR port$[rbp]
	mov	DWORD PTR [rax+48], -1			; ffffffffH

; 306  : 
; 307  : 	port->cmd &= ~HBA_PX_CMD_ICC;

	mov	rax, QWORD PTR port$[rbp]
	mov	eax, DWORD PTR [rax+24]
	and	eax, 268435455				; 0fffffffH
	mov	rcx, QWORD PTR port$[rbp]
	mov	DWORD PTR [rcx+24], eax

; 308  : 	port->cmd |= PX_CMD_POD | PX_CMD_SUD | HBA_PX_CMD_ICC_ACTIVE;

	mov	rax, QWORD PTR port$[rbp]
	mov	eax, DWORD PTR [rax+24]
	or	eax, 268435462				; 10000006H
	mov	rcx, QWORD PTR port$[rbp]
	mov	DWORD PTR [rcx+24], eax

; 309  : 
; 310  : 
; 311  : 	port->ie = (1 << 0) | (1 << 1) | (1 << 2) | (1 << 3) | (1 << 4) | (1 << 5) | (1 << 6) |

	mov	rax, QWORD PTR port$[rbp]
	mov	DWORD PTR [rax+20], -37748481		; fdc000ffH

; 312  : 		(1 << 7) | (1 << 22) | (1 << 23) | (1 << 24) | (1 << 26) | (1 << 27) | (1 << 28) |
; 313  : 		(1 << 29) | (1 << 30) | (1 << 31);
; 314  : 
; 315  : 	/* start the command DMA engine */
; 316  : 	AuAHCIStartCmd(port);

	mov	rcx, QWORD PTR port$[rbp]
	call	?AuAHCIStartCmd@@YAXPEAU_hba_port_@@@Z	; AuAHCIStartCmd

; 317  : 
; 318  : 	uint8_t current_slot = port->cmd & (1 << 8);

	mov	rax, QWORD PTR port$[rbp]
	mov	eax, DWORD PTR [rax+24]
	and	eax, 256				; 00000100H
	mov	BYTE PTR current_slot$[rbp], al

; 319  : 
; 320  : 	uint64_t *addr = (uint64_t*)AuPmmngrAlloc();

	call	AuPmmngrAlloc
	mov	QWORD PTR addr$[rbp], rax

; 321  : 	memset(addr, 0, 4096);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR addr$[rbp]
	call	memset

; 322  : 	AuAHCIDiskIdentify(port, 0, 1, addr);

	mov	r9, QWORD PTR addr$[rbp]
	mov	r8d, 1
	xor	edx, edx
	mov	rcx, QWORD PTR port$[rbp]
	call	?AuAHCIDiskIdentify@@YAXPEAU_hba_port_@@_KIPEA_K@Z ; AuAHCIDiskIdentify

; 323  : 	char ata_device_name[40];
; 324  : 	uint8_t *ide_buf = (uint8_t*)addr;

	mov	rax, QWORD PTR addr$[rbp]
	mov	QWORD PTR ide_buf$[rbp], rax

; 325  : 	uint16_t* aligned_buf = (uint16_t*)addr;

	mov	rax, QWORD PTR addr$[rbp]
	mov	QWORD PTR aligned_buf$[rbp], rax

; 326  : 	for (int i = 0; i < 40; i += 2)

	mov	DWORD PTR i$2[rbp], 0
	jmp	SHORT $LN7@AuAHCIDisk
$LN5@AuAHCIDisk:
	mov	eax, DWORD PTR i$2[rbp]
	add	eax, 2
	mov	DWORD PTR i$2[rbp], eax
$LN7@AuAHCIDisk:
	cmp	DWORD PTR i$2[rbp], 40			; 00000028H
	jge	SHORT $LN6@AuAHCIDisk

; 327  : 	{
; 328  : 		ata_device_name[i] = ide_buf[54 + i + 1];

	mov	eax, DWORD PTR i$2[rbp]
	add	eax, 55					; 00000037H
	cdqe
	movsxd	rcx, DWORD PTR i$2[rbp]
	mov	rdx, QWORD PTR ide_buf$[rbp]
	movzx	eax, BYTE PTR [rdx+rax]
	mov	BYTE PTR ata_device_name$[rbp+rcx], al

; 329  : 		ata_device_name[i + 1] = ide_buf[54 + i];

	mov	eax, DWORD PTR i$2[rbp]
	add	eax, 54					; 00000036H
	cdqe
	mov	ecx, DWORD PTR i$2[rbp]
	inc	ecx
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR ide_buf$[rbp]
	movzx	eax, BYTE PTR [rdx+rax]
	mov	BYTE PTR ata_device_name$[rbp+rcx], al

; 330  : 	}

	jmp	SHORT $LN5@AuAHCIDisk
$LN6@AuAHCIDisk:

; 331  : 	uint64 max_sectors = 0;

	mov	QWORD PTR max_sectors$[rbp], 0

; 332  : 
; 333  : 	/* not correct */
; 334  : 	uint16_t offset_83 = aligned_buf[83];

	mov	eax, 2
	imul	rax, rax, 83				; 00000053H
	mov	rcx, QWORD PTR aligned_buf$[rbp]
	movzx	eax, WORD PTR [rcx+rax]
	mov	WORD PTR offset_83$[rbp], ax

; 335  : 
; 336  : 	if (offset_83 & (1 << 10)) {

	movzx	eax, WORD PTR offset_83$[rbp]
	and	eax, 1024				; 00000400H
	test	eax, eax
	je	SHORT $LN9@AuAHCIDisk

; 337  : 		max_sectors = (uint16_t)aligned_buf[100];

	mov	eax, 2
	imul	rax, rax, 100				; 00000064H
	mov	rcx, QWORD PTR aligned_buf$[rbp]
	movzx	eax, WORD PTR [rcx+rax]
	mov	QWORD PTR max_sectors$[rbp], rax

; 338  : 	}

	jmp	SHORT $LN10@AuAHCIDisk
$LN9@AuAHCIDisk:

; 339  : 	else{
; 340  : 		max_sectors = aligned_buf[60] + aligned_buf[61];

	mov	eax, 2
	imul	rax, rax, 60				; 0000003cH
	mov	rcx, QWORD PTR aligned_buf$[rbp]
	movzx	eax, WORD PTR [rcx+rax]
	mov	ecx, 2
	imul	rcx, rcx, 61				; 0000003dH
	mov	rdx, QWORD PTR aligned_buf$[rbp]
	movzx	ecx, WORD PTR [rdx+rcx]
	add	eax, ecx
	cdqe
	mov	QWORD PTR max_sectors$[rbp], rax
$LN10@AuAHCIDisk:

; 341  : 	}
; 342  : 
; 343  : 	AuVDisk *disk = AuCreateVDisk();

	call	AuCreateVDisk
	mov	QWORD PTR disk$[rbp], rax

; 344  : 	strcpy(disk->diskname, ata_device_name);

	mov	rax, QWORD PTR disk$[rbp]
	lea	rdx, QWORD PTR ata_device_name$[rbp]
	mov	rcx, rax
	call	strcpy

; 345  : 	disk->data = port;

	mov	rax, QWORD PTR disk$[rbp]
	mov	rcx, QWORD PTR port$[rbp]
	mov	QWORD PTR [rax+60], rcx

; 346  : 	disk->Read = AuAHCIVDiskRead;

	mov	rax, QWORD PTR disk$[rbp]
	lea	rcx, OFFSET FLAT:?AuAHCIVDiskRead@@YAHPEAU_VDISK_@@_KIPEA_K@Z ; AuAHCIVDiskRead
	mov	QWORD PTR [rax+142], rcx

; 347  : 	disk->Write = AuAHCIVDiskWrite;

	mov	rax, QWORD PTR disk$[rbp]
	lea	rcx, OFFSET FLAT:?AuAHCIVDiskWrite@@YAHPEAU_VDISK_@@_KIPEA_K@Z ; AuAHCIVDiskWrite
	mov	QWORD PTR [rax+150], rcx

; 348  : 	disk->max_blocks = -1;

	mov	rax, QWORD PTR disk$[rbp]
	mov	QWORD PTR [rax+68], -1

; 349  : 	disk->currentLBA = 0;

	mov	rax, QWORD PTR disk$[rbp]
	mov	QWORD PTR [rax+94], 0

; 350  : 	AuVDiskRegister(disk);

	mov	rcx, QWORD PTR disk$[rbp]
	call	AuVDiskRegister

; 351  : }

	lea	rsp, QWORD PTR [rbp+208]
	pop	rbp
	ret	0
?AuAHCIDiskInitialise@@YAXPEAU_hba_port_@@@Z ENDP	; AuAHCIDiskInitialise
_TEXT	ENDS
END
