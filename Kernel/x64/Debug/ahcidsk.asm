; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.21005.1 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG3513	DB	'[AHCI]:Port Hung', 0aH, 00H
	ORG $+6
$SG3519	DB	'[AHCI]: Port error ', 0dH, 0aH, 00H
	ORG $+2
$SG3548	DB	'[AHCI]:Port Hung', 0aH, 00H
	ORG $+6
$SG3584	DB	'ahci Port Supports cold presence %d', 0aH, 00H
CONST	ENDS
PUBLIC	?AuAHCIDiskInitialise@@YAXPEAU_hba_port_@@@Z	; AuAHCIDiskInitialise
PUBLIC	?AuAHCIStopCmd@@YAXPEAU_hba_port_@@@Z		; AuAHCIStopCmd
PUBLIC	?AuAHCIStartCmd@@YAXPEAU_hba_port_@@@Z		; AuAHCIStartCmd
PUBLIC	?AuAHCIDiskFindSlot@@YAIPEAU_hba_port_@@@Z	; AuAHCIDiskFindSlot
PUBLIC	?AuAHCIDiskRead@@YAXPEAU_hba_port_@@_KIPEA_K@Z	; AuAHCIDiskRead
PUBLIC	?AuAHCIDiskWrite@@YAXPEAU_hba_port_@@_KIPEA_K@Z	; AuAHCIDiskWrite
PUBLIC	?AuAHCIDiskIdentify@@YAXPEAU_hba_port_@@_KIPEA_K@Z ; AuAHCIDiskIdentify
PUBLIC	?AuAHCIVDiskRead@@YAHPEAU_VDISK_@@_KIPEA_K@Z	; AuAHCIVDiskRead
PUBLIC	?AuAHCIVDiskWrite@@YAHPEAU_VDISK_@@_KIPEA_K@Z	; AuAHCIVDiskWrite
EXTRN	AuPmmngrAlloc:PROC
EXTRN	P2V:PROC
EXTRN	AuTextOut:PROC
EXTRN	strcpy:PROC
EXTRN	memset:PROC
EXTRN	AuVDiskRegister:PROC
EXTRN	AuCreateVDisk:PROC
pdata	SEGMENT
$pdata$?AuAHCIDiskInitialise@@YAXPEAU_hba_port_@@@Z DD imagerel $LN12
	DD	imagerel $LN12+983
	DD	imagerel $unwind$?AuAHCIDiskInitialise@@YAXPEAU_hba_port_@@@Z
$pdata$?AuAHCIDiskFindSlot@@YAIPEAU_hba_port_@@@Z DD imagerel $LN7
	DD	imagerel $LN7+87
	DD	imagerel $unwind$?AuAHCIDiskFindSlot@@YAIPEAU_hba_port_@@@Z
$pdata$?AuAHCIDiskRead@@YAXPEAU_hba_port_@@_KIPEA_K@Z DD imagerel $LN11
	DD	imagerel $LN11+739
	DD	imagerel $unwind$?AuAHCIDiskRead@@YAXPEAU_hba_port_@@_KIPEA_K@Z
$pdata$?AuAHCIDiskWrite@@YAXPEAU_hba_port_@@_KIPEA_K@Z DD imagerel $LN10
	DD	imagerel $LN10+756
	DD	imagerel $unwind$?AuAHCIDiskWrite@@YAXPEAU_hba_port_@@_KIPEA_K@Z
$pdata$?AuAHCIDiskIdentify@@YAXPEAU_hba_port_@@_KIPEA_K@Z DD imagerel $LN13
	DD	imagerel $LN13+1014
	DD	imagerel $unwind$?AuAHCIDiskIdentify@@YAXPEAU_hba_port_@@_KIPEA_K@Z
$pdata$?AuAHCIVDiskRead@@YAHPEAU_VDISK_@@_KIPEA_K@Z DD imagerel $LN3
	DD	imagerel $LN3+72
	DD	imagerel $unwind$?AuAHCIVDiskRead@@YAHPEAU_VDISK_@@_KIPEA_K@Z
$pdata$?AuAHCIVDiskWrite@@YAHPEAU_VDISK_@@_KIPEA_K@Z DD imagerel $LN3
	DD	imagerel $LN3+72
	DD	imagerel $unwind$?AuAHCIVDiskWrite@@YAHPEAU_VDISK_@@_KIPEA_K@Z
pdata	ENDS
xdata	SEGMENT
$unwind$?AuAHCIDiskInitialise@@YAXPEAU_hba_port_@@@Z DD 020c01H
	DD	015010cH
$unwind$?AuAHCIDiskFindSlot@@YAIPEAU_hba_port_@@@Z DD 010901H
	DD	02209H
$unwind$?AuAHCIDiskRead@@YAXPEAU_hba_port_@@_KIPEA_K@Z DD 011801H
	DD	0c218H
$unwind$?AuAHCIDiskWrite@@YAXPEAU_hba_port_@@_KIPEA_K@Z DD 011801H
	DD	0c218H
$unwind$?AuAHCIDiskIdentify@@YAXPEAU_hba_port_@@_KIPEA_K@Z DD 011801H
	DD	0c218H
$unwind$?AuAHCIVDiskRead@@YAHPEAU_VDISK_@@_KIPEA_K@Z DD 011801H
	DD	06218H
$unwind$?AuAHCIVDiskWrite@@YAHPEAU_VDISK_@@_KIPEA_K@Z DD 011801H
	DD	06218H
xdata	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\ahcidsk.cpp
_TEXT	SEGMENT
port$ = 32
disk$ = 64
lba$ = 72
count$ = 80
buffer$ = 88
?AuAHCIVDiskWrite@@YAHPEAU_VDISK_@@_KIPEA_K@Z PROC	; AuAHCIVDiskWrite

; 255  : int AuAHCIVDiskWrite(AuVDisk *disk, uint64_t lba, uint32_t count, uint64_t* buffer) {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 256  : 	HBA_PORT* port = (HBA_PORT*)disk->data;

	mov	rax, QWORD PTR disk$[rsp]
	mov	rax, QWORD PTR [rax+40]
	mov	QWORD PTR port$[rsp], rax

; 257  : 	AuAHCIDiskWrite(port, lba, count, buffer);

	mov	r9, QWORD PTR buffer$[rsp]
	mov	r8d, DWORD PTR count$[rsp]
	mov	rdx, QWORD PTR lba$[rsp]
	mov	rcx, QWORD PTR port$[rsp]
	call	?AuAHCIDiskWrite@@YAXPEAU_hba_port_@@_KIPEA_K@Z ; AuAHCIDiskWrite

; 258  : 	return count;

	mov	eax, DWORD PTR count$[rsp]

; 259  : }

	add	rsp, 56					; 00000038H
	ret	0
?AuAHCIVDiskWrite@@YAHPEAU_VDISK_@@_KIPEA_K@Z ENDP	; AuAHCIVDiskWrite
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\ahcidsk.cpp
_TEXT	SEGMENT
port$ = 32
disk$ = 64
lba$ = 72
count$ = 80
buffer$ = 88
?AuAHCIVDiskRead@@YAHPEAU_VDISK_@@_KIPEA_K@Z PROC	; AuAHCIVDiskRead

; 249  : int AuAHCIVDiskRead(AuVDisk *disk, uint64_t lba, uint32_t count, uint64_t* buffer) {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 250  : 	HBA_PORT * port = (HBA_PORT*)disk->data;

	mov	rax, QWORD PTR disk$[rsp]
	mov	rax, QWORD PTR [rax+40]
	mov	QWORD PTR port$[rsp], rax

; 251  : 	AuAHCIDiskRead(port, lba, count, buffer);

	mov	r9, QWORD PTR buffer$[rsp]
	mov	r8d, DWORD PTR count$[rsp]
	mov	rdx, QWORD PTR lba$[rsp]
	mov	rcx, QWORD PTR port$[rsp]
	call	?AuAHCIDiskRead@@YAXPEAU_hba_port_@@_KIPEA_K@Z ; AuAHCIDiskRead

; 252  : 	return count;

	mov	eax, DWORD PTR count$[rsp]

; 253  : }

	add	rsp, 56					; 00000038H
	ret	0
?AuAHCIVDiskRead@@YAHPEAU_VDISK_@@_KIPEA_K@Z ENDP	; AuAHCIVDiskRead
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\ahcidsk.cpp
_TEXT	SEGMENT
i$ = 32
fis$ = 40
tbl$ = 48
spin$ = 56
command_slot$ = 60
cmd_list$ = 64
buffer_whole$ = 72
tv349 = 80
tv344 = 84
port$ = 112
lba$ = 120
count$ = 128
buffer$ = 136
?AuAHCIDiskIdentify@@YAXPEAU_hba_port_@@_KIPEA_K@Z PROC	; AuAHCIDiskIdentify

; 193  : void AuAHCIDiskIdentify(HBA_PORT *port, uint64_t lba, uint32_t count, uint64_t *buffer) {

$LN13:
	mov	QWORD PTR [rsp+32], r9
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 194  : 	int spin = 0;

	mov	DWORD PTR spin$[rsp], 0

; 195  : 	HBA_CMD_HEADER *cmd_list = (HBA_CMD_HEADER*)port->clb;

	mov	rax, QWORD PTR port$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	QWORD PTR cmd_list$[rsp], rax

; 196  : 	uint64_t buffer_whole = (uint64_t)buffer;

	mov	rax, QWORD PTR buffer$[rsp]
	mov	QWORD PTR buffer_whole$[rsp], rax

; 197  : 
; 198  : 	cmd_list->cfl = sizeof(FIS_REG_H2D) / sizeof(uint32_t);

	mov	rax, QWORD PTR cmd_list$[rsp]
	movzx	eax, BYTE PTR [rax]
	and	al, 224					; 000000e0H
	or	al, 5
	mov	rcx, QWORD PTR cmd_list$[rsp]
	mov	BYTE PTR [rcx], al

; 199  : 	cmd_list->w = 0;

	mov	rax, QWORD PTR cmd_list$[rsp]
	movzx	eax, BYTE PTR [rax]
	and	al, 191					; 000000bfH
	mov	rcx, QWORD PTR cmd_list$[rsp]
	mov	BYTE PTR [rcx], al

; 200  : 	cmd_list->prdtl = (uint16_t)((count - 1) >> 4) + 1;

	mov	eax, DWORD PTR count$[rsp]
	dec	eax
	shr	eax, 4
	movzx	eax, ax
	inc	eax
	mov	rcx, QWORD PTR cmd_list$[rsp]
	mov	WORD PTR [rcx+2], ax

; 201  : 
; 202  : 	uint32_t command_slot = AuAHCIDiskFindSlot(port);

	mov	rcx, QWORD PTR port$[rsp]
	call	?AuAHCIDiskFindSlot@@YAIPEAU_hba_port_@@@Z ; AuAHCIDiskFindSlot
	mov	DWORD PTR command_slot$[rsp], eax

; 203  : 
; 204  : 	HBA_CMD_TABLE *tbl = (HBA_CMD_TABLE*)cmd_list[command_slot].ctba;

	mov	eax, DWORD PTR command_slot$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR cmd_list$[rsp]
	mov	eax, DWORD PTR [rcx+rax+8]
	mov	QWORD PTR tbl$[rsp], rax

; 205  : 	int i = 0;

	mov	DWORD PTR i$[rsp], 0

; 206  : 	for (i = 0; i < cmd_list->prdtl; i++){

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN10@AuAHCIDisk
$LN9@AuAHCIDisk:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN10@AuAHCIDisk:
	mov	rax, QWORD PTR cmd_list$[rsp]
	movzx	eax, WORD PTR [rax+2]
	cmp	DWORD PTR i$[rsp], eax
	jge	$LN8@AuAHCIDisk

; 207  : 		tbl->prdt[i].data_base_address = buffer_whole & 0xffffffff;

	mov	eax, -1					; ffffffffH
	mov	rcx, QWORD PTR buffer_whole$[rsp]
	and	rcx, rax
	mov	rax, rcx
	movsxd	rcx, DWORD PTR i$[rsp]
	imul	rcx, rcx, 16
	mov	rdx, QWORD PTR tbl$[rsp]
	mov	DWORD PTR [rdx+rcx+128], eax

; 208  : 		tbl->prdt[i].dbau = buffer_whole >> 32;

	mov	rax, QWORD PTR buffer_whole$[rsp]
	shr	rax, 32					; 00000020H
	movsxd	rcx, DWORD PTR i$[rsp]
	imul	rcx, rcx, 16
	mov	rdx, QWORD PTR tbl$[rsp]
	mov	DWORD PTR [rdx+rcx+132], eax

; 209  : 		tbl->prdt[i].data_byte_count = (512 * count) - 1;

	imul	eax, DWORD PTR count$[rsp], 512		; 00000200H
	dec	eax
	movsxd	rcx, DWORD PTR i$[rsp]
	imul	rcx, rcx, 16
	and	eax, 4194303				; 003fffffH
	mov	rdx, QWORD PTR tbl$[rsp]
	mov	ecx, DWORD PTR [rdx+rcx+140]
	and	ecx, -4194304				; ffc00000H
	or	ecx, eax
	mov	eax, ecx
	movsxd	rcx, DWORD PTR i$[rsp]
	imul	rcx, rcx, 16
	mov	rdx, QWORD PTR tbl$[rsp]
	mov	DWORD PTR [rdx+rcx+140], eax

; 210  : 		tbl->prdt[i].i = 1;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 16
	mov	rcx, QWORD PTR tbl$[rsp]
	mov	eax, DWORD PTR [rcx+rax+140]
	bts	eax, 31
	movsxd	rcx, DWORD PTR i$[rsp]
	imul	rcx, rcx, 16
	mov	rdx, QWORD PTR tbl$[rsp]
	mov	DWORD PTR [rdx+rcx+140], eax

; 211  : 		buffer += 512 * count;

	imul	eax, DWORD PTR count$[rsp], 512		; 00000200H
	mov	eax, eax
	mov	rcx, QWORD PTR buffer$[rsp]
	lea	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR buffer$[rsp], rax

; 212  : 		buffer_whole = (uint32_t)buffer;

	mov	eax, DWORD PTR buffer$[rsp]
	mov	QWORD PTR buffer_whole$[rsp], rax

; 213  : 	}

	jmp	$LN9@AuAHCIDisk
$LN8@AuAHCIDisk:

; 214  : 	tbl->prdt[i].data_base_address = buffer_whole & 0xffffffff;

	mov	eax, -1					; ffffffffH
	mov	rcx, QWORD PTR buffer_whole$[rsp]
	and	rcx, rax
	mov	rax, rcx
	movsxd	rcx, DWORD PTR i$[rsp]
	imul	rcx, rcx, 16
	mov	rdx, QWORD PTR tbl$[rsp]
	mov	DWORD PTR [rdx+rcx+128], eax

; 215  : 	tbl->prdt[i].dbau = buffer_whole >> 32;

	mov	rax, QWORD PTR buffer_whole$[rsp]
	shr	rax, 32					; 00000020H
	movsxd	rcx, DWORD PTR i$[rsp]
	imul	rcx, rcx, 16
	mov	rdx, QWORD PTR tbl$[rsp]
	mov	DWORD PTR [rdx+rcx+132], eax

; 216  : 	tbl->prdt[i].data_byte_count = (512 * count) - 1;

	imul	eax, DWORD PTR count$[rsp], 512		; 00000200H
	dec	eax
	movsxd	rcx, DWORD PTR i$[rsp]
	imul	rcx, rcx, 16
	and	eax, 4194303				; 003fffffH
	mov	rdx, QWORD PTR tbl$[rsp]
	mov	ecx, DWORD PTR [rdx+rcx+140]
	and	ecx, -4194304				; ffc00000H
	or	ecx, eax
	mov	eax, ecx
	movsxd	rcx, DWORD PTR i$[rsp]
	imul	rcx, rcx, 16
	mov	rdx, QWORD PTR tbl$[rsp]
	mov	DWORD PTR [rdx+rcx+140], eax

; 217  : 	tbl->prdt[i].i = 1;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, rax, 16
	mov	rcx, QWORD PTR tbl$[rsp]
	mov	eax, DWORD PTR [rcx+rax+140]
	bts	eax, 31
	movsxd	rcx, DWORD PTR i$[rsp]
	imul	rcx, rcx, 16
	mov	rdx, QWORD PTR tbl$[rsp]
	mov	DWORD PTR [rdx+rcx+140], eax

; 218  : 
; 219  : 	FIS_REG_H2D *fis = (FIS_REG_H2D*)tbl->cmd_fis;

	mov	rax, QWORD PTR tbl$[rsp]
	mov	QWORD PTR fis$[rsp], rax

; 220  : 	fis->fis_type = FIS_TYPE_REG_H2D;

	mov	rax, QWORD PTR fis$[rsp]
	mov	BYTE PTR [rax], 39			; 00000027H

; 221  : 	fis->c = 1;

	mov	rax, QWORD PTR fis$[rsp]
	movzx	eax, BYTE PTR [rax+1]
	or	al, 128					; 00000080H
	mov	rcx, QWORD PTR fis$[rsp]
	mov	BYTE PTR [rcx+1], al

; 222  : 	fis->command = ATA_CMD_IDENTIFY;

	mov	rax, QWORD PTR fis$[rsp]
	mov	BYTE PTR [rax+2], 236			; 000000ecH

; 223  : 	fis->lba0 = lba & 0xff;

	mov	rax, QWORD PTR lba$[rsp]
	and	rax, 255				; 000000ffH
	mov	rcx, QWORD PTR fis$[rsp]
	mov	BYTE PTR [rcx+4], al

; 224  : 	fis->lba1 = (lba >> 8) & 0xff;

	mov	rax, QWORD PTR lba$[rsp]
	shr	rax, 8
	and	rax, 255				; 000000ffH
	mov	rcx, QWORD PTR fis$[rsp]
	mov	BYTE PTR [rcx+5], al

; 225  : 	fis->lba2 = (lba >> 16) & 0xff;

	mov	rax, QWORD PTR lba$[rsp]
	shr	rax, 16
	and	rax, 255				; 000000ffH
	mov	rcx, QWORD PTR fis$[rsp]
	mov	BYTE PTR [rcx+6], al

; 226  : 	fis->device = 1 << 6;

	mov	rax, QWORD PTR fis$[rsp]
	mov	BYTE PTR [rax+7], 64			; 00000040H

; 227  : 	fis->lba3 = (lba >> 24) & 0xff;

	mov	rax, QWORD PTR lba$[rsp]
	shr	rax, 24
	and	rax, 255				; 000000ffH
	mov	rcx, QWORD PTR fis$[rsp]
	mov	BYTE PTR [rcx+8], al

; 228  : 	fis->lba4 = (lba >> 32) & 0xff;

	mov	rax, QWORD PTR lba$[rsp]
	shr	rax, 32					; 00000020H
	and	rax, 255				; 000000ffH
	mov	rcx, QWORD PTR fis$[rsp]
	mov	BYTE PTR [rcx+9], al

; 229  : 	fis->lba5 = (lba >> 40) & 0xff;

	mov	rax, QWORD PTR lba$[rsp]
	shr	rax, 40					; 00000028H
	and	rax, 255				; 000000ffH
	mov	rcx, QWORD PTR fis$[rsp]
	mov	BYTE PTR [rcx+10], al

; 230  : 	fis->countl = count & 0xff;

	mov	eax, DWORD PTR count$[rsp]
	and	eax, 255				; 000000ffH
	mov	rcx, QWORD PTR fis$[rsp]
	mov	BYTE PTR [rcx+12], al

; 231  : 	fis->counth = (count >> 8) & 0xff;

	mov	eax, DWORD PTR count$[rsp]
	shr	eax, 8
	and	eax, 255				; 000000ffH
	mov	rcx, QWORD PTR fis$[rsp]
	mov	BYTE PTR [rcx+13], al
$LN7@AuAHCIDisk:

; 232  : 
; 233  : 	while ((port->tfd & (ATA_SR_BSY | ATA_SR_DRQ)) && spin < 1000000) {

	mov	rax, QWORD PTR port$[rsp]
	mov	eax, DWORD PTR [rax+32]
	and	eax, 136				; 00000088H
	test	eax, eax
	je	SHORT $LN6@AuAHCIDisk
	cmp	DWORD PTR spin$[rsp], 1000000		; 000f4240H
	jge	SHORT $LN6@AuAHCIDisk

; 234  : 		spin++;

	mov	eax, DWORD PTR spin$[rsp]
	inc	eax
	mov	DWORD PTR spin$[rsp], eax

; 235  : 	}

	jmp	SHORT $LN7@AuAHCIDisk
$LN6@AuAHCIDisk:

; 236  : 	if (spin == 1000000)

	cmp	DWORD PTR spin$[rsp], 1000000		; 000f4240H
	jne	SHORT $LN5@AuAHCIDisk

; 237  : 		AuTextOut("[AHCI]:Port Hung\n");

	lea	rcx, OFFSET FLAT:$SG3548
	call	AuTextOut
$LN5@AuAHCIDisk:

; 238  : 
; 239  : 	port->ci = 1 << command_slot;

	mov	eax, DWORD PTR command_slot$[rsp]
	mov	ecx, 1
	mov	DWORD PTR tv344[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv344[rsp]
	shl	eax, cl
	mov	rcx, QWORD PTR port$[rsp]
	mov	DWORD PTR [rcx+56], eax
$LN4@AuAHCIDisk:

; 240  : 	while (1) {

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN3@AuAHCIDisk

; 241  : 		if ((port->ci & (1 << command_slot)) == 0)

	mov	eax, DWORD PTR command_slot$[rsp]
	mov	ecx, 1
	mov	DWORD PTR tv349[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv349[rsp]
	shl	eax, cl
	mov	rcx, QWORD PTR port$[rsp]
	mov	ecx, DWORD PTR [rcx+56]
	and	ecx, eax
	mov	eax, ecx
	test	eax, eax
	jne	SHORT $LN2@AuAHCIDisk

; 242  : 			break;

	jmp	SHORT $LN3@AuAHCIDisk
$LN2@AuAHCIDisk:

; 243  : 		if (port->is & (1 << 30))

	mov	rax, QWORD PTR port$[rsp]
	mov	eax, DWORD PTR [rax+16]
	and	eax, 1073741824				; 40000000H
	test	eax, eax
	je	SHORT $LN1@AuAHCIDisk

; 244  : 			break;

	jmp	SHORT $LN3@AuAHCIDisk
$LN1@AuAHCIDisk:

; 245  : 	}

	jmp	SHORT $LN4@AuAHCIDisk
$LN3@AuAHCIDisk:

; 246  : }

	add	rsp, 104				; 00000068H
	ret	0
?AuAHCIDiskIdentify@@YAXPEAU_hba_port_@@_KIPEA_K@Z ENDP	; AuAHCIDiskIdentify
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\ahcidsk.cpp
_TEXT	SEGMENT
fis$ = 32
spin$ = 40
command_slot$ = 44
tbl$ = 48
cmd_list$ = 56
tv283 = 64
tv278 = 68
buffer_whole$ = 72
i$ = 80
port$ = 112
lba$ = 120
count$ = 128
buffer$ = 136
?AuAHCIDiskWrite@@YAXPEAU_hba_port_@@_KIPEA_K@Z PROC	; AuAHCIDiskWrite

; 134  : void AuAHCIDiskWrite(HBA_PORT *port, uint64_t lba, uint32_t count, uint64_t *buffer) {

$LN10:
	mov	QWORD PTR [rsp+32], r9
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 135  : 	int spin = 0;

	mov	DWORD PTR spin$[rsp], 0

; 136  : 	HBA_CMD_HEADER *cmd_list = (HBA_CMD_HEADER*)P2V(port->clb);

	mov	rax, QWORD PTR port$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	ecx, eax
	call	P2V
	mov	QWORD PTR cmd_list$[rsp], rax

; 137  : 	uint64_t buffer_whole = (uint64_t)buffer;

	mov	rax, QWORD PTR buffer$[rsp]
	mov	QWORD PTR buffer_whole$[rsp], rax

; 138  : 
; 139  : 	cmd_list->cfl = sizeof(FIS_REG_H2D) / sizeof(uint32_t);

	mov	rax, QWORD PTR cmd_list$[rsp]
	movzx	eax, BYTE PTR [rax]
	and	al, 224					; 000000e0H
	or	al, 5
	mov	rcx, QWORD PTR cmd_list$[rsp]
	mov	BYTE PTR [rcx], al

; 140  : 	cmd_list->w = 1;

	mov	rax, QWORD PTR cmd_list$[rsp]
	movzx	eax, BYTE PTR [rax]
	or	al, 64					; 00000040H
	mov	rcx, QWORD PTR cmd_list$[rsp]
	mov	BYTE PTR [rcx], al

; 141  : 	cmd_list->prdtl = 1;

	mov	eax, 1
	mov	rcx, QWORD PTR cmd_list$[rsp]
	mov	WORD PTR [rcx+2], ax

; 142  : 
; 143  : 	uint32_t command_slot = AuAHCIDiskFindSlot(port);

	mov	rcx, QWORD PTR port$[rsp]
	call	?AuAHCIDiskFindSlot@@YAIPEAU_hba_port_@@@Z ; AuAHCIDiskFindSlot
	mov	DWORD PTR command_slot$[rsp], eax

; 144  : 
; 145  : 	HBA_CMD_TABLE *tbl = (HBA_CMD_TABLE*)P2V(cmd_list[command_slot].ctba);

	mov	eax, DWORD PTR command_slot$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR cmd_list$[rsp]
	mov	eax, DWORD PTR [rcx+rax+8]
	mov	ecx, eax
	call	P2V
	mov	QWORD PTR tbl$[rsp], rax

; 146  : 	
; 147  : 	int i = 0;

	mov	DWORD PTR i$[rsp], 0

; 148  : 	tbl->prdt[0].data_base_address = buffer_whole & 0xffffffff;

	mov	eax, -1					; ffffffffH
	mov	rcx, QWORD PTR buffer_whole$[rsp]
	and	rcx, rax
	mov	rax, rcx
	mov	ecx, 16
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR tbl$[rsp]
	mov	DWORD PTR [rdx+rcx+128], eax

; 149  : 	tbl->prdt[0].dbau = buffer_whole >> 32;

	mov	rax, QWORD PTR buffer_whole$[rsp]
	shr	rax, 32					; 00000020H
	mov	ecx, 16
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR tbl$[rsp]
	mov	DWORD PTR [rdx+rcx+132], eax

; 150  : 	tbl->prdt[0].data_byte_count = 512 * count - 1;

	imul	eax, DWORD PTR count$[rsp], 512		; 00000200H
	dec	eax
	mov	ecx, 16
	imul	rcx, rcx, 0
	and	eax, 4194303				; 003fffffH
	mov	rdx, QWORD PTR tbl$[rsp]
	mov	ecx, DWORD PTR [rdx+rcx+140]
	and	ecx, -4194304				; ffc00000H
	or	ecx, eax
	mov	eax, ecx
	mov	ecx, 16
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR tbl$[rsp]
	mov	DWORD PTR [rdx+rcx+140], eax

; 151  : 	tbl->prdt[0].i = 1;

	mov	eax, 16
	imul	rax, rax, 0
	mov	rcx, QWORD PTR tbl$[rsp]
	mov	eax, DWORD PTR [rcx+rax+140]
	bts	eax, 31
	mov	ecx, 16
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR tbl$[rsp]
	mov	DWORD PTR [rdx+rcx+140], eax

; 152  : 
; 153  : 	FIS_REG_H2D *fis = (FIS_REG_H2D*)tbl->cmd_fis;

	mov	rax, QWORD PTR tbl$[rsp]
	mov	QWORD PTR fis$[rsp], rax

; 154  : 	fis->fis_type = FIS_TYPE_REG_H2D;

	mov	rax, QWORD PTR fis$[rsp]
	mov	BYTE PTR [rax], 39			; 00000027H

; 155  : 	fis->c = 1;

	mov	rax, QWORD PTR fis$[rsp]
	movzx	eax, BYTE PTR [rax+1]
	or	al, 128					; 00000080H
	mov	rcx, QWORD PTR fis$[rsp]
	mov	BYTE PTR [rcx+1], al

; 156  : 	fis->command = ATA_CMD_WRITE_DMA_EXT;

	mov	rax, QWORD PTR fis$[rsp]
	mov	BYTE PTR [rax+2], 53			; 00000035H

; 157  : 	fis->lba0 = lba & 0xff;

	mov	rax, QWORD PTR lba$[rsp]
	and	rax, 255				; 000000ffH
	mov	rcx, QWORD PTR fis$[rsp]
	mov	BYTE PTR [rcx+4], al

; 158  : 	fis->lba1 = (lba >> 8) & 0xff;

	mov	rax, QWORD PTR lba$[rsp]
	shr	rax, 8
	and	rax, 255				; 000000ffH
	mov	rcx, QWORD PTR fis$[rsp]
	mov	BYTE PTR [rcx+5], al

; 159  : 	fis->lba2 = (lba >> 16) & 0xff;

	mov	rax, QWORD PTR lba$[rsp]
	shr	rax, 16
	and	rax, 255				; 000000ffH
	mov	rcx, QWORD PTR fis$[rsp]
	mov	BYTE PTR [rcx+6], al

; 160  : 	fis->device = 1 << 6;

	mov	rax, QWORD PTR fis$[rsp]
	mov	BYTE PTR [rax+7], 64			; 00000040H

; 161  : 	fis->lba3 = (lba >> 24) & 0xff;

	mov	rax, QWORD PTR lba$[rsp]
	shr	rax, 24
	and	rax, 255				; 000000ffH
	mov	rcx, QWORD PTR fis$[rsp]
	mov	BYTE PTR [rcx+8], al

; 162  : 	fis->lba4 = (lba >> 32) & 0xff;

	mov	rax, QWORD PTR lba$[rsp]
	shr	rax, 32					; 00000020H
	and	rax, 255				; 000000ffH
	mov	rcx, QWORD PTR fis$[rsp]
	mov	BYTE PTR [rcx+9], al

; 163  : 	fis->lba5 = (lba >> 40) & 0xff;

	mov	rax, QWORD PTR lba$[rsp]
	shr	rax, 40					; 00000028H
	and	rax, 255				; 000000ffH
	mov	rcx, QWORD PTR fis$[rsp]
	mov	BYTE PTR [rcx+10], al

; 164  : 	fis->countl = count & 0xff;

	mov	eax, DWORD PTR count$[rsp]
	and	eax, 255				; 000000ffH
	mov	rcx, QWORD PTR fis$[rsp]
	mov	BYTE PTR [rcx+12], al

; 165  : 	fis->counth = (count >> 8) & 0xff;

	mov	eax, DWORD PTR count$[rsp]
	shr	eax, 8
	and	eax, 255				; 000000ffH
	mov	rcx, QWORD PTR fis$[rsp]
	mov	BYTE PTR [rcx+13], al
$LN7@AuAHCIDisk:

; 166  : 
; 167  : 	while ((port->tfd & (ATA_SR_BSY | ATA_SR_DRQ)) && spin < 1000000) {

	mov	rax, QWORD PTR port$[rsp]
	mov	eax, DWORD PTR [rax+32]
	and	eax, 136				; 00000088H
	test	eax, eax
	je	SHORT $LN6@AuAHCIDisk
	cmp	DWORD PTR spin$[rsp], 1000000		; 000f4240H
	jge	SHORT $LN6@AuAHCIDisk

; 168  : 		spin++;

	mov	eax, DWORD PTR spin$[rsp]
	inc	eax
	mov	DWORD PTR spin$[rsp], eax

; 169  : 	}

	jmp	SHORT $LN7@AuAHCIDisk
$LN6@AuAHCIDisk:

; 170  : 	if (spin == 1000000)

	cmp	DWORD PTR spin$[rsp], 1000000		; 000f4240H
	jne	SHORT $LN5@AuAHCIDisk

; 171  : 		AuTextOut("[AHCI]:Port Hung\n");

	lea	rcx, OFFSET FLAT:$SG3513
	call	AuTextOut
$LN5@AuAHCIDisk:

; 172  : 
; 173  : 	port->ci = 1 << command_slot;

	mov	eax, DWORD PTR command_slot$[rsp]
	mov	ecx, 1
	mov	DWORD PTR tv278[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv278[rsp]
	shl	eax, cl
	mov	rcx, QWORD PTR port$[rsp]
	mov	DWORD PTR [rcx+56], eax
$LN4@AuAHCIDisk:

; 174  : 	while (1) {

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN3@AuAHCIDisk

; 175  : 		if ((port->ci & (1 << command_slot)) == 0)

	mov	eax, DWORD PTR command_slot$[rsp]
	mov	ecx, 1
	mov	DWORD PTR tv283[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv283[rsp]
	shl	eax, cl
	mov	rcx, QWORD PTR port$[rsp]
	mov	ecx, DWORD PTR [rcx+56]
	and	ecx, eax
	mov	eax, ecx
	test	eax, eax
	jne	SHORT $LN2@AuAHCIDisk

; 176  : 			break;

	jmp	SHORT $LN3@AuAHCIDisk
$LN2@AuAHCIDisk:

; 177  : 		if (port->is & (1 << 30))  {

	mov	rax, QWORD PTR port$[rsp]
	mov	eax, DWORD PTR [rax+16]
	and	eax, 1073741824				; 40000000H
	test	eax, eax
	je	SHORT $LN1@AuAHCIDisk

; 178  : 			AuTextOut("[AHCI]: Port error \r\n");

	lea	rcx, OFFSET FLAT:$SG3519
	call	AuTextOut

; 179  : 			break;

	jmp	SHORT $LN3@AuAHCIDisk
$LN1@AuAHCIDisk:

; 180  : 		}
; 181  : 	}

	jmp	SHORT $LN4@AuAHCIDisk
$LN3@AuAHCIDisk:

; 182  : }

	add	rsp, 104				; 00000068H
	ret	0
?AuAHCIDiskWrite@@YAXPEAU_hba_port_@@_KIPEA_K@Z ENDP	; AuAHCIDiskWrite
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\ahcidsk.cpp
_TEXT	SEGMENT
fis$ = 32
cmd_slot$ = 40
tbl$ = 48
cmd_list$ = 56
spin$ = 64
tv285 = 68
tv280 = 72
buffer_while$ = 80
i$ = 88
port$ = 112
lba$ = 120
count$ = 128
buffer$ = 136
?AuAHCIDiskRead@@YAXPEAU_hba_port_@@_KIPEA_K@Z PROC	; AuAHCIDiskRead

; 75   : void AuAHCIDiskRead(HBA_PORT* port, uint64_t lba, uint32_t count, uint64_t *buffer) {

$LN11:
	mov	QWORD PTR [rsp+32], r9
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 76   : 	int spin = 0;

	mov	DWORD PTR spin$[rsp], 0

; 77   : 	HBA_CMD_HEADER *cmd_list = (HBA_CMD_HEADER*)P2V(port->clb);

	mov	rax, QWORD PTR port$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	ecx, eax
	call	P2V
	mov	QWORD PTR cmd_list$[rsp], rax

; 78   : 	uint64_t buffer_while = (uint64_t)buffer;

	mov	rax, QWORD PTR buffer$[rsp]
	mov	QWORD PTR buffer_while$[rsp], rax

; 79   : 
; 80   : 	cmd_list->cfl = sizeof(FIS_REG_H2D) / sizeof(uint32_t);

	mov	rax, QWORD PTR cmd_list$[rsp]
	movzx	eax, BYTE PTR [rax]
	and	al, 224					; 000000e0H
	or	al, 5
	mov	rcx, QWORD PTR cmd_list$[rsp]
	mov	BYTE PTR [rcx], al

; 81   : 	cmd_list->w = 0;

	mov	rax, QWORD PTR cmd_list$[rsp]
	movzx	eax, BYTE PTR [rax]
	and	al, 191					; 000000bfH
	mov	rcx, QWORD PTR cmd_list$[rsp]
	mov	BYTE PTR [rcx], al

; 82   : 	cmd_list->prdtl = 1;

	mov	eax, 1
	mov	rcx, QWORD PTR cmd_list$[rsp]
	mov	WORD PTR [rcx+2], ax

; 83   : 
; 84   : 	uint32_t cmd_slot = AuAHCIDiskFindSlot(port);

	mov	rcx, QWORD PTR port$[rsp]
	call	?AuAHCIDiskFindSlot@@YAIPEAU_hba_port_@@@Z ; AuAHCIDiskFindSlot
	mov	DWORD PTR cmd_slot$[rsp], eax

; 85   : 
; 86   : 	HBA_CMD_TABLE *tbl = (HBA_CMD_TABLE*)P2V(cmd_list[cmd_slot].ctba);

	mov	eax, DWORD PTR cmd_slot$[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR cmd_list$[rsp]
	mov	eax, DWORD PTR [rcx+rax+8]
	mov	ecx, eax
	call	P2V
	mov	QWORD PTR tbl$[rsp], rax

; 87   : 
; 88   : 	int i = 0;

	mov	DWORD PTR i$[rsp], 0

; 89   : 	tbl->prdt[0].data_base_address = buffer_while & UINT32_MAX;

	mov	eax, -1					; ffffffffH
	mov	rcx, QWORD PTR buffer_while$[rsp]
	and	rcx, rax
	mov	rax, rcx
	mov	ecx, 16
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR tbl$[rsp]
	mov	DWORD PTR [rdx+rcx+128], eax

; 90   : 	tbl->prdt[0].dbau = (buffer_while >> 32) & UINT32_MAX;

	mov	rax, QWORD PTR buffer_while$[rsp]
	shr	rax, 32					; 00000020H
	mov	ecx, -1					; ffffffffH
	and	rax, rcx
	mov	ecx, 16
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR tbl$[rsp]
	mov	DWORD PTR [rdx+rcx+132], eax

; 91   : 	tbl->prdt[0].data_byte_count = 512 * count - 1;

	imul	eax, DWORD PTR count$[rsp], 512		; 00000200H
	dec	eax
	mov	ecx, 16
	imul	rcx, rcx, 0
	and	eax, 4194303				; 003fffffH
	mov	rdx, QWORD PTR tbl$[rsp]
	mov	ecx, DWORD PTR [rdx+rcx+140]
	and	ecx, -4194304				; ffc00000H
	or	ecx, eax
	mov	eax, ecx
	mov	ecx, 16
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR tbl$[rsp]
	mov	DWORD PTR [rdx+rcx+140], eax

; 92   : 	tbl->prdt[0].i = 1;

	mov	eax, 16
	imul	rax, rax, 0
	mov	rcx, QWORD PTR tbl$[rsp]
	mov	eax, DWORD PTR [rcx+rax+140]
	bts	eax, 31
	mov	ecx, 16
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR tbl$[rsp]
	mov	DWORD PTR [rdx+rcx+140], eax

; 93   : 
; 94   : 	FIS_REG_H2D *fis = (FIS_REG_H2D*)tbl->cmd_fis;

	mov	rax, QWORD PTR tbl$[rsp]
	mov	QWORD PTR fis$[rsp], rax

; 95   : 	fis->fis_type = FIS_TYPE_REG_H2D;

	mov	rax, QWORD PTR fis$[rsp]
	mov	BYTE PTR [rax], 39			; 00000027H

; 96   : 	fis->c = 1;

	mov	rax, QWORD PTR fis$[rsp]
	movzx	eax, BYTE PTR [rax+1]
	or	al, 128					; 00000080H
	mov	rcx, QWORD PTR fis$[rsp]
	mov	BYTE PTR [rcx+1], al

; 97   : 	fis->command = ATA_CMD_READ_DMA_EXT;

	mov	rax, QWORD PTR fis$[rsp]
	mov	BYTE PTR [rax+2], 37			; 00000025H

; 98   : 	fis->lba0 = lba & 0xff;

	mov	rax, QWORD PTR lba$[rsp]
	and	rax, 255				; 000000ffH
	mov	rcx, QWORD PTR fis$[rsp]
	mov	BYTE PTR [rcx+4], al

; 99   : 	fis->lba1 = (lba >> 8) & 0xff;

	mov	rax, QWORD PTR lba$[rsp]
	shr	rax, 8
	and	rax, 255				; 000000ffH
	mov	rcx, QWORD PTR fis$[rsp]
	mov	BYTE PTR [rcx+5], al

; 100  : 	fis->lba2 = (lba >> 16) & 0xff;

	mov	rax, QWORD PTR lba$[rsp]
	shr	rax, 16
	and	rax, 255				; 000000ffH
	mov	rcx, QWORD PTR fis$[rsp]
	mov	BYTE PTR [rcx+6], al

; 101  : 	fis->device = 1 << 6;

	mov	rax, QWORD PTR fis$[rsp]
	mov	BYTE PTR [rax+7], 64			; 00000040H

; 102  : 	fis->lba3 = (lba >> 24) & 0xff;

	mov	rax, QWORD PTR lba$[rsp]
	shr	rax, 24
	and	rax, 255				; 000000ffH
	mov	rcx, QWORD PTR fis$[rsp]
	mov	BYTE PTR [rcx+8], al

; 103  : 	fis->lba4 = (lba >> 32) & 0xff;

	mov	rax, QWORD PTR lba$[rsp]
	shr	rax, 32					; 00000020H
	and	rax, 255				; 000000ffH
	mov	rcx, QWORD PTR fis$[rsp]
	mov	BYTE PTR [rcx+9], al

; 104  : 	fis->lba5 = (lba >> 40) & 0xff;

	mov	rax, QWORD PTR lba$[rsp]
	shr	rax, 40					; 00000028H
	and	rax, 255				; 000000ffH
	mov	rcx, QWORD PTR fis$[rsp]
	mov	BYTE PTR [rcx+10], al

; 105  : 	fis->countl = count & 0xff;

	mov	eax, DWORD PTR count$[rsp]
	and	eax, 255				; 000000ffH
	mov	rcx, QWORD PTR fis$[rsp]
	mov	BYTE PTR [rcx+12], al

; 106  : 	fis->counth = (count >> 8) & 0xff;

	mov	eax, DWORD PTR count$[rsp]
	shr	eax, 8
	and	eax, 255				; 000000ffH
	mov	rcx, QWORD PTR fis$[rsp]
	mov	BYTE PTR [rcx+13], al
$LN8@AuAHCIDisk:

; 107  : 
; 108  : 	while ((port->tfd & (ATA_SR_BSY | ATA_SR_DRQ))) {

	mov	rax, QWORD PTR port$[rsp]
	mov	eax, DWORD PTR [rax+32]
	and	eax, 136				; 00000088H
	test	eax, eax
	je	SHORT $LN7@AuAHCIDisk

; 109  : 		spin++;

	mov	eax, DWORD PTR spin$[rsp]
	inc	eax
	mov	DWORD PTR spin$[rsp], eax

; 110  : 	}

	jmp	SHORT $LN8@AuAHCIDisk
$LN7@AuAHCIDisk:

; 111  : 	
; 112  : 	port->ci = 1 << cmd_slot;

	mov	eax, DWORD PTR cmd_slot$[rsp]
	mov	ecx, 1
	mov	DWORD PTR tv280[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv280[rsp]
	shl	eax, cl
	mov	rcx, QWORD PTR port$[rsp]
	mov	DWORD PTR [rcx+56], eax
$LN6@AuAHCIDisk:

; 113  : 	while (1) {

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN5@AuAHCIDisk

; 114  : 		if ((port->ci & (1 << cmd_slot)) == 0)

	mov	eax, DWORD PTR cmd_slot$[rsp]
	mov	ecx, 1
	mov	DWORD PTR tv285[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv285[rsp]
	shl	eax, cl
	mov	rcx, QWORD PTR port$[rsp]
	mov	ecx, DWORD PTR [rcx+56]
	and	ecx, eax
	mov	eax, ecx
	test	eax, eax
	jne	SHORT $LN4@AuAHCIDisk

; 115  : 			break;

	jmp	SHORT $LN5@AuAHCIDisk
$LN4@AuAHCIDisk:

; 116  : 		if (port->is & (1 << 30))  {

	mov	rax, QWORD PTR port$[rsp]
	mov	eax, DWORD PTR [rax+16]
	and	eax, 1073741824				; 40000000H
	test	eax, eax
	je	SHORT $LN3@AuAHCIDisk

; 117  : 			break;

	jmp	SHORT $LN5@AuAHCIDisk
$LN3@AuAHCIDisk:

; 118  : 		}
; 119  : 	}

	jmp	SHORT $LN6@AuAHCIDisk
$LN5@AuAHCIDisk:
$LN2@AuAHCIDisk:

; 120  : 
; 121  : 	while (port->tfd & (ATA_SR_BSY | ATA_SR_DRQ))

	mov	rax, QWORD PTR port$[rsp]
	mov	eax, DWORD PTR [rax+32]
	and	eax, 136				; 00000088H
	test	eax, eax
	je	SHORT $LN1@AuAHCIDisk

; 122  : 		;

	jmp	SHORT $LN2@AuAHCIDisk
$LN1@AuAHCIDisk:

; 123  : 
; 124  : }

	add	rsp, 104				; 00000068H
	ret	0
?AuAHCIDiskRead@@YAXPEAU_hba_port_@@_KIPEA_K@Z ENDP	; AuAHCIDiskRead
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\ahcidsk.cpp
_TEXT	SEGMENT
i$1 = 0
slots$ = 4
port$ = 32
?AuAHCIDiskFindSlot@@YAIPEAU_hba_port_@@@Z PROC		; AuAHCIDiskFindSlot

; 66   : uint32_t AuAHCIDiskFindSlot(HBA_PORT* port) {

$LN7:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 67   : 	uint32_t slots = (port->sact | port->ci);

	mov	rax, QWORD PTR port$[rsp]
	mov	rcx, QWORD PTR port$[rsp]
	mov	ecx, DWORD PTR [rcx+56]
	mov	eax, DWORD PTR [rax+52]
	or	eax, ecx
	mov	DWORD PTR slots$[rsp], eax

; 68   : 	for (int i = 0; i < 32; i++){

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN4@AuAHCIDisk
$LN3@AuAHCIDisk:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN4@AuAHCIDisk:
	cmp	DWORD PTR i$1[rsp], 32			; 00000020H
	jge	SHORT $LN2@AuAHCIDisk

; 69   : 		if ((slots & 1) == 0)

	mov	eax, DWORD PTR slots$[rsp]
	and	eax, 1
	test	eax, eax
	jne	SHORT $LN1@AuAHCIDisk

; 70   : 			return i;

	mov	eax, DWORD PTR i$1[rsp]
	jmp	SHORT $LN5@AuAHCIDisk
$LN1@AuAHCIDisk:

; 71   : 		slots >>= 1;

	mov	eax, DWORD PTR slots$[rsp]
	shr	eax, 1
	mov	DWORD PTR slots$[rsp], eax

; 72   : 	}

	jmp	SHORT $LN3@AuAHCIDisk
$LN2@AuAHCIDisk:
$LN5@AuAHCIDisk:

; 73   : }

	add	rsp, 24
	ret	0
?AuAHCIDiskFindSlot@@YAIPEAU_hba_port_@@@Z ENDP		; AuAHCIDiskFindSlot
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\ahcidsk.cpp
_TEXT	SEGMENT
port$ = 8
?AuAHCIStartCmd@@YAXPEAU_hba_port_@@@Z PROC		; AuAHCIStartCmd

; 59   : void AuAHCIStartCmd(HBA_PORT* port) {

	mov	QWORD PTR [rsp+8], rcx
$LN2@AuAHCIStar:

; 60   : 	while (port->cmd & PX_CMD_CR)

	mov	rax, QWORD PTR port$[rsp]
	mov	eax, DWORD PTR [rax+24]
	and	eax, 32768				; 00008000H
	test	eax, eax
	je	SHORT $LN1@AuAHCIStar

; 61   : 		;

	jmp	SHORT $LN2@AuAHCIStar
$LN1@AuAHCIStar:

; 62   : 	port->cmd |= PX_CMD_FRE;

	mov	rax, QWORD PTR port$[rsp]
	mov	eax, DWORD PTR [rax+24]
	or	eax, 16
	mov	rcx, QWORD PTR port$[rsp]
	mov	DWORD PTR [rcx+24], eax

; 63   : 	port->cmd |= PX_CMD_START;

	mov	rax, QWORD PTR port$[rsp]
	mov	eax, DWORD PTR [rax+24]
	or	eax, 1
	mov	rcx, QWORD PTR port$[rsp]
	mov	DWORD PTR [rcx+24], eax

; 64   : }

	ret	0
?AuAHCIStartCmd@@YAXPEAU_hba_port_@@@Z ENDP		; AuAHCIStartCmd
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\ahcidsk.cpp
_TEXT	SEGMENT
port$ = 8
?AuAHCIStopCmd@@YAXPEAU_hba_port_@@@Z PROC		; AuAHCIStopCmd

; 43   : void AuAHCIStopCmd(HBA_PORT* port) {

	mov	QWORD PTR [rsp+8], rcx

; 44   : 	port->cmd &= ~PX_CMD_START;

	mov	rax, QWORD PTR port$[rsp]
	mov	eax, DWORD PTR [rax+24]
	and	eax, -2					; fffffffeH
	mov	rcx, QWORD PTR port$[rsp]
	mov	DWORD PTR [rcx+24], eax

; 45   : 	port->cmd &= ~PX_CMD_FRE;

	mov	rax, QWORD PTR port$[rsp]
	mov	eax, DWORD PTR [rax+24]
	and	eax, -17				; ffffffefH
	mov	rcx, QWORD PTR port$[rsp]
	mov	DWORD PTR [rcx+24], eax
$LN7@AuAHCIStop:
$LN4@AuAHCIStop:

; 46   : 	while (1) {

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN3@AuAHCIStop

; 47   : 		if (port->cmd & PX_CMD_FR)

	mov	rax, QWORD PTR port$[rsp]
	mov	eax, DWORD PTR [rax+24]
	and	eax, 16384				; 00004000H
	test	eax, eax
	je	SHORT $LN2@AuAHCIStop

; 48   : 			continue;

	jmp	SHORT $LN4@AuAHCIStop
$LN2@AuAHCIStop:

; 49   : 		if (port->cmd & PX_CMD_CR)

	mov	rax, QWORD PTR port$[rsp]
	mov	eax, DWORD PTR [rax+24]
	and	eax, 32768				; 00008000H
	test	eax, eax
	je	SHORT $LN1@AuAHCIStop

; 50   : 			continue;

	jmp	SHORT $LN7@AuAHCIStop
$LN1@AuAHCIStop:

; 51   : 		break;

	jmp	SHORT $LN3@AuAHCIStop

; 52   : 	}

	jmp	SHORT $LN4@AuAHCIStop
$LN3@AuAHCIStop:

; 53   : }

	ret	0
?AuAHCIStopCmd@@YAXPEAU_hba_port_@@@Z ENDP		; AuAHCIStopCmd
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\ahcidsk.cpp
_TEXT	SEGMENT
cold_presence$ = 32
i$1 = 36
i$2 = 40
phys$ = 48
cmd_list$ = 56
offset_83$ = 64
current_slot$ = 68
disk$ = 72
aligned_buf$ = 80
addr$ = 88
max_sectors$ = 96
ide_buf$ = 104
fis_dev$ = 112
ata_device_name$ = 120
port$ = 176
?AuAHCIDiskInitialise@@YAXPEAU_hba_port_@@@Z PROC	; AuAHCIDiskInitialise

; 266  : void AuAHCIDiskInitialise(HBA_PORT *port) {

$LN12:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 168				; 000000a8H

; 267  : 
; 268  : 	/* stop the DMA engine */
; 269  : 	AuAHCIStopCmd(port);

	mov	rcx, QWORD PTR port$[rsp]
	call	?AuAHCIStopCmd@@YAXPEAU_hba_port_@@@Z	; AuAHCIStopCmd

; 270  : 
; 271  : 	uint64_t phys;
; 272  : 
; 273  : 	/* Allocate command list */
; 274  : 	phys = (uint64_t)AuPmmngrAlloc();

	call	AuPmmngrAlloc
	mov	QWORD PTR phys$[rsp], rax

; 275  : 	port->clb = phys & 0xffffffff;

	mov	eax, -1					; ffffffffH
	mov	rcx, QWORD PTR phys$[rsp]
	and	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR port$[rsp]
	mov	DWORD PTR [rcx], eax

; 276  : 	port->clbu = phys >> 32;

	mov	rax, QWORD PTR phys$[rsp]
	shr	rax, 32					; 00000020H
	mov	rcx, QWORD PTR port$[rsp]
	mov	DWORD PTR [rcx+4], eax

; 277  : 
; 278  : 	HBA_CMD_HEADER *cmd_list = (HBA_CMD_HEADER*)phys;

	mov	rax, QWORD PTR phys$[rsp]
	mov	QWORD PTR cmd_list$[rsp], rax

; 279  : 	memset((void*)phys, 0, 4096);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR phys$[rsp]
	call	memset

; 280  : 
; 281  : 	/* Allocate FIS */
; 282  : 	phys = (uint64_t)AuPmmngrAlloc();

	call	AuPmmngrAlloc
	mov	QWORD PTR phys$[rsp], rax

; 283  : 	port->fb = phys & 0xffffffff;

	mov	eax, -1					; ffffffffH
	mov	rcx, QWORD PTR phys$[rsp]
	and	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR port$[rsp]
	mov	DWORD PTR [rcx+8], eax

; 284  : 	port->fbu = (phys >> 32);

	mov	rax, QWORD PTR phys$[rsp]
	shr	rax, 32					; 00000020H
	mov	rcx, QWORD PTR port$[rsp]
	mov	DWORD PTR [rcx+12], eax

; 285  : 
; 286  : 	HBA_FIS *fis_dev = (HBA_FIS*)phys;

	mov	rax, QWORD PTR phys$[rsp]
	mov	QWORD PTR fis_dev$[rsp], rax

; 287  : 	memset((void*)phys, 0, 4096);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR phys$[rsp]
	call	memset

; 288  : 
; 289  : 	uint8_t cold_presence = port->cmd & (1 << 20);

	mov	rax, QWORD PTR port$[rsp]
	mov	eax, DWORD PTR [rax+24]
	and	eax, 1048576				; 00100000H
	mov	BYTE PTR cold_presence$[rsp], al

; 290  : 	if (cold_presence) {

	movzx	eax, BYTE PTR cold_presence$[rsp]
	test	eax, eax
	je	SHORT $LN9@AuAHCIDisk

; 291  : 		AuTextOut("ahci Port Supports cold presence %d\n", cold_presence);

	movzx	eax, BYTE PTR cold_presence$[rsp]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG3584
	call	AuTextOut
$LN9@AuAHCIDisk:

; 292  : 	}
; 293  : 
; 294  : 	for (int i = 0; i < 31; i++) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN8@AuAHCIDisk
$LN7@AuAHCIDisk:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN8@AuAHCIDisk:
	cmp	DWORD PTR i$1[rsp], 31
	jge	$LN6@AuAHCIDisk

; 295  : 		cmd_list[i].prdtl = 1;

	movsxd	rax, DWORD PTR i$1[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	ecx, 1
	mov	rdx, QWORD PTR cmd_list$[rsp]
	mov	WORD PTR [rdx+rax+2], cx

; 296  : 		phys = (uint64_t)AuPmmngrAlloc();

	call	AuPmmngrAlloc
	mov	QWORD PTR phys$[rsp], rax

; 297  : 		cmd_list[i].ctba = phys & 0xffffffff;

	mov	eax, -1					; ffffffffH
	mov	rcx, QWORD PTR phys$[rsp]
	and	rcx, rax
	mov	rax, rcx
	movsxd	rcx, DWORD PTR i$1[rsp]
	imul	rcx, rcx, 32				; 00000020H
	mov	rdx, QWORD PTR cmd_list$[rsp]
	mov	DWORD PTR [rdx+rcx+8], eax

; 298  : 		cmd_list[i].ctbau = phys >> 32;

	mov	rax, QWORD PTR phys$[rsp]
	shr	rax, 32					; 00000020H
	movsxd	rcx, DWORD PTR i$1[rsp]
	imul	rcx, rcx, 32				; 00000020H
	mov	rdx, QWORD PTR cmd_list$[rsp]
	mov	DWORD PTR [rdx+rcx+12], eax

; 299  : 		cmd_list[i].p = 1;

	movsxd	rax, DWORD PTR i$1[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR cmd_list$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	or	al, 128					; 00000080H
	movsxd	rcx, DWORD PTR i$1[rsp]
	imul	rcx, rcx, 32				; 00000020H
	mov	rdx, QWORD PTR cmd_list$[rsp]
	mov	BYTE PTR [rdx+rcx], al

; 300  : 		cmd_list[i].cfl = 0x10;

	movsxd	rax, DWORD PTR i$1[rsp]
	imul	rax, rax, 32				; 00000020H
	mov	rcx, QWORD PTR cmd_list$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	and	al, 224					; 000000e0H
	or	al, 16
	movsxd	rcx, DWORD PTR i$1[rsp]
	imul	rcx, rcx, 32				; 00000020H
	mov	rdx, QWORD PTR cmd_list$[rsp]
	mov	BYTE PTR [rdx+rcx], al

; 301  : 		memset((void*)phys, 0, 4096);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR phys$[rsp]
	call	memset

; 302  : 	}

	jmp	$LN7@AuAHCIDisk
$LN6@AuAHCIDisk:

; 303  : 
; 304  : 	port->serr = 0xffffffff;

	mov	rax, QWORD PTR port$[rsp]
	mov	DWORD PTR [rax+48], -1			; ffffffffH

; 305  : 
; 306  : 	port->cmd &= ~HBA_PX_CMD_ICC;

	mov	rax, QWORD PTR port$[rsp]
	mov	eax, DWORD PTR [rax+24]
	and	eax, 268435455				; 0fffffffH
	mov	rcx, QWORD PTR port$[rsp]
	mov	DWORD PTR [rcx+24], eax

; 307  : 	port->cmd |= PX_CMD_POD | PX_CMD_SUD | HBA_PX_CMD_ICC_ACTIVE;

	mov	rax, QWORD PTR port$[rsp]
	mov	eax, DWORD PTR [rax+24]
	or	eax, 268435462				; 10000006H
	mov	rcx, QWORD PTR port$[rsp]
	mov	DWORD PTR [rcx+24], eax

; 308  : 
; 309  : 
; 310  : 	port->ie = (1 << 0) | (1 << 1) | (1 << 2) | (1 << 3) | (1 << 4) | (1 << 5) | (1 << 6) |
; 311  : 		(1 << 7) | (1 << 22) | (1 << 23) | (1 << 24) | (1 << 26) | (1 << 27) | (1 << 28) |
; 312  : 		(1 << 29) | (1 << 30) | (1 << 31);

	mov	rax, QWORD PTR port$[rsp]
	mov	DWORD PTR [rax+20], -37748481		; fdc000ffH

; 313  : 
; 314  : 	/* start the command DMA engine */
; 315  : 	AuAHCIStartCmd(port);

	mov	rcx, QWORD PTR port$[rsp]
	call	?AuAHCIStartCmd@@YAXPEAU_hba_port_@@@Z	; AuAHCIStartCmd

; 316  : 
; 317  : 	uint8_t current_slot = port->cmd & (1 << 8);

	mov	rax, QWORD PTR port$[rsp]
	mov	eax, DWORD PTR [rax+24]
	and	eax, 256				; 00000100H
	mov	BYTE PTR current_slot$[rsp], al

; 318  : 
; 319  : 	uint64_t *addr = (uint64_t*)AuPmmngrAlloc();

	call	AuPmmngrAlloc
	mov	QWORD PTR addr$[rsp], rax

; 320  : 	memset(addr, 0, 4096);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR addr$[rsp]
	call	memset

; 321  : 	AuAHCIDiskIdentify(port, 0, 1, addr);

	mov	r9, QWORD PTR addr$[rsp]
	mov	r8d, 1
	xor	edx, edx
	mov	rcx, QWORD PTR port$[rsp]
	call	?AuAHCIDiskIdentify@@YAXPEAU_hba_port_@@_KIPEA_K@Z ; AuAHCIDiskIdentify

; 322  : 	char ata_device_name[40];
; 323  : 	uint8_t *ide_buf = (uint8_t*)addr;

	mov	rax, QWORD PTR addr$[rsp]
	mov	QWORD PTR ide_buf$[rsp], rax

; 324  : 	uint16_t* aligned_buf = (uint16_t*)addr;

	mov	rax, QWORD PTR addr$[rsp]
	mov	QWORD PTR aligned_buf$[rsp], rax

; 325  : 	for (int i = 0; i < 40; i += 2)

	mov	DWORD PTR i$2[rsp], 0
	jmp	SHORT $LN5@AuAHCIDisk
$LN4@AuAHCIDisk:
	mov	eax, DWORD PTR i$2[rsp]
	add	eax, 2
	mov	DWORD PTR i$2[rsp], eax
$LN5@AuAHCIDisk:
	cmp	DWORD PTR i$2[rsp], 40			; 00000028H
	jge	SHORT $LN3@AuAHCIDisk

; 326  : 	{
; 327  : 		ata_device_name[i] = ide_buf[54 + i + 1];

	mov	eax, DWORD PTR i$2[rsp]
	add	eax, 55					; 00000037H
	cdqe
	movsxd	rcx, DWORD PTR i$2[rsp]
	mov	rdx, QWORD PTR ide_buf$[rsp]
	movzx	eax, BYTE PTR [rdx+rax]
	mov	BYTE PTR ata_device_name$[rsp+rcx], al

; 328  : 		ata_device_name[i + 1] = ide_buf[54 + i];

	mov	eax, DWORD PTR i$2[rsp]
	add	eax, 54					; 00000036H
	cdqe
	mov	ecx, DWORD PTR i$2[rsp]
	inc	ecx
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR ide_buf$[rsp]
	movzx	eax, BYTE PTR [rdx+rax]
	mov	BYTE PTR ata_device_name$[rsp+rcx], al

; 329  : 	}

	jmp	SHORT $LN4@AuAHCIDisk
$LN3@AuAHCIDisk:

; 330  : 	uint64 max_sectors = 0;

	mov	QWORD PTR max_sectors$[rsp], 0

; 331  : 
; 332  : 	/* not correct */
; 333  : 	uint16_t offset_83 = aligned_buf[83];

	mov	eax, 2
	imul	rax, rax, 83				; 00000053H
	mov	rcx, QWORD PTR aligned_buf$[rsp]
	movzx	eax, WORD PTR [rcx+rax]
	mov	WORD PTR offset_83$[rsp], ax

; 334  : 
; 335  : 	if (offset_83 & (1 << 10)) {

	movzx	eax, WORD PTR offset_83$[rsp]
	and	eax, 1024				; 00000400H
	test	eax, eax
	je	SHORT $LN2@AuAHCIDisk

; 336  : 		max_sectors = (uint16_t)aligned_buf[100];

	mov	eax, 2
	imul	rax, rax, 100				; 00000064H
	mov	rcx, QWORD PTR aligned_buf$[rsp]
	movzx	eax, WORD PTR [rcx+rax]
	mov	QWORD PTR max_sectors$[rsp], rax

; 337  : 	}
; 338  : 	else{

	jmp	SHORT $LN1@AuAHCIDisk
$LN2@AuAHCIDisk:

; 339  : 		max_sectors = aligned_buf[60] + aligned_buf[61];

	mov	eax, 2
	imul	rax, rax, 60				; 0000003cH
	mov	rcx, QWORD PTR aligned_buf$[rsp]
	movzx	eax, WORD PTR [rcx+rax]
	mov	ecx, 2
	imul	rcx, rcx, 61				; 0000003dH
	mov	rdx, QWORD PTR aligned_buf$[rsp]
	movzx	ecx, WORD PTR [rdx+rcx]
	add	eax, ecx
	cdqe
	mov	QWORD PTR max_sectors$[rsp], rax
$LN1@AuAHCIDisk:

; 340  : 	}
; 341  : 
; 342  : 	AuVDisk *disk = AuCreateVDisk();

	call	AuCreateVDisk
	mov	QWORD PTR disk$[rsp], rax

; 343  : 	strcpy(disk->diskname, ata_device_name);

	mov	rax, QWORD PTR disk$[rsp]
	lea	rdx, QWORD PTR ata_device_name$[rsp]
	mov	rcx, rax
	call	strcpy

; 344  : 	disk->data = port;

	mov	rax, QWORD PTR disk$[rsp]
	mov	rcx, QWORD PTR port$[rsp]
	mov	QWORD PTR [rax+40], rcx

; 345  : 	disk->Read = AuAHCIVDiskRead;

	mov	rax, QWORD PTR disk$[rsp]
	lea	rcx, OFFSET FLAT:?AuAHCIVDiskRead@@YAHPEAU_VDISK_@@_KIPEA_K@Z ; AuAHCIVDiskRead
	mov	QWORD PTR [rax+114], rcx

; 346  : 	disk->Write = AuAHCIVDiskWrite;

	mov	rax, QWORD PTR disk$[rsp]
	lea	rcx, OFFSET FLAT:?AuAHCIVDiskWrite@@YAHPEAU_VDISK_@@_KIPEA_K@Z ; AuAHCIVDiskWrite
	mov	QWORD PTR [rax+122], rcx

; 347  : 	disk->max_blocks = -1;

	mov	rax, QWORD PTR disk$[rsp]
	mov	QWORD PTR [rax+48], -1

; 348  : 	disk->currentLBA = 0;

	mov	rax, QWORD PTR disk$[rsp]
	mov	QWORD PTR [rax+64], 0

; 349  : 	AuVDiskRegister(disk);

	mov	rcx, QWORD PTR disk$[rsp]
	call	AuVDiskRegister

; 350  : }

	add	rsp, 168				; 000000a8H
	ret	0
?AuAHCIDiskInitialise@@YAXPEAU_hba_port_@@@Z ENDP	; AuAHCIDiskInitialise
_TEXT	ENDS
END
