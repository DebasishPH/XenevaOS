; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.21005.1 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG3338	DB	'Mutex acquired ', 0dH, 0aH, 00H
	ORG $+6
$SG3353	DB	'Mutex released ', 0dH, 0aH, 00H
CONST	ENDS
PUBLIC	AuCreateMutex
PUBLIC	AuAcquireMutex
PUBLIC	AuReleaseMutex
PUBLIC	AuDeleteMutex
EXTRN	AuCreateSpinlock:PROC
EXTRN	AuAcquireSpinlock:PROC
EXTRN	AuReleaseSpinlock:PROC
EXTRN	AuGetCurrentThread:PROC
EXTRN	AuBlockThread:PROC
EXTRN	AuUnblockThread:PROC
EXTRN	?AuIsSchedulerInitialised@@YA_NXZ:PROC		; AuIsSchedulerInitialised
EXTRN	initialize_list:PROC
EXTRN	list_add:PROC
EXTRN	list_remove:PROC
EXTRN	x64_cli:PROC
EXTRN	x64_force_sched:PROC
EXTRN	?AuProcessFindThread@@YAPEAU_au_proc_@@PEAU_au_thread_@@@Z:PROC ; AuProcessFindThread
EXTRN	SeTextOut:PROC
EXTRN	kmalloc:PROC
EXTRN	kfree:PROC
pdata	SEGMENT
$pdata$AuCreateMutex DD imagerel $LN3
	DD	imagerel $LN3+71
	DD	imagerel $unwind$AuCreateMutex
$pdata$AuAcquireMutex DD imagerel $LN7
	DD	imagerel $LN7+222
	DD	imagerel $unwind$AuAcquireMutex
$pdata$AuReleaseMutex DD imagerel $LN10
	DD	imagerel $LN10+263
	DD	imagerel $unwind$AuReleaseMutex
$pdata$AuDeleteMutex DD imagerel $LN3
	DD	imagerel $LN3+38
	DD	imagerel $unwind$AuDeleteMutex
pdata	ENDS
xdata	SEGMENT
$unwind$AuCreateMutex DD 010401H
	DD	06204H
$unwind$AuAcquireMutex DD 010901H
	DD	06209H
$unwind$AuReleaseMutex DD 010901H
	DD	08209H
$unwind$AuDeleteMutex DD 010901H
	DD	04209H
xdata	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\sync\mutex.cpp
_TEXT	SEGMENT
mutex$ = 48
AuDeleteMutex PROC

; 110  : AU_EXTERN AU_EXPORT void AuDeleteMutex(AuMutex *mutex) {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 111  : 	kfree(mutex->waiters);

	mov	rax, QWORD PTR mutex$[rsp]
	mov	rcx, QWORD PTR [rax+17]
	call	kfree

; 112  : 	kfree(mutex);

	mov	rcx, QWORD PTR mutex$[rsp]
	call	kfree

; 113  : }

	add	rsp, 40					; 00000028H
	ret	0
AuDeleteMutex ENDP
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\sync\mutex.cpp
_TEXT	SEGMENT
i$1 = 32
current_proc$2 = 40
thr_$3 = 48
mutex$ = 80
AuReleaseMutex PROC

; 81   : AU_EXTERN AU_EXPORT int AuReleaseMutex(AuMutex *mutex) {

$LN10:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 82   : 	if (!AuIsSchedulerInitialised())

	call	?AuIsSchedulerInitialised@@YA_NXZ	; AuIsSchedulerInitialised
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN7@AuReleaseM

; 83   : 		return 0;

	xor	eax, eax
	jmp	$LN8@AuReleaseM
$LN7@AuReleaseM:

; 84   : 	if (!mutex)

	cmp	QWORD PTR mutex$[rsp], 0
	jne	SHORT $LN6@AuReleaseM

; 85   : 		return -1;

	mov	eax, -1
	jmp	$LN8@AuReleaseM
$LN6@AuReleaseM:

; 86   : 	if (mutex->owner != AuGetCurrentThread()) {

	call	AuGetCurrentThread
	mov	rcx, QWORD PTR mutex$[rsp]
	cmp	QWORD PTR [rcx+9], rax
	je	SHORT $LN5@AuReleaseM

; 87   : 		return -1;

	mov	eax, -1
	jmp	$LN8@AuReleaseM
$LN5@AuReleaseM:

; 88   : 	}
; 89   : 	AuAcquireSpinlock(mutex->lock);

	mov	rax, QWORD PTR mutex$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	AuAcquireSpinlock

; 90   : 	mutex->status = 0;

	mov	rax, QWORD PTR mutex$[rsp]
	mov	BYTE PTR [rax+8], 0

; 91   : 	mutex->owner = NULL;

	mov	rax, QWORD PTR mutex$[rsp]
	mov	QWORD PTR [rax+9], 0

; 92   : 	for (int i = 0; i < mutex->waiters->pointer; i++) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN4@AuReleaseM
$LN3@AuReleaseM:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN4@AuReleaseM:
	mov	rax, QWORD PTR mutex$[rsp]
	mov	rax, QWORD PTR [rax+17]
	mov	eax, DWORD PTR [rax]
	cmp	DWORD PTR i$1[rsp], eax
	jae	SHORT $LN2@AuReleaseM

; 93   : 		AuThread* thr_ = (AuThread*)list_remove(mutex->waiters, i);

	mov	edx, DWORD PTR i$1[rsp]
	mov	rax, QWORD PTR mutex$[rsp]
	mov	rcx, QWORD PTR [rax+17]
	call	list_remove
	mov	QWORD PTR thr_$3[rsp], rax

; 94   : 		AuProcess* current_proc = AuProcessFindThread(thr_);

	mov	rcx, QWORD PTR thr_$3[rsp]
	call	?AuProcessFindThread@@YAPEAU_au_proc_@@PEAU_au_thread_@@@Z ; AuProcessFindThread
	mov	QWORD PTR current_proc$2[rsp], rax

; 95   : 		if (thr_) {

	cmp	QWORD PTR thr_$3[rsp], 0
	je	SHORT $LN1@AuReleaseM

; 96   : 			current_proc->state = 0;

	mov	rax, QWORD PTR current_proc$2[rsp]
	mov	BYTE PTR [rax+12], 0

; 97   : 			current_proc->state |= PROCESS_STATE_READY;

	mov	rax, QWORD PTR current_proc$2[rsp]
	movzx	eax, BYTE PTR [rax+12]
	or	eax, 2
	mov	rcx, QWORD PTR current_proc$2[rsp]
	mov	BYTE PTR [rcx+12], al

; 98   : 			AuUnblockThread(thr_);

	mov	rcx, QWORD PTR thr_$3[rsp]
	call	AuUnblockThread
$LN1@AuReleaseM:

; 99   : 		}
; 100  : 	}

	jmp	SHORT $LN3@AuReleaseM
$LN2@AuReleaseM:

; 101  : 	SeTextOut("Mutex released \r\n");

	lea	rcx, OFFSET FLAT:$SG3353
	call	SeTextOut

; 102  : 	AuReleaseSpinlock(mutex->lock);

	mov	rax, QWORD PTR mutex$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	AuReleaseSpinlock

; 103  : 	return 0;

	xor	eax, eax
$LN8@AuReleaseM:

; 104  : }

	add	rsp, 72					; 00000048H
	ret	0
AuReleaseMutex ENDP
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\sync\mutex.cpp
_TEXT	SEGMENT
current_thr$ = 32
current_proc$ = 40
mut$ = 64
AuAcquireMutex PROC

; 53   : AU_EXTERN AU_EXPORT int AuAcquireMutex(AuMutex* mut) {

$LN7:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 54   : 	if (!AuIsSchedulerInitialised())

	call	?AuIsSchedulerInitialised@@YA_NXZ	; AuIsSchedulerInitialised
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN4@AuAcquireM

; 55   : 		return 0;

	xor	eax, eax
	jmp	$LN5@AuAcquireM
$LN4@AuAcquireM:

; 56   : 	if (!mut)

	cmp	QWORD PTR mut$[rsp], 0
	jne	SHORT $LN3@AuAcquireM

; 57   : 		return 0;

	xor	eax, eax
	jmp	$LN5@AuAcquireM
$LN3@AuAcquireM:

; 58   : 	x64_cli();

	call	x64_cli

; 59   : 	AuAcquireSpinlock(mut->lock);

	mov	rax, QWORD PTR mut$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	AuAcquireSpinlock

; 60   : 	AuThread* current_thr = AuGetCurrentThread();

	call	AuGetCurrentThread
	mov	QWORD PTR current_thr$[rsp], rax

; 61   : 	AuProcess* current_proc = AuProcessFindThread(current_thr);

	mov	rcx, QWORD PTR current_thr$[rsp]
	call	?AuProcessFindThread@@YAPEAU_au_proc_@@PEAU_au_thread_@@@Z ; AuProcessFindThread
	mov	QWORD PTR current_proc$[rsp], rax
$LN2@AuAcquireM:

; 62   : 	while (mut->status) {

	mov	rax, QWORD PTR mut$[rsp]
	movzx	eax, BYTE PTR [rax+8]
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@AuAcquireM

; 63   : 		list_add(mut->waiters, current_thr);

	mov	rdx, QWORD PTR current_thr$[rsp]
	mov	rax, QWORD PTR mut$[rsp]
	mov	rcx, QWORD PTR [rax+17]
	call	list_add

; 64   : 		current_proc->state = 0;

	mov	rax, QWORD PTR current_proc$[rsp]
	mov	BYTE PTR [rax+12], 0

; 65   : 		current_proc->state |= PROCESS_STATE_BUSY_WAIT;

	mov	rax, QWORD PTR current_proc$[rsp]
	movzx	eax, BYTE PTR [rax+12]
	or	eax, 64					; 00000040H
	mov	rcx, QWORD PTR current_proc$[rsp]
	mov	BYTE PTR [rcx+12], al

; 66   : 		AuBlockThread(current_thr);

	mov	rcx, QWORD PTR current_thr$[rsp]
	call	AuBlockThread

; 67   : 		x64_force_sched();

	call	x64_force_sched

; 68   : 	}

	jmp	SHORT $LN2@AuAcquireM
$LN1@AuAcquireM:

; 69   : 
; 70   : 	mut->status = 1;

	mov	rax, QWORD PTR mut$[rsp]
	mov	BYTE PTR [rax+8], 1

; 71   : 	mut->owner = current_thr;

	mov	rax, QWORD PTR mut$[rsp]
	mov	rcx, QWORD PTR current_thr$[rsp]
	mov	QWORD PTR [rax+9], rcx

; 72   : 	SeTextOut("Mutex acquired \r\n");

	lea	rcx, OFFSET FLAT:$SG3338
	call	SeTextOut

; 73   : 	AuReleaseSpinlock(mut->lock);

	mov	rax, QWORD PTR mut$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	AuReleaseSpinlock

; 74   : 	return 0;

	xor	eax, eax
$LN5@AuAcquireM:

; 75   : }

	add	rsp, 56					; 00000038H
	ret	0
AuAcquireMutex ENDP
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\sync\mutex.cpp
_TEXT	SEGMENT
mut$ = 32
AuCreateMutex PROC

; 41   : AU_EXTERN AU_EXPORT AuMutex* AuCreateMutex() {

$LN3:
	sub	rsp, 56					; 00000038H

; 42   : 	AuMutex* mut = (AuMutex*)kmalloc(sizeof(AuMutex));

	mov	ecx, 25
	call	kmalloc
	mov	QWORD PTR mut$[rsp], rax

; 43   : 	mut->lock = AuCreateSpinlock(false);

	xor	ecx, ecx
	call	AuCreateSpinlock
	mov	rcx, QWORD PTR mut$[rsp]
	mov	QWORD PTR [rcx], rax

; 44   : 	mut->owner = NULL;

	mov	rax, QWORD PTR mut$[rsp]
	mov	QWORD PTR [rax+9], 0

; 45   : 	mut->waiters = initialize_list();

	call	initialize_list
	mov	rcx, QWORD PTR mut$[rsp]
	mov	QWORD PTR [rcx+17], rax

; 46   : 	return mut;

	mov	rax, QWORD PTR mut$[rsp]

; 47   : }

	add	rsp, 56					; 00000038H
	ret	0
AuCreateMutex ENDP
_TEXT	ENDS
END
