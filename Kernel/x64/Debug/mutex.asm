; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30154.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

msvcjmc	SEGMENT
__B1769D37_mutex@cpp DB 01H
msvcjmc	ENDS
PUBLIC	AuCreateMutex
PUBLIC	AuAcquireMutex
PUBLIC	AuReleaseMutex
PUBLIC	AuDeleteMutex
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_0BC@FKNNBGMF@Mutex?5acquired?5?$AN?6@	; `string'
PUBLIC	??_C@_0BC@MCOMLLKC@Mutex?5released?5?$AN?6@	; `string'
EXTRN	AuCreateSpinlock:PROC
EXTRN	AuAcquireSpinlock:PROC
EXTRN	AuReleaseSpinlock:PROC
EXTRN	AuGetCurrentThread:PROC
EXTRN	AuBlockThread:PROC
EXTRN	AuUnblockThread:PROC
EXTRN	?AuIsSchedulerInitialised@@YA_NXZ:PROC		; AuIsSchedulerInitialised
EXTRN	initialize_list:PROC
EXTRN	list_add:PROC
EXTRN	list_remove:PROC
EXTRN	x64_cli:PROC
EXTRN	x64_force_sched:PROC
EXTRN	?AuProcessFindThread@@YAPEAU_au_proc_@@PEAU_au_thread_@@@Z:PROC ; AuProcessFindThread
EXTRN	SeTextOut:PROC
EXTRN	kmalloc:PROC
EXTRN	kfree:PROC
EXTRN	__CheckForDebuggerJustMyCode:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$AuCreateMutex DD imagerel $LN3
	DD	imagerel $LN3+86
	DD	imagerel $unwind$AuCreateMutex
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AuAcquireMutex DD imagerel $LN7
	DD	imagerel $LN7+225
	DD	imagerel $unwind$AuAcquireMutex
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AuReleaseMutex DD imagerel $LN10
	DD	imagerel $LN10+264
	DD	imagerel $unwind$AuReleaseMutex
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AuDeleteMutex DD imagerel $LN3
	DD	imagerel $LN3+55
	DD	imagerel $unwind$AuDeleteMutex
pdata	ENDS
;	COMDAT ??_C@_0BC@MCOMLLKC@Mutex?5released?5?$AN?6@
CONST	SEGMENT
??_C@_0BC@MCOMLLKC@Mutex?5released?5?$AN?6@ DB 'Mutex released ', 0dH, 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@FKNNBGMF@Mutex?5acquired?5?$AN?6@
CONST	SEGMENT
??_C@_0BC@FKNNBGMF@Mutex?5acquired?5?$AN?6@ DB 'Mutex acquired ', 0dH, 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AuDeleteMutex DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	06bH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AuReleaseMutex DD 025031201H
	DD	0f20d2312H
	DD	05006H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	067H
	DB	0b1H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AuAcquireMutex DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AuCreateMutex DD 025030b01H
	DD	0d206230bH
	DD	05002H
xdata	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Sync\mutex.cpp
;	COMDAT AuDeleteMutex
_TEXT	SEGMENT
mutex$ = 80
AuDeleteMutex PROC					; COMDAT

; 110  : AU_EXTERN AU_EXPORT void AuDeleteMutex(AuMutex *mutex) {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__B1769D37_mutex@cpp
	call	__CheckForDebuggerJustMyCode

; 111  : 	kfree(mutex->waiters);

	mov	rax, QWORD PTR mutex$[rbp]
	mov	rcx, QWORD PTR [rax+17]
	call	kfree

; 112  : 	kfree(mutex);

	mov	rcx, QWORD PTR mutex$[rbp]
	call	kfree

; 113  : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
AuDeleteMutex ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Sync\mutex.cpp
;	COMDAT AuReleaseMutex
_TEXT	SEGMENT
i$1 = 0
thr_$2 = 8
current_proc$3 = 16
mutex$ = 112
AuReleaseMutex PROC					; COMDAT

; 81   : AU_EXTERN AU_EXPORT int AuReleaseMutex(AuMutex *mutex) {

$LN10:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 128				; 00000080H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__B1769D37_mutex@cpp
	call	__CheckForDebuggerJustMyCode

; 82   : 	if (!AuIsSchedulerInitialised())

	call	?AuIsSchedulerInitialised@@YA_NXZ	; AuIsSchedulerInitialised
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN5@AuReleaseM

; 83   : 		return 0;

	xor	eax, eax
	jmp	$LN1@AuReleaseM
$LN5@AuReleaseM:

; 84   : 	if (!mutex)

	cmp	QWORD PTR mutex$[rbp], 0
	jne	SHORT $LN6@AuReleaseM

; 85   : 		return -1;

	mov	eax, -1
	jmp	$LN1@AuReleaseM
$LN6@AuReleaseM:

; 86   : 	if (mutex->owner != AuGetCurrentThread()) {

	call	AuGetCurrentThread
	mov	rcx, QWORD PTR mutex$[rbp]
	cmp	QWORD PTR [rcx+9], rax
	je	SHORT $LN7@AuReleaseM

; 87   : 		return -1;

	mov	eax, -1
	jmp	$LN1@AuReleaseM
$LN7@AuReleaseM:

; 88   : 	}
; 89   : 	AuAcquireSpinlock(mutex->lock);

	mov	rax, QWORD PTR mutex$[rbp]
	mov	rcx, QWORD PTR [rax]
	call	AuAcquireSpinlock

; 90   : 	mutex->status = 0;

	mov	rax, QWORD PTR mutex$[rbp]
	mov	BYTE PTR [rax+8], 0

; 91   : 	mutex->owner = NULL;

	mov	rax, QWORD PTR mutex$[rbp]
	mov	QWORD PTR [rax+9], 0

; 92   : 	for (int i = 0; i < mutex->waiters->pointer; i++) {

	mov	DWORD PTR i$1[rbp], 0
	jmp	SHORT $LN4@AuReleaseM
$LN2@AuReleaseM:
	mov	eax, DWORD PTR i$1[rbp]
	inc	eax
	mov	DWORD PTR i$1[rbp], eax
$LN4@AuReleaseM:
	mov	rax, QWORD PTR mutex$[rbp]
	mov	rax, QWORD PTR [rax+17]
	mov	eax, DWORD PTR [rax]
	cmp	DWORD PTR i$1[rbp], eax
	jae	SHORT $LN3@AuReleaseM

; 93   : 		AuThread* thr_ = (AuThread*)list_remove(mutex->waiters, i);

	mov	edx, DWORD PTR i$1[rbp]
	mov	rax, QWORD PTR mutex$[rbp]
	mov	rcx, QWORD PTR [rax+17]
	call	list_remove
	mov	QWORD PTR thr_$2[rbp], rax

; 94   : 		AuProcess* current_proc = AuProcessFindThread(thr_);

	mov	rcx, QWORD PTR thr_$2[rbp]
	call	?AuProcessFindThread@@YAPEAU_au_proc_@@PEAU_au_thread_@@@Z ; AuProcessFindThread
	mov	QWORD PTR current_proc$3[rbp], rax

; 95   : 		if (thr_) {

	cmp	QWORD PTR thr_$2[rbp], 0
	je	SHORT $LN8@AuReleaseM

; 96   : 			current_proc->state = 0;

	mov	rax, QWORD PTR current_proc$3[rbp]
	mov	BYTE PTR [rax+20], 0

; 97   : 			current_proc->state |= PROCESS_STATE_READY;

	mov	rax, QWORD PTR current_proc$3[rbp]
	movzx	eax, BYTE PTR [rax+20]
	or	eax, 2
	mov	rcx, QWORD PTR current_proc$3[rbp]
	mov	BYTE PTR [rcx+20], al

; 98   : 			AuUnblockThread(thr_);

	mov	rcx, QWORD PTR thr_$2[rbp]
	call	AuUnblockThread
$LN8@AuReleaseM:

; 99   : 		}
; 100  : 	}

	jmp	SHORT $LN2@AuReleaseM
$LN3@AuReleaseM:

; 101  : 	SeTextOut("Mutex released \r\n");

	lea	rcx, OFFSET FLAT:??_C@_0BC@MCOMLLKC@Mutex?5released?5?$AN?6@
	call	SeTextOut

; 102  : 	AuReleaseSpinlock(mutex->lock);

	mov	rax, QWORD PTR mutex$[rbp]
	mov	rcx, QWORD PTR [rax]
	call	AuReleaseSpinlock

; 103  : 	return 0;

	xor	eax, eax
$LN1@AuReleaseM:

; 104  : }

	lea	rsp, QWORD PTR [rbp+96]
	pop	rbp
	ret	0
AuReleaseMutex ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Sync\mutex.cpp
;	COMDAT AuAcquireMutex
_TEXT	SEGMENT
current_thr$ = 0
current_proc$ = 8
mut$ = 96
AuAcquireMutex PROC					; COMDAT

; 53   : AU_EXTERN AU_EXPORT int AuAcquireMutex(AuMutex* mut) {

$LN7:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__B1769D37_mutex@cpp
	call	__CheckForDebuggerJustMyCode

; 54   : 	if (!AuIsSchedulerInitialised())

	call	?AuIsSchedulerInitialised@@YA_NXZ	; AuIsSchedulerInitialised
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN4@AuAcquireM

; 55   : 		return 0;

	xor	eax, eax
	jmp	$LN1@AuAcquireM
$LN4@AuAcquireM:

; 56   : 	if (!mut)

	cmp	QWORD PTR mut$[rbp], 0
	jne	SHORT $LN5@AuAcquireM

; 57   : 		return 0;

	xor	eax, eax
	jmp	$LN1@AuAcquireM
$LN5@AuAcquireM:

; 58   : 	x64_cli();

	call	x64_cli

; 59   : 	AuAcquireSpinlock(mut->lock);

	mov	rax, QWORD PTR mut$[rbp]
	mov	rcx, QWORD PTR [rax]
	call	AuAcquireSpinlock

; 60   : 	AuThread* current_thr = AuGetCurrentThread();

	call	AuGetCurrentThread
	mov	QWORD PTR current_thr$[rbp], rax

; 61   : 	AuProcess* current_proc = AuProcessFindThread(current_thr);

	mov	rcx, QWORD PTR current_thr$[rbp]
	call	?AuProcessFindThread@@YAPEAU_au_proc_@@PEAU_au_thread_@@@Z ; AuProcessFindThread
	mov	QWORD PTR current_proc$[rbp], rax
$LN2@AuAcquireM:

; 62   : 	while (mut->status) {

	mov	rax, QWORD PTR mut$[rbp]
	movzx	eax, BYTE PTR [rax+8]
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@AuAcquireM

; 63   : 		list_add(mut->waiters, current_thr);

	mov	rdx, QWORD PTR current_thr$[rbp]
	mov	rax, QWORD PTR mut$[rbp]
	mov	rcx, QWORD PTR [rax+17]
	call	list_add

; 64   : 		current_proc->state = 0;

	mov	rax, QWORD PTR current_proc$[rbp]
	mov	BYTE PTR [rax+20], 0

; 65   : 		current_proc->state |= PROCESS_STATE_BUSY_WAIT;

	mov	rax, QWORD PTR current_proc$[rbp]
	movzx	eax, BYTE PTR [rax+20]
	or	eax, 64					; 00000040H
	mov	rcx, QWORD PTR current_proc$[rbp]
	mov	BYTE PTR [rcx+20], al

; 66   : 		AuBlockThread(current_thr);

	mov	rcx, QWORD PTR current_thr$[rbp]
	call	AuBlockThread

; 67   : 		x64_force_sched();

	call	x64_force_sched

; 68   : 	}

	jmp	SHORT $LN2@AuAcquireM
$LN3@AuAcquireM:

; 69   : 
; 70   : 	mut->status = 1;

	mov	rax, QWORD PTR mut$[rbp]
	mov	BYTE PTR [rax+8], 1

; 71   : 	mut->owner = current_thr;

	mov	rax, QWORD PTR mut$[rbp]
	mov	rcx, QWORD PTR current_thr$[rbp]
	mov	QWORD PTR [rax+9], rcx

; 72   : 	SeTextOut("Mutex acquired \r\n");

	lea	rcx, OFFSET FLAT:??_C@_0BC@FKNNBGMF@Mutex?5acquired?5?$AN?6@
	call	SeTextOut

; 73   : 	AuReleaseSpinlock(mut->lock);

	mov	rax, QWORD PTR mut$[rbp]
	mov	rcx, QWORD PTR [rax]
	call	AuReleaseSpinlock

; 74   : 	return 0;

	xor	eax, eax
$LN1@AuAcquireM:

; 75   : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
AuAcquireMutex ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Sync\mutex.cpp
;	COMDAT AuCreateMutex
_TEXT	SEGMENT
mut$ = 0
AuCreateMutex PROC					; COMDAT

; 41   : AU_EXTERN AU_EXPORT AuMutex* AuCreateMutex() {

$LN3:
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__B1769D37_mutex@cpp
	call	__CheckForDebuggerJustMyCode

; 42   : 	AuMutex* mut = (AuMutex*)kmalloc(sizeof(AuMutex));

	mov	ecx, 25
	call	kmalloc
	mov	QWORD PTR mut$[rbp], rax

; 43   : 	mut->lock = AuCreateSpinlock(false);

	xor	ecx, ecx
	call	AuCreateSpinlock
	mov	rcx, QWORD PTR mut$[rbp]
	mov	QWORD PTR [rcx], rax

; 44   : 	mut->owner = NULL;

	mov	rax, QWORD PTR mut$[rbp]
	mov	QWORD PTR [rax+9], 0

; 45   : 	mut->waiters = initialize_list();

	call	initialize_list
	mov	rcx, QWORD PTR mut$[rbp]
	mov	QWORD PTR [rcx+17], rax

; 46   : 	return mut;

	mov	rax, QWORD PTR mut$[rbp]

; 47   : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
AuCreateMutex ENDP
_TEXT	ENDS
END
