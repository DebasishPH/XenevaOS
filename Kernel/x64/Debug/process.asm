; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.21005.1 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?proc_root@@3PEAU_au_proc_@@EA			; proc_root
_BSS	SEGMENT
?proc_root@@3PEAU_au_proc_@@EA DQ 01H DUP (?)		; proc_root
_BSS	ENDS
CONST	SEGMENT
$SG3838	DB	'_root', 00H
	ORG $+2
$SG3867	DB	'-about', 00H
	ORG $+1
$SG3868	DB	'/init.exe', 00H
	ORG $+6
$SG3906	DB	'[aurora]: cannot exit root process ', 0dH, 0aH, 00H
CONST	ENDS
_DATA	SEGMENT
pid	DD	01H
_DATA	ENDS
PUBLIC	?AuAddProcess@@YAXPEAU_au_proc_@@0@Z		; AuAddProcess
PUBLIC	?AuProcessFindPID@@YAPEAU_au_proc_@@H@Z		; AuProcessFindPID
PUBLIC	?AuProcessFindThread@@YAPEAU_au_proc_@@PEAU_au_thread_@@@Z ; AuProcessFindThread
PUBLIC	?CreateUserStack@@YAPEA_KPEA_K@Z		; CreateUserStack
PUBLIC	?AuStartRootProc@@YAXXZ				; AuStartRootProc
PUBLIC	?AuGetRootProcess@@YAPEAU_au_proc_@@XZ		; AuGetRootProcess
PUBLIC	?AuCreateProcessSlot@@YAPEAU_au_proc_@@PEAU1@PEAD@Z ; AuCreateProcessSlot
PUBLIC	?AuProcessExit@@YAXPEAU_au_proc_@@@Z		; AuProcessExit
PUBLIC	?AuProcessGetFileDesc@@YAHPEAU_au_proc_@@@Z	; AuProcessGetFileDesc
PUBLIC	?AuProcessWaitForTermination@@YAXPEAU_au_proc_@@H@Z ; AuProcessWaitForTermination
PUBLIC	?AuRemoveProcess@@YAXPEAU_au_proc_@@0@Z		; AuRemoveProcess
PUBLIC	?AuProcessFindByPID@@YAPEAU_au_proc_@@PEAU1@H@Z	; AuProcessFindByPID
PUBLIC	?AuProcessFindByThread@@YAPEAU_au_proc_@@PEAU1@PEAU_au_thread_@@@Z ; AuProcessFindByThread
PUBLIC	?AuAllocateProcessID@@YAHXZ			; AuAllocateProcessID
PUBLIC	?AuCreateRootProc@@YAPEAU_au_proc_@@XZ		; AuCreateRootProc
PUBLIC	?AuGetKillableProcess@@YAPEAU_au_proc_@@PEAU1@@Z ; AuGetKillableProcess
EXTRN	initialize_list:PROC
EXTRN	list_add:PROC
EXTRN	list_remove:PROC
EXTRN	list_get_at:PROC
EXTRN	AuBlockThread:PROC
EXTRN	AuUnblockThread:PROC
EXTRN	?AuThreadMoveToTrash@@YAXPEAU_au_thread_@@@Z:PROC ; AuThreadMoveToTrash
EXTRN	AuMapPageEx:PROC
EXTRN	AuCreateVirtualAddressSpace:PROC
EXTRN	kmalloc:PROC
EXTRN	kfree:PROC
EXTRN	AuPmmngrAlloc:PROC
EXTRN	P2V:PROC
EXTRN	V2P:PROC
EXTRN	strcpy:PROC
EXTRN	memset:PROC
EXTRN	x64_force_sched:PROC
EXTRN	SeTextOut:PROC
EXTRN	?AuLoadExecToProcess@@YAXPEAU_au_proc_@@PEADHPEAPEAD@Z:PROC ; AuLoadExecToProcess
EXTRN	?AuProcessClean@@YAXPEAU_au_proc_@@0@Z:PROC	; AuProcessClean
EXTRN	?AuSHMUnmapAll@@YAXPEAU_au_proc_@@@Z:PROC	; AuSHMUnmapAll
pdata	SEGMENT
$pdata$?AuAddProcess@@YAXPEAU_au_proc_@@0@Z DD imagerel $LN5
	DD	imagerel $LN5+65
	DD	imagerel $unwind$?AuAddProcess@@YAXPEAU_au_proc_@@0@Z
$pdata$?AuProcessFindPID@@YAPEAU_au_proc_@@H@Z DD imagerel $LN3
	DD	imagerel $LN3+39
	DD	imagerel $unwind$?AuProcessFindPID@@YAPEAU_au_proc_@@H@Z
$pdata$?AuProcessFindThread@@YAPEAU_au_proc_@@PEAU_au_thread_@@@Z DD imagerel $LN3
	DD	imagerel $LN3+41
	DD	imagerel $unwind$?AuProcessFindThread@@YAPEAU_au_proc_@@PEAU_au_thread_@@@Z
$pdata$?CreateUserStack@@YAPEA_KPEA_K@Z DD imagerel $LN6
	DD	imagerel $LN6+146
	DD	imagerel $unwind$?CreateUserStack@@YAPEA_KPEA_K@Z
$pdata$?AuStartRootProc@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+112
	DD	imagerel $unwind$?AuStartRootProc@@YAXXZ
$pdata$?AuCreateProcessSlot@@YAPEAU_au_proc_@@PEAU1@PEAD@Z DD imagerel $LN6
	DD	imagerel $LN6+333
	DD	imagerel $unwind$?AuCreateProcessSlot@@YAPEAU_au_proc_@@PEAU1@PEAD@Z
$pdata$?AuProcessExit@@YAXPEAU_au_proc_@@@Z DD imagerel $LN17
	DD	imagerel $LN17+397
	DD	imagerel $unwind$?AuProcessExit@@YAXPEAU_au_proc_@@@Z
$pdata$?AuProcessGetFileDesc@@YAHPEAU_au_proc_@@@Z DD imagerel $LN7
	DD	imagerel $LN7+69
	DD	imagerel $unwind$?AuProcessGetFileDesc@@YAHPEAU_au_proc_@@@Z
$pdata$?AuProcessWaitForTermination@@YAXPEAU_au_proc_@@H@Z DD imagerel $LN8
	DD	imagerel $LN8+99
	DD	imagerel $unwind$?AuProcessWaitForTermination@@YAXPEAU_au_proc_@@H@Z
$pdata$?AuRemoveProcess@@YAXPEAU_au_proc_@@0@Z DD imagerel $LN7
	DD	imagerel $LN7+136
	DD	imagerel $unwind$?AuRemoveProcess@@YAXPEAU_au_proc_@@0@Z
$pdata$?AuProcessFindByPID@@YAPEAU_au_proc_@@PEAU1@H@Z DD imagerel $LN8
	DD	imagerel $LN8+151
	DD	imagerel $unwind$?AuProcessFindByPID@@YAPEAU_au_proc_@@PEAU1@H@Z
$pdata$?AuProcessFindByThread@@YAPEAU_au_proc_@@PEAU1@PEAU_au_thread_@@@Z DD imagerel $LN8
	DD	imagerel $LN8+156
	DD	imagerel $unwind$?AuProcessFindByThread@@YAPEAU_au_proc_@@PEAU1@PEAU_au_thread_@@@Z
$pdata$?AuAllocateProcessID@@YAHXZ DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$?AuAllocateProcessID@@YAHXZ
$pdata$?AuCreateRootProc@@YAPEAU_au_proc_@@XZ DD imagerel $LN6
	DD	imagerel $LN6+292
	DD	imagerel $unwind$?AuCreateRootProc@@YAPEAU_au_proc_@@XZ
$pdata$?AuGetKillableProcess@@YAPEAU_au_proc_@@PEAU1@@Z DD imagerel $LN9
	DD	imagerel $LN9+162
	DD	imagerel $unwind$?AuGetKillableProcess@@YAPEAU_au_proc_@@PEAU1@@Z
pdata	ENDS
xdata	SEGMENT
$unwind$?AuAddProcess@@YAXPEAU_au_proc_@@0@Z DD 010e01H
	DD	0420eH
$unwind$?AuProcessFindPID@@YAPEAU_au_proc_@@H@Z DD 010801H
	DD	06208H
$unwind$?AuProcessFindThread@@YAPEAU_au_proc_@@PEAU_au_thread_@@@Z DD 010901H
	DD	06209H
$unwind$?CreateUserStack@@YAPEA_KPEA_K@Z DD 010901H
	DD	08209H
$unwind$?AuStartRootProc@@YAXXZ DD 010401H
	DD	08204H
$unwind$?AuCreateProcessSlot@@YAPEAU_au_proc_@@PEAU1@PEAD@Z DD 010e01H
	DD	0820eH
$unwind$?AuProcessExit@@YAXPEAU_au_proc_@@@Z DD 010901H
	DD	08209H
$unwind$?AuProcessGetFileDesc@@YAHPEAU_au_proc_@@@Z DD 010901H
	DD	02209H
$unwind$?AuProcessWaitForTermination@@YAXPEAU_au_proc_@@H@Z DD 010d01H
	DD	0620dH
$unwind$?AuRemoveProcess@@YAXPEAU_au_proc_@@0@Z DD 010e01H
	DD	0620eH
$unwind$?AuProcessFindByPID@@YAPEAU_au_proc_@@PEAU1@H@Z DD 010d01H
	DD	0820dH
$unwind$?AuProcessFindByThread@@YAPEAU_au_proc_@@PEAU1@PEAU_au_thread_@@@Z DD 010e01H
	DD	0820eH
$unwind$?AuAllocateProcessID@@YAHXZ DD 010401H
	DD	02204H
$unwind$?AuCreateRootProc@@YAPEAU_au_proc_@@XZ DD 010401H
	DD	08204H
$unwind$?AuGetKillableProcess@@YAPEAU_au_proc_@@PEAU1@@Z DD 010901H
	DD	08209H
xdata	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\process.cpp
_TEXT	SEGMENT
i$1 = 32
found$ = 40
proc_$2 = 48
proc$ = 80
?AuGetKillableProcess@@YAPEAU_au_proc_@@PEAU1@@Z PROC	; AuGetKillableProcess

; 264  : AuProcess* AuGetKillableProcess(AuProcess* proc) {

$LN9:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 265  : 	if (proc->state & PROCESS_STATE_DIED || proc->state & PROCESS_STATE_ZOMBIE)

	mov	rax, QWORD PTR proc$[rsp]
	movzx	eax, BYTE PTR [rax+12]
	and	eax, 4
	test	eax, eax
	jne	SHORT $LN5@AuGetKilla
	mov	rax, QWORD PTR proc$[rsp]
	movzx	eax, BYTE PTR [rax+12]
	and	eax, 5
	test	eax, eax
	je	SHORT $LN6@AuGetKilla
$LN5@AuGetKilla:

; 266  : 		return proc;

	mov	rax, QWORD PTR proc$[rsp]
	jmp	SHORT $LN7@AuGetKilla
$LN6@AuGetKilla:

; 267  : 
; 268  : 	AuProcess *found = NULL;

	mov	QWORD PTR found$[rsp], 0

; 269  : 	for (int i = 0; i < proc->childs->pointer; i++) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN4@AuGetKilla
$LN3@AuGetKilla:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN4@AuGetKilla:
	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+1047]
	mov	eax, DWORD PTR [rax]
	cmp	DWORD PTR i$1[rsp], eax
	jae	SHORT $LN2@AuGetKilla

; 270  : 		AuProcess *proc_ = (AuProcess*)list_get_at(proc->childs, i);

	mov	edx, DWORD PTR i$1[rsp]
	mov	rax, QWORD PTR proc$[rsp]
	mov	rcx, QWORD PTR [rax+1047]
	call	list_get_at
	mov	QWORD PTR proc_$2[rsp], rax

; 271  : 		found = AuGetKillableProcess(proc_);

	mov	rcx, QWORD PTR proc_$2[rsp]
	call	?AuGetKillableProcess@@YAPEAU_au_proc_@@PEAU1@@Z ; AuGetKillableProcess
	mov	QWORD PTR found$[rsp], rax

; 272  : 		if (found) return found;

	cmp	QWORD PTR found$[rsp], 0
	je	SHORT $LN1@AuGetKilla
	mov	rax, QWORD PTR found$[rsp]
	jmp	SHORT $LN7@AuGetKilla
$LN1@AuGetKilla:

; 273  : 	}

	jmp	SHORT $LN3@AuGetKilla
$LN2@AuGetKilla:

; 274  : 
; 275  : 	return NULL;

	xor	eax, eax
$LN7@AuGetKilla:

; 276  : }

	add	rsp, 72					; 00000048H
	ret	0
?AuGetKillableProcess@@YAPEAU_au_proc_@@PEAU1@@Z ENDP	; AuGetKillableProcess
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\process.cpp
_TEXT	SEGMENT
i$1 = 32
proc$ = 40
cr3$ = 48
main_thr_stack$ = 56
?AuCreateRootProc@@YAPEAU_au_proc_@@XZ PROC		; AuCreateRootProc

; 168  : AuProcess* AuCreateRootProc() {

$LN6:
	sub	rsp, 72					; 00000048H

; 169  : 	AuProcess *proc = (AuProcess*)kmalloc(sizeof(AuProcess));

	mov	ecx, 1095				; 00000447H
	call	kmalloc
	mov	QWORD PTR proc$[rsp], rax

; 170  : 	memset(proc, 0, sizeof(AuProcess));

	mov	r8d, 1095				; 00000447H
	xor	edx, edx
	mov	rcx, QWORD PTR proc$[rsp]
	call	memset

; 171  : 
; 172  : 	proc->proc_id = AuAllocateProcessID();

	call	?AuAllocateProcessID@@YAHXZ		; AuAllocateProcessID
	mov	rcx, QWORD PTR proc$[rsp]
	mov	DWORD PTR [rcx], eax

; 173  : 	strcpy(proc->name, "_root");

	mov	rax, QWORD PTR proc$[rsp]
	add	rax, 4
	lea	rdx, OFFSET FLAT:$SG3838
	mov	rcx, rax
	call	strcpy

; 174  : 
; 175  : 	/* create empty virtual address space */
; 176  : 	uint64_t* cr3 = AuCreateVirtualAddressSpace();

	call	AuCreateVirtualAddressSpace
	mov	QWORD PTR cr3$[rsp], rax

; 177  : 	/* create the process main thread stack */
; 178  : 	uint64_t  main_thr_stack = (uint64_t)CreateUserStack(cr3);

	mov	rcx, QWORD PTR cr3$[rsp]
	call	?CreateUserStack@@YAPEA_KPEA_K@Z	; CreateUserStack
	mov	QWORD PTR main_thr_stack$[rsp], rax

; 179  : 	proc->state = PROCESS_STATE_NOT_READY;

	mov	rax, QWORD PTR proc$[rsp]
	mov	BYTE PTR [rax+12], 1

; 180  : 	proc->cr3 = cr3;

	mov	rax, QWORD PTR proc$[rsp]
	mov	rcx, QWORD PTR cr3$[rsp]
	mov	QWORD PTR [rax+14], rcx

; 181  : 	proc->_main_stack_ = main_thr_stack;

	mov	rax, QWORD PTR proc$[rsp]
	mov	rcx, QWORD PTR main_thr_stack$[rsp]
	mov	QWORD PTR [rax+38], rcx

; 182  : 	proc->childs = initialize_list();

	call	initialize_list
	mov	rcx, QWORD PTR proc$[rsp]
	mov	QWORD PTR [rcx+1047], rax

; 183  : 	proc->vmareas = initialize_list();

	call	initialize_list
	mov	rcx, QWORD PTR proc$[rsp]
	mov	QWORD PTR [rcx+1055], rax

; 184  : 	proc->shmmaps = initialize_list();

	call	initialize_list
	mov	rcx, QWORD PTR proc$[rsp]
	mov	QWORD PTR [rcx+1063], rax

; 185  : 	proc->shm_break = USER_SHARED_MEM_START;

	mov	rax, QWORD PTR proc$[rsp]
	mov	ecx, -2147483648			; 80000000H
	mov	QWORD PTR [rax+1071], rcx

; 186  : 	proc->proc_mem_heap = PROCESS_BREAK_ADDRESS;

	mov	rax, QWORD PTR proc$[rsp]
	mov	QWORD PTR [rax+1079], 805306368		; 30000000H

; 187  : 	for (int i = 0; i < FILE_DESC_PER_PROCESS; i++)

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN3@AuCreateRo
$LN2@AuCreateRo:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN3@AuCreateRo:
	cmp	DWORD PTR i$1[rsp], 60			; 0000003cH
	jge	SHORT $LN1@AuCreateRo

; 188  : 		proc->fds[i] = 0;

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR proc$[rsp]
	mov	QWORD PTR [rcx+rax*8+543], 0
	jmp	SHORT $LN2@AuCreateRo
$LN1@AuCreateRo:

; 189  : 
; 190  : 	/* create the main thread after loading the
; 191  : 	 * image file to process, because just after
; 192  : 	 * creating the thread, scheduler starts
; 193  : 	 * scheduling that thread
; 194  : 	 */
; 195  : 	AuAddProcess(NULL,proc);

	mov	rdx, QWORD PTR proc$[rsp]
	xor	ecx, ecx
	call	?AuAddProcess@@YAXPEAU_au_proc_@@0@Z	; AuAddProcess

; 196  : 	return proc;

	mov	rax, QWORD PTR proc$[rsp]

; 197  : }

	add	rsp, 72					; 00000048H
	ret	0
?AuCreateRootProc@@YAPEAU_au_proc_@@XZ ENDP		; AuCreateRootProc
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\process.cpp
_TEXT	SEGMENT
_pid$ = 0
?AuAllocateProcessID@@YAHXZ PROC			; AuAllocateProcessID

; 159  : int AuAllocateProcessID() {

$LN3:
	sub	rsp, 24

; 160  : 	size_t _pid = pid;

	movsxd	rax, DWORD PTR pid
	mov	QWORD PTR _pid$[rsp], rax

; 161  : 	pid = pid + 1;

	mov	eax, DWORD PTR pid
	inc	eax
	mov	DWORD PTR pid, eax

; 162  : 	return _pid;

	mov	eax, DWORD PTR _pid$[rsp]

; 163  : }

	add	rsp, 24
	ret	0
?AuAllocateProcessID@@YAHXZ ENDP			; AuAllocateProcessID
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\process.cpp
_TEXT	SEGMENT
i$1 = 32
found$ = 40
proc_$2 = 48
proc$ = 80
thread$ = 88
?AuProcessFindByThread@@YAPEAU_au_proc_@@PEAU1@PEAU_au_thread_@@@Z PROC ; AuProcessFindByThread

; 103  : AuProcess* AuProcessFindByThread(AuProcess* proc, AuThread* thread) {

$LN8:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 104  : 	if (proc->main_thread == thread) {

	mov	rax, QWORD PTR proc$[rsp]
	mov	rcx, QWORD PTR thread$[rsp]
	cmp	QWORD PTR [rax+46], rcx
	jne	SHORT $LN5@AuProcessF

; 105  : 		return proc;

	mov	rax, QWORD PTR proc$[rsp]
	jmp	SHORT $LN6@AuProcessF
$LN5@AuProcessF:

; 106  : 	}
; 107  : 	AuProcess *found = NULL;

	mov	QWORD PTR found$[rsp], 0

; 108  : 	for (int i = 0; i < proc->childs->pointer; i++) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN4@AuProcessF
$LN3@AuProcessF:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN4@AuProcessF:
	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+1047]
	mov	eax, DWORD PTR [rax]
	cmp	DWORD PTR i$1[rsp], eax
	jae	SHORT $LN2@AuProcessF

; 109  : 		AuProcess *proc_ = (AuProcess*)list_get_at(proc->childs, i);

	mov	edx, DWORD PTR i$1[rsp]
	mov	rax, QWORD PTR proc$[rsp]
	mov	rcx, QWORD PTR [rax+1047]
	call	list_get_at
	mov	QWORD PTR proc_$2[rsp], rax

; 110  : 		found = AuProcessFindByThread(proc_, thread);

	mov	rdx, QWORD PTR thread$[rsp]
	mov	rcx, QWORD PTR proc_$2[rsp]
	call	?AuProcessFindByThread@@YAPEAU_au_proc_@@PEAU1@PEAU_au_thread_@@@Z ; AuProcessFindByThread
	mov	QWORD PTR found$[rsp], rax

; 111  : 		if (found) return found;

	cmp	QWORD PTR found$[rsp], 0
	je	SHORT $LN1@AuProcessF
	mov	rax, QWORD PTR found$[rsp]
	jmp	SHORT $LN6@AuProcessF
$LN1@AuProcessF:

; 112  : 	}

	jmp	SHORT $LN3@AuProcessF
$LN2@AuProcessF:

; 113  : 
; 114  : 	return NULL;

	xor	eax, eax
$LN6@AuProcessF:

; 115  : }

	add	rsp, 72					; 00000048H
	ret	0
?AuProcessFindByThread@@YAPEAU_au_proc_@@PEAU1@PEAU_au_thread_@@@Z ENDP ; AuProcessFindByThread
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\process.cpp
_TEXT	SEGMENT
i$1 = 32
found$ = 40
proc_$2 = 48
proc$ = 80
pid$ = 88
?AuProcessFindByPID@@YAPEAU_au_proc_@@PEAU1@H@Z PROC	; AuProcessFindByPID

; 84   : AuProcess* AuProcessFindByPID(AuProcess* proc, int pid) {

$LN8:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 85   : 	if (proc->proc_id == pid) {

	mov	rax, QWORD PTR proc$[rsp]
	mov	ecx, DWORD PTR pid$[rsp]
	cmp	DWORD PTR [rax], ecx
	jne	SHORT $LN5@AuProcessF

; 86   : 		return proc;

	mov	rax, QWORD PTR proc$[rsp]
	jmp	SHORT $LN6@AuProcessF
$LN5@AuProcessF:

; 87   : 	}
; 88   : 	AuProcess *found = NULL;

	mov	QWORD PTR found$[rsp], 0

; 89   : 	for (int i = 0; i < proc->childs->pointer; i++) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN4@AuProcessF
$LN3@AuProcessF:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN4@AuProcessF:
	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+1047]
	mov	eax, DWORD PTR [rax]
	cmp	DWORD PTR i$1[rsp], eax
	jae	SHORT $LN2@AuProcessF

; 90   : 		AuProcess *proc_ = (AuProcess*)list_get_at(proc->childs, i);

	mov	edx, DWORD PTR i$1[rsp]
	mov	rax, QWORD PTR proc$[rsp]
	mov	rcx, QWORD PTR [rax+1047]
	call	list_get_at
	mov	QWORD PTR proc_$2[rsp], rax

; 91   : 		found = AuProcessFindByPID(proc_, pid);

	mov	edx, DWORD PTR pid$[rsp]
	mov	rcx, QWORD PTR proc_$2[rsp]
	call	?AuProcessFindByPID@@YAPEAU_au_proc_@@PEAU1@H@Z ; AuProcessFindByPID
	mov	QWORD PTR found$[rsp], rax

; 92   : 		if (found) return found;

	cmp	QWORD PTR found$[rsp], 0
	je	SHORT $LN1@AuProcessF
	mov	rax, QWORD PTR found$[rsp]
	jmp	SHORT $LN6@AuProcessF
$LN1@AuProcessF:

; 93   : 	}

	jmp	SHORT $LN3@AuProcessF
$LN2@AuProcessF:

; 94   : 	
; 95   : 	return NULL;

	xor	eax, eax
$LN6@AuProcessF:

; 96   : }

	add	rsp, 72					; 00000048H
	ret	0
?AuProcessFindByPID@@YAPEAU_au_proc_@@PEAU1@H@Z ENDP	; AuProcessFindByPID
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\process.cpp
_TEXT	SEGMENT
i$1 = 32
proc_$2 = 40
parent$ = 64
proc$ = 72
?AuRemoveProcess@@YAXPEAU_au_proc_@@0@Z PROC		; AuRemoveProcess

; 70   : void AuRemoveProcess(AuProcess* parent, AuProcess* proc) {

$LN7:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 71   : 	for (int i = 0; i < parent->childs->pointer; i++) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN4@AuRemovePr
$LN3@AuRemovePr:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN4@AuRemovePr:
	mov	rax, QWORD PTR parent$[rsp]
	mov	rax, QWORD PTR [rax+1047]
	mov	eax, DWORD PTR [rax]
	cmp	DWORD PTR i$1[rsp], eax
	jae	SHORT $LN2@AuRemovePr

; 72   : 		AuProcess* proc_ = (AuProcess*)list_get_at(parent->childs, i);

	mov	edx, DWORD PTR i$1[rsp]
	mov	rax, QWORD PTR parent$[rsp]
	mov	rcx, QWORD PTR [rax+1047]
	call	list_get_at
	mov	QWORD PTR proc_$2[rsp], rax

; 73   : 		if (proc_ = proc)

	mov	rax, QWORD PTR proc$[rsp]
	mov	QWORD PTR proc_$2[rsp], rax
	cmp	QWORD PTR proc_$2[rsp], 0
	je	SHORT $LN1@AuRemovePr

; 74   : 			list_remove(parent->childs, i);

	mov	edx, DWORD PTR i$1[rsp]
	mov	rax, QWORD PTR parent$[rsp]
	mov	rcx, QWORD PTR [rax+1047]
	call	list_remove
$LN1@AuRemovePr:

; 75   : 	}

	jmp	SHORT $LN3@AuRemovePr
$LN2@AuRemovePr:

; 76   : 	kfree(proc);

	mov	rcx, QWORD PTR proc$[rsp]
	call	kfree

; 77   : }

	add	rsp, 56					; 00000038H
	ret	0
?AuRemoveProcess@@YAXPEAU_au_proc_@@0@Z ENDP		; AuRemoveProcess
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\process.cpp
_TEXT	SEGMENT
killable$1 = 32
proc$ = 64
pid$ = 72
?AuProcessWaitForTermination@@YAXPEAU_au_proc_@@H@Z PROC ; AuProcessWaitForTermination

; 288  : void AuProcessWaitForTermination(AuProcess *proc, int pid) {

$LN8:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
$LN5@AuProcessW:

; 289  : 	do {
; 290  : 		AuProcess *killable = AuGetKillableProcess(proc);

	mov	rcx, QWORD PTR proc$[rsp]
	call	?AuGetKillableProcess@@YAPEAU_au_proc_@@PEAU1@@Z ; AuGetKillableProcess
	mov	QWORD PTR killable$1[rsp], rax

; 291  : 
; 292  : 		if (killable) {

	cmp	QWORD PTR killable$1[rsp], 0
	je	SHORT $LN2@AuProcessW

; 293  : 			AuProcessClean(proc, killable);

	mov	rdx, QWORD PTR killable$1[rsp]
	mov	rcx, QWORD PTR proc$[rsp]
	call	?AuProcessClean@@YAXPEAU_au_proc_@@0@Z	; AuProcessClean
$LN2@AuProcessW:

; 294  : 		}
; 295  : 		
; 296  : 		if (!killable){

	cmp	QWORD PTR killable$1[rsp], 0
	jne	SHORT $LN1@AuProcessW

; 297  : 			AuBlockThread(proc->main_thread);

	mov	rax, QWORD PTR proc$[rsp]
	mov	rcx, QWORD PTR [rax+46]
	call	AuBlockThread

; 298  : 			proc->state = PROCESS_STATE_SUSPENDED;

	mov	rax, QWORD PTR proc$[rsp]
	mov	BYTE PTR [rax+12], 3

; 299  : 			x64_force_sched();

	call	x64_force_sched
$LN1@AuProcessW:

; 300  : 		}
; 301  : 	} while (1);

	xor	eax, eax
	cmp	eax, 1
	jne	SHORT $LN5@AuProcessW

; 302  : }

	add	rsp, 56					; 00000038H
	ret	0
?AuProcessWaitForTermination@@YAXPEAU_au_proc_@@H@Z ENDP ; AuProcessWaitForTermination
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\process.cpp
_TEXT	SEGMENT
i$1 = 0
proc$ = 32
?AuProcessGetFileDesc@@YAHPEAU_au_proc_@@@Z PROC	; AuProcessGetFileDesc

; 309  : int AuProcessGetFileDesc(AuProcess* proc) {

$LN7:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 310  : 	for (int i = 0; i < FILE_DESC_PER_PROCESS; i++) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN4@AuProcessG
$LN3@AuProcessG:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN4@AuProcessG:
	cmp	DWORD PTR i$1[rsp], 60			; 0000003cH
	jge	SHORT $LN2@AuProcessG

; 311  : 		if (!proc->fds[i])

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR proc$[rsp]
	cmp	QWORD PTR [rcx+rax*8+543], 0
	jne	SHORT $LN1@AuProcessG

; 312  : 			return i;

	mov	eax, DWORD PTR i$1[rsp]
	jmp	SHORT $LN5@AuProcessG
$LN1@AuProcessG:

; 313  : 	}

	jmp	SHORT $LN3@AuProcessG
$LN2@AuProcessG:

; 314  : 	return -1;

	mov	eax, -1
$LN5@AuProcessG:

; 315  : }

	add	rsp, 24
	ret	0
?AuProcessGetFileDesc@@YAHPEAU_au_proc_@@@Z ENDP	; AuProcessGetFileDesc
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\process.cpp
_TEXT	SEGMENT
i$1 = 32
i$2 = 36
file$3 = 40
killable$4 = 48
proc$ = 80
?AuProcessExit@@YAXPEAU_au_proc_@@@Z PROC		; AuProcessExit

; 322  : void AuProcessExit(AuProcess* proc) {

$LN17:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 323  : 	if (proc == proc_root) {

	mov	rax, QWORD PTR ?proc_root@@3PEAU_au_proc_@@EA ; proc_root
	cmp	QWORD PTR proc$[rsp], rax
	jne	SHORT $LN14@AuProcessE

; 324  : 		SeTextOut("[aurora]: cannot exit root process \r\n");

	lea	rcx, OFFSET FLAT:$SG3906
	call	SeTextOut

; 325  : 		return;

	jmp	$LN15@AuProcessE
$LN14@AuProcessE:

; 326  : 	}
; 327  : 
; 328  : 	proc->state = PROCESS_STATE_DIED;

	mov	rax, QWORD PTR proc$[rsp]
	mov	BYTE PTR [rax+12], 4

; 329  : 
; 330  : 	/* mark all the threads as blocked */
; 331  : 	for (int i = 1; i < proc->num_thread - 1; i++) {

	mov	DWORD PTR i$1[rsp], 1
	jmp	SHORT $LN13@AuProcessE
$LN12@AuProcessE:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN13@AuProcessE:
	mov	rax, QWORD PTR proc$[rsp]
	movzx	eax, BYTE PTR [rax+54]
	dec	eax
	cmp	DWORD PTR i$1[rsp], eax
	jge	SHORT $LN11@AuProcessE

; 332  : 		AuThread *killable = proc->threads[i];

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rcx+rax*8+63]
	mov	QWORD PTR killable$4[rsp], rax

; 333  : 		AuThreadMoveToTrash(killable);

	mov	rcx, QWORD PTR killable$4[rsp]
	call	?AuThreadMoveToTrash@@YAXPEAU_au_thread_@@@Z ; AuThreadMoveToTrash

; 334  : 	}

	jmp	SHORT $LN12@AuProcessE
$LN11@AuProcessE:

; 335  : 
; 336  : 	/* here we free almost every possible
; 337  : 	 * data, that we can free
; 338  : 	 */
; 339  : 	for (int i = 0; i < FILE_DESC_PER_PROCESS; i++) {

	mov	DWORD PTR i$2[rsp], 0
	jmp	SHORT $LN10@AuProcessE
$LN9@AuProcessE:
	mov	eax, DWORD PTR i$2[rsp]
	inc	eax
	mov	DWORD PTR i$2[rsp], eax
$LN10@AuProcessE:
	cmp	DWORD PTR i$2[rsp], 60			; 0000003cH
	jge	SHORT $LN8@AuProcessE

; 340  : 		AuVFSNode *file = proc->fds[i];

	movsxd	rax, DWORD PTR i$2[rsp]
	mov	rcx, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rcx+rax*8+543]
	mov	QWORD PTR file$3[rsp], rax

; 341  : 		if (file) {

	cmp	QWORD PTR file$3[rsp], 0
	je	SHORT $LN7@AuProcessE

; 342  : 			if (file->flags & FS_FLAG_DEVICE || file->flags & FS_FLAG_FILE_SYSTEM)

	mov	rax, QWORD PTR file$3[rsp]
	movzx	eax, BYTE PTR [rax+61]
	and	eax, 8
	test	eax, eax
	jne	SHORT $LN5@AuProcessE
	mov	rax, QWORD PTR file$3[rsp]
	movzx	eax, BYTE PTR [rax+61]
	and	eax, 64					; 00000040H
	test	eax, eax
	je	SHORT $LN6@AuProcessE
$LN5@AuProcessE:

; 343  : 				continue;

	jmp	SHORT $LN9@AuProcessE
$LN6@AuProcessE:

; 344  : 			kfree(file);

	mov	rcx, QWORD PTR file$3[rsp]
	call	kfree
$LN7@AuProcessE:

; 345  : 		}
; 346  : 	}

	jmp	SHORT $LN9@AuProcessE
$LN8@AuProcessE:

; 347  : 	/*unmap all shared memory mappings */
; 348  : 	AuSHMUnmapAll(proc);

	mov	rcx, QWORD PTR proc$[rsp]
	call	?AuSHMUnmapAll@@YAXPEAU_au_proc_@@@Z	; AuSHMUnmapAll

; 349  : 
; 350  : 	kfree(proc->file);

	mov	rax, QWORD PTR proc$[rsp]
	mov	rcx, QWORD PTR [rax+1023]
	call	kfree

; 351  : 
; 352  : 	AuThreadMoveToTrash(proc->main_thread);

	mov	rax, QWORD PTR proc$[rsp]
	mov	rcx, QWORD PTR [rax+46]
	call	?AuThreadMoveToTrash@@YAXPEAU_au_thread_@@@Z ; AuThreadMoveToTrash

; 353  : 
; 354  : 	if (proc->parent) {

	mov	rax, QWORD PTR proc$[rsp]
	cmp	QWORD PTR [rax+1087], 0
	je	SHORT $LN4@AuProcessE

; 355  : 		if (!(proc->parent->state & PROCESS_STATE_SUSPENDED)){

	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+1087]
	movzx	eax, BYTE PTR [rax+12]
	and	eax, 3
	test	eax, eax
	jne	SHORT $LN3@AuProcessE

; 356  : 			proc->state = PROCESS_STATE_ZOMBIE;

	mov	rax, QWORD PTR proc$[rsp]
	mov	BYTE PTR [rax+12], 5

; 357  : 		}
; 358  : 		else {

	jmp	SHORT $LN2@AuProcessE
$LN3@AuProcessE:

; 359  : 			/* else make parent runnable then it will reap
; 360  : 			 * the current process,
; 361  : 			 * in Aurora unblocking a process means, unblocking its
; 362  : 			 * all threads that are suspended, for now only the main
; 363  : 			 * thread
; 364  : 			 */
; 365  : 			AuUnblockThread(proc->parent->main_thread);

	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+1087]
	mov	rcx, QWORD PTR [rax+46]
	call	AuUnblockThread

; 366  : 			proc->parent->state = PROCESS_STATE_READY;

	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+1087]
	mov	BYTE PTR [rax+12], 2
$LN2@AuProcessE:

; 367  : 		}
; 368  : 	}
; 369  : 	else {

	jmp	SHORT $LN1@AuProcessE
$LN4@AuProcessE:

; 370  : 		proc->state = PROCESS_STATE_ZOMBIE;

	mov	rax, QWORD PTR proc$[rsp]
	mov	BYTE PTR [rax+12], 5

; 371  : 		/* unblock the root process */
; 372  : 		AuUnblockThread(proc_root->main_thread);

	mov	rax, QWORD PTR ?proc_root@@3PEAU_au_proc_@@EA ; proc_root
	mov	rcx, QWORD PTR [rax+46]
	call	AuUnblockThread

; 373  : 		proc_root->state = PROCESS_STATE_READY;

	mov	rax, QWORD PTR ?proc_root@@3PEAU_au_proc_@@EA ; proc_root
	mov	BYTE PTR [rax+12], 2
$LN1@AuProcessE:

; 374  : 	}
; 375  : 	x64_force_sched();

	call	x64_force_sched
$LN15@AuProcessE:

; 376  : }

	add	rsp, 72					; 00000048H
	ret	0
?AuProcessExit@@YAXPEAU_au_proc_@@@Z ENDP		; AuProcessExit
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\process.cpp
_TEXT	SEGMENT
i$1 = 32
proc$ = 40
cr3$ = 48
main_thr_stack$ = 56
parent$ = 80
name$ = 88
?AuCreateProcessSlot@@YAPEAU_au_proc_@@PEAU1@PEAD@Z PROC ; AuCreateProcessSlot

; 204  : AuProcess* AuCreateProcessSlot(AuProcess* parent, char* name) {

$LN6:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 205  : 	AuProcess* proc = (AuProcess*)kmalloc(sizeof(AuProcess));

	mov	ecx, 1095				; 00000447H
	call	kmalloc
	mov	QWORD PTR proc$[rsp], rax

; 206  : 	memset(proc, 0, sizeof(AuProcess));

	mov	r8d, 1095				; 00000447H
	xor	edx, edx
	mov	rcx, QWORD PTR proc$[rsp]
	call	memset

; 207  : 
; 208  : 	proc->proc_id = AuAllocateProcessID();

	call	?AuAllocateProcessID@@YAHXZ		; AuAllocateProcessID
	mov	rcx, QWORD PTR proc$[rsp]
	mov	DWORD PTR [rcx], eax

; 209  : 	strcpy(proc->name, name);

	mov	rax, QWORD PTR proc$[rsp]
	add	rax, 4
	mov	rdx, QWORD PTR name$[rsp]
	mov	rcx, rax
	call	strcpy

; 210  : 
; 211  : 	/* create empty virtual address space */
; 212  : 	uint64_t* cr3 = AuCreateVirtualAddressSpace();

	call	AuCreateVirtualAddressSpace
	mov	QWORD PTR cr3$[rsp], rax

; 213  : 	/* create the process main thread stack */
; 214  : 	uint64_t  main_thr_stack = (uint64_t)CreateUserStack(cr3);

	mov	rcx, QWORD PTR cr3$[rsp]
	call	?CreateUserStack@@YAPEA_KPEA_K@Z	; CreateUserStack
	mov	QWORD PTR main_thr_stack$[rsp], rax

; 215  : 	proc->state = PROCESS_STATE_NOT_READY;

	mov	rax, QWORD PTR proc$[rsp]
	mov	BYTE PTR [rax+12], 1

; 216  : 	proc->cr3 = cr3;

	mov	rax, QWORD PTR proc$[rsp]
	mov	rcx, QWORD PTR cr3$[rsp]
	mov	QWORD PTR [rax+14], rcx

; 217  : 	proc->_main_stack_ = main_thr_stack;

	mov	rax, QWORD PTR proc$[rsp]
	mov	rcx, QWORD PTR main_thr_stack$[rsp]
	mov	QWORD PTR [rax+38], rcx

; 218  : 	proc->childs = initialize_list();

	call	initialize_list
	mov	rcx, QWORD PTR proc$[rsp]
	mov	QWORD PTR [rcx+1047], rax

; 219  : 
; 220  : 	proc->vmareas = initialize_list();

	call	initialize_list
	mov	rcx, QWORD PTR proc$[rsp]
	mov	QWORD PTR [rcx+1055], rax

; 221  : 	proc->shmmaps = initialize_list();

	call	initialize_list
	mov	rcx, QWORD PTR proc$[rsp]
	mov	QWORD PTR [rcx+1063], rax

; 222  : 	proc->shm_break = USER_SHARED_MEM_START;

	mov	rax, QWORD PTR proc$[rsp]
	mov	ecx, -2147483648			; 80000000H
	mov	QWORD PTR [rax+1071], rcx

; 223  : 	proc->proc_mem_heap = PROCESS_BREAK_ADDRESS;

	mov	rax, QWORD PTR proc$[rsp]
	mov	QWORD PTR [rax+1079], 805306368		; 30000000H

; 224  : 
; 225  : 	for (int i = 0; i < FILE_DESC_PER_PROCESS; i++)

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN3@AuCreatePr
$LN2@AuCreatePr:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN3@AuCreatePr:
	cmp	DWORD PTR i$1[rsp], 60			; 0000003cH
	jge	SHORT $LN1@AuCreatePr

; 226  : 		proc->fds[i] = 0;

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR proc$[rsp]
	mov	QWORD PTR [rcx+rax*8+543], 0
	jmp	SHORT $LN2@AuCreatePr
$LN1@AuCreatePr:

; 227  : 
; 228  : 	proc->main_thread = NULL;

	mov	rax, QWORD PTR proc$[rsp]
	mov	QWORD PTR [rax+46], 0

; 229  : 
; 230  : 	/* create the main thread after loading the
; 231  : 	* image file to process, because just after
; 232  : 	* creating the thread, scheduler starts
; 233  : 	* scheduling that thread
; 234  : 	*/
; 235  : 	AuAddProcess(parent, proc);

	mov	rdx, QWORD PTR proc$[rsp]
	mov	rcx, QWORD PTR parent$[rsp]
	call	?AuAddProcess@@YAXPEAU_au_proc_@@0@Z	; AuAddProcess

; 236  : 	proc->parent = parent;

	mov	rax, QWORD PTR proc$[rsp]
	mov	rcx, QWORD PTR parent$[rsp]
	mov	QWORD PTR [rax+1087], rcx

; 237  : 	return proc;

	mov	rax, QWORD PTR proc$[rsp]

; 238  : }

	add	rsp, 72					; 00000048H
	ret	0
?AuCreateProcessSlot@@YAPEAU_au_proc_@@PEAU1@PEAD@Z ENDP ; AuCreateProcessSlot
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\process.cpp
_TEXT	SEGMENT
?AuGetRootProcess@@YAPEAU_au_proc_@@XZ PROC		; AuGetRootProcess

; 257  : 	return proc_root;

	mov	rax, QWORD PTR ?proc_root@@3PEAU_au_proc_@@EA ; proc_root

; 258  : }

	ret	0
?AuGetRootProcess@@YAPEAU_au_proc_@@XZ ENDP		; AuGetRootProcess
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\process.cpp
_TEXT	SEGMENT
num_args$ = 32
argvs$ = 40
root_proc$ = 48
?AuStartRootProc@@YAXXZ PROC				; AuStartRootProc

; 244  : void AuStartRootProc() {

$LN3:
	sub	rsp, 72					; 00000048H

; 245  : 	AuProcess* root_proc = AuCreateRootProc();

	call	?AuCreateRootProc@@YAPEAU_au_proc_@@XZ	; AuCreateRootProc
	mov	QWORD PTR root_proc$[rsp], rax

; 246  : 	int num_args = 1;

	mov	DWORD PTR num_args$[rsp], 1

; 247  : 	char** argvs = (char**)kmalloc(6);

	mov	ecx, 6
	call	kmalloc
	mov	QWORD PTR argvs$[rsp], rax

; 248  : 	memset(argvs, 0, 6);

	mov	r8d, 6
	xor	edx, edx
	mov	rcx, QWORD PTR argvs$[rsp]
	call	memset

; 249  : 	argvs[0] = "-about";

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR argvs$[rsp]
	lea	rdx, OFFSET FLAT:$SG3867
	mov	QWORD PTR [rcx+rax], rdx

; 250  : 	AuLoadExecToProcess(root_proc, "/init.exe",num_args,argvs);

	mov	r9, QWORD PTR argvs$[rsp]
	mov	r8d, DWORD PTR num_args$[rsp]
	lea	rdx, OFFSET FLAT:$SG3868
	mov	rcx, QWORD PTR root_proc$[rsp]
	call	?AuLoadExecToProcess@@YAXPEAU_au_proc_@@PEADHPEAPEAD@Z ; AuLoadExecToProcess

; 251  : }

	add	rsp, 72					; 00000048H
	ret	0
?AuStartRootProc@@YAXXZ ENDP				; AuStartRootProc
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\process.cpp
_TEXT	SEGMENT
i$1 = 32
location$ = 40
blk$2 = 48
tv73 = 56
cr3$ = 80
?CreateUserStack@@YAPEA_KPEA_K@Z PROC			; CreateUserStack

; 142  : uint64_t* CreateUserStack(uint64_t* cr3) {

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 143  : #define USER_STACK 0x0000700000000000 
; 144  : 	uint64_t location = USER_STACK;

	mov	rax, 123145302310912			; 0000700000000000H
	mov	QWORD PTR location$[rsp], rax

; 145  : 
; 146  : 	for (int i = 0; i < PROCESS_USER_STACK_SZ / 4096; i++) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN3@CreateUser
$LN2@CreateUser:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN3@CreateUser:
	cmp	DWORD PTR i$1[rsp], 64			; 00000040H
	jge	SHORT $LN1@CreateUser

; 147  : 		uint64_t* blk = (uint64_t*)P2V((size_t)AuPmmngrAlloc());

	call	AuPmmngrAlloc
	mov	rcx, rax
	call	P2V
	mov	QWORD PTR blk$2[rsp], rax

; 148  : 		AuMapPageEx(cr3, V2P((size_t)blk), location + i * PAGE_SIZE, X86_64_PAGING_USER);

	imul	eax, DWORD PTR i$1[rsp], 4096		; 00001000H
	cdqe
	mov	rcx, QWORD PTR location$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR tv73[rsp], rax
	mov	rcx, QWORD PTR blk$2[rsp]
	call	V2P
	mov	r9b, 4
	mov	rcx, QWORD PTR tv73[rsp]
	mov	r8, rcx
	mov	rdx, rax
	mov	rcx, QWORD PTR cr3$[rsp]
	call	AuMapPageEx

; 149  : 	}

	jmp	SHORT $LN2@CreateUser
$LN1@CreateUser:

; 150  : 
; 151  : 	return (uint64_t*)(USER_STACK + (PROCESS_USER_STACK_SZ));

	mov	rax, 123145302573056			; 0000700000040000H

; 152  : }

	add	rsp, 72					; 00000048H
	ret	0
?CreateUserStack@@YAPEA_KPEA_K@Z ENDP			; CreateUserStack
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\process.cpp
_TEXT	SEGMENT
proc_$ = 32
thread$ = 64
?AuProcessFindThread@@YAPEAU_au_proc_@@PEAU_au_thread_@@@Z PROC ; AuProcessFindThread

; 132  : AuProcess *AuProcessFindThread(AuThread* thread) {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 133  : 	AuProcess* proc_ = AuProcessFindByThread(proc_root, thread);

	mov	rdx, QWORD PTR thread$[rsp]
	mov	rcx, QWORD PTR ?proc_root@@3PEAU_au_proc_@@EA ; proc_root
	call	?AuProcessFindByThread@@YAPEAU_au_proc_@@PEAU1@PEAU_au_thread_@@@Z ; AuProcessFindByThread
	mov	QWORD PTR proc_$[rsp], rax

; 134  : 	return proc_;

	mov	rax, QWORD PTR proc_$[rsp]

; 135  : }

	add	rsp, 56					; 00000038H
	ret	0
?AuProcessFindThread@@YAPEAU_au_proc_@@PEAU_au_thread_@@@Z ENDP ; AuProcessFindThread
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\process.cpp
_TEXT	SEGMENT
proc_$ = 32
pid$ = 64
?AuProcessFindPID@@YAPEAU_au_proc_@@H@Z PROC		; AuProcessFindPID

; 122  : AuProcess *AuProcessFindPID(int pid) {

$LN3:
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 56					; 00000038H

; 123  : 	AuProcess *proc_ = AuProcessFindByPID(proc_root, pid);

	mov	edx, DWORD PTR pid$[rsp]
	mov	rcx, QWORD PTR ?proc_root@@3PEAU_au_proc_@@EA ; proc_root
	call	?AuProcessFindByPID@@YAPEAU_au_proc_@@PEAU1@H@Z ; AuProcessFindByPID
	mov	QWORD PTR proc_$[rsp], rax

; 124  : 	return proc_;

	mov	rax, QWORD PTR proc_$[rsp]

; 125  : }

	add	rsp, 56					; 00000038H
	ret	0
?AuProcessFindPID@@YAPEAU_au_proc_@@H@Z ENDP		; AuProcessFindPID
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\process.cpp
_TEXT	SEGMENT
parent$ = 48
proc$ = 56
?AuAddProcess@@YAXPEAU_au_proc_@@0@Z PROC		; AuAddProcess

; 57   : void AuAddProcess(AuProcess* parent, AuProcess *proc) {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 58   : 	if (!proc_root)

	cmp	QWORD PTR ?proc_root@@3PEAU_au_proc_@@EA, 0 ; proc_root
	jne	SHORT $LN2@AuAddProce

; 59   : 		proc_root = proc;

	mov	rax, QWORD PTR proc$[rsp]
	mov	QWORD PTR ?proc_root@@3PEAU_au_proc_@@EA, rax ; proc_root

; 60   : 	else

	jmp	SHORT $LN1@AuAddProce
$LN2@AuAddProce:

; 61   : 		list_add(parent->childs, proc);

	mov	rdx, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR parent$[rsp]
	mov	rcx, QWORD PTR [rax+1047]
	call	list_add
$LN1@AuAddProce:

; 62   : }

	add	rsp, 40					; 00000028H
	ret	0
?AuAddProcess@@YAXPEAU_au_proc_@@0@Z ENDP		; AuAddProcess
_TEXT	ENDS
END
