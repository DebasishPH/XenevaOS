; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.21005.1 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?proc_first@@3PEAU_au_proc_@@EA			; proc_first
PUBLIC	?proc_last@@3PEAU_au_proc_@@EA			; proc_last
PUBLIC	?root_proc@@3PEAU_au_proc_@@EA			; root_proc
PUBLIC	?process_mutex@@3PEAU_mutex_@@EA		; process_mutex
_BSS	SEGMENT
?proc_first@@3PEAU_au_proc_@@EA DQ 01H DUP (?)		; proc_first
?proc_last@@3PEAU_au_proc_@@EA DQ 01H DUP (?)		; proc_last
?root_proc@@3PEAU_au_proc_@@EA DQ 01H DUP (?)		; root_proc
?process_mutex@@3PEAU_mutex_@@EA DQ 01H DUP (?)		; process_mutex
_BSS	ENDS
CONST	SEGMENT
$SG4216	DB	'_root', 00H
	ORG $+2
$SG4243	DB	'-about', 00H
	ORG $+1
$SG4248	DB	'/init.exe', 00H
	ORG $+6
$SG4304	DB	'[aurora]: cannot exit root process ', 0dH, 0aH, 00H
	ORG $+2
$SG4317	DB	'Closing file -> %s , address -> %x ', 0dH, 0aH, 00H
	ORG $+2
$SG4331	DB	'closing process -> %s ', 0dH, 0aH, 00H
CONST	ENDS
_DATA	SEGMENT
pid	DD	01H
_DATA	ENDS
PUBLIC	?AuAddProcess@@YAXPEAU_au_proc_@@0@Z		; AuAddProcess
PUBLIC	?AuRemoveProcess@@YAXPEAU_au_proc_@@0@Z		; AuRemoveProcess
PUBLIC	?CreateKernelStack@@YA_KPEAU_au_proc_@@PEA_K@Z	; CreateKernelStack
PUBLIC	?KernelStackFree@@YAXPEAU_au_proc_@@PEAXPEA_K@Z	; KernelStackFree
PUBLIC	?AuProcessFindPID@@YAPEAU_au_proc_@@H@Z		; AuProcessFindPID
PUBLIC	?AuProcessFindThread@@YAPEAU_au_proc_@@PEAU_au_thread_@@@Z ; AuProcessFindThread
PUBLIC	?AuProcessFindSubThread@@YAPEAU_au_proc_@@PEAU_au_thread_@@@Z ; AuProcessFindSubThread
PUBLIC	?CreateUserStack@@YAPEA_KPEAU_au_proc_@@PEA_K@Z	; CreateUserStack
PUBLIC	?AuStartRootProc@@YAXXZ				; AuStartRootProc
PUBLIC	?AuGetRootProcess@@YAPEAU_au_proc_@@XZ		; AuGetRootProcess
PUBLIC	?AuCreateProcessSlot@@YAPEAU_au_proc_@@PEAU1@PEAD@Z ; AuCreateProcessSlot
PUBLIC	?AuProcessExit@@YAXPEAU_au_proc_@@_N@Z		; AuProcessExit
PUBLIC	?AuProcessGetFileDesc@@YAHPEAU_au_proc_@@@Z	; AuProcessGetFileDesc
PUBLIC	?AuProcessWaitForTermination@@YAXPEAU_au_proc_@@H@Z ; AuProcessWaitForTermination
PUBLIC	?AuProcessGetMutex@@YAPEAU_mutex_@@XZ		; AuProcessGetMutex
PUBLIC	?AuCreateUserthread@@YAHPEAU_au_proc_@@P6AXPEAX@ZPEAD@Z ; AuCreateUserthread
PUBLIC	?AuProcessFindByPID@@YAPEAU_au_proc_@@PEAU1@H@Z	; AuProcessFindByPID
PUBLIC	?AuProcessFindByThread@@YAPEAU_au_proc_@@PEAU1@PEAU_au_thread_@@@Z ; AuProcessFindByThread
PUBLIC	?AuAllocateProcessID@@YAHXZ			; AuAllocateProcessID
PUBLIC	?AuCreateRootProc@@YAPEAU_au_proc_@@XZ		; AuCreateRootProc
PUBLIC	?AuGetKillableProcess@@YAPEAU_au_proc_@@XZ	; AuGetKillableProcess
PUBLIC	?AuProcessHeapMemDestroy@@YAXPEAU_au_proc_@@@Z	; AuProcessHeapMemDestroy
PUBLIC	?AuProcessFreeKeResource@@YAXPEAU_au_thread_@@@Z ; AuProcessFreeKeResource
EXTRN	initialize_list:PROC
EXTRN	list_add:PROC
EXTRN	list_remove:PROC
EXTRN	AuCreateKthread:PROC
EXTRN	AuGetCurrentThread:PROC
EXTRN	AuBlockThread:PROC
EXTRN	AuSleepThread:PROC
EXTRN	AuUnblockThread:PROC
EXTRN	?AuThreadMoveToTrash@@YAXPEAU_au_thread_@@@Z:PROC ; AuThreadMoveToTrash
EXTRN	AuForceScheduler:PROC
EXTRN	AuCreateMutex:PROC
EXTRN	AuVmmngrGetPage:PROC
EXTRN	AuMapPageEx:PROC
EXTRN	AuCreateVirtualAddressSpace:PROC
EXTRN	strcpy:PROC
EXTRN	strlen:PROC
EXTRN	memset:PROC
EXTRN	AuPmmngrAlloc:PROC
EXTRN	AuPmmngrFree:PROC
EXTRN	P2V:PROC
EXTRN	V2P:PROC
EXTRN	kmalloc:PROC
EXTRN	kfree:PROC
EXTRN	kmalloc_debug_on:PROC
EXTRN	?UnmapMemMapping@@YAXPEAX_K@Z:PROC		; UnmapMemMapping
EXTRN	x64_cli:PROC
EXTRN	x64_sti:PROC
EXTRN	x64_force_sched:PROC
EXTRN	SeTextOut:PROC
EXTRN	?AuLoadExecToProcess@@YAHPEAU_au_proc_@@PEADHPEAPEAD@Z:PROC ; AuLoadExecToProcess
EXTRN	?AuProcessEntUser@@YAX_K@Z:PROC			; AuProcessEntUser
EXTRN	?AuProcessClean@@YAXPEAU_au_proc_@@0@Z:PROC	; AuProcessClean
EXTRN	?AuSHMUnmapAll@@YAXPEAU_au_proc_@@@Z:PROC	; AuSHMUnmapAll
EXTRN	AuSoundRemoveDSP:PROC
EXTRN	?AuSignalRemoveAll@@YAXPEAU_au_thread_@@@Z:PROC	; AuSignalRemoveAll
EXTRN	?PostBoxDestroyByID@@YAXG@Z:PROC		; PostBoxDestroyByID
EXTRN	?AuTimerDestroy@@YAXG@Z:PROC			; AuTimerDestroy
pdata	SEGMENT
$pdata$?AuRemoveProcess@@YAXPEAU_au_proc_@@0@Z DD imagerel $LN8
	DD	imagerel $LN8+178
	DD	imagerel $unwind$?AuRemoveProcess@@YAXPEAU_au_proc_@@0@Z
$pdata$?CreateKernelStack@@YA_KPEAU_au_proc_@@PEA_K@Z DD imagerel $LN6
	DD	imagerel $LN6+175
	DD	imagerel $unwind$?CreateKernelStack@@YA_KPEAU_au_proc_@@PEA_K@Z
$pdata$?KernelStackFree@@YAXPEAU_au_proc_@@PEAXPEA_K@Z DD imagerel $LN8
	DD	imagerel $LN8+211
	DD	imagerel $unwind$?KernelStackFree@@YAXPEAU_au_proc_@@PEAXPEA_K@Z
$pdata$?AuProcessFindPID@@YAPEAU_au_proc_@@H@Z DD imagerel $LN7
	DD	imagerel $LN7+70
	DD	imagerel $unwind$?AuProcessFindPID@@YAPEAU_au_proc_@@H@Z
$pdata$?AuProcessFindThread@@YAPEAU_au_proc_@@PEAU_au_thread_@@@Z DD imagerel $LN7
	DD	imagerel $LN7+74
	DD	imagerel $unwind$?AuProcessFindThread@@YAPEAU_au_proc_@@PEAU_au_thread_@@@Z
$pdata$?AuProcessFindSubThread@@YAPEAU_au_proc_@@PEAU_au_thread_@@@Z DD imagerel $LN3
	DD	imagerel $LN3+34
	DD	imagerel $unwind$?AuProcessFindSubThread@@YAPEAU_au_proc_@@PEAU_au_thread_@@@Z
$pdata$?CreateUserStack@@YAPEA_KPEAU_au_proc_@@PEA_K@Z DD imagerel $LN6
	DD	imagerel $LN6+204
	DD	imagerel $unwind$?CreateUserStack@@YAPEA_KPEAU_au_proc_@@PEA_K@Z
$pdata$?AuStartRootProc@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+205
	DD	imagerel $unwind$?AuStartRootProc@@YAXXZ
$pdata$?AuCreateProcessSlot@@YAPEAU_au_proc_@@PEAU1@PEAD@Z DD imagerel $LN6
	DD	imagerel $LN6+368
	DD	imagerel $unwind$?AuCreateProcessSlot@@YAPEAU_au_proc_@@PEAU1@PEAD@Z
$pdata$?AuProcessExit@@YAXPEAU_au_proc_@@_N@Z DD imagerel $LN23
	DD	imagerel $LN23+592
	DD	imagerel $unwind$?AuProcessExit@@YAXPEAU_au_proc_@@_N@Z
$pdata$?AuProcessGetFileDesc@@YAHPEAU_au_proc_@@@Z DD imagerel $LN7
	DD	imagerel $LN7+69
	DD	imagerel $unwind$?AuProcessGetFileDesc@@YAHPEAU_au_proc_@@@Z
$pdata$?AuProcessWaitForTermination@@YAXPEAU_au_proc_@@H@Z DD imagerel $LN11
	DD	imagerel $LN11+197
	DD	imagerel $unwind$?AuProcessWaitForTermination@@YAXPEAU_au_proc_@@H@Z
$pdata$?AuCreateUserthread@@YAHPEAU_au_proc_@@P6AXPEAX@ZPEAD@Z DD imagerel $LN3
	DD	imagerel $LN3+415
	DD	imagerel $unwind$?AuCreateUserthread@@YAHPEAU_au_proc_@@P6AXPEAX@ZPEAD@Z
$pdata$?AuProcessFindByPID@@YAPEAU_au_proc_@@PEAU1@H@Z DD imagerel $LN7
	DD	imagerel $LN7+75
	DD	imagerel $unwind$?AuProcessFindByPID@@YAPEAU_au_proc_@@PEAU1@H@Z
$pdata$?AuProcessFindByThread@@YAPEAU_au_proc_@@PEAU1@PEAU_au_thread_@@@Z DD imagerel $LN7
	DD	imagerel $LN7+79
	DD	imagerel $unwind$?AuProcessFindByThread@@YAPEAU_au_proc_@@PEAU1@PEAU_au_thread_@@@Z
$pdata$?AuAllocateProcessID@@YAHXZ DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$?AuAllocateProcessID@@YAHXZ
$pdata$?AuCreateRootProc@@YAPEAU_au_proc_@@XZ DD imagerel $LN6
	DD	imagerel $LN6+344
	DD	imagerel $unwind$?AuCreateRootProc@@YAPEAU_au_proc_@@XZ
$pdata$?AuGetKillableProcess@@YAPEAU_au_proc_@@XZ DD imagerel $LN7
	DD	imagerel $LN7+69
	DD	imagerel $unwind$?AuGetKillableProcess@@YAPEAU_au_proc_@@XZ
$pdata$?AuProcessHeapMemDestroy@@YAXPEAU_au_proc_@@@Z DD imagerel $LN9
	DD	imagerel $LN9+298
	DD	imagerel $unwind$?AuProcessHeapMemDestroy@@YAXPEAU_au_proc_@@@Z
$pdata$?AuProcessFreeKeResource@@YAXPEAU_au_thread_@@@Z DD imagerel $LN4
	DD	imagerel $LN4+85
	DD	imagerel $unwind$?AuProcessFreeKeResource@@YAXPEAU_au_thread_@@@Z
pdata	ENDS
xdata	SEGMENT
$unwind$?AuRemoveProcess@@YAXPEAU_au_proc_@@0@Z DD 010e01H
	DD	0420eH
$unwind$?CreateKernelStack@@YA_KPEAU_au_proc_@@PEA_K@Z DD 010e01H
	DD	0820eH
$unwind$?KernelStackFree@@YAXPEAU_au_proc_@@PEAXPEA_K@Z DD 011301H
	DD	08213H
$unwind$?AuProcessFindPID@@YAPEAU_au_proc_@@H@Z DD 010801H
	DD	02208H
$unwind$?AuProcessFindThread@@YAPEAU_au_proc_@@PEAU_au_thread_@@@Z DD 010901H
	DD	02209H
$unwind$?AuProcessFindSubThread@@YAPEAU_au_proc_@@PEAU_au_thread_@@@Z DD 010901H
	DD	02209H
$unwind$?CreateUserStack@@YAPEA_KPEAU_au_proc_@@PEA_K@Z DD 010e01H
	DD	0820eH
$unwind$?AuStartRootProc@@YAXXZ DD 010401H
	DD	08204H
$unwind$?AuCreateProcessSlot@@YAPEAU_au_proc_@@PEAU1@PEAD@Z DD 010e01H
	DD	0820eH
$unwind$?AuProcessExit@@YAXPEAU_au_proc_@@_N@Z DD 010d01H
	DD	0a20dH
$unwind$?AuProcessGetFileDesc@@YAHPEAU_au_proc_@@@Z DD 010901H
	DD	02209H
$unwind$?AuProcessWaitForTermination@@YAXPEAU_au_proc_@@H@Z DD 010d01H
	DD	0820dH
$unwind$?AuCreateUserthread@@YAHPEAU_au_proc_@@P6AXPEAX@ZPEAD@Z DD 011301H
	DD	08213H
$unwind$?AuProcessFindByPID@@YAPEAU_au_proc_@@PEAU1@H@Z DD 010d01H
	DD	0220dH
$unwind$?AuProcessFindByThread@@YAPEAU_au_proc_@@PEAU1@PEAU_au_thread_@@@Z DD 010e01H
	DD	0220eH
$unwind$?AuAllocateProcessID@@YAHXZ DD 010401H
	DD	02204H
$unwind$?AuCreateRootProc@@YAPEAU_au_proc_@@XZ DD 010401H
	DD	08204H
$unwind$?AuGetKillableProcess@@YAPEAU_au_proc_@@XZ DD 010401H
	DD	02204H
$unwind$?AuProcessHeapMemDestroy@@YAXPEAU_au_proc_@@@Z DD 010901H
	DD	0a209H
$unwind$?AuProcessFreeKeResource@@YAXPEAU_au_thread_@@@Z DD 010901H
	DD	04209H
xdata	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\process.cpp
_TEXT	SEGMENT
thr$ = 48
?AuProcessFreeKeResource@@YAXPEAU_au_thread_@@@Z PROC	; AuProcessFreeKeResource

; 445  : void AuProcessFreeKeResource(AuThread* thr) {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 446  : 	if (!thr)

	cmp	QWORD PTR thr$[rsp], 0
	jne	SHORT $LN1@AuProcessF

; 447  : 		return;

	jmp	SHORT $LN2@AuProcessF
$LN1@AuProcessF:

; 448  : 	/* free-up all allocated kernel resources */
; 449  : 
; 450  : 	AuSoundRemoveDSP(thr->id);

	mov	rax, QWORD PTR thr$[rsp]
	movzx	ecx, WORD PTR [rax+301]
	call	AuSoundRemoveDSP

; 451  : 
; 452  : 	/* close allocated signals */
; 453  : 	AuSignalRemoveAll(thr);

	mov	rcx, QWORD PTR thr$[rsp]
	call	?AuSignalRemoveAll@@YAXPEAU_au_thread_@@@Z ; AuSignalRemoveAll

; 454  : 
; 455  : 	/* remove allocated postbox*/
; 456  : 	PostBoxDestroyByID(thr->id);

	mov	rax, QWORD PTR thr$[rsp]
	movzx	ecx, WORD PTR [rax+301]
	call	?PostBoxDestroyByID@@YAXG@Z		; PostBoxDestroyByID

; 457  : 
; 458  : 	/* destroy allocated timer */
; 459  : 	AuTimerDestroy(thr->id);

	mov	rax, QWORD PTR thr$[rsp]
	movzx	ecx, WORD PTR [rax+301]
	call	?AuTimerDestroy@@YAXG@Z			; AuTimerDestroy
$LN2@AuProcessF:

; 460  : }

	add	rsp, 40					; 00000028H
	ret	0
?AuProcessFreeKeResource@@YAXPEAU_au_thread_@@@Z ENDP	; AuProcessFreeKeResource
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\process.cpp
_TEXT	SEGMENT
i$1 = 32
page$2 = 40
phys$3 = 48
tv72 = 56
startaddr$ = 64
proc$ = 96
?AuProcessHeapMemDestroy@@YAXPEAU_au_proc_@@@Z PROC	; AuProcessHeapMemDestroy

; 418  : void AuProcessHeapMemDestroy(AuProcess* proc) {

$LN9:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 419  : 	uint64_t startaddr = PROCESS_BREAK_ADDRESS;

	mov	rax, 12884901888			; 0000000300000000H
	mov	QWORD PTR startaddr$[rsp], rax

; 420  : 	if ((proc->proc_heapmem_len % PAGE_SIZE) != 0)

	xor	edx, edx
	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+1112]
	mov	ecx, 4096				; 00001000H
	div	rcx
	mov	rax, rdx
	test	rax, rax
	je	SHORT $LN6@AuProcessH

; 421  : 		proc->proc_heapmem_len++;

	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+1112]
	inc	rax
	mov	rcx, QWORD PTR proc$[rsp]
	mov	QWORD PTR [rcx+1112], rax
$LN6@AuProcessH:

; 422  : 
; 423  : 	for (int i = 0; i < proc->proc_heapmem_len / 4096; i++) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN5@AuProcessH
$LN4@AuProcessH:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN5@AuProcessH:
	movsxd	rax, DWORD PTR i$1[rsp]
	mov	QWORD PTR tv72[rsp], rax
	xor	edx, edx
	mov	rcx, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rcx+1112]
	mov	ecx, 4096				; 00001000H
	div	rcx
	mov	rcx, QWORD PTR tv72[rsp]
	cmp	rcx, rax
	jae	$LN3@AuProcessH

; 424  : 		AuVPage* page = AuVmmngrGetPage(startaddr + i * PAGE_SIZE, VIRT_GETPAGE_ONLY_RET, VIRT_GETPAGE_ONLY_RET);

	imul	eax, DWORD PTR i$1[rsp], 4096		; 00001000H
	cdqe
	mov	rcx, QWORD PTR startaddr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	r8b, 2
	mov	dl, 2
	mov	rcx, rax
	call	AuVmmngrGetPage
	mov	QWORD PTR page$2[rsp], rax

; 425  : 		if (page) {

	cmp	QWORD PTR page$2[rsp], 0
	je	SHORT $LN2@AuProcessH

; 426  : 			uint64_t phys = page->bits.page << PAGE_SHIFT;

	mov	rax, QWORD PTR page$2[rsp]
	mov	rax, QWORD PTR [rax]
	shr	rax, 12
	and	rax, 268435455				; 0fffffffH
	shl	rax, 12
	mov	QWORD PTR phys$3[rsp], rax

; 427  : 			if (phys){

	cmp	QWORD PTR phys$3[rsp], 0
	je	SHORT $LN1@AuProcessH

; 428  : #if 0
; 429  : 				SeTextOut("Heap mem destroy -> %x \r\n", phys);
; 430  : #endif
; 431  : 				AuPmmngrFree((void*)phys);

	mov	rcx, QWORD PTR phys$3[rsp]
	call	AuPmmngrFree
$LN1@AuProcessH:

; 432  : 			}
; 433  : 			page->bits.page = 0;

	mov	rax, QWORD PTR page$2[rsp]
	mov	rcx, -1099511623681			; ffffff0000000fffH
	mov	rax, QWORD PTR [rax]
	and	rax, rcx
	mov	rcx, QWORD PTR page$2[rsp]
	mov	QWORD PTR [rcx], rax

; 434  : 			page->bits.present = 0;

	mov	rax, QWORD PTR page$2[rsp]
	mov	rax, QWORD PTR [rax]
	and	rax, -2
	mov	rcx, QWORD PTR page$2[rsp]
	mov	QWORD PTR [rcx], rax
$LN2@AuProcessH:

; 435  : 		}
; 436  : 	}

	jmp	$LN4@AuProcessH
$LN3@AuProcessH:

; 437  : }

	add	rsp, 88					; 00000058H
	ret	0
?AuProcessHeapMemDestroy@@YAXPEAU_au_proc_@@@Z ENDP	; AuProcessHeapMemDestroy
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\process.cpp
_TEXT	SEGMENT
proc_$1 = 0
?AuGetKillableProcess@@YAPEAU_au_proc_@@XZ PROC		; AuGetKillableProcess

; 350  : AuProcess* AuGetKillableProcess() {

$LN7:
	sub	rsp, 24

; 351  : 	for (AuProcess* proc_ = proc_first; proc_ != NULL; proc_ = proc_->next) {

	mov	rax, QWORD PTR ?proc_first@@3PEAU_au_proc_@@EA ; proc_first
	mov	QWORD PTR proc_$1[rsp], rax
	jmp	SHORT $LN4@AuGetKilla
$LN3@AuGetKilla:
	mov	rax, QWORD PTR proc_$1[rsp]
	mov	rax, QWORD PTR [rax+1128]
	mov	QWORD PTR proc_$1[rsp], rax
$LN4@AuGetKilla:
	cmp	QWORD PTR proc_$1[rsp], 0
	je	SHORT $LN2@AuGetKilla

; 352  : 		if (proc_->state & PROCESS_STATE_DIED)

	mov	rax, QWORD PTR proc_$1[rsp]
	movzx	eax, BYTE PTR [rax+20]
	and	eax, 8
	test	eax, eax
	je	SHORT $LN1@AuGetKilla

; 353  : 			return proc_;

	mov	rax, QWORD PTR proc_$1[rsp]
	jmp	SHORT $LN5@AuGetKilla
$LN1@AuGetKilla:

; 354  : 	}

	jmp	SHORT $LN3@AuGetKilla
$LN2@AuGetKilla:

; 355  : 
; 356  : 	return NULL;

	xor	eax, eax
$LN5@AuGetKilla:

; 357  : }

	add	rsp, 24
	ret	0
?AuGetKillableProcess@@YAPEAU_au_proc_@@XZ ENDP		; AuGetKillableProcess
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\process.cpp
_TEXT	SEGMENT
i$1 = 32
proc$ = 40
cr3$ = 48
main_thr_stack$ = 56
?AuCreateRootProc@@YAPEAU_au_proc_@@XZ PROC		; AuCreateRootProc

; 244  : AuProcess* AuCreateRootProc() {

$LN6:
	sub	rsp, 72					; 00000048H

; 245  : 	AuProcess *proc = (AuProcess*)kmalloc(sizeof(AuProcess));

	mov	ecx, 1144				; 00000478H
	call	kmalloc
	mov	QWORD PTR proc$[rsp], rax

; 246  : 	memset(proc, 0, sizeof(AuProcess));

	mov	r8d, 1144				; 00000478H
	xor	edx, edx
	mov	rcx, QWORD PTR proc$[rsp]
	call	memset

; 247  : 
; 248  : 	proc->proc_id = AuAllocateProcessID();

	call	?AuAllocateProcessID@@YAHXZ		; AuAllocateProcessID
	mov	rcx, QWORD PTR proc$[rsp]
	mov	DWORD PTR [rcx], eax

; 249  : 	memset(proc->name, 0, 16);

	mov	rax, QWORD PTR proc$[rsp]
	add	rax, 4
	mov	r8d, 16
	xor	edx, edx
	mov	rcx, rax
	call	memset

; 250  : 	strcpy(proc->name, "_root");

	mov	rax, QWORD PTR proc$[rsp]
	add	rax, 4
	lea	rdx, OFFSET FLAT:$SG4216
	mov	rcx, rax
	call	strcpy

; 251  : 
; 252  : 	/* create empty virtual address space */
; 253  : 	uint64_t* cr3 = AuCreateVirtualAddressSpace();

	call	AuCreateVirtualAddressSpace
	mov	QWORD PTR cr3$[rsp], rax

; 254  : 	/* create the process main thread stack */
; 255  : 	uint64_t  main_thr_stack = (uint64_t)CreateUserStack(proc,cr3);

	mov	rdx, QWORD PTR cr3$[rsp]
	mov	rcx, QWORD PTR proc$[rsp]
	call	?CreateUserStack@@YAPEA_KPEAU_au_proc_@@PEA_K@Z ; CreateUserStack
	mov	QWORD PTR main_thr_stack$[rsp], rax

; 256  : 	proc->state = PROCESS_STATE_NOT_READY;

	mov	rax, QWORD PTR proc$[rsp]
	mov	BYTE PTR [rax+20], 1

; 257  : 	proc->cr3 = cr3;

	mov	rax, QWORD PTR proc$[rsp]
	mov	rcx, QWORD PTR cr3$[rsp]
	mov	QWORD PTR [rax+24], rcx

; 258  : 	proc->_main_stack_ = main_thr_stack;

	mov	rax, QWORD PTR proc$[rsp]
	mov	rcx, QWORD PTR main_thr_stack$[rsp]
	mov	QWORD PTR [rax+48], rcx

; 259  : 	
; 260  : 	proc->vmareas = initialize_list();

	call	initialize_list
	mov	rcx, QWORD PTR proc$[rsp]
	mov	QWORD PTR [rcx+1072], rax

; 261  : 	proc->shmmaps = initialize_list();

	call	initialize_list
	mov	rcx, QWORD PTR proc$[rsp]
	mov	QWORD PTR [rcx+1080], rax

; 262  : 	proc->shm_break = USER_SHARED_MEM_START;

	mov	rax, QWORD PTR proc$[rsp]
	mov	ecx, -2147483648			; 80000000H
	mov	QWORD PTR [rax+1096], rcx

; 263  : 	proc->proc_mem_heap = PROCESS_BREAK_ADDRESS;

	mov	rax, QWORD PTR proc$[rsp]
	mov	rcx, 12884901888			; 0000000300000000H
	mov	QWORD PTR [rax+1104], rcx

; 264  : 	proc->proc_mmap_len = 0;

	mov	rax, QWORD PTR proc$[rsp]
	mov	QWORD PTR [rax+1120], 0

; 265  : 	proc->waitlist = initialize_list();

	call	initialize_list
	mov	rcx, QWORD PTR proc$[rsp]
	mov	QWORD PTR [rcx+1088], rax

; 266  : 	for (int i = 0; i < FILE_DESC_PER_PROCESS; i++)

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN3@AuCreateRo
$LN2@AuCreateRo:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN3@AuCreateRo:
	cmp	DWORD PTR i$1[rsp], 60			; 0000003cH
	jge	SHORT $LN1@AuCreateRo

; 267  : 		proc->fds[i] = 0;

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR proc$[rsp]
	mov	QWORD PTR [rcx+rax*8+576], 0
	jmp	SHORT $LN2@AuCreateRo
$LN1@AuCreateRo:

; 268  : 
; 269  : 	/* create the main thread after loading the
; 270  : 	 * image file to process, because just after
; 271  : 	 * creating the thread, scheduler starts
; 272  : 	 * scheduling that thread
; 273  : 	 */
; 274  : 	AuAddProcess(NULL,proc);

	mov	rdx, QWORD PTR proc$[rsp]
	xor	ecx, ecx
	call	?AuAddProcess@@YAXPEAU_au_proc_@@0@Z	; AuAddProcess

; 275  : 	return proc;

	mov	rax, QWORD PTR proc$[rsp]

; 276  : }

	add	rsp, 72					; 00000048H
	ret	0
?AuCreateRootProc@@YAPEAU_au_proc_@@XZ ENDP		; AuCreateRootProc
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\process.cpp
_TEXT	SEGMENT
_pid$ = 0
?AuAllocateProcessID@@YAHXZ PROC			; AuAllocateProcessID

; 235  : int AuAllocateProcessID() {

$LN3:
	sub	rsp, 24

; 236  : 	size_t _pid = pid;

	movsxd	rax, DWORD PTR pid
	mov	QWORD PTR _pid$[rsp], rax

; 237  : 	pid = pid + 1;

	mov	eax, DWORD PTR pid
	inc	eax
	mov	DWORD PTR pid, eax

; 238  : 	return _pid;

	mov	eax, DWORD PTR _pid$[rsp]

; 239  : }

	add	rsp, 24
	ret	0
?AuAllocateProcessID@@YAHXZ ENDP			; AuAllocateProcessID
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\process.cpp
_TEXT	SEGMENT
proc_$1 = 0
proc$ = 32
thread$ = 40
?AuProcessFindByThread@@YAPEAU_au_proc_@@PEAU1@PEAU_au_thread_@@@Z PROC ; AuProcessFindByThread

; 124  : AuProcess* AuProcessFindByThread(AuProcess* proc, AuThread* thread) {

$LN7:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 125  : 	for (AuProcess *proc_ = proc_first; proc_ != NULL; proc_ = proc_->next) {

	mov	rax, QWORD PTR ?proc_first@@3PEAU_au_proc_@@EA ; proc_first
	mov	QWORD PTR proc_$1[rsp], rax
	jmp	SHORT $LN4@AuProcessF
$LN3@AuProcessF:
	mov	rax, QWORD PTR proc_$1[rsp]
	mov	rax, QWORD PTR [rax+1128]
	mov	QWORD PTR proc_$1[rsp], rax
$LN4@AuProcessF:
	cmp	QWORD PTR proc_$1[rsp], 0
	je	SHORT $LN2@AuProcessF

; 126  : 		if (proc_->main_thread == thread) {

	mov	rax, QWORD PTR proc_$1[rsp]
	mov	rcx, QWORD PTR thread$[rsp]
	cmp	QWORD PTR [rax+72], rcx
	jne	SHORT $LN1@AuProcessF

; 127  : 			return proc_;

	mov	rax, QWORD PTR proc_$1[rsp]
	jmp	SHORT $LN5@AuProcessF
$LN1@AuProcessF:

; 128  : 		}
; 129  : 	}

	jmp	SHORT $LN3@AuProcessF
$LN2@AuProcessF:

; 130  : 
; 131  : 	return NULL;

	xor	eax, eax
$LN5@AuProcessF:

; 132  : }

	add	rsp, 24
	ret	0
?AuProcessFindByThread@@YAPEAU_au_proc_@@PEAU1@PEAU_au_thread_@@@Z ENDP ; AuProcessFindByThread
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\process.cpp
_TEXT	SEGMENT
proc_$1 = 0
proc$ = 32
pid$ = 40
?AuProcessFindByPID@@YAPEAU_au_proc_@@PEAU1@H@Z PROC	; AuProcessFindByPID

; 111  : AuProcess* AuProcessFindByPID(AuProcess* proc, int pid) {

$LN7:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 112  : 	for (AuProcess *proc_ = proc_first; proc_ != NULL; proc_ = proc_->next) {

	mov	rax, QWORD PTR ?proc_first@@3PEAU_au_proc_@@EA ; proc_first
	mov	QWORD PTR proc_$1[rsp], rax
	jmp	SHORT $LN4@AuProcessF
$LN3@AuProcessF:
	mov	rax, QWORD PTR proc_$1[rsp]
	mov	rax, QWORD PTR [rax+1128]
	mov	QWORD PTR proc_$1[rsp], rax
$LN4@AuProcessF:
	cmp	QWORD PTR proc_$1[rsp], 0
	je	SHORT $LN2@AuProcessF

; 113  : 		if (proc_->proc_id == pid)

	mov	rax, QWORD PTR proc_$1[rsp]
	mov	ecx, DWORD PTR pid$[rsp]
	cmp	DWORD PTR [rax], ecx
	jne	SHORT $LN1@AuProcessF

; 114  : 			return proc_;

	mov	rax, QWORD PTR proc_$1[rsp]
	jmp	SHORT $LN5@AuProcessF
$LN1@AuProcessF:

; 115  : 	}

	jmp	SHORT $LN3@AuProcessF
$LN2@AuProcessF:

; 116  : 	return NULL;

	xor	eax, eax
$LN5@AuProcessF:

; 117  : }

	add	rsp, 24
	ret	0
?AuProcessFindByPID@@YAPEAU_au_proc_@@PEAU1@H@Z ENDP	; AuProcessFindByPID
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\process.cpp
_TEXT	SEGMENT
thread_indx$ = 32
uentry$ = 40
thr$ = 48
tv66 = 56
proc$ = 80
entry$ = 88
name$ = 96
?AuCreateUserthread@@YAHPEAU_au_proc_@@P6AXPEAX@ZPEAD@Z PROC ; AuCreateUserthread

; 555  : {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 556  : 	AuThread* thr = AuCreateKthread(AuProcessEntUser, CreateKernelStack(proc, proc->cr3), V2P((size_t)proc->cr3), name);

	mov	rax, QWORD PTR proc$[rsp]
	mov	rcx, QWORD PTR [rax+24]
	call	V2P
	mov	QWORD PTR tv66[rsp], rax
	mov	rcx, QWORD PTR proc$[rsp]
	mov	rdx, QWORD PTR [rcx+24]
	mov	rcx, QWORD PTR proc$[rsp]
	call	?CreateKernelStack@@YA_KPEAU_au_proc_@@PEA_K@Z ; CreateKernelStack
	mov	r9, QWORD PTR name$[rsp]
	mov	rcx, QWORD PTR tv66[rsp]
	mov	r8, rcx
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:?AuProcessEntUser@@YAX_K@Z ; AuProcessEntUser
	call	AuCreateKthread
	mov	QWORD PTR thr$[rsp], rax

; 557  : 	thr->frame.rsp -= 32;

	mov	rax, QWORD PTR thr$[rsp]
	mov	rax, QWORD PTR [rax+8]
	sub	rax, 32					; 00000020H
	mov	rcx, QWORD PTR thr$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 558  : 	thr->priviledge |= THREAD_LEVEL_USER | THREAD_LEVEL_SUBTHREAD | ~THREAD_LEVEL_MAIN_THREAD;

	mov	rax, QWORD PTR thr$[rsp]
	movzx	eax, BYTE PTR [rax+305]
	or	eax, -9
	mov	rcx, QWORD PTR thr$[rsp]
	mov	BYTE PTR [rcx+305], al

; 559  : 	thr->procSlot = proc;

	mov	rax, QWORD PTR thr$[rsp]
	mov	rcx, QWORD PTR proc$[rsp]
	mov	QWORD PTR [rax+643], rcx

; 560  : 	AuUserEntry *uentry = (AuUserEntry*)kmalloc(sizeof(AuUserEntry));

	mov	ecx, 60					; 0000003cH
	call	kmalloc
	mov	QWORD PTR uentry$[rsp], rax

; 561  : 	memset(uentry, 0, sizeof(AuUserEntry));

	mov	r8d, 60					; 0000003cH
	xor	edx, edx
	mov	rcx, QWORD PTR uentry$[rsp]
	call	memset

; 562  : 	uentry->argvaddr = 0;

	mov	rax, QWORD PTR uentry$[rsp]
	mov	QWORD PTR [rax+36], 0

; 563  : 	uentry->entrypoint = (uint64_t)entry;

	mov	rax, QWORD PTR uentry$[rsp]
	mov	rcx, QWORD PTR entry$[rsp]
	mov	QWORD PTR [rax], rcx

; 564  : 	uentry->argvs = 0;

	mov	rax, QWORD PTR uentry$[rsp]
	mov	QWORD PTR [rax+44], 0

; 565  : 	uentry->cs = SEGVAL(GDT_ENTRY_USER_CODE, 3);

	mov	rax, QWORD PTR uentry$[rsp]
	mov	QWORD PTR [rax+16], 43			; 0000002bH

; 566  : 	uentry->ss = SEGVAL(GDT_ENTRY_USER_DATA, 3);

	mov	rax, QWORD PTR uentry$[rsp]
	mov	QWORD PTR [rax+24], 35			; 00000023H

; 567  : 	uentry->num_args = 0;

	mov	rax, QWORD PTR uentry$[rsp]
	mov	DWORD PTR [rax+32], 0

; 568  : 	uentry->rsp = (uint64_t)CreateUserStack(proc, proc->cr3);

	mov	rax, QWORD PTR proc$[rsp]
	mov	rdx, QWORD PTR [rax+24]
	mov	rcx, QWORD PTR proc$[rsp]
	call	?CreateUserStack@@YAPEA_KPEAU_au_proc_@@PEA_K@Z ; CreateUserStack
	mov	rcx, QWORD PTR uentry$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 569  : 	uentry->rsp -= 32;

	mov	rax, QWORD PTR uentry$[rsp]
	mov	rax, QWORD PTR [rax+8]
	sub	rax, 32					; 00000020H
	mov	rcx, QWORD PTR uentry$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 570  : 	uentry->stackBase = uentry->rsp;

	mov	rax, QWORD PTR uentry$[rsp]
	mov	rcx, QWORD PTR uentry$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	QWORD PTR [rax+52], rcx

; 571  : 	thr->uentry = uentry;

	mov	rax, QWORD PTR thr$[rsp]
	mov	rcx, QWORD PTR uentry$[rsp]
	mov	QWORD PTR [rax+635], rcx

; 572  : 	int thread_indx = proc->num_thread;

	mov	rax, QWORD PTR proc$[rsp]
	movzx	eax, BYTE PTR [rax+80]
	mov	DWORD PTR thread_indx$[rsp], eax

; 573  : 	proc->threads[proc->num_thread] = thr;

	mov	rax, QWORD PTR proc$[rsp]
	movzx	eax, BYTE PTR [rax+80]
	mov	rcx, QWORD PTR proc$[rsp]
	mov	rdx, QWORD PTR thr$[rsp]
	mov	QWORD PTR [rcx+rax*8+96], rdx

; 574  : 	proc->num_thread += 1;

	mov	rax, QWORD PTR proc$[rsp]
	movzx	eax, BYTE PTR [rax+80]
	inc	eax
	mov	rcx, QWORD PTR proc$[rsp]
	mov	BYTE PTR [rcx+80], al

; 575  : 	return thread_indx;

	mov	eax, DWORD PTR thread_indx$[rsp]

; 576  : }

	add	rsp, 72					; 00000048H
	ret	0
?AuCreateUserthread@@YAHPEAU_au_proc_@@P6AXPEAX@ZPEAD@Z ENDP ; AuCreateUserthread
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\process.cpp
_TEXT	SEGMENT
?AuProcessGetMutex@@YAPEAU_mutex_@@XZ PROC		; AuProcessGetMutex

; 540  : 	return process_mutex;

	mov	rax, QWORD PTR ?process_mutex@@3PEAU_mutex_@@EA ; process_mutex

; 541  : }

	ret	0
?AuProcessGetMutex@@YAPEAU_mutex_@@XZ ENDP		; AuProcessGetMutex
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\process.cpp
_TEXT	SEGMENT
killable$1 = 32
thr$2 = 40
proc$3 = 48
proc$ = 80
pid$ = 88
?AuProcessWaitForTermination@@YAXPEAU_au_proc_@@H@Z PROC ; AuProcessWaitForTermination

; 369  : void AuProcessWaitForTermination(AuProcess *proc, int pid) {

$LN11:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 370  : 	if (pid == -1) {

	cmp	DWORD PTR pid$[rsp], -1
	jne	SHORT $LN8@AuProcessW
$LN7@AuProcessW:

; 371  : 		do {
; 372  : 			AuProcess *killable = AuGetKillableProcess();

	call	?AuGetKillableProcess@@YAPEAU_au_proc_@@XZ ; AuGetKillableProcess
	mov	QWORD PTR killable$1[rsp], rax

; 373  : 
; 374  : 			if (killable) {

	cmp	QWORD PTR killable$1[rsp], 0
	je	SHORT $LN4@AuProcessW

; 375  : 				x64_cli();

	call	x64_cli

; 376  : 				AuProcessClean(0, killable);

	mov	rdx, QWORD PTR killable$1[rsp]
	xor	ecx, ecx
	call	?AuProcessClean@@YAXPEAU_au_proc_@@0@Z	; AuProcessClean

; 377  : 				x64_sti();

	call	x64_sti

; 378  : 				killable = NULL;

	mov	QWORD PTR killable$1[rsp], 0
$LN4@AuProcessW:

; 379  : 			}
; 380  : 
; 381  : 
; 382  : 			if (!killable){

	cmp	QWORD PTR killable$1[rsp], 0
	jne	SHORT $LN3@AuProcessW

; 383  : 				AuSleepThread(proc->main_thread, 10000);

	mov	edx, 10000				; 00002710H
	mov	rax, QWORD PTR proc$[rsp]
	mov	rcx, QWORD PTR [rax+72]
	call	AuSleepThread

; 384  : 				proc->state = PROCESS_STATE_SUSPENDED;

	mov	rax, QWORD PTR proc$[rsp]
	mov	BYTE PTR [rax+20], 4

; 385  : 				x64_force_sched();

	call	x64_force_sched
$LN3@AuProcessW:

; 386  : 			}
; 387  : 		} while (1);

	xor	eax, eax
	cmp	eax, 1
	jne	SHORT $LN7@AuProcessW

; 388  : 	}
; 389  : 	else {

	jmp	SHORT $LN2@AuProcessW
$LN8@AuProcessW:

; 390  : 		AuProcess* proc = AuProcessFindByPID(0,pid);

	mov	edx, DWORD PTR pid$[rsp]
	xor	ecx, ecx
	call	?AuProcessFindByPID@@YAPEAU_au_proc_@@PEAU1@H@Z ; AuProcessFindByPID
	mov	QWORD PTR proc$3[rsp], rax

; 391  : 		if (!proc)

	cmp	QWORD PTR proc$3[rsp], 0
	jne	SHORT $LN1@AuProcessW

; 392  : 			return;

	jmp	SHORT $LN9@AuProcessW
$LN1@AuProcessW:

; 393  : 		AuThread* thr = AuGetCurrentThread();

	call	AuGetCurrentThread
	mov	QWORD PTR thr$2[rsp], rax

; 394  : 		AuBlockThread(thr);

	mov	rcx, QWORD PTR thr$2[rsp]
	call	AuBlockThread

; 395  : 		list_add(proc->waitlist, thr);

	mov	rdx, QWORD PTR thr$2[rsp]
	mov	rax, QWORD PTR proc$3[rsp]
	mov	rcx, QWORD PTR [rax+1088]
	call	list_add

; 396  : 		AuForceScheduler();

	call	AuForceScheduler
$LN2@AuProcessW:
$LN9@AuProcessW:

; 397  : 	}
; 398  : }

	add	rsp, 72					; 00000048H
	ret	0
?AuProcessWaitForTermination@@YAXPEAU_au_proc_@@H@Z ENDP ; AuProcessWaitForTermination
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\process.cpp
_TEXT	SEGMENT
i$1 = 0
proc$ = 32
?AuProcessGetFileDesc@@YAHPEAU_au_proc_@@@Z PROC	; AuProcessGetFileDesc

; 406  : int AuProcessGetFileDesc(AuProcess* proc) {

$LN7:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 407  : 	for (int i = 3; i < FILE_DESC_PER_PROCESS; i++) {

	mov	DWORD PTR i$1[rsp], 3
	jmp	SHORT $LN4@AuProcessG
$LN3@AuProcessG:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN4@AuProcessG:
	cmp	DWORD PTR i$1[rsp], 60			; 0000003cH
	jge	SHORT $LN2@AuProcessG

; 408  : 		if (!proc->fds[i])

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR proc$[rsp]
	cmp	QWORD PTR [rcx+rax*8+576], 0
	jne	SHORT $LN1@AuProcessG

; 409  : 			return i;

	mov	eax, DWORD PTR i$1[rsp]
	jmp	SHORT $LN5@AuProcessG
$LN1@AuProcessG:

; 410  : 	}

	jmp	SHORT $LN3@AuProcessG
$LN2@AuProcessG:

; 411  : 	return -1;

	mov	eax, -1
$LN5@AuProcessG:

; 412  : }

	add	rsp, 24
	ret	0
?AuProcessGetFileDesc@@YAHPEAU_au_proc_@@@Z ENDP	; AuProcessGetFileDesc
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\process.cpp
_TEXT	SEGMENT
i$1 = 32
i$2 = 36
i$3 = 40
file$4 = 48
killable$5 = 56
thr$6 = 64
proc$ = 96
schedulable$ = 104
?AuProcessExit@@YAXPEAU_au_proc_@@_N@Z PROC		; AuProcessExit

; 466  : void AuProcessExit(AuProcess* proc, bool schedulable) {

$LN23:
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 467  : 	x64_cli();

	call	x64_cli

; 468  : 	if (proc == root_proc) {

	mov	rax, QWORD PTR ?root_proc@@3PEAU_au_proc_@@EA ; root_proc
	cmp	QWORD PTR proc$[rsp], rax
	jne	SHORT $LN20@AuProcessE

; 469  : 		SeTextOut("[aurora]: cannot exit root process \r\n");

	lea	rcx, OFFSET FLAT:$SG4304
	call	SeTextOut

; 470  : 		return;

	jmp	$LN21@AuProcessE
$LN20@AuProcessE:

; 471  : 	}
; 472  : 
; 473  : 	kmalloc_debug_on(true);

	mov	cl, 1
	call	kmalloc_debug_on

; 474  : 
; 475  : 	proc->state = PROCESS_STATE_DIED;

	mov	rax, QWORD PTR proc$[rsp]
	mov	BYTE PTR [rax+20], 8

; 476  : 
; 477  : 	AuProcessFreeKeResource(proc->main_thread);

	mov	rax, QWORD PTR proc$[rsp]
	mov	rcx, QWORD PTR [rax+72]
	call	?AuProcessFreeKeResource@@YAXPEAU_au_thread_@@@Z ; AuProcessFreeKeResource

; 478  : 
; 479  : 	/* mark all the threads as blocked */
; 480  : 	for (int i = 1; i < proc->num_thread; i++) {

	mov	DWORD PTR i$1[rsp], 1
	jmp	SHORT $LN19@AuProcessE
$LN18@AuProcessE:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN19@AuProcessE:
	mov	rax, QWORD PTR proc$[rsp]
	movzx	eax, BYTE PTR [rax+80]
	cmp	DWORD PTR i$1[rsp], eax
	jge	SHORT $LN17@AuProcessE

; 481  : 		AuThread *killable = proc->threads[i];

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rcx+rax*8+96]
	mov	QWORD PTR killable$5[rsp], rax

; 482  : 		if (killable) {

	cmp	QWORD PTR killable$5[rsp], 0
	je	SHORT $LN16@AuProcessE

; 483  : 			/* here we should cleanup sub postbox
; 484  : 			 * sound, timer resources also
; 485  : 			 */
; 486  : 			AuProcessFreeKeResource(killable);

	mov	rcx, QWORD PTR killable$5[rsp]
	call	?AuProcessFreeKeResource@@YAXPEAU_au_thread_@@@Z ; AuProcessFreeKeResource

; 487  : 			AuThreadMoveToTrash(killable);

	mov	rcx, QWORD PTR killable$5[rsp]
	call	?AuThreadMoveToTrash@@YAXPEAU_au_thread_@@@Z ; AuThreadMoveToTrash
$LN16@AuProcessE:

; 488  : 		}
; 489  : 	}

	jmp	SHORT $LN18@AuProcessE
$LN17@AuProcessE:

; 490  : 
; 491  : 
; 492  : 	/* here we free almost every possible
; 493  : 	 * data, that we can free
; 494  : 	 */
; 495  : 	for (int i = 0; i < FILE_DESC_PER_PROCESS; i++) {

	mov	DWORD PTR i$2[rsp], 0
	jmp	SHORT $LN15@AuProcessE
$LN14@AuProcessE:
	mov	eax, DWORD PTR i$2[rsp]
	inc	eax
	mov	DWORD PTR i$2[rsp], eax
$LN15@AuProcessE:
	cmp	DWORD PTR i$2[rsp], 60			; 0000003cH
	jge	$LN13@AuProcessE

; 496  : 		AuVFSNode *file = proc->fds[i];

	movsxd	rax, DWORD PTR i$2[rsp]
	mov	rcx, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rcx+rax*8+576]
	mov	QWORD PTR file$4[rsp], rax

; 497  : 		if (file) {

	cmp	QWORD PTR file$4[rsp], 0
	je	SHORT $LN12@AuProcessE

; 498  : 			SeTextOut("Closing file -> %s , address -> %x \r\n", file->filename, file);

	mov	rax, QWORD PTR file$4[rsp]
	mov	r8, QWORD PTR file$4[rsp]
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG4317
	call	SeTextOut

; 499  : 			if (file->flags & FS_FLAG_DEVICE || file->flags & FS_FLAG_FILE_SYSTEM)

	mov	rax, QWORD PTR file$4[rsp]
	movzx	eax, WORD PTR [rax+64]
	and	eax, 8
	test	eax, eax
	jne	SHORT $LN10@AuProcessE
	mov	rax, QWORD PTR file$4[rsp]
	movzx	eax, WORD PTR [rax+64]
	and	eax, 64					; 00000040H
	test	eax, eax
	je	SHORT $LN11@AuProcessE
$LN10@AuProcessE:

; 500  : 				continue;

	jmp	SHORT $LN14@AuProcessE
$LN11@AuProcessE:

; 501  : 			if (file->flags & FS_FLAG_GENERAL)  {

	mov	rax, QWORD PTR file$4[rsp]
	movzx	eax, WORD PTR [rax+64]
	and	eax, 4
	test	eax, eax
	je	SHORT $LN9@AuProcessE

; 502  : 				if (file->fileCopyCount <= 0)

	mov	rax, QWORD PTR file$4[rsp]
	movzx	eax, WORD PTR [rax+80]
	test	eax, eax
	jg	SHORT $LN8@AuProcessE

; 503  : 					kfree(file);

	mov	rcx, QWORD PTR file$4[rsp]
	call	kfree

; 504  : 				else

	jmp	SHORT $LN7@AuProcessE
$LN8@AuProcessE:

; 505  : 					file->fileCopyCount -= 1;

	mov	rax, QWORD PTR file$4[rsp]
	movzx	eax, WORD PTR [rax+80]
	dec	eax
	mov	rcx, QWORD PTR file$4[rsp]
	mov	WORD PTR [rcx+80], ax
$LN7@AuProcessE:
$LN9@AuProcessE:
$LN12@AuProcessE:

; 506  : 			}
; 507  : 		}
; 508  : 	}

	jmp	$LN14@AuProcessE
$LN13@AuProcessE:

; 509  : 
; 510  : 	for (int i = 0; i < proc->waitlist->pointer; i++) {

	mov	DWORD PTR i$3[rsp], 0
	jmp	SHORT $LN6@AuProcessE
$LN5@AuProcessE:
	mov	eax, DWORD PTR i$3[rsp]
	inc	eax
	mov	DWORD PTR i$3[rsp], eax
$LN6@AuProcessE:
	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+1088]
	mov	eax, DWORD PTR [rax]
	cmp	DWORD PTR i$3[rsp], eax
	jae	SHORT $LN4@AuProcessE

; 511  : 		AuThread* thr = (AuThread*)list_remove(proc->waitlist, i);

	mov	edx, DWORD PTR i$3[rsp]
	mov	rax, QWORD PTR proc$[rsp]
	mov	rcx, QWORD PTR [rax+1088]
	call	list_remove
	mov	QWORD PTR thr$6[rsp], rax

; 512  : 		if (thr) {

	cmp	QWORD PTR thr$6[rsp], 0
	je	SHORT $LN3@AuProcessE

; 513  : 			AuUnblockThread(thr);

	mov	rcx, QWORD PTR thr$6[rsp]
	call	AuUnblockThread
$LN3@AuProcessE:

; 514  : 		}
; 515  : 	}

	jmp	SHORT $LN5@AuProcessE
$LN4@AuProcessE:

; 516  : 
; 517  : 	kfree(proc->waitlist);

	mov	rax, QWORD PTR proc$[rsp]
	mov	rcx, QWORD PTR [rax+1088]
	call	kfree

; 518  : 
; 519  : 	UnmapMemMapping((void*)PROCESS_MMAP_ADDRESS, proc->proc_mmap_len);

	mov	rax, QWORD PTR proc$[rsp]
	mov	rdx, QWORD PTR [rax+1120]
	mov	ecx, -1073741824			; ffffffffc0000000H
	call	?UnmapMemMapping@@YAXPEAX_K@Z		; UnmapMemMapping

; 520  : 	
; 521  : 	/*unmap all shared memory mappings */
; 522  : 	AuSHMUnmapAll(proc);

	mov	rcx, QWORD PTR proc$[rsp]
	call	?AuSHMUnmapAll@@YAXPEAU_au_proc_@@@Z	; AuSHMUnmapAll

; 523  : 
; 524  : 	AuProcessHeapMemDestroy(proc);

	mov	rcx, QWORD PTR proc$[rsp]
	call	?AuProcessHeapMemDestroy@@YAXPEAU_au_proc_@@@Z ; AuProcessHeapMemDestroy

; 525  : 
; 526  : 	SeTextOut("closing process -> %s \r\n", proc->name);

	mov	rax, QWORD PTR proc$[rsp]
	add	rax, 4
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG4331
	call	SeTextOut

; 527  : 
; 528  : 	if (proc->file)

	mov	rax, QWORD PTR proc$[rsp]
	cmp	QWORD PTR [rax+1056], 0
	je	SHORT $LN2@AuProcessE

; 529  : 		kfree(proc->file);

	mov	rax, QWORD PTR proc$[rsp]
	mov	rcx, QWORD PTR [rax+1056]
	call	kfree
$LN2@AuProcessE:

; 530  : 
; 531  : 	AuThreadMoveToTrash(proc->main_thread);

	mov	rax, QWORD PTR proc$[rsp]
	mov	rcx, QWORD PTR [rax+72]
	call	?AuThreadMoveToTrash@@YAXPEAU_au_thread_@@@Z ; AuThreadMoveToTrash

; 532  : 	
; 533  : 	kmalloc_debug_on(false);

	xor	ecx, ecx
	call	kmalloc_debug_on

; 534  : 	if (schedulable)

	movzx	eax, BYTE PTR schedulable$[rsp]
	test	eax, eax
	je	SHORT $LN1@AuProcessE

; 535  : 		x64_force_sched();

	call	x64_force_sched
$LN1@AuProcessE:
$LN21@AuProcessE:

; 536  : }

	add	rsp, 88					; 00000058H
	ret	0
?AuProcessExit@@YAXPEAU_au_proc_@@_N@Z ENDP		; AuProcessExit
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\process.cpp
_TEXT	SEGMENT
i$1 = 32
proc$ = 40
cr3$ = 48
main_thr_stack$ = 56
parent$ = 80
name$ = 88
?AuCreateProcessSlot@@YAPEAU_au_proc_@@PEAU1@PEAD@Z PROC ; AuCreateProcessSlot

; 283  : AuProcess* AuCreateProcessSlot(AuProcess* parent, char* name) {

$LN6:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 284  : 	AuProcess* proc = (AuProcess*)kmalloc(sizeof(AuProcess));

	mov	ecx, 1144				; 00000478H
	call	kmalloc
	mov	QWORD PTR proc$[rsp], rax

; 285  : 	memset(proc, 0, sizeof(AuProcess));

	mov	r8d, 1144				; 00000478H
	xor	edx, edx
	mov	rcx, QWORD PTR proc$[rsp]
	call	memset

; 286  : 
; 287  : 	proc->proc_id = AuAllocateProcessID();

	call	?AuAllocateProcessID@@YAHXZ		; AuAllocateProcessID
	mov	rcx, QWORD PTR proc$[rsp]
	mov	DWORD PTR [rcx], eax

; 288  : 	memset(proc->name, 0, 16);

	mov	rax, QWORD PTR proc$[rsp]
	add	rax, 4
	mov	r8d, 16
	xor	edx, edx
	mov	rcx, rax
	call	memset

; 289  : 	strcpy(proc->name, name);

	mov	rax, QWORD PTR proc$[rsp]
	add	rax, 4
	mov	rdx, QWORD PTR name$[rsp]
	mov	rcx, rax
	call	strcpy

; 290  : 
; 291  : 	/* create empty virtual address space */
; 292  : 	uint64_t* cr3 = AuCreateVirtualAddressSpace();

	call	AuCreateVirtualAddressSpace
	mov	QWORD PTR cr3$[rsp], rax

; 293  : 	/* create the process main thread stack */
; 294  : 	uint64_t  main_thr_stack = (uint64_t)CreateUserStack(proc,cr3);

	mov	rdx, QWORD PTR cr3$[rsp]
	mov	rcx, QWORD PTR proc$[rsp]
	call	?CreateUserStack@@YAPEA_KPEAU_au_proc_@@PEA_K@Z ; CreateUserStack
	mov	QWORD PTR main_thr_stack$[rsp], rax

; 295  : 	proc->state = PROCESS_STATE_NOT_READY;

	mov	rax, QWORD PTR proc$[rsp]
	mov	BYTE PTR [rax+20], 1

; 296  : 	proc->cr3 = cr3;

	mov	rax, QWORD PTR proc$[rsp]
	mov	rcx, QWORD PTR cr3$[rsp]
	mov	QWORD PTR [rax+24], rcx

; 297  : 	proc->_main_stack_ = main_thr_stack;

	mov	rax, QWORD PTR proc$[rsp]
	mov	rcx, QWORD PTR main_thr_stack$[rsp]
	mov	QWORD PTR [rax+48], rcx

; 298  : 
; 299  : 	proc->vmareas = initialize_list();

	call	initialize_list
	mov	rcx, QWORD PTR proc$[rsp]
	mov	QWORD PTR [rcx+1072], rax

; 300  : 	proc->shmmaps = initialize_list();

	call	initialize_list
	mov	rcx, QWORD PTR proc$[rsp]
	mov	QWORD PTR [rcx+1080], rax

; 301  : 	proc->shm_break = USER_SHARED_MEM_START;

	mov	rax, QWORD PTR proc$[rsp]
	mov	ecx, -2147483648			; 80000000H
	mov	QWORD PTR [rax+1096], rcx

; 302  : 	proc->proc_mem_heap = PROCESS_BREAK_ADDRESS;

	mov	rax, QWORD PTR proc$[rsp]
	mov	rcx, 12884901888			; 0000000300000000H
	mov	QWORD PTR [rax+1104], rcx

; 303  : 	proc->proc_mmap_len = 0;

	mov	rax, QWORD PTR proc$[rsp]
	mov	QWORD PTR [rax+1120], 0

; 304  : 	proc->waitlist = initialize_list();

	call	initialize_list
	mov	rcx, QWORD PTR proc$[rsp]
	mov	QWORD PTR [rcx+1088], rax

; 305  : 	for (int i = 0; i < FILE_DESC_PER_PROCESS; i++)

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN3@AuCreatePr
$LN2@AuCreatePr:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN3@AuCreatePr:
	cmp	DWORD PTR i$1[rsp], 60			; 0000003cH
	jge	SHORT $LN1@AuCreatePr

; 306  : 		proc->fds[i] = 0;

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR proc$[rsp]
	mov	QWORD PTR [rcx+rax*8+576], 0
	jmp	SHORT $LN2@AuCreatePr
$LN1@AuCreatePr:

; 307  : 
; 308  : 	proc->main_thread = NULL;

	mov	rax, QWORD PTR proc$[rsp]
	mov	QWORD PTR [rax+72], 0

; 309  : 
; 310  : 	/* create the main thread after loading the
; 311  : 	* image file to process, because just after
; 312  : 	* creating the thread, scheduler starts
; 313  : 	* scheduling that thread
; 314  : 	*/
; 315  : 	AuAddProcess(parent, proc);

	mov	rdx, QWORD PTR proc$[rsp]
	mov	rcx, QWORD PTR parent$[rsp]
	call	?AuAddProcess@@YAXPEAU_au_proc_@@0@Z	; AuAddProcess

; 316  : 	return proc;

	mov	rax, QWORD PTR proc$[rsp]

; 317  : }

	add	rsp, 72					; 00000048H
	ret	0
?AuCreateProcessSlot@@YAPEAU_au_proc_@@PEAU1@PEAD@Z ENDP ; AuCreateProcessSlot
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\process.cpp
_TEXT	SEGMENT
?AuGetRootProcess@@YAPEAU_au_proc_@@XZ PROC		; AuGetRootProcess

; 343  : 	return root_proc;

	mov	rax, QWORD PTR ?root_proc@@3PEAU_au_proc_@@EA ; root_proc

; 344  : }

	ret	0
?AuGetRootProcess@@YAPEAU_au_proc_@@XZ ENDP		; AuGetRootProcess
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\process.cpp
_TEXT	SEGMENT
num_args$ = 32
argvs$ = 40
about_str$ = 48
about$ = 56
?AuStartRootProc@@YAXXZ PROC				; AuStartRootProc

; 323  : void AuStartRootProc() {

$LN3:
	sub	rsp, 72					; 00000048H

; 324  : 	proc_first = NULL;

	mov	QWORD PTR ?proc_first@@3PEAU_au_proc_@@EA, 0 ; proc_first

; 325  : 	proc_last = NULL;

	mov	QWORD PTR ?proc_last@@3PEAU_au_proc_@@EA, 0 ; proc_last

; 326  : 	pid = 1;

	mov	DWORD PTR pid, 1

; 327  : 	process_mutex = AuCreateMutex();

	call	AuCreateMutex
	mov	QWORD PTR ?process_mutex@@3PEAU_mutex_@@EA, rax ; process_mutex

; 328  : 	root_proc = AuCreateRootProc();

	call	?AuCreateRootProc@@YAPEAU_au_proc_@@XZ	; AuCreateRootProc
	mov	QWORD PTR ?root_proc@@3PEAU_au_proc_@@EA, rax ; root_proc

; 329  : 	int num_args = 1;

	mov	DWORD PTR num_args$[rsp], 1

; 330  : 	char* about_str = "-about";

	lea	rax, OFFSET FLAT:$SG4243
	mov	QWORD PTR about_str$[rsp], rax

; 331  : 	char* about = (char*)kmalloc(strlen(about_str));

	mov	rcx, QWORD PTR about_str$[rsp]
	call	strlen
	mov	ecx, eax
	call	kmalloc
	mov	QWORD PTR about$[rsp], rax

; 332  : 	strcpy(about, about_str);

	mov	rdx, QWORD PTR about_str$[rsp]
	mov	rcx, QWORD PTR about$[rsp]
	call	strcpy

; 333  : 	char** argvs = (char**)kmalloc(num_args);

	mov	ecx, DWORD PTR num_args$[rsp]
	call	kmalloc
	mov	QWORD PTR argvs$[rsp], rax

; 334  : 	memset(argvs, 0, num_args);

	mov	r8d, DWORD PTR num_args$[rsp]
	xor	edx, edx
	mov	rcx, QWORD PTR argvs$[rsp]
	call	memset

; 335  : 	argvs[0] = about;

	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR argvs$[rsp]
	mov	rdx, QWORD PTR about$[rsp]
	mov	QWORD PTR [rcx+rax], rdx

; 336  : 	AuLoadExecToProcess(root_proc, "/init.exe",num_args,argvs);

	mov	r9, QWORD PTR argvs$[rsp]
	mov	r8d, DWORD PTR num_args$[rsp]
	lea	rdx, OFFSET FLAT:$SG4248
	mov	rcx, QWORD PTR ?root_proc@@3PEAU_au_proc_@@EA ; root_proc
	call	?AuLoadExecToProcess@@YAHPEAU_au_proc_@@PEADHPEAPEAD@Z ; AuLoadExecToProcess

; 337  : }

	add	rsp, 72					; 00000048H
	ret	0
?AuStartRootProc@@YAXXZ ENDP				; AuStartRootProc
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\process.cpp
_TEXT	SEGMENT
i$1 = 32
location$ = 40
blk$2 = 48
tv75 = 56
proc$ = 80
cr3$ = 88
?CreateUserStack@@YAPEA_KPEAU_au_proc_@@PEA_K@Z PROC	; CreateUserStack

; 179  : uint64_t* CreateUserStack(AuProcess *proc, uint64_t* cr3) {

$LN6:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 180  : #define USER_STACK 0x0000700000000000 
; 181  : 	uint64_t location = USER_STACK;

	mov	rax, 123145302310912			; 0000700000000000H
	mov	QWORD PTR location$[rsp], rax

; 182  : 	location += proc->_user_stack_index_;

	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+56]
	mov	rcx, QWORD PTR location$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR location$[rsp], rax

; 183  : 	for (int i = 0; i < PROCESS_USER_STACK_SZ / 4096; i++) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN3@CreateUser
$LN2@CreateUser:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN3@CreateUser:
	cmp	DWORD PTR i$1[rsp], 128			; 00000080H
	jge	SHORT $LN1@CreateUser

; 184  : 		uint64_t* blk = (uint64_t*)P2V((size_t)AuPmmngrAlloc());

	call	AuPmmngrAlloc
	mov	rcx, rax
	call	P2V
	mov	QWORD PTR blk$2[rsp], rax

; 185  : 		AuMapPageEx(cr3, V2P((size_t)blk), location + i * PAGE_SIZE, X86_64_PAGING_USER);

	imul	eax, DWORD PTR i$1[rsp], 4096		; 00001000H
	cdqe
	mov	rcx, QWORD PTR location$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR tv75[rsp], rax
	mov	rcx, QWORD PTR blk$2[rsp]
	call	V2P
	mov	r9b, 4
	mov	rcx, QWORD PTR tv75[rsp]
	mov	r8, rcx
	mov	rdx, rax
	mov	rcx, QWORD PTR cr3$[rsp]
	call	AuMapPageEx

; 186  : 	}

	jmp	SHORT $LN2@CreateUser
$LN1@CreateUser:

; 187  : 
; 188  : 	proc->_user_stack_index_ += PROCESS_USER_STACK_SZ;

	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+56]
	add	rax, 524288				; 00080000H
	mov	rcx, QWORD PTR proc$[rsp]
	mov	QWORD PTR [rcx+56], rax

; 189  : 	return (uint64_t*)(location + (PROCESS_USER_STACK_SZ));

	mov	rax, QWORD PTR location$[rsp]
	add	rax, 524288				; 00080000H

; 190  : }

	add	rsp, 72					; 00000048H
	ret	0
?CreateUserStack@@YAPEA_KPEAU_au_proc_@@PEA_K@Z ENDP	; CreateUserStack
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\process.cpp
_TEXT	SEGMENT
proc$ = 0
thread$ = 32
?AuProcessFindSubThread@@YAPEAU_au_proc_@@PEAU_au_thread_@@@Z PROC ; AuProcessFindSubThread

; 168  : AuProcess* AuProcessFindSubThread(AuThread* thread) {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 169  : 	AuProcess* proc = (AuProcess*)thread->procSlot;

	mov	rax, QWORD PTR thread$[rsp]
	mov	rax, QWORD PTR [rax+643]
	mov	QWORD PTR proc$[rsp], rax

; 170  : 	return proc;

	mov	rax, QWORD PTR proc$[rsp]

; 171  : }

	add	rsp, 24
	ret	0
?AuProcessFindSubThread@@YAPEAU_au_proc_@@PEAU_au_thread_@@@Z ENDP ; AuProcessFindSubThread
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\process.cpp
_TEXT	SEGMENT
proc_$1 = 0
thread$ = 32
?AuProcessFindThread@@YAPEAU_au_proc_@@PEAU_au_thread_@@@Z PROC ; AuProcessFindThread

; 152  : AuProcess *AuProcessFindThread(AuThread* thread) {

$LN7:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 153  : 	for (AuProcess *proc_ = proc_first; proc_ != NULL; proc_ = proc_->next) {

	mov	rax, QWORD PTR ?proc_first@@3PEAU_au_proc_@@EA ; proc_first
	mov	QWORD PTR proc_$1[rsp], rax
	jmp	SHORT $LN4@AuProcessF
$LN3@AuProcessF:
	mov	rax, QWORD PTR proc_$1[rsp]
	mov	rax, QWORD PTR [rax+1128]
	mov	QWORD PTR proc_$1[rsp], rax
$LN4@AuProcessF:
	cmp	QWORD PTR proc_$1[rsp], 0
	je	SHORT $LN2@AuProcessF

; 154  : 		if (proc_->main_thread == thread) {

	mov	rax, QWORD PTR proc_$1[rsp]
	mov	rcx, QWORD PTR thread$[rsp]
	cmp	QWORD PTR [rax+72], rcx
	jne	SHORT $LN1@AuProcessF

; 155  : 			return proc_;

	mov	rax, QWORD PTR proc_$1[rsp]
	jmp	SHORT $LN5@AuProcessF
$LN1@AuProcessF:

; 156  : 		}
; 157  : 	}

	jmp	SHORT $LN3@AuProcessF
$LN2@AuProcessF:

; 158  : 
; 159  : 	return NULL;

	xor	eax, eax
$LN5@AuProcessF:

; 160  : }

	add	rsp, 24
	ret	0
?AuProcessFindThread@@YAPEAU_au_proc_@@PEAU_au_thread_@@@Z ENDP ; AuProcessFindThread
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\process.cpp
_TEXT	SEGMENT
proc_$1 = 0
pid$ = 32
?AuProcessFindPID@@YAPEAU_au_proc_@@H@Z PROC		; AuProcessFindPID

; 139  : AuProcess *AuProcessFindPID(int pid) {

$LN7:
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 24

; 140  : 	for (AuProcess *proc_ = proc_first; proc_ != NULL; proc_ = proc_->next) {

	mov	rax, QWORD PTR ?proc_first@@3PEAU_au_proc_@@EA ; proc_first
	mov	QWORD PTR proc_$1[rsp], rax
	jmp	SHORT $LN4@AuProcessF
$LN3@AuProcessF:
	mov	rax, QWORD PTR proc_$1[rsp]
	mov	rax, QWORD PTR [rax+1128]
	mov	QWORD PTR proc_$1[rsp], rax
$LN4@AuProcessF:
	cmp	QWORD PTR proc_$1[rsp], 0
	je	SHORT $LN2@AuProcessF

; 141  : 		if (proc_->proc_id == pid)

	mov	rax, QWORD PTR proc_$1[rsp]
	mov	ecx, DWORD PTR pid$[rsp]
	cmp	DWORD PTR [rax], ecx
	jne	SHORT $LN1@AuProcessF

; 142  : 			return proc_;

	mov	rax, QWORD PTR proc_$1[rsp]
	jmp	SHORT $LN5@AuProcessF
$LN1@AuProcessF:

; 143  : 	}

	jmp	SHORT $LN3@AuProcessF
$LN2@AuProcessF:

; 144  : 	return NULL;

	xor	eax, eax
$LN5@AuProcessF:

; 145  : }

	add	rsp, 24
	ret	0
?AuProcessFindPID@@YAPEAU_au_proc_@@H@Z ENDP		; AuProcessFindPID
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\process.cpp
_TEXT	SEGMENT
i$1 = 32
page$2 = 40
phys$3 = 48
location$ = 56
proc$ = 80
ptr$ = 88
cr3$ = 96
?KernelStackFree@@YAXPEAU_au_proc_@@PEAXPEA_K@Z PROC	; KernelStackFree

; 217  : void KernelStackFree(AuProcess* proc,void* ptr, uint64_t *cr3) {

$LN8:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 218  : 	uint64_t location = (uint64_t)ptr;

	mov	rax, QWORD PTR ptr$[rsp]
	mov	QWORD PTR location$[rsp], rax

; 219  : 	for (int i = 0; i < 8192 / 4096; i++) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN5@KernelStac
$LN4@KernelStac:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN5@KernelStac:
	cmp	DWORD PTR i$1[rsp], 2
	jge	SHORT $LN3@KernelStac

; 220  : 		AuVPage* page = AuVmmngrGetPage((location + (i * PAGE_SIZE)), VIRT_GETPAGE_ONLY_RET, VIRT_GETPAGE_ONLY_RET);

	imul	eax, DWORD PTR i$1[rsp], 4096		; 00001000H
	cdqe
	mov	rcx, QWORD PTR location$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	r8b, 2
	mov	dl, 2
	mov	rcx, rax
	call	AuVmmngrGetPage
	mov	QWORD PTR page$2[rsp], rax

; 221  : 		if (page) {

	cmp	QWORD PTR page$2[rsp], 0
	je	SHORT $LN2@KernelStac

; 222  : 			uint64_t phys = page->bits.page << PAGE_SHIFT;

	mov	rax, QWORD PTR page$2[rsp]
	mov	rax, QWORD PTR [rax]
	shr	rax, 12
	and	rax, 268435455				; 0fffffffH
	shl	rax, 12
	mov	QWORD PTR phys$3[rsp], rax

; 223  : 			if (phys) {

	cmp	QWORD PTR phys$3[rsp], 0
	je	SHORT $LN1@KernelStac

; 224  : 				AuPmmngrFree((void*)phys);

	mov	rcx, QWORD PTR phys$3[rsp]
	call	AuPmmngrFree
$LN1@KernelStac:

; 225  : 			}
; 226  : 			page->bits.page = 0;

	mov	rax, QWORD PTR page$2[rsp]
	mov	rcx, -1099511623681			; ffffff0000000fffH
	mov	rax, QWORD PTR [rax]
	and	rax, rcx
	mov	rcx, QWORD PTR page$2[rsp]
	mov	QWORD PTR [rcx], rax
$LN2@KernelStac:

; 227  : 		}
; 228  : 	}

	jmp	$LN4@KernelStac
$LN3@KernelStac:

; 229  : 	proc->_kstack_index_ -= 8192;

	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+64]
	sub	rax, 8192				; 00002000H
	mov	rcx, QWORD PTR proc$[rsp]
	mov	QWORD PTR [rcx+64], rax

; 230  : }

	add	rsp, 72					; 00000048H
	ret	0
?KernelStackFree@@YAXPEAU_au_proc_@@PEAXPEA_K@Z ENDP	; KernelStackFree
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\process.cpp
_TEXT	SEGMENT
i$1 = 32
location$ = 40
p$2 = 48
proc$ = 80
cr3$ = 88
?CreateKernelStack@@YA_KPEAU_au_proc_@@PEA_K@Z PROC	; CreateKernelStack

; 198  : uint64_t CreateKernelStack(AuProcess* proc, uint64_t *cr3) {

$LN6:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 199  : 	uint64_t location = KERNEL_STACK_LOCATION;

	mov	rax, -5497558138880			; fffffb0000000000H
	mov	QWORD PTR location$[rsp], rax

; 200  : 	location += proc->_kstack_index_;

	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+64]
	mov	rcx, QWORD PTR location$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR location$[rsp], rax

; 201  : 
; 202  : 	for (int i = 0; i < 8192 / 4096; i++) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN3@CreateKern
$LN2@CreateKern:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN3@CreateKern:
	cmp	DWORD PTR i$1[rsp], 2
	jge	SHORT $LN1@CreateKern

; 203  : 		void* p = AuPmmngrAlloc();

	call	AuPmmngrAlloc
	mov	QWORD PTR p$2[rsp], rax

; 204  : 		AuMapPageEx(cr3, (uint64_t)p, location + i * PAGE_SIZE, X86_64_PAGING_USER);

	imul	eax, DWORD PTR i$1[rsp], 4096		; 00001000H
	cdqe
	mov	rcx, QWORD PTR location$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	r9b, 4
	mov	r8, rax
	mov	rdx, QWORD PTR p$2[rsp]
	mov	rcx, QWORD PTR cr3$[rsp]
	call	AuMapPageEx

; 205  : 	}

	jmp	SHORT $LN2@CreateKern
$LN1@CreateKern:

; 206  : 
; 207  : 	proc->_kstack_index_ += 8192;

	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+64]
	add	rax, 8192				; 00002000H
	mov	rcx, QWORD PTR proc$[rsp]
	mov	QWORD PTR [rcx+64], rax

; 208  : 	return (location + 8192);

	mov	rax, QWORD PTR location$[rsp]
	add	rax, 8192				; 00002000H

; 209  : }

	add	rsp, 72					; 00000048H
	ret	0
?CreateKernelStack@@YA_KPEAU_au_proc_@@PEA_K@Z ENDP	; CreateKernelStack
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\process.cpp
_TEXT	SEGMENT
parent$ = 48
proc$ = 56
?AuRemoveProcess@@YAXPEAU_au_proc_@@0@Z PROC		; AuRemoveProcess

; 86   : void AuRemoveProcess(AuProcess* parent, AuProcess* proc) {

$LN8:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 87   : 	if (proc_first == NULL)

	cmp	QWORD PTR ?proc_first@@3PEAU_au_proc_@@EA, 0 ; proc_first
	jne	SHORT $LN5@AuRemovePr

; 88   : 		return;

	jmp	$LN6@AuRemovePr
$LN5@AuRemovePr:

; 89   : 
; 90   : 	if (proc == proc_first) {

	mov	rax, QWORD PTR ?proc_first@@3PEAU_au_proc_@@EA ; proc_first
	cmp	QWORD PTR proc$[rsp], rax
	jne	SHORT $LN4@AuRemovePr

; 91   : 		proc_first = proc_first->next;

	mov	rax, QWORD PTR ?proc_first@@3PEAU_au_proc_@@EA ; proc_first
	mov	rax, QWORD PTR [rax+1128]
	mov	QWORD PTR ?proc_first@@3PEAU_au_proc_@@EA, rax ; proc_first

; 92   : 	}
; 93   : 	else {

	jmp	SHORT $LN3@AuRemovePr
$LN4@AuRemovePr:

; 94   : 		proc->prev->next = proc->next;

	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+1136]
	mov	rcx, QWORD PTR proc$[rsp]
	mov	rcx, QWORD PTR [rcx+1128]
	mov	QWORD PTR [rax+1128], rcx
$LN3@AuRemovePr:

; 95   : 	}
; 96   : 
; 97   : 	if (proc == proc_last) {

	mov	rax, QWORD PTR ?proc_last@@3PEAU_au_proc_@@EA ; proc_last
	cmp	QWORD PTR proc$[rsp], rax
	jne	SHORT $LN2@AuRemovePr

; 98   : 		proc_last = proc->prev;

	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+1136]
	mov	QWORD PTR ?proc_last@@3PEAU_au_proc_@@EA, rax ; proc_last

; 99   : 	}
; 100  : 	else {

	jmp	SHORT $LN1@AuRemovePr
$LN2@AuRemovePr:

; 101  : 		proc->next->prev = proc->prev;

	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+1128]
	mov	rcx, QWORD PTR proc$[rsp]
	mov	rcx, QWORD PTR [rcx+1136]
	mov	QWORD PTR [rax+1136], rcx
$LN1@AuRemovePr:

; 102  : 	}
; 103  : 	kfree(proc);

	mov	rcx, QWORD PTR proc$[rsp]
	call	kfree
$LN6@AuRemovePr:

; 104  : }

	add	rsp, 40					; 00000028H
	ret	0
?AuRemoveProcess@@YAXPEAU_au_proc_@@0@Z ENDP		; AuRemoveProcess
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\process.cpp
_TEXT	SEGMENT
parent$ = 8
proc$ = 16
?AuAddProcess@@YAXPEAU_au_proc_@@0@Z PROC		; AuAddProcess

; 64   : void AuAddProcess(AuProcess* parent, AuProcess *proc) {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 65   : 	proc->next = NULL;

	mov	rax, QWORD PTR proc$[rsp]
	mov	QWORD PTR [rax+1128], 0

; 66   : 	proc->prev = NULL;

	mov	rax, QWORD PTR proc$[rsp]
	mov	QWORD PTR [rax+1136], 0

; 67   : 
; 68   : 	if (proc_first == NULL) {

	cmp	QWORD PTR ?proc_first@@3PEAU_au_proc_@@EA, 0 ; proc_first
	jne	SHORT $LN2@AuAddProce

; 69   : 		proc_last = proc;

	mov	rax, QWORD PTR proc$[rsp]
	mov	QWORD PTR ?proc_last@@3PEAU_au_proc_@@EA, rax ; proc_last

; 70   : 		proc_first = proc;

	mov	rax, QWORD PTR proc$[rsp]
	mov	QWORD PTR ?proc_first@@3PEAU_au_proc_@@EA, rax ; proc_first

; 71   : 	}
; 72   : 	else {

	jmp	SHORT $LN1@AuAddProce
$LN2@AuAddProce:

; 73   : 		proc_last->next = proc;

	mov	rax, QWORD PTR ?proc_last@@3PEAU_au_proc_@@EA ; proc_last
	mov	rcx, QWORD PTR proc$[rsp]
	mov	QWORD PTR [rax+1128], rcx

; 74   : 		proc->prev = proc_last;

	mov	rax, QWORD PTR proc$[rsp]
	mov	rcx, QWORD PTR ?proc_last@@3PEAU_au_proc_@@EA ; proc_last
	mov	QWORD PTR [rax+1136], rcx
$LN1@AuAddProce:

; 75   : 	}
; 76   : 	proc_last = proc;

	mov	rax, QWORD PTR proc$[rsp]
	mov	QWORD PTR ?proc_last@@3PEAU_au_proc_@@EA, rax ; proc_last

; 77   : 	//proc->parent = parent;
; 78   : }

	ret	0
?AuAddProcess@@YAXPEAU_au_proc_@@0@Z ENDP		; AuAddProcess
_TEXT	ENDS
END
