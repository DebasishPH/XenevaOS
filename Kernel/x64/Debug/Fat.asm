; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.21005.1 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG3669	DB	'Buffer ->%x ', 0aH, 00H
	ORG $+2
$SG3817	DB	'%c', 00H
CONST	ENDS
PUBLIC	?FatInitialise@@YAPEAU__VFS_NODE__@@PEAU_VDISK_@@PEAD@Z ; FatInitialise
PUBLIC	?FatClusterToSector32@@YA_KPEAU_FatFS_@@_K@Z	; FatClusterToSector32
PUBLIC	?FatToDOSFilename@@YAXPEBDPEADI@Z		; FatToDOSFilename
PUBLIC	?FatFindFreeCluster@@YAIPEAU__VFS_NODE__@@@Z	; FatFindFreeCluster
PUBLIC	?FatAllocCluster@@YAXPEAU__VFS_NODE__@@HI@Z	; FatAllocCluster
PUBLIC	?FatClearCluster@@YAXPEAU__VFS_NODE__@@I@Z	; FatClearCluster
PUBLIC	?FatReadFAT@@YAIPEAU__VFS_NODE__@@I@Z		; FatReadFAT
PUBLIC	?FatFormatDate@@YAGXZ				; FatFormatDate
PUBLIC	?FatFormatTime@@YAGXZ				; FatFormatTime
PUBLIC	?FatLocateDir@@YAPEAU__VFS_NODE__@@PEAU1@PEBD@Z	; FatLocateDir
PUBLIC	?FatLocateSubDir@@YAPEAU__VFS_NODE__@@PEAU1@0PEBD@Z ; FatLocateSubDir
PUBLIC	?FatRead@@YA_KPEAU__VFS_NODE__@@0PEA_K@Z	; FatRead
PUBLIC	?FatOpen@@YAPEAU__VFS_NODE__@@PEAU1@PEAD@Z	; FatOpen
PUBLIC	?FatGetClusterFor@@YA_KPEAU__VFS_NODE__@@0_K@Z	; FatGetClusterFor
EXTRN	AuVFSAddFileSystem:PROC
EXTRN	AuVFSRegisterRoot:PROC
EXTRN	AuVDiskRead:PROC
EXTRN	AuVDiskWrite:PROC
EXTRN	?FatCreateFile@@YAPEAU__VFS_NODE__@@PEAU1@PEAD@Z:PROC ; FatCreateFile
EXTRN	?FatWrite@@YA_KPEAU__VFS_NODE__@@0PEA_KI@Z:PROC	; FatWrite
EXTRN	?FatFileRemove@@YAHPEAU__VFS_NODE__@@0@Z:PROC	; FatFileRemove
EXTRN	?FatCreateDir@@YAPEAU__VFS_NODE__@@PEAU1@PEAD@Z:PROC ; FatCreateDir
EXTRN	?FatRemoveDir@@YAHPEAU__VFS_NODE__@@0@Z:PROC	; FatRemoveDir
EXTRN	AuPmmngrAlloc:PROC
EXTRN	AuPmmngrFree:PROC
EXTRN	P2V:PROC
EXTRN	V2P:PROC
EXTRN	strcmp:PROC
EXTRN	strcpy:PROC
EXTRN	strlen:PROC
EXTRN	strchr:PROC
EXTRN	memset:PROC
EXTRN	memcpy:PROC
EXTRN	AuTextOut:PROC
EXTRN	toupper:PROC
EXTRN	kmalloc:PROC
EXTRN	kfree:PROC
EXTRN	AuRTCGetYear:PROC
EXTRN	AuRTCGetMinutes:PROC
EXTRN	AuRTCGetSecond:PROC
EXTRN	AuRTCGetDay:PROC
EXTRN	AuRTCGetHour:PROC
EXTRN	AuRTCGetMonth:PROC
pdata	SEGMENT
$pdata$?FatInitialise@@YAPEAU__VFS_NODE__@@PEAU_VDISK_@@PEAD@Z DD imagerel $LN16
	DD	imagerel $LN16+1038
	DD	imagerel $unwind$?FatInitialise@@YAPEAU__VFS_NODE__@@PEAU_VDISK_@@PEAD@Z
$pdata$?FatToDOSFilename@@YAXPEBDPEADI@Z DD imagerel $LN19
	DD	imagerel $LN19+382
	DD	imagerel $unwind$?FatToDOSFilename@@YAXPEBDPEADI@Z
$pdata$?FatFindFreeCluster@@YAIPEAU__VFS_NODE__@@@Z DD imagerel $LN8
	DD	imagerel $LN8+308
	DD	imagerel $unwind$?FatFindFreeCluster@@YAIPEAU__VFS_NODE__@@@Z
$pdata$?FatAllocCluster@@YAXPEAU__VFS_NODE__@@HI@Z DD imagerel $LN4
	DD	imagerel $LN4+343
	DD	imagerel $unwind$?FatAllocCluster@@YAXPEAU__VFS_NODE__@@HI@Z
$pdata$?FatClearCluster@@YAXPEAU__VFS_NODE__@@I@Z DD imagerel $LN4
	DD	imagerel $LN4+189
	DD	imagerel $unwind$?FatClearCluster@@YAXPEAU__VFS_NODE__@@I@Z
$pdata$?FatReadFAT@@YAIPEAU__VFS_NODE__@@I@Z DD imagerel $LN4
	DD	imagerel $LN4+255
	DD	imagerel $unwind$?FatReadFAT@@YAIPEAU__VFS_NODE__@@I@Z
$pdata$?FatFormatDate@@YAGXZ DD imagerel $LN3
	DD	imagerel $LN3+66
	DD	imagerel $unwind$?FatFormatDate@@YAGXZ
$pdata$?FatFormatTime@@YAGXZ DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$?FatFormatTime@@YAGXZ
$pdata$?FatLocateDir@@YAPEAU__VFS_NODE__@@PEAU1@PEBD@Z DD imagerel $LN13
	DD	imagerel $LN13+690
	DD	imagerel $unwind$?FatLocateDir@@YAPEAU__VFS_NODE__@@PEAU1@PEBD@Z
$pdata$?FatLocateSubDir@@YAPEAU__VFS_NODE__@@PEAU1@0PEBD@Z DD imagerel $LN12
	DD	imagerel $LN12+539
	DD	imagerel $unwind$?FatLocateSubDir@@YAPEAU__VFS_NODE__@@PEAU1@0PEBD@Z
$pdata$?FatRead@@YA_KPEAU__VFS_NODE__@@0PEA_K@Z DD imagerel $LN6
	DD	imagerel $LN6+213
	DD	imagerel $unwind$?FatRead@@YA_KPEAU__VFS_NODE__@@0PEA_K@Z
$pdata$?FatOpen@@YAPEAU__VFS_NODE__@@PEAU1@PEAD@Z DD imagerel $LN17
	DD	imagerel $LN17+413
	DD	imagerel $unwind$?FatOpen@@YAPEAU__VFS_NODE__@@PEAU1@PEAD@Z
$pdata$?FatGetClusterFor@@YA_KPEAU__VFS_NODE__@@0_K@Z DD imagerel $LN6
	DD	imagerel $LN6+127
	DD	imagerel $unwind$?FatGetClusterFor@@YA_KPEAU__VFS_NODE__@@0_K@Z
pdata	ENDS
xdata	SEGMENT
$unwind$?FatInitialise@@YAPEAU__VFS_NODE__@@PEAU_VDISK_@@PEAD@Z DD 021101H
	DD	0110111H
$unwind$?FatToDOSFilename@@YAXPEBDPEADI@Z DD 011301H
	DD	06213H
$unwind$?FatFindFreeCluster@@YAIPEAU__VFS_NODE__@@@Z DD 010901H
	DD	0c209H
$unwind$?FatAllocCluster@@YAXPEAU__VFS_NODE__@@HI@Z DD 011201H
	DD	0c212H
$unwind$?FatClearCluster@@YAXPEAU__VFS_NODE__@@I@Z DD 010d01H
	DD	0820dH
$unwind$?FatReadFAT@@YAIPEAU__VFS_NODE__@@I@Z DD 010d01H
	DD	0c20dH
$unwind$?FatFormatDate@@YAGXZ DD 010401H
	DD	06204H
$unwind$?FatFormatTime@@YAGXZ DD 010401H
	DD	06204H
$unwind$?FatLocateDir@@YAPEAU__VFS_NODE__@@PEAU1@PEBD@Z DD 021101H
	DD	0110111H
$unwind$?FatLocateSubDir@@YAPEAU__VFS_NODE__@@PEAU1@0PEBD@Z DD 011301H
	DD	0c213H
$unwind$?FatRead@@YA_KPEAU__VFS_NODE__@@0PEA_K@Z DD 011301H
	DD	08213H
$unwind$?FatOpen@@YAPEAU__VFS_NODE__@@PEAU1@PEAD@Z DD 010e01H
	DD	0c20eH
$unwind$?FatGetClusterFor@@YA_KPEAU__VFS_NODE__@@0_K@Z DD 011301H
	DD	08213H
xdata	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\fs\fat\fat.cpp
_TEXT	SEGMENT
i$1 = 32
cluster$ = 36
fatfs$ = 40
index$ = 48
fs$ = 80
file$ = 88
offset$ = 96
?FatGetClusterFor@@YA_KPEAU__VFS_NODE__@@0_K@Z PROC	; FatGetClusterFor

; 419  : size_t FatGetClusterFor(AuVFSNode* fs,AuVFSNode* file, uint64_t offset){

$LN6:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 420  : 	FatFS *fatfs = (FatFS*)fs->device;

	mov	rax, QWORD PTR fs$[rsp]
	mov	rax, QWORD PTR [rax+63]
	mov	QWORD PTR fatfs$[rsp], rax

; 421  : 	size_t index = offset / fatfs->cluster_sz_in_bytes;

	xor	edx, edx
	mov	rax, QWORD PTR offset$[rsp]
	mov	rcx, QWORD PTR fatfs$[rsp]
	div	QWORD PTR [rcx+72]
	mov	QWORD PTR index$[rsp], rax

; 422  : 	uint32_t cluster = file->current;

	mov	rax, QWORD PTR file$[rsp]
	mov	eax, DWORD PTR [rax+53]
	mov	DWORD PTR cluster$[rsp], eax

; 423  : 	for (int i = 0; i < index; i++) 

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN3@FatGetClus
$LN2@FatGetClus:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN3@FatGetClus:
	movsxd	rax, DWORD PTR i$1[rsp]
	cmp	rax, QWORD PTR index$[rsp]
	jae	SHORT $LN1@FatGetClus

; 424  : 		cluster = FatReadFAT(fs, cluster);

	mov	edx, DWORD PTR cluster$[rsp]
	mov	rcx, QWORD PTR fs$[rsp]
	call	?FatReadFAT@@YAIPEAU__VFS_NODE__@@I@Z	; FatReadFAT
	mov	DWORD PTR cluster$[rsp], eax
	jmp	SHORT $LN2@FatGetClus
$LN1@FatGetClus:

; 425  : 	return cluster;

	mov	eax, DWORD PTR cluster$[rsp]

; 426  : }

	add	rsp, 72					; 00000048H
	ret	0
?FatGetClusterFor@@YA_KPEAU__VFS_NODE__@@0_K@Z ENDP	; FatGetClusterFor
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\fs\fat\fat.cpp
_TEXT	SEGMENT
root_dir$ = 32
i$1 = 36
p$ = 40
cur_dir$ = 48
path$ = 56
vdisk$ = 64
pathname$2 = 72
fsys$ = 112
filename$ = 120
?FatOpen@@YAPEAU__VFS_NODE__@@PEAU1@PEAD@Z PROC		; FatOpen

; 341  : AuVFSNode * FatOpen(AuVFSNode * fsys, char* filename) {

$LN17:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 342  : 	AuVFSNode *cur_dir = NULL;

	mov	QWORD PTR cur_dir$[rsp], 0

; 343  : 	AuVDisk *vdisk = (AuVDisk*)fsys->device;

	mov	rax, QWORD PTR fsys$[rsp]
	mov	rax, QWORD PTR [rax+63]
	mov	QWORD PTR vdisk$[rsp], rax

; 344  : 	char* p = 0;

	mov	QWORD PTR p$[rsp], 0

; 345  : 	bool  root_dir = true;

	mov	BYTE PTR root_dir$[rsp], 1

; 346  : 	char* path = (char*)filename;

	mov	rax, QWORD PTR filename$[rsp]
	mov	QWORD PTR path$[rsp], rax

; 347  : 
; 348  : 	//! any '\'s in path ?
; 349  : 	p = strchr(path, '/');

	mov	edx, 47					; 0000002fH
	mov	rcx, QWORD PTR path$[rsp]
	call	strchr
	mov	QWORD PTR p$[rsp], rax

; 350  : 	if (!p) {

	cmp	QWORD PTR p$[rsp], 0
	jne	SHORT $LN14@FatOpen

; 351  : 		//! nope, must be in root directory, search it
; 352  : 		cur_dir = FatLocateDir(fsys,path);

	mov	rdx, QWORD PTR path$[rsp]
	mov	rcx, QWORD PTR fsys$[rsp]
	call	?FatLocateDir@@YAPEAU__VFS_NODE__@@PEAU1@PEBD@Z ; FatLocateDir
	mov	QWORD PTR cur_dir$[rsp], rax

; 353  : 
; 354  : 		//! found file ?
; 355  : 		if (cur_dir != NULL) {

	cmp	QWORD PTR cur_dir$[rsp], 0
	je	SHORT $LN13@FatOpen

; 356  : 			return cur_dir;

	mov	rax, QWORD PTR cur_dir$[rsp]
	jmp	$LN15@FatOpen
$LN13@FatOpen:

; 357  : 		}
; 358  : 
; 359  : 		//! unable to find
; 360  : 		return NULL;

	xor	eax, eax
	jmp	$LN15@FatOpen
$LN14@FatOpen:

; 361  : 	}
; 362  : 
; 363  : 	//! go to next character after first '\'
; 364  : 	p++;

	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax
$LN12@FatOpen:

; 365  : 	while (p) {

	cmp	QWORD PTR p$[rsp], 0
	je	$LN11@FatOpen

; 366  : 
; 367  : 		//! get pathname
; 368  : 		char pathname[16];
; 369  : 		int i = 0;

	mov	DWORD PTR i$1[rsp], 0

; 370  : 		for (i = 0; i < 16; i++) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN10@FatOpen
$LN9@FatOpen:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN10@FatOpen:
	cmp	DWORD PTR i$1[rsp], 16
	jge	SHORT $LN8@FatOpen

; 371  : 
; 372  : 			//! if another '\' or end of line is reached, we are done
; 373  : 			if (p[i] == '/' || p[i] == '\0')

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 47					; 0000002fH
	je	SHORT $LN6@FatOpen
	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	jne	SHORT $LN7@FatOpen
$LN6@FatOpen:

; 374  : 				break;

	jmp	SHORT $LN8@FatOpen
$LN7@FatOpen:

; 375  : 
; 376  : 			//! copy character
; 377  : 			pathname[i] = p[i];

	movsxd	rax, DWORD PTR i$1[rsp]
	movsxd	rcx, DWORD PTR i$1[rsp]
	mov	rdx, QWORD PTR p$[rsp]
	movzx	eax, BYTE PTR [rdx+rax]
	mov	BYTE PTR pathname$2[rsp+rcx], al

; 378  : 		}

	jmp	SHORT $LN9@FatOpen
$LN8@FatOpen:

; 379  : 		pathname[i] = 0; //null terminate

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	BYTE PTR pathname$2[rsp+rax], 0

; 380  : 		//! open subdirectory or file
; 381  : 		if (root_dir) {

	movzx	eax, BYTE PTR root_dir$[rsp]
	test	eax, eax
	je	SHORT $LN5@FatOpen

; 382  : 			//! search root dir -- open pathname
; 383  : 			cur_dir = FatLocateDir(fsys,pathname);

	lea	rdx, QWORD PTR pathname$2[rsp]
	mov	rcx, QWORD PTR fsys$[rsp]
	call	?FatLocateDir@@YAPEAU__VFS_NODE__@@PEAU1@PEBD@Z ; FatLocateDir
	mov	QWORD PTR cur_dir$[rsp], rax

; 384  : 			root_dir = false;

	mov	BYTE PTR root_dir$[rsp], 0

; 385  : 		}
; 386  : 		else {

	jmp	SHORT $LN4@FatOpen
$LN5@FatOpen:

; 387  : 			//! search a sub directory instead for pathname
; 388  : 			cur_dir = FatLocateSubDir(fsys,cur_dir, pathname);

	lea	r8, QWORD PTR pathname$2[rsp]
	mov	rdx, QWORD PTR cur_dir$[rsp]
	mov	rcx, QWORD PTR fsys$[rsp]
	call	?FatLocateSubDir@@YAPEAU__VFS_NODE__@@PEAU1@0PEBD@Z ; FatLocateSubDir
	mov	QWORD PTR cur_dir$[rsp], rax
$LN4@FatOpen:

; 389  : 		}
; 390  : 
; 391  : 		//! found directory or file?
; 392  : 		if (cur_dir == NULL)

	cmp	QWORD PTR cur_dir$[rsp], 0
	jne	SHORT $LN3@FatOpen

; 393  : 			break;

	jmp	SHORT $LN11@FatOpen
$LN3@FatOpen:

; 394  : 
; 395  : 		//! find next '\'
; 396  : 		p = strchr(p + 1, '/');

	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	edx, 47					; 0000002fH
	mov	rcx, rax
	call	strchr
	mov	QWORD PTR p$[rsp], rax

; 397  : 		if (p)

	cmp	QWORD PTR p$[rsp], 0
	je	SHORT $LN2@FatOpen

; 398  : 			p++;

	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax
$LN2@FatOpen:

; 399  : 	}

	jmp	$LN12@FatOpen
$LN11@FatOpen:

; 400  : 
; 401  : 	//! found file?
; 402  : 	if (cur_dir != NULL){

	cmp	QWORD PTR cur_dir$[rsp], 0
	je	SHORT $LN1@FatOpen

; 403  : 		return cur_dir;

	mov	rax, QWORD PTR cur_dir$[rsp]
	jmp	SHORT $LN15@FatOpen
$LN1@FatOpen:

; 404  : 	}
; 405  : 	//! unable to find
; 406  : 	/*vfs_node_t ret;
; 407  : 	ret.flags = FS_FLAG_INVALID;
; 408  : 	ret.size = 0;*/
; 409  : 	return NULL;

	xor	eax, eax
$LN15@FatOpen:

; 410  : }

	add	rsp, 104				; 00000068H
	ret	0
?FatOpen@@YAPEAU__VFS_NODE__@@PEAU1@PEAD@Z ENDP		; FatOpen
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\fs\fat\fat.cpp
_TEXT	SEGMENT
value$ = 32
fs$ = 40
vdisk$ = 48
lba$ = 56
fsys$ = 80
file$ = 88
buf$ = 96
?FatRead@@YA_KPEAU__VFS_NODE__@@0PEA_K@Z PROC		; FatRead

; 205  : size_t FatRead(AuVFSNode* fsys, AuVFSNode *file, uint64_t* buf) {

$LN6:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 206  : 	FatFS* fs = (FatFS*)fsys->device;

	mov	rax, QWORD PTR fsys$[rsp]
	mov	rax, QWORD PTR [rax+63]
	mov	QWORD PTR fs$[rsp], rax

; 207  : 	AuVDisk* vdisk = (AuVDisk*)fs->vdisk;

	mov	rax, QWORD PTR fs$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR vdisk$[rsp], rax

; 208  : 	if (!vdisk)

	cmp	QWORD PTR vdisk$[rsp], 0
	jne	SHORT $LN3@FatRead

; 209  : 		return NULL;

	xor	eax, eax
	jmp	$LN4@FatRead
$LN3@FatRead:

; 210  : 
; 211  : 	auto lba = FatClusterToSector32(fs, file->current);

	mov	rax, QWORD PTR file$[rsp]
	mov	rdx, QWORD PTR [rax+53]
	mov	rcx, QWORD PTR fs$[rsp]
	call	?FatClusterToSector32@@YA_KPEAU_FatFS_@@_K@Z ; FatClusterToSector32
	mov	QWORD PTR lba$[rsp], rax

; 212  : 
; 213  : 	AuVDiskRead(vdisk, lba, 8, buf);

	mov	r9, QWORD PTR buf$[rsp]
	mov	r8d, 8
	mov	rdx, QWORD PTR lba$[rsp]
	mov	rcx, QWORD PTR vdisk$[rsp]
	call	AuVDiskRead

; 214  : 
; 215  : 	uint32_t value = FatReadFAT(fsys,file->current);

	mov	rax, QWORD PTR file$[rsp]
	mov	edx, DWORD PTR [rax+53]
	mov	rcx, QWORD PTR fsys$[rsp]
	call	?FatReadFAT@@YAIPEAU__VFS_NODE__@@I@Z	; FatReadFAT
	mov	DWORD PTR value$[rsp], eax

; 216  : 
; 217  : 	if (value >= 0x0FFFFFF8) {

	cmp	DWORD PTR value$[rsp], 268435448	; 0ffffff8H
	jb	SHORT $LN2@FatRead

; 218  : 		file->eof = 1;

	mov	rax, QWORD PTR file$[rsp]
	mov	BYTE PTR [rax+36], 1

; 219  : 		return -1;

	mov	rax, -1
	jmp	SHORT $LN4@FatRead
$LN2@FatRead:

; 220  : 	}
; 221  : 
; 222  : 	if (value == 0x0FFFFFF7) {

	cmp	DWORD PTR value$[rsp], 268435447	; 0ffffff7H
	jne	SHORT $LN1@FatRead

; 223  : 		file->eof = 1;

	mov	rax, QWORD PTR file$[rsp]
	mov	BYTE PTR [rax+36], 1

; 224  : 		return -1;

	mov	rax, -1
	jmp	SHORT $LN4@FatRead
$LN1@FatRead:

; 225  : 	}
; 226  : 	file->current = value;

	mov	eax, DWORD PTR value$[rsp]
	mov	rcx, QWORD PTR file$[rsp]
	mov	QWORD PTR [rcx+53], rax

; 227  : 	return 4096;

	mov	eax, 4096				; 00001000H
$LN4@FatRead:

; 228  : }

	add	rsp, 72					; 00000048H
	ret	0
?FatRead@@YA_KPEAU__VFS_NODE__@@0PEA_K@Z ENDP		; FatRead
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\fs\fat\fat.cpp
_TEXT	SEGMENT
i$1 = 32
file$ = 40
pkDir$2 = 48
buf$ = 56
dos_file_name$ = 64
name$3 = 80
fsys$ = 112
kfile$ = 120
filename$ = 128
?FatLocateSubDir@@YAPEAU__VFS_NODE__@@PEAU1@0PEBD@Z PROC ; FatLocateSubDir

; 230  : AuVFSNode* FatLocateSubDir(AuVFSNode* fsys,AuVFSNode* kfile, const char* filename) {

$LN12:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 231  : 	AuVFSNode* file = (AuVFSNode*)kmalloc(sizeof(AuVFSNode));

	mov	ecx, 159				; 0000009fH
	call	kmalloc
	mov	QWORD PTR file$[rsp], rax

; 232  : 	memset(file, 0, sizeof(AuVFSNode));

	mov	r8d, 159				; 0000009fH
	xor	edx, edx
	mov	rcx, QWORD PTR file$[rsp]
	call	memset

; 233  : 
; 234  : 	char dos_file_name[11];
; 235  : 	memset(dos_file_name, 0, 11);

	mov	r8d, 11
	xor	edx, edx
	lea	rcx, QWORD PTR dos_file_name$[rsp]
	call	memset

; 236  : 	FatToDOSFilename(filename, dos_file_name, 11);

	mov	r8d, 11
	lea	rdx, QWORD PTR dos_file_name$[rsp]
	mov	rcx, QWORD PTR filename$[rsp]
	call	?FatToDOSFilename@@YAXPEBDPEADI@Z	; FatToDOSFilename

; 237  : 	dos_file_name[11] = 0;

	mov	eax, 1
	imul	rax, rax, 11
	mov	BYTE PTR dos_file_name$[rsp+rax], 0

; 238  : 
; 239  : 	uint64_t* buf = (uint64_t*)P2V((size_t)AuPmmngrAlloc());

	call	AuPmmngrAlloc
	mov	rcx, rax
	call	P2V
	mov	QWORD PTR buf$[rsp], rax

; 240  : 	if (kfile->flags != FS_FLAG_INVALID) {

	mov	rax, QWORD PTR kfile$[rsp]
	movzx	eax, BYTE PTR [rax+61]
	cmp	eax, 32					; 00000020H
	je	$LN9@FatLocateS
$LN8@FatLocateS:

; 241  : 		while (!kfile->eof) {

	mov	rax, QWORD PTR kfile$[rsp]
	movzx	eax, BYTE PTR [rax+36]
	test	eax, eax
	jne	$LN7@FatLocateS

; 242  : 			FatRead(fsys, kfile, (uint64_t*)V2P((size_t)buf));

	mov	rcx, QWORD PTR buf$[rsp]
	call	V2P
	mov	r8, rax
	mov	rdx, QWORD PTR kfile$[rsp]
	mov	rcx, QWORD PTR fsys$[rsp]
	call	?FatRead@@YA_KPEAU__VFS_NODE__@@0PEA_K@Z ; FatRead

; 243  : 
; 244  : 			FatDir* pkDir = (FatDir*)buf;

	mov	rax, QWORD PTR buf$[rsp]
	mov	QWORD PTR pkDir$2[rsp], rax

; 245  : 			for (unsigned int i = 0; i < 16; i++) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN6@FatLocateS
$LN5@FatLocateS:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN6@FatLocateS:
	cmp	DWORD PTR i$1[rsp], 16
	jae	$LN4@FatLocateS

; 246  : 				char name[11];
; 247  : 				memcpy(name, pkDir->filename, 11);

	mov	rax, QWORD PTR pkDir$2[rsp]
	mov	r8d, 11
	mov	rdx, rax
	lea	rcx, QWORD PTR name$3[rsp]
	call	memcpy

; 248  : 				if (strcmp(name, dos_file_name) == 0) {

	lea	rdx, QWORD PTR dos_file_name$[rsp]
	lea	rcx, QWORD PTR name$3[rsp]
	call	strcmp
	test	eax, eax
	jne	$LN3@FatLocateS

; 249  : 					
; 250  : 					strcpy(file->filename, filename);

	mov	rax, QWORD PTR file$[rsp]
	mov	rdx, QWORD PTR filename$[rsp]
	mov	rcx, rax
	call	strcpy

; 251  : 					file->current = pkDir->first_cluster;

	mov	rax, QWORD PTR pkDir$2[rsp]
	movzx	eax, WORD PTR [rax+26]
	mov	rcx, QWORD PTR file$[rsp]
	mov	QWORD PTR [rcx+53], rax

; 252  : 					file->size = pkDir->file_size;

	mov	rax, QWORD PTR file$[rsp]
	mov	rcx, QWORD PTR pkDir$2[rsp]
	mov	ecx, DWORD PTR [rcx+28]
	mov	DWORD PTR [rax+32], ecx

; 253  : 					file->eof = 0;

	mov	rax, QWORD PTR file$[rsp]
	mov	BYTE PTR [rax+36], 0

; 254  : 					file->pos = 0;

	mov	rax, QWORD PTR file$[rsp]
	mov	DWORD PTR [rax+37], 0

; 255  : 					file->status = FS_STATUS_FOUND;

	mov	rax, QWORD PTR file$[rsp]
	mov	BYTE PTR [rax+62], 1

; 256  : 					file->first_block = file->current;

	mov	rax, QWORD PTR file$[rsp]
	mov	rcx, QWORD PTR file$[rsp]
	mov	rcx, QWORD PTR [rcx+53]
	mov	QWORD PTR [rax+45], rcx

; 257  : 					file->device = fsys;

	mov	rax, QWORD PTR file$[rsp]
	mov	rcx, QWORD PTR fsys$[rsp]
	mov	QWORD PTR [rax+63], rcx

; 258  : 					file->parent_block = kfile->current;

	mov	rax, QWORD PTR file$[rsp]
	mov	rcx, QWORD PTR kfile$[rsp]
	mov	ecx, DWORD PTR [rcx+53]
	mov	DWORD PTR [rax+41], ecx

; 259  : 					if (pkDir->attrib == 0x10)

	mov	rax, QWORD PTR pkDir$2[rsp]
	movzx	eax, BYTE PTR [rax+11]
	cmp	eax, 16
	jne	SHORT $LN2@FatLocateS

; 260  : 						file->flags = FS_FLAG_DIRECTORY;

	mov	rax, QWORD PTR file$[rsp]
	mov	BYTE PTR [rax+61], 2

; 261  : 					else

	jmp	SHORT $LN1@FatLocateS
$LN2@FatLocateS:

; 262  : 						file->flags |= FS_FLAG_GENERAL;

	mov	rax, QWORD PTR file$[rsp]
	movzx	eax, BYTE PTR [rax+61]
	or	eax, 4
	mov	rcx, QWORD PTR file$[rsp]
	mov	BYTE PTR [rcx+61], al
$LN1@FatLocateS:

; 263  : 
; 264  : 					AuPmmngrFree((void*)V2P((size_t)buf));

	mov	rcx, QWORD PTR buf$[rsp]
	call	V2P
	mov	rcx, rax
	call	AuPmmngrFree

; 265  : 					//kfree(kfile);
; 266  : 					return file;

	mov	rax, QWORD PTR file$[rsp]
	jmp	SHORT $LN10@FatLocateS
$LN3@FatLocateS:

; 267  : 				}
; 268  : 
; 269  : 				pkDir++;

	mov	rax, QWORD PTR pkDir$2[rsp]
	add	rax, 32					; 00000020H
	mov	QWORD PTR pkDir$2[rsp], rax

; 270  : 			}

	jmp	$LN5@FatLocateS
$LN4@FatLocateS:

; 271  : 		}

	jmp	$LN8@FatLocateS
$LN7@FatLocateS:
$LN9@FatLocateS:

; 272  : 	}
; 273  : 
; 274  : 	AuPmmngrFree((void*)V2P((size_t)buf));

	mov	rcx, QWORD PTR buf$[rsp]
	call	V2P
	mov	rcx, rax
	call	AuPmmngrFree

; 275  : 	kfree(file);

	mov	rcx, QWORD PTR file$[rsp]
	call	kfree

; 276  : 	return NULL;

	xor	eax, eax
$LN10@FatLocateS:

; 277  : }

	add	rsp, 104				; 00000068H
	ret	0
?FatLocateSubDir@@YAPEAU__VFS_NODE__@@PEAU1@0PEBD@Z ENDP ; FatLocateSubDir
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\fs\fat\fat.cpp
_TEXT	SEGMENT
file$ = 32
sector$1 = 40
i$2 = 44
buf$ = 48
dirent$ = 56
fs$ = 64
vdisk$ = 72
name$3 = 80
dos_file_name$ = 96
tv91 = 112
fsys$ = 144
dir$ = 152
?FatLocateDir@@YAPEAU__VFS_NODE__@@PEAU1@PEBD@Z PROC	; FatLocateDir

; 279  : AuVFSNode* FatLocateDir(AuVFSNode* fsys, const char* dir) {

$LN13:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 136				; 00000088H

; 280  : 	AuVFSNode* file = (AuVFSNode*)kmalloc(sizeof(AuVFSNode));

	mov	ecx, 159				; 0000009fH
	call	kmalloc
	mov	QWORD PTR file$[rsp], rax

; 281  : 	memset(file, 0, sizeof(AuVFSNode));

	mov	r8d, 159				; 0000009fH
	xor	edx, edx
	mov	rcx, QWORD PTR file$[rsp]
	call	memset

; 282  : 
; 283  : 	FatFS* fs = (FatFS*)fsys->device;

	mov	rax, QWORD PTR fsys$[rsp]
	mov	rax, QWORD PTR [rax+63]
	mov	QWORD PTR fs$[rsp], rax

; 284  : 	AuVDisk *vdisk = (AuVDisk*)fs->vdisk;

	mov	rax, QWORD PTR fs$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR vdisk$[rsp], rax

; 285  : 	if (!vdisk)

	cmp	QWORD PTR vdisk$[rsp], 0
	jne	SHORT $LN10@FatLocateD

; 286  : 		return NULL;

	xor	eax, eax
	jmp	$LN11@FatLocateD
$LN10@FatLocateD:

; 287  : 
; 288  : 	uint64_t* buf;
; 289  : 	FatDir *dirent;
; 290  : 	char dos_file_name[11];
; 291  : 	FatToDOSFilename(dir, dos_file_name, 11);

	mov	r8d, 11
	lea	rdx, QWORD PTR dos_file_name$[rsp]
	mov	rcx, QWORD PTR dir$[rsp]
	call	?FatToDOSFilename@@YAXPEBDPEADI@Z	; FatToDOSFilename

; 292  : 	dos_file_name[11] = 0;

	mov	eax, 1
	imul	rax, rax, 11
	mov	BYTE PTR dos_file_name$[rsp+rax], 0

; 293  : 	
; 294  : 	buf = (uint64_t*)P2V((uint64_t)AuPmmngrAlloc());

	call	AuPmmngrAlloc
	mov	rcx, rax
	call	P2V
	mov	QWORD PTR buf$[rsp], rax

; 295  : 	memset(buf, 0, PAGE_SIZE);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR buf$[rsp]
	call	memset

; 296  : 	for (unsigned int sector = 0; sector < fs->__SectorPerCluster; sector++) {

	mov	DWORD PTR sector$1[rsp], 0
	jmp	SHORT $LN9@FatLocateD
$LN8@FatLocateD:
	mov	eax, DWORD PTR sector$1[rsp]
	inc	eax
	mov	DWORD PTR sector$1[rsp], eax
$LN9@FatLocateD:
	mov	rax, QWORD PTR fs$[rsp]
	movzx	eax, BYTE PTR [rax+36]
	cmp	DWORD PTR sector$1[rsp], eax
	jae	$LN7@FatLocateD

; 297  : 
; 298  : 		memset(buf, 0, PAGE_SIZE);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR buf$[rsp]
	call	memset

; 299  : 		//ata_read_28 (root_sector + sector,1, buf);
; 300  : 		AuVDiskRead(vdisk, FatClusterToSector32(fs,fs->__RootDirFirstCluster) + sector, 1, (uint64_t*)V2P((uint64_t)buf));

	mov	rcx, QWORD PTR buf$[rsp]
	call	V2P
	mov	QWORD PTR tv91[rsp], rax
	mov	rcx, QWORD PTR fs$[rsp]
	mov	ecx, DWORD PTR [rcx+40]
	mov	edx, ecx
	mov	rcx, QWORD PTR fs$[rsp]
	call	?FatClusterToSector32@@YA_KPEAU_FatFS_@@_K@Z ; FatClusterToSector32
	mov	ecx, DWORD PTR sector$1[rsp]
	add	rax, rcx
	mov	rcx, QWORD PTR tv91[rsp]
	mov	r9, rcx
	mov	r8d, 1
	mov	rdx, rax
	mov	rcx, QWORD PTR vdisk$[rsp]
	call	AuVDiskRead

; 301  : 
; 302  : 		dirent = (FatDir*)buf;

	mov	rax, QWORD PTR buf$[rsp]
	mov	QWORD PTR dirent$[rsp], rax

; 303  : 
; 304  : 		for (int i = 0; i < 16; i++) {

	mov	DWORD PTR i$2[rsp], 0
	jmp	SHORT $LN6@FatLocateD
$LN5@FatLocateD:
	mov	eax, DWORD PTR i$2[rsp]
	inc	eax
	mov	DWORD PTR i$2[rsp], eax
$LN6@FatLocateD:
	cmp	DWORD PTR i$2[rsp], 16
	jge	$LN4@FatLocateD

; 305  : 			char name[11];
; 306  : 			memcpy(name, dirent->filename, 11);

	mov	rax, QWORD PTR dirent$[rsp]
	mov	r8d, 11
	mov	rdx, rax
	lea	rcx, QWORD PTR name$3[rsp]
	call	memcpy

; 307  : 			name[11] = 0;

	mov	eax, 1
	imul	rax, rax, 11
	mov	BYTE PTR name$3[rsp+rax], 0

; 308  : 			if (strcmp(dos_file_name, name) == 0) {

	lea	rdx, QWORD PTR name$3[rsp]
	lea	rcx, QWORD PTR dos_file_name$[rsp]
	call	strcmp
	test	eax, eax
	jne	$LN3@FatLocateD

; 309  : 				strcpy(file->filename, dir);

	mov	rax, QWORD PTR file$[rsp]
	mov	rdx, QWORD PTR dir$[rsp]
	mov	rcx, rax
	call	strcpy

; 310  : 				file->current = dirent->first_cluster;

	mov	rax, QWORD PTR dirent$[rsp]
	movzx	eax, WORD PTR [rax+26]
	mov	rcx, QWORD PTR file$[rsp]
	mov	QWORD PTR [rcx+53], rax

; 311  : 				file->size = dirent->file_size;

	mov	rax, QWORD PTR file$[rsp]
	mov	rcx, QWORD PTR dirent$[rsp]
	mov	ecx, DWORD PTR [rcx+28]
	mov	DWORD PTR [rax+32], ecx

; 312  : 				file->eof = 0;

	mov	rax, QWORD PTR file$[rsp]
	mov	BYTE PTR [rax+36], 0

; 313  : 				file->status = FS_STATUS_FOUND;

	mov	rax, QWORD PTR file$[rsp]
	mov	BYTE PTR [rax+62], 1

; 314  : 				file->close = 0;

	mov	rax, QWORD PTR file$[rsp]
	mov	QWORD PTR [rax+127], 0

; 315  : 				file->first_block = file->current;

	mov	rax, QWORD PTR file$[rsp]
	mov	rcx, QWORD PTR file$[rsp]
	mov	rcx, QWORD PTR [rcx+53]
	mov	QWORD PTR [rax+45], rcx

; 316  : 				file->pos = 0;

	mov	rax, QWORD PTR file$[rsp]
	mov	DWORD PTR [rax+37], 0

; 317  : 				file->device = fsys;

	mov	rax, QWORD PTR file$[rsp]
	mov	rcx, QWORD PTR fsys$[rsp]
	mov	QWORD PTR [rax+63], rcx

; 318  : 				file->parent_block = fs->__RootDirFirstCluster;

	mov	rax, QWORD PTR file$[rsp]
	mov	rcx, QWORD PTR fs$[rsp]
	mov	ecx, DWORD PTR [rcx+40]
	mov	DWORD PTR [rax+41], ecx

; 319  : 				if (dirent->attrib == 0x10)

	mov	rax, QWORD PTR dirent$[rsp]
	movzx	eax, BYTE PTR [rax+11]
	cmp	eax, 16
	jne	SHORT $LN2@FatLocateD

; 320  : 					file->flags |= FS_FLAG_DIRECTORY;

	mov	rax, QWORD PTR file$[rsp]
	movzx	eax, BYTE PTR [rax+61]
	or	eax, 2
	mov	rcx, QWORD PTR file$[rsp]
	mov	BYTE PTR [rcx+61], al

; 321  : 				else

	jmp	SHORT $LN1@FatLocateD
$LN2@FatLocateD:

; 322  : 					file->flags |= FS_FLAG_GENERAL;

	mov	rax, QWORD PTR file$[rsp]
	movzx	eax, BYTE PTR [rax+61]
	or	eax, 4
	mov	rcx, QWORD PTR file$[rsp]
	mov	BYTE PTR [rcx+61], al
$LN1@FatLocateD:

; 323  : 
; 324  : 				AuPmmngrFree((void*)V2P((size_t)buf));

	mov	rcx, QWORD PTR buf$[rsp]
	call	V2P
	mov	rcx, rax
	call	AuPmmngrFree

; 325  : 				return file;

	mov	rax, QWORD PTR file$[rsp]
	jmp	SHORT $LN11@FatLocateD
$LN3@FatLocateD:

; 326  : 			}
; 327  : 			dirent++;

	mov	rax, QWORD PTR dirent$[rsp]
	add	rax, 32					; 00000020H
	mov	QWORD PTR dirent$[rsp], rax

; 328  : 		}

	jmp	$LN5@FatLocateD
$LN4@FatLocateD:

; 329  : 	}

	jmp	$LN8@FatLocateD
$LN7@FatLocateD:

; 330  : 
; 331  : 	AuPmmngrFree((void*)V2P((size_t)buf));

	mov	rcx, QWORD PTR buf$[rsp]
	call	V2P
	mov	rcx, rax
	call	AuPmmngrFree

; 332  : 	kfree(file);

	mov	rcx, QWORD PTR file$[rsp]
	call	kfree

; 333  : 	return NULL;

	xor	eax, eax
$LN11@FatLocateD:

; 334  : }

	add	rsp, 136				; 00000088H
	ret	0
?FatLocateDir@@YAPEAU__VFS_NODE__@@PEAU1@PEBD@Z ENDP	; FatLocateDir
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\fs\fat\fat.cpp
_TEXT	SEGMENT
tv66 = 32
tv70 = 36
?FatFormatTime@@YAGXZ PROC				; FatFormatTime

; 510  : uint16_t FatFormatTime() {

$LN3:
	sub	rsp, 56					; 00000038H

; 511  : 	return (uint16_t)(AuRTCGetHour() << 11 | AuRTCGetMinutes() << 5 | AuRTCGetSecond() / 2);

	call	AuRTCGetHour
	movzx	eax, al
	shl	eax, 11
	mov	DWORD PTR tv66[rsp], eax
	call	AuRTCGetMinutes
	movzx	eax, al
	shl	eax, 5
	mov	ecx, DWORD PTR tv66[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR tv70[rsp], eax
	call	AuRTCGetSecond
	movzx	eax, al
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR tv70[rsp]
	or	ecx, eax
	mov	eax, ecx

; 512  : }

	add	rsp, 56					; 00000038H
	ret	0
?FatFormatTime@@YAGXZ ENDP				; FatFormatTime
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\fs\fat\fat.cpp
_TEXT	SEGMENT
tv68 = 32
tv72 = 36
?FatFormatDate@@YAGXZ PROC				; FatFormatDate

; 503  : uint16_t FatFormatDate() {

$LN3:
	sub	rsp, 56					; 00000038H

; 504  : 	return (uint16_t)((2000 + AuRTCGetYear() - 1980) << 9 | AuRTCGetMonth() << 5 | AuRTCGetDay());

	call	AuRTCGetYear
	movzx	eax, al
	add	eax, 20
	shl	eax, 9
	mov	DWORD PTR tv68[rsp], eax
	call	AuRTCGetMonth
	movzx	eax, al
	shl	eax, 5
	mov	ecx, DWORD PTR tv68[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR tv72[rsp], eax
	call	AuRTCGetDay
	movzx	eax, al
	mov	ecx, DWORD PTR tv72[rsp]
	or	ecx, eax
	mov	eax, ecx

; 505  : }

	add	rsp, 56					; 00000038H
	ret	0
?FatFormatDate@@YAGXZ ENDP				; FatFormatDate
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\fs\fat\fat.cpp
_TEXT	SEGMENT
fat_offset$ = 32
value$ = 36
BuffArea$ = 40
fs$ = 48
vdisk$ = 56
fat_sector$ = 64
ent_offset$ = 72
buf$ = 80
node$ = 112
cluster_index$ = 120
?FatReadFAT@@YAIPEAU__VFS_NODE__@@I@Z PROC		; FatReadFAT

; 102  : uint32_t FatReadFAT(AuVFSNode *node, uint32_t cluster_index) {

$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 103  : 	FatFS *fs = (FatFS*)node->device;

	mov	rax, QWORD PTR node$[rsp]
	mov	rax, QWORD PTR [rax+63]
	mov	QWORD PTR fs$[rsp], rax

; 104  : 	AuVDisk *vdisk = (AuVDisk*)fs->vdisk;

	mov	rax, QWORD PTR fs$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR vdisk$[rsp], rax

; 105  : 	if (!vdisk)

	cmp	QWORD PTR vdisk$[rsp], 0
	jne	SHORT $LN1@FatReadFAT

; 106  : 		return NULL;

	xor	eax, eax
	jmp	$LN2@FatReadFAT
$LN1@FatReadFAT:

; 107  : 
; 108  : 	auto fat_offset = cluster_index * 4;

	mov	eax, DWORD PTR cluster_index$[rsp]
	shl	eax, 2
	mov	DWORD PTR fat_offset$[rsp], eax

; 109  : 	uint64_t fat_sector = fs->__FatBeginLBA + (fat_offset / 512);

	xor	edx, edx
	mov	eax, DWORD PTR fat_offset$[rsp]
	mov	ecx, 512				; 00000200H
	div	ecx
	mov	rcx, QWORD PTR fs$[rsp]
	mov	ecx, DWORD PTR [rcx+28]
	add	ecx, eax
	mov	eax, ecx
	mov	eax, eax
	mov	QWORD PTR fat_sector$[rsp], rax

; 110  : 	size_t ent_offset = fat_offset % 512;

	xor	edx, edx
	mov	eax, DWORD PTR fat_offset$[rsp]
	mov	ecx, 512				; 00000200H
	div	ecx
	mov	eax, edx
	mov	eax, eax
	mov	QWORD PTR ent_offset$[rsp], rax

; 111  : 	uint64_t *BuffArea = (uint64_t*)P2V((size_t)AuPmmngrAlloc());

	call	AuPmmngrAlloc
	mov	rcx, rax
	call	P2V
	mov	QWORD PTR BuffArea$[rsp], rax

; 112  : 	memset(BuffArea, 0, 4096);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR BuffArea$[rsp]
	call	memset

; 113  : 	AuVDiskRead(vdisk, fat_sector, 1, (uint64_t*)V2P((size_t)BuffArea));

	mov	rcx, QWORD PTR BuffArea$[rsp]
	call	V2P
	mov	r9, rax
	mov	r8d, 1
	mov	rdx, QWORD PTR fat_sector$[rsp]
	mov	rcx, QWORD PTR vdisk$[rsp]
	call	AuVDiskRead

; 114  : 	unsigned char* buf = (unsigned char*)BuffArea;

	mov	rax, QWORD PTR BuffArea$[rsp]
	mov	QWORD PTR buf$[rsp], rax

; 115  : 	uint32_t value = *(uint32_t*)&buf[ent_offset];

	mov	rax, QWORD PTR ent_offset$[rsp]
	mov	rcx, QWORD PTR buf$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR value$[rsp], eax

; 116  : 	AuPmmngrFree((void*)V2P((size_t)BuffArea));

	mov	rcx, QWORD PTR BuffArea$[rsp]
	call	V2P
	mov	rcx, rax
	call	AuPmmngrFree

; 117  : 	return value & 0x0FFFFFFF;

	mov	eax, DWORD PTR value$[rsp]
	and	eax, 268435455				; 0fffffffH
$LN2@FatReadFAT:

; 118  : }

	add	rsp, 104				; 00000068H
	ret	0
?FatReadFAT@@YAIPEAU__VFS_NODE__@@I@Z ENDP		; FatReadFAT
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\fs\fat\fat.cpp
_TEXT	SEGMENT
sector$ = 32
buffer$ = 40
fs$ = 48
vdisk$ = 56
node$ = 80
cluster$ = 88
?FatClearCluster@@YAXPEAU__VFS_NODE__@@I@Z PROC		; FatClearCluster

; 184  : void FatClearCluster(AuVFSNode* node, uint32_t cluster) {

$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 185  : 	FatFS* fs = (FatFS*)node->device;

	mov	rax, QWORD PTR node$[rsp]
	mov	rax, QWORD PTR [rax+63]
	mov	QWORD PTR fs$[rsp], rax

; 186  : 	AuVDisk* vdisk = (AuVDisk*)fs->vdisk;

	mov	rax, QWORD PTR fs$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR vdisk$[rsp], rax

; 187  : 	if (!vdisk)

	cmp	QWORD PTR vdisk$[rsp], 0
	jne	SHORT $LN1@FatClearCl

; 188  : 		return;

	jmp	$LN2@FatClearCl
$LN1@FatClearCl:

; 189  : 
; 190  : 	uint64_t *buffer = (uint64_t*)P2V((size_t)AuPmmngrAlloc());

	call	AuPmmngrAlloc
	mov	rcx, rax
	call	P2V
	mov	QWORD PTR buffer$[rsp], rax

; 191  : 	memset(buffer, 0, PAGE_SIZE);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR buffer$[rsp]
	call	memset

; 192  : 	AuTextOut("Buffer ->%x \n", buffer);

	mov	rdx, QWORD PTR buffer$[rsp]
	lea	rcx, OFFSET FLAT:$SG3669
	call	AuTextOut

; 193  : 	//update_cluster (buffer,cluster);
; 194  : 	uint32_t sector = FatClusterToSector32(fs, cluster);

	mov	eax, DWORD PTR cluster$[rsp]
	mov	edx, eax
	mov	rcx, QWORD PTR fs$[rsp]
	call	?FatClusterToSector32@@YA_KPEAU_FatFS_@@_K@Z ; FatClusterToSector32
	mov	DWORD PTR sector$[rsp], eax

; 195  : 	AuVDiskWrite(vdisk, sector, fs->__SectorPerCluster, (uint64_t*)V2P((size_t)buffer));

	mov	rcx, QWORD PTR buffer$[rsp]
	call	V2P
	mov	rcx, QWORD PTR fs$[rsp]
	movzx	ecx, BYTE PTR [rcx+36]
	mov	edx, DWORD PTR sector$[rsp]
	mov	r9, rax
	mov	r8d, ecx
	mov	rcx, QWORD PTR vdisk$[rsp]
	call	AuVDiskWrite

; 196  : 	AuPmmngrFree((void*)V2P((size_t)buffer));

	mov	rcx, QWORD PTR buffer$[rsp]
	call	V2P
	mov	rcx, rax
	call	AuPmmngrFree
$LN2@FatClearCl:

; 197  : }

	add	rsp, 72					; 00000048H
	ret	0
?FatClearCluster@@YAXPEAU__VFS_NODE__@@I@Z ENDP		; FatClearCluster
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\fs\fat\fat.cpp
_TEXT	SEGMENT
fat_offset$ = 32
buffer$ = 40
ent_offset$ = 48
buf$ = 56
vdisk$ = 64
fat_sector$ = 72
fs$ = 80
value2$ = 88
value$ = 92
fsys$ = 112
position$ = 120
n_value$ = 128
?FatAllocCluster@@YAXPEAU__VFS_NODE__@@HI@Z PROC	; FatAllocCluster

; 157  : void FatAllocCluster(AuVFSNode* fsys, int position, uint32_t n_value) {

$LN4:
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 158  : 	FatFS *fs = (FatFS*)fsys->device;

	mov	rax, QWORD PTR fsys$[rsp]
	mov	rax, QWORD PTR [rax+63]
	mov	QWORD PTR fs$[rsp], rax

; 159  : 	AuVDisk* vdisk = (AuVDisk*)fs->vdisk;

	mov	rax, QWORD PTR fs$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR vdisk$[rsp], rax

; 160  : 	if (!vdisk)

	cmp	QWORD PTR vdisk$[rsp], 0
	jne	SHORT $LN1@FatAllocCl

; 161  : 		return;

	jmp	$LN2@FatAllocCl
$LN1@FatAllocCl:

; 162  : 
; 163  : 	auto fat_offset = position * 4;

	mov	eax, DWORD PTR position$[rsp]
	shl	eax, 2
	mov	DWORD PTR fat_offset$[rsp], eax

; 164  : 	uint64_t fat_sector = fs->__FatBeginLBA + (fat_offset / 512);

	mov	eax, DWORD PTR fat_offset$[rsp]
	cdq
	and	edx, 511				; 000001ffH
	add	eax, edx
	sar	eax, 9
	mov	rcx, QWORD PTR fs$[rsp]
	mov	ecx, DWORD PTR [rcx+28]
	add	ecx, eax
	mov	eax, ecx
	mov	eax, eax
	mov	QWORD PTR fat_sector$[rsp], rax

; 165  : 	size_t ent_offset = fat_offset % 512;

	mov	eax, DWORD PTR fat_offset$[rsp]
	cdq
	and	edx, 511				; 000001ffH
	add	eax, edx
	and	eax, 511				; 000001ffH
	sub	eax, edx
	cdqe
	mov	QWORD PTR ent_offset$[rsp], rax

; 166  : 	uint64_t *buffer = (uint64_t*)P2V((size_t)AuPmmngrAlloc());

	call	AuPmmngrAlloc
	mov	rcx, rax
	call	P2V
	mov	QWORD PTR buffer$[rsp], rax

; 167  : 	memset(buffer, 0, PAGE_SIZE);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR buffer$[rsp]
	call	memset

; 168  : 	AuVDiskRead(vdisk, fat_sector, 1, (uint64_t*)V2P((size_t)buffer));

	mov	rcx, QWORD PTR buffer$[rsp]
	call	V2P
	mov	r9, rax
	mov	r8d, 1
	mov	rdx, QWORD PTR fat_sector$[rsp]
	mov	rcx, QWORD PTR vdisk$[rsp]
	call	AuVDiskRead

; 169  : 
; 170  : 	uint8_t* buf = (uint8_t*)buffer;

	mov	rax, QWORD PTR buffer$[rsp]
	mov	QWORD PTR buf$[rsp], rax

; 171  : 	uint32_t value = *(uint32_t*)&buf[ent_offset];

	mov	rax, QWORD PTR ent_offset$[rsp]
	mov	rcx, QWORD PTR buf$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR value$[rsp], eax

; 172  : 	*(uint32_t*)&buf[ent_offset] = n_value & 0x0FFFFFFF;

	mov	eax, DWORD PTR n_value$[rsp]
	and	eax, 268435455				; 0fffffffH
	mov	rcx, QWORD PTR ent_offset$[rsp]
	mov	rdx, QWORD PTR buf$[rsp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	DWORD PTR [rcx], eax

; 173  : 
; 174  : 	uint32_t value2 = *(uint32_t*)&buf[ent_offset];

	mov	rax, QWORD PTR ent_offset$[rsp]
	mov	rcx, QWORD PTR buf$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR value2$[rsp], eax

; 175  : 	AuVDiskWrite(vdisk, fat_sector, 1, (uint64_t*)V2P((size_t)buffer));

	mov	rcx, QWORD PTR buffer$[rsp]
	call	V2P
	mov	r9, rax
	mov	r8d, 1
	mov	rdx, QWORD PTR fat_sector$[rsp]
	mov	rcx, QWORD PTR vdisk$[rsp]
	call	AuVDiskWrite

; 176  : 	AuPmmngrFree((void*)V2P((size_t)buffer));

	mov	rcx, QWORD PTR buffer$[rsp]
	call	V2P
	mov	rcx, rax
	call	AuPmmngrFree
$LN2@FatAllocCl:

; 177  : }

	add	rsp, 104				; 00000068H
	ret	0
?FatAllocCluster@@YAXPEAU__VFS_NODE__@@HI@Z ENDP	; FatAllocCluster
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\fs\fat\fat.cpp
_TEXT	SEGMENT
i$1 = 32
fat_offset$2 = 36
buffer$3 = 40
fs$ = 48
value$4 = 56
vdisk$ = 64
fat_sector$5 = 72
ent_offset$6 = 80
buf$7 = 88
node$ = 112
?FatFindFreeCluster@@YAIPEAU__VFS_NODE__@@@Z PROC	; FatFindFreeCluster

; 125  : uint32_t FatFindFreeCluster(AuVFSNode* node) {

$LN8:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 126  : 	FatFS *fs = (FatFS*)node->device;

	mov	rax, QWORD PTR node$[rsp]
	mov	rax, QWORD PTR [rax+63]
	mov	QWORD PTR fs$[rsp], rax

; 127  : 	AuVDisk *vdisk = (AuVDisk*)fs->vdisk;

	mov	rax, QWORD PTR fs$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR vdisk$[rsp], rax

; 128  : 	if (!vdisk)

	cmp	QWORD PTR vdisk$[rsp], 0
	jne	SHORT $LN5@FatFindFre

; 129  : 		return NULL;

	xor	eax, eax
	jmp	$LN6@FatFindFre
$LN5@FatFindFre:

; 130  : 
; 131  : 	for (int i = 2; i < fs->__TotalClusters; i++) {

	mov	DWORD PTR i$1[rsp], 2
	jmp	SHORT $LN4@FatFindFre
$LN3@FatFindFre:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN4@FatFindFre:
	mov	rax, QWORD PTR fs$[rsp]
	mov	eax, DWORD PTR [rax+52]
	cmp	DWORD PTR i$1[rsp], eax
	jae	$LN2@FatFindFre

; 132  : 		auto fat_offset = i * 4;

	mov	eax, DWORD PTR i$1[rsp]
	shl	eax, 2
	mov	DWORD PTR fat_offset$2[rsp], eax

; 133  : 		uint64_t fat_sector = fs->__FatBeginLBA + (fat_offset / 512);

	mov	eax, DWORD PTR fat_offset$2[rsp]
	cdq
	and	edx, 511				; 000001ffH
	add	eax, edx
	sar	eax, 9
	mov	rcx, QWORD PTR fs$[rsp]
	mov	ecx, DWORD PTR [rcx+28]
	add	ecx, eax
	mov	eax, ecx
	mov	eax, eax
	mov	QWORD PTR fat_sector$5[rsp], rax

; 134  : 		size_t ent_offset = fat_offset % 512;

	mov	eax, DWORD PTR fat_offset$2[rsp]
	cdq
	and	edx, 511				; 000001ffH
	add	eax, edx
	and	eax, 511				; 000001ffH
	sub	eax, edx
	cdqe
	mov	QWORD PTR ent_offset$6[rsp], rax

; 135  : 		uint64_t *buffer = (uint64_t*)P2V((size_t)AuPmmngrAlloc());

	call	AuPmmngrAlloc
	mov	rcx, rax
	call	P2V
	mov	QWORD PTR buffer$3[rsp], rax

; 136  : 		memset(buffer, 0, PAGE_SIZE);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR buffer$3[rsp]
	call	memset

; 137  : 		AuVDiskRead(vdisk, fat_sector, 1, (uint64_t*)V2P((size_t)buffer));

	mov	rcx, QWORD PTR buffer$3[rsp]
	call	V2P
	mov	r9, rax
	mov	r8d, 1
	mov	rdx, QWORD PTR fat_sector$5[rsp]
	mov	rcx, QWORD PTR vdisk$[rsp]
	call	AuVDiskRead

; 138  : 		uint8_t* buf = (uint8_t*)buffer;

	mov	rax, QWORD PTR buffer$3[rsp]
	mov	QWORD PTR buf$7[rsp], rax

; 139  : 		uint32_t value = *(uint32_t*)&buf[ent_offset];

	mov	rax, QWORD PTR ent_offset$6[rsp]
	mov	rcx, QWORD PTR buf$7[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR value$4[rsp], eax

; 140  : 
; 141  : 		AuPmmngrFree((void*)V2P((size_t)buffer));

	mov	rcx, QWORD PTR buffer$3[rsp]
	call	V2P
	mov	rcx, rax
	call	AuPmmngrFree

; 142  : 		//! Found a free cluster return the value
; 143  : 		if (value == 0x00) {

	cmp	DWORD PTR value$4[rsp], 0
	jne	SHORT $LN1@FatFindFre

; 144  : 			return i;

	mov	eax, DWORD PTR i$1[rsp]
	jmp	SHORT $LN6@FatFindFre
$LN1@FatFindFre:

; 145  : 		}
; 146  : 	}

	jmp	$LN3@FatFindFre
$LN2@FatFindFre:

; 147  : 	return 0;

	xor	eax, eax
$LN6@FatFindFre:

; 148  : }

	add	rsp, 104				; 00000068H
	ret	0
?FatFindFreeCluster@@YAIPEAU__VFS_NODE__@@@Z ENDP	; FatFindFreeCluster
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\fs\fat\fat.cpp
_TEXT	SEGMENT
i$ = 32
k$1 = 36
tv71 = 40
filename$ = 64
fname$ = 72
fname_length$ = 80
?FatToDOSFilename@@YAXPEBDPEADI@Z PROC			; FatToDOSFilename

; 64   : {

$LN19:
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 65   : 	unsigned int i = 0;

	mov	DWORD PTR i$[rsp], 0

; 66   : 
; 67   : 	if (fname_length > 11)

	cmp	DWORD PTR fname_length$[rsp], 11
	jbe	SHORT $LN16@FatToDOSFi

; 68   : 		return;

	jmp	$LN17@FatToDOSFi
$LN16@FatToDOSFi:

; 69   : 
; 70   : 	if (!fname || !filename)

	cmp	QWORD PTR fname$[rsp], 0
	je	SHORT $LN14@FatToDOSFi
	cmp	QWORD PTR filename$[rsp], 0
	jne	SHORT $LN15@FatToDOSFi
$LN14@FatToDOSFi:

; 71   : 		return;

	jmp	$LN17@FatToDOSFi
$LN15@FatToDOSFi:

; 72   : 
; 73   : 	memset(fname, ' ', fname_length);

	mov	r8d, DWORD PTR fname_length$[rsp]
	mov	dl, 32					; 00000020H
	mov	rcx, QWORD PTR fname$[rsp]
	call	memset

; 74   : 
; 75   : 	for (i = 0; i < strlen(filename) - 1 && i < fname_length; i++)

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN13@FatToDOSFi
$LN12@FatToDOSFi:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN13@FatToDOSFi:
	mov	eax, DWORD PTR i$[rsp]
	mov	QWORD PTR tv71[rsp], rax
	mov	rcx, QWORD PTR filename$[rsp]
	call	strlen
	dec	rax
	mov	rcx, QWORD PTR tv71[rsp]
	cmp	rcx, rax
	jae	SHORT $LN11@FatToDOSFi
	mov	eax, DWORD PTR fname_length$[rsp]
	cmp	DWORD PTR i$[rsp], eax
	jae	SHORT $LN11@FatToDOSFi

; 76   : 	{
; 77   : 		if (filename[i] == '.' || i == 8)

	mov	eax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR filename$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 46					; 0000002eH
	je	SHORT $LN9@FatToDOSFi
	cmp	DWORD PTR i$[rsp], 8
	jne	SHORT $LN10@FatToDOSFi
$LN9@FatToDOSFi:

; 78   : 			break;

	jmp	SHORT $LN11@FatToDOSFi
$LN10@FatToDOSFi:

; 79   : 
; 80   : 		fname[i] = toupper(filename[i]);

	mov	eax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR filename$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	mov	ecx, eax
	call	toupper
	mov	ecx, DWORD PTR i$[rsp]
	mov	rdx, QWORD PTR fname$[rsp]
	mov	BYTE PTR [rdx+rcx], al

; 81   : 	}

	jmp	SHORT $LN12@FatToDOSFi
$LN11@FatToDOSFi:

; 82   : 
; 83   : 	if (filename[i] == '.')

	mov	eax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR filename$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 46					; 0000002eH
	jne	SHORT $LN8@FatToDOSFi

; 84   : 	{
; 85   : 		for (int k = 0; k < 3; k++)

	mov	DWORD PTR k$1[rsp], 0
	jmp	SHORT $LN7@FatToDOSFi
$LN6@FatToDOSFi:
	mov	eax, DWORD PTR k$1[rsp]
	inc	eax
	mov	DWORD PTR k$1[rsp], eax
$LN7@FatToDOSFi:
	cmp	DWORD PTR k$1[rsp], 3
	jge	SHORT $LN5@FatToDOSFi

; 86   : 		{
; 87   : 			++i;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 88   : 			if (filename[i])

	mov	eax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR filename$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN4@FatToDOSFi

; 89   : 				fname[8 + k] = filename[i];

	mov	eax, DWORD PTR i$[rsp]
	mov	ecx, DWORD PTR k$1[rsp]
	add	ecx, 8
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR fname$[rsp]
	mov	r8, QWORD PTR filename$[rsp]
	movzx	eax, BYTE PTR [r8+rax]
	mov	BYTE PTR [rdx+rcx], al
$LN4@FatToDOSFi:

; 90   : 		}

	jmp	SHORT $LN6@FatToDOSFi
$LN5@FatToDOSFi:
$LN8@FatToDOSFi:

; 91   : 	}
; 92   : 
; 93   : 	for (i = 0; i < 3; i++)

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN3@FatToDOSFi
$LN2@FatToDOSFi:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN3@FatToDOSFi:
	cmp	DWORD PTR i$[rsp], 3
	jae	SHORT $LN1@FatToDOSFi

; 94   : 		fname[8 + i] = toupper(fname[8 + i]);

	mov	eax, DWORD PTR i$[rsp]
	add	eax, 8
	mov	eax, eax
	mov	rcx, QWORD PTR fname$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	mov	ecx, eax
	call	toupper
	mov	ecx, DWORD PTR i$[rsp]
	add	ecx, 8
	mov	ecx, ecx
	mov	rdx, QWORD PTR fname$[rsp]
	mov	BYTE PTR [rdx+rcx], al
	jmp	SHORT $LN2@FatToDOSFi
$LN1@FatToDOSFi:
$LN17@FatToDOSFi:

; 95   : }

	add	rsp, 56					; 00000038H
	ret	0
?FatToDOSFilename@@YAXPEBDPEADI@Z ENDP			; FatToDOSFilename
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\fs\fat\fat.cpp
_TEXT	SEGMENT
fs$ = 8
cluster$ = 16
?FatClusterToSector32@@YA_KPEAU_FatFS_@@_K@Z PROC	; FatClusterToSector32

; 52   : uint64_t FatClusterToSector32(FatFS *fs, uint64_t cluster) {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 53   : 	return fs->__ClusterBeginLBA + (cluster - 2) * fs->__SectorPerCluster;

	mov	rax, QWORD PTR fs$[rsp]
	mov	eax, DWORD PTR [rax+32]
	mov	rcx, QWORD PTR cluster$[rsp]
	sub	rcx, 2
	mov	rdx, QWORD PTR fs$[rsp]
	movzx	edx, BYTE PTR [rdx+36]
	imul	rcx, rdx
	add	rax, rcx

; 54   : }

	ret	0
?FatClusterToSector32@@YA_KPEAU_FatFS_@@_K@Z ENDP	; FatClusterToSector32
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\fs\fat\fat.cpp
_TEXT	SEGMENT
fs$ = 32
bpb$ = 40
fsys$ = 48
i$1 = 56
buffer$ = 64
tv202 = 72
tv192 = 76
_dataSectors$ = 80
tv173 = 88
fatsize$ = 96
_root_dir_sectors$ = 104
_TotalSectors$ = 112
vdisk$ = 144
mountname$ = 152
?FatInitialise@@YAPEAU__VFS_NODE__@@PEAU_VDISK_@@PEAD@Z PROC ; FatInitialise

; 433  : AuVFSNode* FatInitialise(AuVDisk *vdisk, char* mountname){

$LN16:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 136				; 00000088H

; 434  : 	uint64_t* buffer = (uint64_t*)AuPmmngrAlloc();

	call	AuPmmngrAlloc
	mov	QWORD PTR buffer$[rsp], rax

; 435  : 	memset(buffer, 0, 4096);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR buffer$[rsp]
	call	memset

; 436  : 	AuVDiskRead(vdisk, 0, 1, buffer);

	mov	r9, QWORD PTR buffer$[rsp]
	mov	r8d, 1
	xor	edx, edx
	mov	rcx, QWORD PTR vdisk$[rsp]
	call	AuVDiskRead

; 437  : 
; 438  : 	FatBPB* bpb = (FatBPB*)buffer;

	mov	rax, QWORD PTR buffer$[rsp]
	mov	QWORD PTR bpb$[rsp], rax

; 439  : 
; 440  : 	FatFS *fs = (FatFS*)kmalloc(sizeof(FatFS));

	mov	ecx, 80					; 00000050H
	call	kmalloc
	mov	QWORD PTR fs$[rsp], rax

; 441  : 	memset(fs, 0, sizeof(FatFS));

	mov	r8d, 80					; 00000050H
	xor	edx, edx
	mov	rcx, QWORD PTR fs$[rsp]
	call	memset

; 442  : 
; 443  : 	fs->bpb = bpb;

	mov	rax, QWORD PTR fs$[rsp]
	mov	rcx, QWORD PTR bpb$[rsp]
	mov	QWORD PTR [rax], rcx

; 444  : 	fs->vdisk = vdisk;

	mov	rax, QWORD PTR fs$[rsp]
	mov	rcx, QWORD PTR vdisk$[rsp]
	mov	QWORD PTR [rax+8], rcx

; 445  : 
; 446  : 	for (int i = 0; i < 8; i++) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN9@FatInitial
$LN8@FatInitial:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN9@FatInitial:
	cmp	DWORD PTR i$1[rsp], 8
	jge	SHORT $LN7@FatInitial

; 447  : 		AuTextOut("%c", bpb->oemid[i]);

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR bpb$[rsp]
	movsx	eax, BYTE PTR [rcx+rax+3]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG3817
	call	AuTextOut

; 448  : 		fs->oemid[i] = bpb->oemid[i];

	movsxd	rax, DWORD PTR i$1[rsp]
	movsxd	rcx, DWORD PTR i$1[rsp]
	mov	rdx, QWORD PTR fs$[rsp]
	mov	r8, QWORD PTR bpb$[rsp]
	movzx	eax, BYTE PTR [r8+rax+3]
	mov	BYTE PTR [rdx+rcx+16], al

; 449  : 	}

	jmp	SHORT $LN8@FatInitial
$LN7@FatInitial:

; 450  : 	fs->oemid[8] = '\0';

	mov	eax, 1
	imul	rax, rax, 8
	mov	rcx, QWORD PTR fs$[rsp]
	mov	BYTE PTR [rcx+rax+16], 0

; 451  : 	fs->__FatBeginLBA = bpb->reserved_sectors;

	mov	rax, QWORD PTR bpb$[rsp]
	movzx	eax, WORD PTR [rax+14]
	mov	rcx, QWORD PTR fs$[rsp]
	mov	DWORD PTR [rcx+28], eax

; 452  : 	fs->__ClusterBeginLBA = bpb->reserved_sectors + (bpb->num_fats* bpb->info.FAT32.sect_per_fat32);

	mov	rax, QWORD PTR bpb$[rsp]
	movzx	eax, WORD PTR [rax+14]
	mov	rcx, QWORD PTR bpb$[rsp]
	movzx	ecx, BYTE PTR [rcx+16]
	mov	rdx, QWORD PTR bpb$[rsp]
	imul	ecx, DWORD PTR [rdx+36]
	add	eax, ecx
	mov	rcx, QWORD PTR fs$[rsp]
	mov	DWORD PTR [rcx+32], eax

; 453  : 	fs->__SectorPerCluster = bpb->sectors_per_cluster;

	mov	rax, QWORD PTR fs$[rsp]
	mov	rcx, QWORD PTR bpb$[rsp]
	movzx	ecx, BYTE PTR [rcx+13]
	mov	BYTE PTR [rax+36], cl

; 454  : 	fs->__RootDirFirstCluster = bpb->info.FAT32.root_dir_cluster;

	mov	rax, QWORD PTR fs$[rsp]
	mov	rcx, QWORD PTR bpb$[rsp]
	mov	ecx, DWORD PTR [rcx+44]
	mov	DWORD PTR [rax+40], ecx

; 455  : 	fs->__RootSector = FatClusterToSector32(fs, fs->__RootDirFirstCluster);

	mov	rax, QWORD PTR fs$[rsp]
	mov	eax, DWORD PTR [rax+40]
	mov	edx, eax
	mov	rcx, QWORD PTR fs$[rsp]
	call	?FatClusterToSector32@@YA_KPEAU_FatFS_@@_K@Z ; FatClusterToSector32
	mov	rcx, QWORD PTR fs$[rsp]
	mov	DWORD PTR [rcx+44], eax

; 456  : 	fs->__SectorPerFAT32 = bpb->info.FAT32.sect_per_fat32;

	mov	rax, QWORD PTR fs$[rsp]
	mov	rcx, QWORD PTR bpb$[rsp]
	mov	ecx, DWORD PTR [rcx+36]
	mov	DWORD PTR [rax+48], ecx

; 457  : 	fs->cluster_sz_in_bytes = fs->__SectorPerCluster * bpb->bytes_per_sector;

	mov	rax, QWORD PTR fs$[rsp]
	movzx	eax, BYTE PTR [rax+36]
	mov	rcx, QWORD PTR bpb$[rsp]
	movzx	ecx, WORD PTR [rcx+11]
	imul	eax, ecx
	cdqe
	mov	rcx, QWORD PTR fs$[rsp]
	mov	QWORD PTR [rcx+72], rax

; 458  : 	fs->__BytesPerSector = bpb->bytes_per_sector;

	mov	rax, QWORD PTR fs$[rsp]
	mov	rcx, QWORD PTR bpb$[rsp]
	movzx	ecx, WORD PTR [rcx+11]
	mov	WORD PTR [rax+64], cx

; 459  : 
; 460  : 	fs->__TotalClusters = bpb->large_sector_count / fs->__SectorPerCluster;

	mov	rax, QWORD PTR fs$[rsp]
	movzx	eax, BYTE PTR [rax+36]
	mov	DWORD PTR tv173[rsp], eax
	xor	edx, edx
	mov	rcx, QWORD PTR bpb$[rsp]
	mov	eax, DWORD PTR [rcx+32]
	mov	ecx, DWORD PTR tv173[rsp]
	div	ecx
	mov	rcx, QWORD PTR fs$[rsp]
	mov	DWORD PTR [rcx+52], eax

; 461  : 	size_t _root_dir_sectors = ((bpb->num_dir_entries * 32) + bpb->bytes_per_sector - 1) / bpb->bytes_per_sector;

	mov	rax, QWORD PTR bpb$[rsp]
	movzx	eax, WORD PTR [rax+17]
	imul	eax, eax, 32				; 00000020H
	mov	rcx, QWORD PTR bpb$[rsp]
	movzx	ecx, WORD PTR [rcx+11]
	lea	eax, DWORD PTR [rax+rcx-1]
	mov	rcx, QWORD PTR bpb$[rsp]
	movzx	ecx, WORD PTR [rcx+11]
	cdq
	idiv	ecx
	cdqe
	mov	QWORD PTR _root_dir_sectors$[rsp], rax

; 462  : 	size_t _TotalSectors = (bpb->total_sectors_short == 0) ? bpb->large_sector_count : bpb->total_sectors_short;

	mov	rax, QWORD PTR bpb$[rsp]
	movzx	eax, WORD PTR [rax+19]
	test	eax, eax
	jne	SHORT $LN12@FatInitial
	mov	rax, QWORD PTR bpb$[rsp]
	mov	eax, DWORD PTR [rax+32]
	mov	DWORD PTR tv192[rsp], eax
	jmp	SHORT $LN13@FatInitial
$LN12@FatInitial:
	mov	rax, QWORD PTR bpb$[rsp]
	movzx	eax, WORD PTR [rax+19]
	mov	DWORD PTR tv192[rsp], eax
$LN13@FatInitial:
	mov	eax, DWORD PTR tv192[rsp]
	mov	QWORD PTR _TotalSectors$[rsp], rax

; 463  : 	size_t fatsize = (bpb->sectors_per_fat == 0) ? bpb->info.FAT32.sect_per_fat32 : bpb->sectors_per_fat;

	mov	rax, QWORD PTR bpb$[rsp]
	movzx	eax, WORD PTR [rax+22]
	test	eax, eax
	jne	SHORT $LN14@FatInitial
	mov	rax, QWORD PTR bpb$[rsp]
	mov	eax, DWORD PTR [rax+36]
	mov	DWORD PTR tv202[rsp], eax
	jmp	SHORT $LN15@FatInitial
$LN14@FatInitial:
	mov	rax, QWORD PTR bpb$[rsp]
	movzx	eax, WORD PTR [rax+22]
	mov	DWORD PTR tv202[rsp], eax
$LN15@FatInitial:
	mov	eax, DWORD PTR tv202[rsp]
	mov	QWORD PTR fatsize$[rsp], rax

; 464  : 	size_t _dataSectors = _TotalSectors - (bpb->reserved_sectors + bpb->num_fats * fatsize + _root_dir_sectors);

	mov	rax, QWORD PTR bpb$[rsp]
	movzx	eax, WORD PTR [rax+14]
	mov	rcx, QWORD PTR bpb$[rsp]
	movzx	ecx, BYTE PTR [rcx+16]
	imul	rcx, QWORD PTR fatsize$[rsp]
	mov	rdx, QWORD PTR _root_dir_sectors$[rsp]
	add	rdx, rax
	mov	rax, rdx
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR _TotalSectors$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _dataSectors$[rsp], rax

; 465  : 
; 466  : 	if (_dataSectors < 4085)

	cmp	QWORD PTR _dataSectors$[rsp], 4085	; 00000ff5H
	jae	SHORT $LN6@FatInitial

; 467  : 		fs->fatType = FSTYPE_FAT12;

	mov	rax, QWORD PTR fs$[rsp]
	mov	BYTE PTR [rax+24], 1
	jmp	SHORT $LN5@FatInitial
$LN6@FatInitial:

; 468  : 	else if (_dataSectors < 65525)

	cmp	QWORD PTR _dataSectors$[rsp], 65525	; 0000fff5H
	jae	SHORT $LN4@FatInitial

; 469  : 		fs->fatType = FSTYPE_FAT16;

	mov	rax, QWORD PTR fs$[rsp]
	mov	BYTE PTR [rax+24], 2
	jmp	SHORT $LN3@FatInitial
$LN4@FatInitial:

; 470  : 	else if (_dataSectors < 268435445)

	cmp	QWORD PTR _dataSectors$[rsp], 268435445	; 0ffffff5H
	jae	SHORT $LN2@FatInitial

; 471  : 		fs->fatType = FSTYPE_FAT32;

	mov	rax, QWORD PTR fs$[rsp]
	mov	BYTE PTR [rax+24], 3
$LN2@FatInitial:
$LN3@FatInitial:
$LN5@FatInitial:

; 472  : 
; 473  : 	if (fs->fatType != FSTYPE_FAT32) {

	mov	rax, QWORD PTR fs$[rsp]
	movzx	eax, BYTE PTR [rax+24]
	cmp	eax, 3
	je	SHORT $LN1@FatInitial

; 474  : 		AuPmmngrFree(buffer);

	mov	rcx, QWORD PTR buffer$[rsp]
	call	AuPmmngrFree

; 475  : 		kfree(fs);

	mov	rcx, QWORD PTR fs$[rsp]
	call	kfree

; 476  : 		return NULL;

	xor	eax, eax
	jmp	$LN10@FatInitial
$LN1@FatInitial:

; 477  : 	}
; 478  : 
; 479  : 	AuVFSNode* fsys = (AuVFSNode*)kmalloc(sizeof(AuVFSNode));

	mov	ecx, 159				; 0000009fH
	call	kmalloc
	mov	QWORD PTR fsys$[rsp], rax

; 480  : 	memset(fsys, 0, sizeof(AuVFSNode));

	mov	r8d, 159				; 0000009fH
	xor	edx, edx
	mov	rcx, QWORD PTR fsys$[rsp]
	call	memset

; 481  : 	strcpy(fsys->filename, mountname);

	mov	rax, QWORD PTR fsys$[rsp]
	mov	rdx, QWORD PTR mountname$[rsp]
	mov	rcx, rax
	call	strcpy

; 482  : 	fsys->flags |= FS_FLAG_FILE_SYSTEM;

	mov	rax, QWORD PTR fsys$[rsp]
	movzx	eax, BYTE PTR [rax+61]
	or	eax, 64					; 00000040H
	mov	rcx, QWORD PTR fsys$[rsp]
	mov	BYTE PTR [rcx+61], al

; 483  : 	fsys->open = FatOpen;

	mov	rax, QWORD PTR fsys$[rsp]
	lea	rcx, OFFSET FLAT:?FatOpen@@YAPEAU__VFS_NODE__@@PEAU1@PEAD@Z ; FatOpen
	mov	QWORD PTR [rax+71], rcx

; 484  : 	fsys->device = fs;

	mov	rax, QWORD PTR fsys$[rsp]
	mov	rcx, QWORD PTR fs$[rsp]
	mov	QWORD PTR [rax+63], rcx

; 485  : 	fsys->read_block = FatRead;

	mov	rax, QWORD PTR fsys$[rsp]
	lea	rcx, OFFSET FLAT:?FatRead@@YA_KPEAU__VFS_NODE__@@0PEA_K@Z ; FatRead
	mov	QWORD PTR [rax+135], rcx

; 486  : 	fsys->remove_dir = FatRemoveDir;

	mov	rax, QWORD PTR fsys$[rsp]
	lea	rcx, OFFSET FLAT:?FatRemoveDir@@YAHPEAU__VFS_NODE__@@0@Z ; FatRemoveDir
	mov	QWORD PTR [rax+111], rcx

; 487  : 	fsys->remove_file = FatFileRemove;

	mov	rax, QWORD PTR fsys$[rsp]
	lea	rcx, OFFSET FLAT:?FatFileRemove@@YAHPEAU__VFS_NODE__@@0@Z ; FatFileRemove
	mov	QWORD PTR [rax+119], rcx

; 488  : 	fsys->write = FatWrite;

	mov	rax, QWORD PTR fsys$[rsp]
	lea	rcx, OFFSET FLAT:?FatWrite@@YA_KPEAU__VFS_NODE__@@0PEA_KI@Z ; FatWrite
	mov	QWORD PTR [rax+87], rcx

; 489  : 	fsys->create_dir = FatCreateDir;

	mov	rax, QWORD PTR fsys$[rsp]
	lea	rcx, OFFSET FLAT:?FatCreateDir@@YAPEAU__VFS_NODE__@@PEAU1@PEAD@Z ; FatCreateDir
	mov	QWORD PTR [rax+95], rcx

; 490  : 	fsys->create_file = FatCreateFile;

	mov	rax, QWORD PTR fsys$[rsp]
	lea	rcx, OFFSET FLAT:?FatCreateFile@@YAPEAU__VFS_NODE__@@PEAU1@PEAD@Z ; FatCreateFile
	mov	QWORD PTR [rax+103], rcx

; 491  : 	fsys->get_blockfor = FatGetClusterFor;

	mov	rax, QWORD PTR fsys$[rsp]
	lea	rcx, OFFSET FLAT:?FatGetClusterFor@@YA_KPEAU__VFS_NODE__@@0_K@Z ; FatGetClusterFor
	mov	QWORD PTR [rax+143], rcx

; 492  : 	AuVFSAddFileSystem(fsys);

	mov	rcx, QWORD PTR fsys$[rsp]
	call	AuVFSAddFileSystem

; 493  : 	AuVFSRegisterRoot(fsys);

	mov	rcx, QWORD PTR fsys$[rsp]
	call	AuVFSRegisterRoot

; 494  : 
; 495  : 	AuPmmngrFree(buffer);

	mov	rcx, QWORD PTR buffer$[rsp]
	call	AuPmmngrFree

; 496  : 
; 497  : 	return fsys;

	mov	rax, QWORD PTR fsys$[rsp]
$LN10@FatInitial:

; 498  : }

	add	rsp, 136				; 00000088H
	ret	0
?FatInitialise@@YAPEAU__VFS_NODE__@@PEAU_VDISK_@@PEAD@Z ENDP ; FatInitialise
_TEXT	ENDS
END
