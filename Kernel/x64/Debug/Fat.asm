; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.21005.1 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG4114	DB	'%c', 00H
CONST	ENDS
PUBLIC	?FatInitialise@@YAPEAU__VFS_NODE__@@PEAU_VDISK_@@PEAD@Z ; FatInitialise
PUBLIC	?FatClusterToSector32@@YA_KPEAU_FatFS_@@_K@Z	; FatClusterToSector32
PUBLIC	?FatToDOSFilename@@YAXPEBDPEADI@Z		; FatToDOSFilename
PUBLIC	?FatFindFreeCluster@@YAIPEAU__VFS_NODE__@@@Z	; FatFindFreeCluster
PUBLIC	?FatAllocCluster@@YAXPEAU__VFS_NODE__@@HI@Z	; FatAllocCluster
PUBLIC	?FatClearCluster@@YAXPEAU__VFS_NODE__@@I@Z	; FatClearCluster
PUBLIC	?FatReadFAT@@YAIPEAU__VFS_NODE__@@I@Z		; FatReadFAT
PUBLIC	?FatOpen@@YAPEAU__VFS_NODE__@@PEAU1@PEAD@Z	; FatOpen
PUBLIC	?FatFormatDate@@YAGXZ				; FatFormatDate
PUBLIC	?FatFormatTime@@YAGXZ				; FatFormatTime
PUBLIC	?FatLocateDir@@YAPEAU__VFS_NODE__@@PEAU1@PEBD@Z	; FatLocateDir
PUBLIC	?FatLocateSubDir@@YAPEAU__VFS_NODE__@@PEAU1@0PEBD@Z ; FatLocateSubDir
PUBLIC	?FatFromDosToFilename@@YAXPEAD0@Z		; FatFromDosToFilename
PUBLIC	?FatCalculateCheckSum@@YAEPEAE@Z		; FatCalculateCheckSum
PUBLIC	?FatRead@@YA_KPEAU__VFS_NODE__@@0PEA_K@Z	; FatRead
PUBLIC	?FatReadFile@@YA_KPEAU__VFS_NODE__@@0PEA_KI@Z	; FatReadFile
PUBLIC	?FatGetClusterFor@@YA_KPEAU__VFS_NODE__@@0_K@Z	; FatGetClusterFor
EXTRN	AuVFSAddFileSystem:PROC
EXTRN	AuVFSRegisterRoot:PROC
EXTRN	AuVDiskRead:PROC
EXTRN	AuVDiskWrite:PROC
EXTRN	AuCreateMutex:PROC
EXTRN	?FatCreateFile@@YAPEAU__VFS_NODE__@@PEAU1@PEAD@Z:PROC ; FatCreateFile
EXTRN	?FatWrite@@YA_KPEAU__VFS_NODE__@@0PEA_KI@Z:PROC	; FatWrite
EXTRN	?FatFileRemove@@YAHPEAU__VFS_NODE__@@0@Z:PROC	; FatFileRemove
EXTRN	?FatCreateDir@@YAPEAU__VFS_NODE__@@PEAU1@PEAD@Z:PROC ; FatCreateDir
EXTRN	?FatRemoveDir@@YAHPEAU__VFS_NODE__@@0@Z:PROC	; FatRemoveDir
EXTRN	?FatOpenDir@@YAPEAU__VFS_NODE__@@PEAU1@PEAD@Z:PROC ; FatOpenDir
EXTRN	?FatDirectoryRead@@YAHPEAU__VFS_NODE__@@0PEAU_AuDirectoryEnty_@@@Z:PROC ; FatDirectoryRead
EXTRN	AuPmmngrAlloc:PROC
EXTRN	AuPmmngrFree:PROC
EXTRN	P2V:PROC
EXTRN	V2P:PROC
EXTRN	strcmp:PROC
EXTRN	strcpy:PROC
EXTRN	strlen:PROC
EXTRN	strchr:PROC
EXTRN	memset:PROC
EXTRN	memcpy:PROC
EXTRN	AuTextOut:PROC
EXTRN	toupper:PROC
EXTRN	kmalloc:PROC
EXTRN	kfree:PROC
EXTRN	AuRTCGetYear:PROC
EXTRN	AuRTCGetMinutes:PROC
EXTRN	AuRTCGetSecond:PROC
EXTRN	AuRTCGetDay:PROC
EXTRN	AuRTCGetHour:PROC
EXTRN	AuRTCGetMonth:PROC
pdata	SEGMENT
$pdata$?FatInitialise@@YAPEAU__VFS_NODE__@@PEAU_VDISK_@@PEAD@Z DD imagerel $LN16
	DD	imagerel $LN16+1141
	DD	imagerel $unwind$?FatInitialise@@YAPEAU__VFS_NODE__@@PEAU_VDISK_@@PEAD@Z
$pdata$?FatToDOSFilename@@YAXPEBDPEADI@Z DD imagerel $LN19
	DD	imagerel $LN19+382
	DD	imagerel $unwind$?FatToDOSFilename@@YAXPEBDPEADI@Z
$pdata$?FatFindFreeCluster@@YAIPEAU__VFS_NODE__@@@Z DD imagerel $LN8
	DD	imagerel $LN8+308
	DD	imagerel $unwind$?FatFindFreeCluster@@YAIPEAU__VFS_NODE__@@@Z
$pdata$?FatAllocCluster@@YAXPEAU__VFS_NODE__@@HI@Z DD imagerel $LN4
	DD	imagerel $LN4+343
	DD	imagerel $unwind$?FatAllocCluster@@YAXPEAU__VFS_NODE__@@HI@Z
$pdata$?FatClearCluster@@YAXPEAU__VFS_NODE__@@I@Z DD imagerel $LN4
	DD	imagerel $LN4+169
	DD	imagerel $unwind$?FatClearCluster@@YAXPEAU__VFS_NODE__@@I@Z
$pdata$?FatReadFAT@@YAIPEAU__VFS_NODE__@@I@Z DD imagerel $LN4
	DD	imagerel $LN4+255
	DD	imagerel $unwind$?FatReadFAT@@YAIPEAU__VFS_NODE__@@I@Z
$pdata$?FatOpen@@YAPEAU__VFS_NODE__@@PEAU1@PEAD@Z DD imagerel $LN18
	DD	imagerel $LN18+442
	DD	imagerel $unwind$?FatOpen@@YAPEAU__VFS_NODE__@@PEAU1@PEAD@Z
$pdata$?FatFormatDate@@YAGXZ DD imagerel $LN3
	DD	imagerel $LN3+66
	DD	imagerel $unwind$?FatFormatDate@@YAGXZ
$pdata$?FatFormatTime@@YAGXZ DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$?FatFormatTime@@YAGXZ
$pdata$?FatLocateDir@@YAPEAU__VFS_NODE__@@PEAU1@PEBD@Z DD imagerel $LN13
	DD	imagerel $LN13+697
	DD	imagerel $unwind$?FatLocateDir@@YAPEAU__VFS_NODE__@@PEAU1@PEBD@Z
$pdata$?FatLocateSubDir@@YAPEAU__VFS_NODE__@@PEAU1@0PEBD@Z DD imagerel $LN13
	DD	imagerel $LN13+582
	DD	imagerel $unwind$?FatLocateSubDir@@YAPEAU__VFS_NODE__@@PEAU1@0PEBD@Z
$pdata$?FatFromDosToFilename@@YAXPEAD0@Z DD imagerel $LN12
	DD	imagerel $LN12+309
	DD	imagerel $unwind$?FatFromDosToFilename@@YAXPEAD0@Z
$pdata$?FatCalculateCheckSum@@YAEPEAE@Z DD imagerel $LN8
	DD	imagerel $LN8+127
	DD	imagerel $unwind$?FatCalculateCheckSum@@YAEPEAE@Z
$pdata$?FatRead@@YA_KPEAU__VFS_NODE__@@0PEA_K@Z DD imagerel $LN6
	DD	imagerel $LN6+251
	DD	imagerel $unwind$?FatRead@@YA_KPEAU__VFS_NODE__@@0PEA_K@Z
$pdata$?FatReadFile@@YA_KPEAU__VFS_NODE__@@0PEA_KI@Z DD imagerel $LN11
	DD	imagerel $LN11+385
	DD	imagerel $unwind$?FatReadFile@@YA_KPEAU__VFS_NODE__@@0PEA_KI@Z
$pdata$?FatGetClusterFor@@YA_KPEAU__VFS_NODE__@@0_K@Z DD imagerel $LN6
	DD	imagerel $LN6+127
	DD	imagerel $unwind$?FatGetClusterFor@@YA_KPEAU__VFS_NODE__@@0_K@Z
pdata	ENDS
xdata	SEGMENT
$unwind$?FatInitialise@@YAPEAU__VFS_NODE__@@PEAU_VDISK_@@PEAD@Z DD 021101H
	DD	0110111H
$unwind$?FatToDOSFilename@@YAXPEBDPEADI@Z DD 011301H
	DD	06213H
$unwind$?FatFindFreeCluster@@YAIPEAU__VFS_NODE__@@@Z DD 010901H
	DD	0c209H
$unwind$?FatAllocCluster@@YAXPEAU__VFS_NODE__@@HI@Z DD 011201H
	DD	0c212H
$unwind$?FatClearCluster@@YAXPEAU__VFS_NODE__@@I@Z DD 010d01H
	DD	0820dH
$unwind$?FatReadFAT@@YAIPEAU__VFS_NODE__@@I@Z DD 010d01H
	DD	0c20dH
$unwind$?FatOpen@@YAPEAU__VFS_NODE__@@PEAU1@PEAD@Z DD 010e01H
	DD	0c20eH
$unwind$?FatFormatDate@@YAGXZ DD 010401H
	DD	06204H
$unwind$?FatFormatTime@@YAGXZ DD 010401H
	DD	06204H
$unwind$?FatLocateDir@@YAPEAU__VFS_NODE__@@PEAU1@PEBD@Z DD 021101H
	DD	0110111H
$unwind$?FatLocateSubDir@@YAPEAU__VFS_NODE__@@PEAU1@0PEBD@Z DD 011301H
	DD	0c213H
$unwind$?FatFromDosToFilename@@YAXPEAD0@Z DD 010e01H
	DD	0820eH
$unwind$?FatCalculateCheckSum@@YAEPEAE@Z DD 010901H
	DD	02209H
$unwind$?FatRead@@YA_KPEAU__VFS_NODE__@@0PEA_K@Z DD 011301H
	DD	08213H
$unwind$?FatReadFile@@YA_KPEAU__VFS_NODE__@@0PEA_KI@Z DD 011801H
	DD	0c218H
$unwind$?FatGetClusterFor@@YA_KPEAU__VFS_NODE__@@0_K@Z DD 011301H
	DD	08213H
xdata	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\fs\fat\fat.cpp
_TEXT	SEGMENT
i$1 = 32
cluster$ = 36
fatfs$ = 40
index$ = 48
fs$ = 80
file$ = 88
offset$ = 96
?FatGetClusterFor@@YA_KPEAU__VFS_NODE__@@0_K@Z PROC	; FatGetClusterFor

; 514  : size_t FatGetClusterFor(AuVFSNode* fs,AuVFSNode* file, uint64_t offset){

$LN6:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 515  : 	FatFS *fatfs = (FatFS*)fs->device;

	mov	rax, QWORD PTR fs$[rsp]
	mov	rax, QWORD PTR [rax+72]
	mov	QWORD PTR fatfs$[rsp], rax

; 516  : 	size_t index = offset / fatfs->cluster_sz_in_bytes;

	xor	edx, edx
	mov	rax, QWORD PTR offset$[rsp]
	mov	rcx, QWORD PTR fatfs$[rsp]
	div	QWORD PTR [rcx+60]
	mov	QWORD PTR index$[rsp], rax

; 517  : 	uint32_t cluster = file->current;

	mov	rax, QWORD PTR file$[rsp]
	mov	eax, DWORD PTR [rax+56]
	mov	DWORD PTR cluster$[rsp], eax

; 518  : 	for (int i = 0; i < index; i++) 

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN3@FatGetClus
$LN2@FatGetClus:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN3@FatGetClus:
	movsxd	rax, DWORD PTR i$1[rsp]
	cmp	rax, QWORD PTR index$[rsp]
	jae	SHORT $LN1@FatGetClus

; 519  : 		cluster = FatReadFAT(fs, cluster);

	mov	edx, DWORD PTR cluster$[rsp]
	mov	rcx, QWORD PTR fs$[rsp]
	call	?FatReadFAT@@YAIPEAU__VFS_NODE__@@I@Z	; FatReadFAT
	mov	DWORD PTR cluster$[rsp], eax
	jmp	SHORT $LN2@FatGetClus
$LN1@FatGetClus:

; 520  : 	return cluster;

	mov	eax, DWORD PTR cluster$[rsp]

; 521  : }

	add	rsp, 72					; 00000048H
	ret	0
?FatGetClusterFor@@YA_KPEAU__VFS_NODE__@@0_K@Z ENDP	; FatGetClusterFor
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\fs\fat\fat.cpp
_TEXT	SEGMENT
i$1 = 32
tv74 = 36
buff$2 = 40
aligned_buffer$ = 48
ret_bytes$ = 56
fs$ = 64
read_bytes$ = 72
num_blocks$ = 80
fsys$ = 112
file$ = 120
buffer$ = 128
length$ = 136
?FatReadFile@@YA_KPEAU__VFS_NODE__@@0PEA_KI@Z PROC	; FatReadFile

; 290  : size_t FatReadFile(AuVFSNode* fsys, AuVFSNode* file, uint64_t* buffer, uint32_t length) {

$LN11:
	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 291  : 	if (!fsys)

	cmp	QWORD PTR fsys$[rsp], 0
	jne	SHORT $LN6@FatReadFil

; 292  : 		return 0;

	xor	eax, eax
	jmp	$LN7@FatReadFil
$LN6@FatReadFil:

; 293  : 
; 294  : 	if (!file)

	cmp	QWORD PTR file$[rsp], 0
	jne	SHORT $LN5@FatReadFil

; 295  : 		return 0;

	xor	eax, eax
	jmp	$LN7@FatReadFil
$LN5@FatReadFil:

; 296  : 
; 297  : 	FatFS* fs = (FatFS*)fsys->device;

	mov	rax, QWORD PTR fsys$[rsp]
	mov	rax, QWORD PTR [rax+72]
	mov	QWORD PTR fs$[rsp], rax

; 298  : 
; 299  : 	uint64_t read_bytes = 0;

	mov	QWORD PTR read_bytes$[rsp], 0

; 300  : 	size_t ret_bytes = 0;

	mov	QWORD PTR ret_bytes$[rsp], 0

; 301  : 	uint8_t* aligned_buffer = (uint8_t*)buffer;

	mov	rax, QWORD PTR buffer$[rsp]
	mov	QWORD PTR aligned_buffer$[rsp], rax

; 302  : 
; 303  : 	size_t num_blocks = length / fs->cluster_sz_in_bytes +
; 304  : 		((length % fs->cluster_sz_in_bytes) ? 1 : 0);

	mov	eax, DWORD PTR length$[rsp]
	xor	edx, edx
	mov	rcx, QWORD PTR fs$[rsp]
	div	QWORD PTR [rcx+60]
	mov	rax, rdx
	test	rax, rax
	je	SHORT $LN9@FatReadFil
	mov	DWORD PTR tv74[rsp], 1
	jmp	SHORT $LN10@FatReadFil
$LN9@FatReadFil:
	mov	DWORD PTR tv74[rsp], 0
$LN10@FatReadFil:
	mov	eax, DWORD PTR length$[rsp]
	xor	edx, edx
	mov	rcx, QWORD PTR fs$[rsp]
	div	QWORD PTR [rcx+60]
	movsxd	rcx, DWORD PTR tv74[rsp]
	add	rax, rcx
	mov	QWORD PTR num_blocks$[rsp], rax

; 305  : 
; 306  : 
; 307  : 	for (int i = 0; i < num_blocks; i++) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN4@FatReadFil
$LN3@FatReadFil:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN4@FatReadFil:
	movsxd	rax, DWORD PTR i$1[rsp]
	cmp	rax, QWORD PTR num_blocks$[rsp]
	jae	$LN2@FatReadFil

; 308  : 		uint64_t* buff = (uint64_t*)P2V((size_t)AuPmmngrAlloc());

	call	AuPmmngrAlloc
	mov	rcx, rax
	call	P2V
	mov	QWORD PTR buff$2[rsp], rax

; 309  : 		memset(buff, 0, PAGE_SIZE);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR buff$2[rsp]
	call	memset

; 310  : 		read_bytes = FatRead(fsys, file, (uint64_t*)V2P((size_t)buff));

	mov	rcx, QWORD PTR buff$2[rsp]
	call	V2P
	mov	r8, rax
	mov	rdx, QWORD PTR file$[rsp]
	mov	rcx, QWORD PTR fsys$[rsp]
	call	?FatRead@@YA_KPEAU__VFS_NODE__@@0PEA_K@Z ; FatRead
	mov	QWORD PTR read_bytes$[rsp], rax

; 311  : 		memcpy(aligned_buffer, buff, PAGE_SIZE);

	mov	r8d, 4096				; 00001000H
	mov	rdx, QWORD PTR buff$2[rsp]
	mov	rcx, QWORD PTR aligned_buffer$[rsp]
	call	memcpy

; 312  : 		AuPmmngrFree((void*)V2P((size_t)buff));

	mov	rcx, QWORD PTR buff$2[rsp]
	call	V2P
	mov	rcx, rax
	call	AuPmmngrFree

; 313  : 		aligned_buffer += PAGE_SIZE;

	mov	rax, QWORD PTR aligned_buffer$[rsp]
	add	rax, 4096				; 00001000H
	mov	QWORD PTR aligned_buffer$[rsp], rax

; 314  : 		ret_bytes += read_bytes;

	mov	rax, QWORD PTR read_bytes$[rsp]
	mov	rcx, QWORD PTR ret_bytes$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR ret_bytes$[rsp], rax

; 315  : 		if (file->eof)

	mov	rax, QWORD PTR file$[rsp]
	movzx	eax, BYTE PTR [rax+36]
	test	eax, eax
	je	SHORT $LN1@FatReadFil

; 316  : 			break;

	jmp	SHORT $LN2@FatReadFil
$LN1@FatReadFil:

; 317  : 	}

	jmp	$LN3@FatReadFil
$LN2@FatReadFil:

; 318  : 
; 319  : 	return ret_bytes;

	mov	rax, QWORD PTR ret_bytes$[rsp]
$LN7@FatReadFil:

; 320  : }

	add	rsp, 104				; 00000068H
	ret	0
?FatReadFile@@YA_KPEAU__VFS_NODE__@@0PEA_KI@Z ENDP	; FatReadFile
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\fs\fat\fat.cpp
_TEXT	SEGMENT
value$ = 32
fs$ = 40
vdisk$ = 48
lba$ = 56
fsys$ = 80
file$ = 88
buf$ = 96
?FatRead@@YA_KPEAU__VFS_NODE__@@0PEA_K@Z PROC		; FatRead

; 258  : size_t FatRead(AuVFSNode* fsys, AuVFSNode *file, uint64_t* buf) {

$LN6:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 259  : 	FatFS* fs = (FatFS*)fsys->device;

	mov	rax, QWORD PTR fsys$[rsp]
	mov	rax, QWORD PTR [rax+72]
	mov	QWORD PTR fs$[rsp], rax

; 260  : 	AuVDisk* vdisk = (AuVDisk*)fs->vdisk;

	mov	rax, QWORD PTR fs$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR vdisk$[rsp], rax

; 261  : 	if (!vdisk) {

	cmp	QWORD PTR vdisk$[rsp], 0
	jne	SHORT $LN3@FatRead

; 262  : 		return NULL;

	xor	eax, eax
	jmp	$LN4@FatRead
$LN3@FatRead:

; 263  : 	}
; 264  : 
; 265  : 	auto lba = FatClusterToSector32(fs, file->current);

	mov	rax, QWORD PTR file$[rsp]
	mov	rdx, QWORD PTR [rax+56]
	mov	rcx, QWORD PTR fs$[rsp]
	call	?FatClusterToSector32@@YA_KPEAU_FatFS_@@_K@Z ; FatClusterToSector32
	mov	QWORD PTR lba$[rsp], rax

; 266  : 	AuVDiskRead(vdisk, lba, fs->__SectorPerCluster, buf);

	mov	rax, QWORD PTR fs$[rsp]
	movzx	eax, BYTE PTR [rax+33]
	mov	r9, QWORD PTR buf$[rsp]
	mov	r8d, eax
	mov	rdx, QWORD PTR lba$[rsp]
	mov	rcx, QWORD PTR vdisk$[rsp]
	call	AuVDiskRead

; 267  : 
; 268  : 	uint32_t value = FatReadFAT(fsys,file->current);

	mov	rax, QWORD PTR file$[rsp]
	mov	edx, DWORD PTR [rax+56]
	mov	rcx, QWORD PTR fsys$[rsp]
	call	?FatReadFAT@@YAIPEAU__VFS_NODE__@@I@Z	; FatReadFAT
	mov	DWORD PTR value$[rsp], eax

; 269  : 	
; 270  : 	if (value >= 0x0FFFFFF8) {

	cmp	DWORD PTR value$[rsp], 268435448	; 0ffffff8H
	jb	SHORT $LN2@FatRead

; 271  : 		file->eof = 1;

	mov	rax, QWORD PTR file$[rsp]
	mov	BYTE PTR [rax+36], 1

; 272  : 		return fs->__SectorPerCluster * 512;

	mov	rax, QWORD PTR fs$[rsp]
	movzx	eax, BYTE PTR [rax+33]
	imul	eax, eax, 512				; 00000200H
	cdqe
	jmp	SHORT $LN4@FatRead
$LN2@FatRead:

; 273  : 	}
; 274  : 
; 275  : 	if (value == 0x0FFFFFF7) {

	cmp	DWORD PTR value$[rsp], 268435447	; 0ffffff7H
	jne	SHORT $LN1@FatRead

; 276  : 		file->eof = 1;

	mov	rax, QWORD PTR file$[rsp]
	mov	BYTE PTR [rax+36], 1

; 277  : 		return fs->__SectorPerCluster * 512;

	mov	rax, QWORD PTR fs$[rsp]
	movzx	eax, BYTE PTR [rax+33]
	imul	eax, eax, 512				; 00000200H
	cdqe
	jmp	SHORT $LN4@FatRead
$LN1@FatRead:

; 278  : 	}
; 279  : 	file->current = value;

	mov	eax, DWORD PTR value$[rsp]
	mov	rcx, QWORD PTR file$[rsp]
	mov	QWORD PTR [rcx+56], rax

; 280  : 	return fs->__SectorPerCluster * 512;

	mov	rax, QWORD PTR fs$[rsp]
	movzx	eax, BYTE PTR [rax+33]
	imul	eax, eax, 512				; 00000200H
	cdqe
$LN4@FatRead:

; 281  : }

	add	rsp, 72					; 00000048H
	ret	0
?FatRead@@YA_KPEAU__VFS_NODE__@@0PEA_K@Z ENDP		; FatRead
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\fs\fat\fat.cpp
_TEXT	SEGMENT
sum$ = 0
fnameLen$ = 4
tv70 = 8
fname$ = 32
?FatCalculateCheckSum@@YAEPEAE@Z PROC			; FatCalculateCheckSum

; 222  : uint8_t FatCalculateCheckSum(uint8_t* fname) {

$LN8:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 223  : 	short fnameLen;
; 224  : 	uint8_t sum = 0;

	mov	BYTE PTR sum$[rsp], 0

; 225  : 
; 226  : 	for (fnameLen = 11; fnameLen != 0; fnameLen--){

	mov	eax, 11
	mov	WORD PTR fnameLen$[rsp], ax
	jmp	SHORT $LN3@FatCalcula
$LN2@FatCalcula:
	movzx	eax, WORD PTR fnameLen$[rsp]
	dec	ax
	mov	WORD PTR fnameLen$[rsp], ax
$LN3@FatCalcula:
	movsx	eax, WORD PTR fnameLen$[rsp]
	test	eax, eax
	je	SHORT $LN1@FatCalcula

; 227  : 		sum = ((sum & 1) ? 0x80 : 0) + (sum >> 1) + *fname++;

	movzx	eax, BYTE PTR sum$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN6@FatCalcula
	mov	DWORD PTR tv70[rsp], 128		; 00000080H
	jmp	SHORT $LN7@FatCalcula
$LN6@FatCalcula:
	mov	DWORD PTR tv70[rsp], 0
$LN7@FatCalcula:
	movzx	eax, BYTE PTR sum$[rsp]
	sar	eax, 1
	mov	ecx, DWORD PTR tv70[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR fname$[rsp]
	movzx	ecx, BYTE PTR [rcx]
	add	eax, ecx
	mov	BYTE PTR sum$[rsp], al
	mov	rax, QWORD PTR fname$[rsp]
	inc	rax
	mov	QWORD PTR fname$[rsp], rax

; 228  : 	}

	jmp	SHORT $LN2@FatCalcula
$LN1@FatCalcula:

; 229  : 
; 230  : 	return sum;

	movzx	eax, BYTE PTR sum$[rsp]

; 231  : }

	add	rsp, 24
	ret	0
?FatCalculateCheckSum@@YAEPEAE@Z ENDP			; FatCalculateCheckSum
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\fs\fat\fat.cpp
_TEXT	SEGMENT
_contain_ext$ = 32
i$1 = 36
index$ = 40
i$2 = 44
extension$ = 48
filename$ = 80
dirfname$ = 88
?FatFromDosToFilename@@YAXPEAD0@Z PROC			; FatFromDosToFilename

; 111  : void FatFromDosToFilename(char* filename, char* dirfname) {

$LN12:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 112  : 	memset(filename, 0, 11);

	mov	r8d, 11
	xor	edx, edx
	mov	rcx, QWORD PTR filename$[rsp]
	call	memset

; 113  : 	int index = 0;

	mov	DWORD PTR index$[rsp], 0

; 114  : 	for (int i = 0; i < 8; i++) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN9@FatFromDos
$LN8@FatFromDos:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN9@FatFromDos:
	cmp	DWORD PTR i$1[rsp], 8
	jge	SHORT $LN7@FatFromDos

; 115  : 		if (dirfname[i] != 0x20 && dirfname[i] > 0x20) {

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR dirfname$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 32					; 00000020H
	je	SHORT $LN6@FatFromDos
	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR dirfname$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 32					; 00000020H
	jle	SHORT $LN6@FatFromDos

; 116  : 			filename[i] = dirfname[i];

	movsxd	rax, DWORD PTR i$1[rsp]
	movsxd	rcx, DWORD PTR i$1[rsp]
	mov	rdx, QWORD PTR filename$[rsp]
	mov	r8, QWORD PTR dirfname$[rsp]
	movzx	eax, BYTE PTR [r8+rax]
	mov	BYTE PTR [rdx+rcx], al

; 117  : 			index++;

	mov	eax, DWORD PTR index$[rsp]
	inc	eax
	mov	DWORD PTR index$[rsp], eax
$LN6@FatFromDos:

; 118  : 		}
; 119  : 	}

	jmp	SHORT $LN8@FatFromDos
$LN7@FatFromDos:

; 120  : 	int extension = index;

	mov	eax, DWORD PTR index$[rsp]
	mov	DWORD PTR extension$[rsp], eax

; 121  : 	filename[index] = '.';

	movsxd	rax, DWORD PTR index$[rsp]
	mov	rcx, QWORD PTR filename$[rsp]
	mov	BYTE PTR [rcx+rax], 46			; 0000002eH

; 122  : 	index++;

	mov	eax, DWORD PTR index$[rsp]
	inc	eax
	mov	DWORD PTR index$[rsp], eax

; 123  : 	bool _contain_ext = false;

	mov	BYTE PTR _contain_ext$[rsp], 0

; 124  : 	for (int i = 0; i < 3; i++) {

	mov	DWORD PTR i$2[rsp], 0
	jmp	SHORT $LN5@FatFromDos
$LN4@FatFromDos:
	mov	eax, DWORD PTR i$2[rsp]
	inc	eax
	mov	DWORD PTR i$2[rsp], eax
$LN5@FatFromDos:
	cmp	DWORD PTR i$2[rsp], 3
	jge	SHORT $LN3@FatFromDos

; 125  : 		if (dirfname[8 + i] != 0x20) {

	mov	eax, DWORD PTR i$2[rsp]
	add	eax, 8
	cdqe
	mov	rcx, QWORD PTR dirfname$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 32					; 00000020H
	je	SHORT $LN2@FatFromDos

; 126  : 			_contain_ext = true;

	mov	BYTE PTR _contain_ext$[rsp], 1

; 127  : 			filename[index + i] = dirfname[8 + i];

	mov	eax, DWORD PTR i$2[rsp]
	add	eax, 8
	cdqe
	mov	ecx, DWORD PTR i$2[rsp]
	mov	edx, DWORD PTR index$[rsp]
	add	edx, ecx
	mov	ecx, edx
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR filename$[rsp]
	mov	r8, QWORD PTR dirfname$[rsp]
	movzx	eax, BYTE PTR [r8+rax]
	mov	BYTE PTR [rdx+rcx], al
$LN2@FatFromDos:

; 128  : 		}
; 129  : 	}

	jmp	SHORT $LN4@FatFromDos
$LN3@FatFromDos:

; 130  : 	if (!_contain_ext)

	movzx	eax, BYTE PTR _contain_ext$[rsp]
	test	eax, eax
	jne	SHORT $LN1@FatFromDos

; 131  : 		filename[extension] = '\0';

	movsxd	rax, DWORD PTR extension$[rsp]
	mov	rcx, QWORD PTR filename$[rsp]
	mov	BYTE PTR [rcx+rax], 0
$LN1@FatFromDos:

; 132  : }

	add	rsp, 72					; 00000048H
	ret	0
?FatFromDosToFilename@@YAXPEAD0@Z ENDP			; FatFromDosToFilename
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\fs\fat\fat.cpp
_TEXT	SEGMENT
i$1 = 32
file$ = 40
pkDir$2 = 48
buf$ = 56
dos_file_name$ = 64
name$3 = 80
fsys$ = 112
kfile$ = 120
filename$ = 128
?FatLocateSubDir@@YAPEAU__VFS_NODE__@@PEAU1@0PEBD@Z PROC ; FatLocateSubDir

; 322  : AuVFSNode* FatLocateSubDir(AuVFSNode* fsys,AuVFSNode* kfile, const char* filename) {

$LN13:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 323  : 	AuVFSNode* file = (AuVFSNode*)kmalloc(sizeof(AuVFSNode));

	mov	ecx, 192				; 000000c0H
	call	kmalloc
	mov	QWORD PTR file$[rsp], rax

; 324  : 	memset(file, 0, sizeof(AuVFSNode));

	mov	r8d, 192				; 000000c0H
	xor	edx, edx
	mov	rcx, QWORD PTR file$[rsp]
	call	memset

; 325  : 
; 326  : 	char dos_file_name[11];
; 327  : 	memset(dos_file_name, 0, 11);

	mov	r8d, 11
	xor	edx, edx
	lea	rcx, QWORD PTR dos_file_name$[rsp]
	call	memset

; 328  : 	FatToDOSFilename(filename, dos_file_name, 11);

	mov	r8d, 11
	lea	rdx, QWORD PTR dos_file_name$[rsp]
	mov	rcx, QWORD PTR filename$[rsp]
	call	?FatToDOSFilename@@YAXPEBDPEADI@Z	; FatToDOSFilename

; 329  : 	dos_file_name[11] = 0;

	mov	eax, 1
	imul	rax, rax, 11
	mov	BYTE PTR dos_file_name$[rsp+rax], 0

; 330  : 
; 331  : 	uint64_t* buf = (uint64_t*)P2V((size_t)AuPmmngrAlloc());

	call	AuPmmngrAlloc
	mov	rcx, rax
	call	P2V
	mov	QWORD PTR buf$[rsp], rax

; 332  : 	if (kfile->flags != FS_FLAG_INVALID) {

	mov	rax, QWORD PTR kfile$[rsp]
	movzx	eax, WORD PTR [rax+64]
	cmp	eax, 32					; 00000020H
	je	$LN10@FatLocateS
$LN9@FatLocateS:

; 333  : 		while (!kfile->eof) {

	mov	rax, QWORD PTR kfile$[rsp]
	movzx	eax, BYTE PTR [rax+36]
	test	eax, eax
	jne	$LN8@FatLocateS

; 334  : 			FatRead(fsys, kfile, (uint64_t*)V2P((size_t)buf));

	mov	rcx, QWORD PTR buf$[rsp]
	call	V2P
	mov	r8, rax
	mov	rdx, QWORD PTR kfile$[rsp]
	mov	rcx, QWORD PTR fsys$[rsp]
	call	?FatRead@@YA_KPEAU__VFS_NODE__@@0PEA_K@Z ; FatRead

; 335  : 
; 336  : 			FatDir* pkDir = (FatDir*)buf;

	mov	rax, QWORD PTR buf$[rsp]
	mov	QWORD PTR pkDir$2[rsp], rax

; 337  : 			for (unsigned int i = 0; i < 16; i++) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN7@FatLocateS
$LN6@FatLocateS:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN7@FatLocateS:
	cmp	DWORD PTR i$1[rsp], 16
	jae	$LN5@FatLocateS

; 338  : 				char name[11];
; 339  : 				memcpy(name, pkDir->filename, 11);

	mov	rax, QWORD PTR pkDir$2[rsp]
	mov	r8d, 11
	mov	rdx, rax
	lea	rcx, QWORD PTR name$3[rsp]
	call	memcpy

; 340  : 				if (strcmp(name, dos_file_name) == 0) {

	lea	rdx, QWORD PTR dos_file_name$[rsp]
	lea	rcx, QWORD PTR name$3[rsp]
	call	strcmp
	test	eax, eax
	jne	$LN4@FatLocateS

; 341  : 					
; 342  : 					strcpy(file->filename, filename);

	mov	rax, QWORD PTR file$[rsp]
	mov	rdx, QWORD PTR filename$[rsp]
	mov	rcx, rax
	call	strcpy

; 343  : 					file->current = pkDir->first_cluster;

	mov	rax, QWORD PTR pkDir$2[rsp]
	movzx	eax, WORD PTR [rax+26]
	mov	rcx, QWORD PTR file$[rsp]
	mov	QWORD PTR [rcx+56], rax

; 344  : 					file->size = pkDir->file_size;

	mov	rax, QWORD PTR file$[rsp]
	mov	rcx, QWORD PTR pkDir$2[rsp]
	mov	ecx, DWORD PTR [rcx+28]
	mov	DWORD PTR [rax+32], ecx

; 345  : 					file->eof = 0;

	mov	rax, QWORD PTR file$[rsp]
	mov	BYTE PTR [rax+36], 0

; 346  : 					file->pos = 0;

	mov	rax, QWORD PTR file$[rsp]
	mov	DWORD PTR [rax+40], 0

; 347  : 					file->status = FS_STATUS_FOUND;

	mov	rax, QWORD PTR file$[rsp]
	mov	BYTE PTR [rax+66], 1

; 348  : 					file->first_block = file->current;

	mov	rax, QWORD PTR file$[rsp]
	mov	rcx, QWORD PTR file$[rsp]
	mov	rcx, QWORD PTR [rcx+56]
	mov	QWORD PTR [rax+48], rcx

; 349  : 					file->device = fsys;

	mov	rax, QWORD PTR file$[rsp]
	mov	rcx, QWORD PTR fsys$[rsp]
	mov	QWORD PTR [rax+72], rcx

; 350  : 					file->parent_block = kfile->current;

	mov	rax, QWORD PTR file$[rsp]
	mov	rcx, QWORD PTR kfile$[rsp]
	mov	ecx, DWORD PTR [rcx+56]
	mov	DWORD PTR [rax+44], ecx

; 351  : 					if (pkDir->attrib & 0x10)

	mov	rax, QWORD PTR pkDir$2[rsp]
	movzx	eax, BYTE PTR [rax+11]
	and	eax, 16
	test	eax, eax
	je	SHORT $LN3@FatLocateS

; 352  : 						file->flags |= FS_FLAG_DIRECTORY;

	mov	rax, QWORD PTR file$[rsp]
	movzx	eax, WORD PTR [rax+64]
	or	eax, 2
	mov	rcx, QWORD PTR file$[rsp]
	mov	WORD PTR [rcx+64], ax

; 353  : 					else

	jmp	SHORT $LN2@FatLocateS
$LN3@FatLocateS:

; 354  : 						file->flags |= FS_FLAG_GENERAL;

	mov	rax, QWORD PTR file$[rsp]
	movzx	eax, WORD PTR [rax+64]
	or	eax, 4
	mov	rcx, QWORD PTR file$[rsp]
	mov	WORD PTR [rcx+64], ax
$LN2@FatLocateS:

; 355  : 
; 356  : 					AuPmmngrFree((void*)V2P((size_t)buf));

	mov	rcx, QWORD PTR buf$[rsp]
	call	V2P
	mov	rcx, rax
	call	AuPmmngrFree

; 357  : 					kfree(kfile);

	mov	rcx, QWORD PTR kfile$[rsp]
	call	kfree

; 358  : 					return file;

	mov	rax, QWORD PTR file$[rsp]
	jmp	SHORT $LN11@FatLocateS
$LN4@FatLocateS:

; 359  : 				}
; 360  : 
; 361  : 				pkDir++;

	mov	rax, QWORD PTR pkDir$2[rsp]
	add	rax, 32					; 00000020H
	mov	QWORD PTR pkDir$2[rsp], rax

; 362  : 			}

	jmp	$LN6@FatLocateS
$LN5@FatLocateS:

; 363  : 		}

	jmp	$LN9@FatLocateS
$LN8@FatLocateS:
$LN10@FatLocateS:

; 364  : 	}
; 365  : 
; 366  : 	AuPmmngrFree((void*)V2P((size_t)buf));

	mov	rcx, QWORD PTR buf$[rsp]
	call	V2P
	mov	rcx, rax
	call	AuPmmngrFree

; 367  : 	kfree(file);

	mov	rcx, QWORD PTR file$[rsp]
	call	kfree

; 368  : 	if (kfile)

	cmp	QWORD PTR kfile$[rsp], 0
	je	SHORT $LN1@FatLocateS

; 369  : 		kfree(kfile);

	mov	rcx, QWORD PTR kfile$[rsp]
	call	kfree
$LN1@FatLocateS:

; 370  : 	return NULL;

	xor	eax, eax
$LN11@FatLocateS:

; 371  : }

	add	rsp, 104				; 00000068H
	ret	0
?FatLocateSubDir@@YAPEAU__VFS_NODE__@@PEAU1@0PEBD@Z ENDP ; FatLocateSubDir
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\fs\fat\fat.cpp
_TEXT	SEGMENT
file$ = 32
sector$1 = 40
i$2 = 44
buf$ = 48
dirent$ = 56
fs$ = 64
vdisk$ = 72
name$3 = 80
dos_file_name$ = 96
tv91 = 112
fsys$ = 144
dir$ = 152
?FatLocateDir@@YAPEAU__VFS_NODE__@@PEAU1@PEBD@Z PROC	; FatLocateDir

; 374  : AuVFSNode* FatLocateDir(AuVFSNode* fsys, const char* dir) {

$LN13:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 136				; 00000088H

; 375  : 	AuVFSNode* file = (AuVFSNode*)kmalloc(sizeof(AuVFSNode));

	mov	ecx, 192				; 000000c0H
	call	kmalloc
	mov	QWORD PTR file$[rsp], rax

; 376  : 	memset(file, 0, sizeof(AuVFSNode));

	mov	r8d, 192				; 000000c0H
	xor	edx, edx
	mov	rcx, QWORD PTR file$[rsp]
	call	memset

; 377  : 
; 378  : 	FatFS* fs = (FatFS*)fsys->device;

	mov	rax, QWORD PTR fsys$[rsp]
	mov	rax, QWORD PTR [rax+72]
	mov	QWORD PTR fs$[rsp], rax

; 379  : 	AuVDisk *vdisk = (AuVDisk*)fs->vdisk;

	mov	rax, QWORD PTR fs$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR vdisk$[rsp], rax

; 380  : 	if (!vdisk)

	cmp	QWORD PTR vdisk$[rsp], 0
	jne	SHORT $LN10@FatLocateD

; 381  : 		return NULL;

	xor	eax, eax
	jmp	$LN11@FatLocateD
$LN10@FatLocateD:

; 382  : 
; 383  : 	uint64_t* buf;
; 384  : 	FatDir *dirent;
; 385  : 	char dos_file_name[11];
; 386  : 	FatToDOSFilename(dir, dos_file_name, 11);

	mov	r8d, 11
	lea	rdx, QWORD PTR dos_file_name$[rsp]
	mov	rcx, QWORD PTR dir$[rsp]
	call	?FatToDOSFilename@@YAXPEBDPEADI@Z	; FatToDOSFilename

; 387  : 	dos_file_name[11] = 0;

	mov	eax, 1
	imul	rax, rax, 11
	mov	BYTE PTR dos_file_name$[rsp+rax], 0

; 388  : 	
; 389  : 	buf = (uint64_t*)P2V((uint64_t)AuPmmngrAlloc());

	call	AuPmmngrAlloc
	mov	rcx, rax
	call	P2V
	mov	QWORD PTR buf$[rsp], rax

; 390  : 	memset(buf, 0, PAGE_SIZE);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR buf$[rsp]
	call	memset

; 391  : 	for (unsigned int sector = 0; sector < fs->__SectorPerCluster; sector++) {

	mov	DWORD PTR sector$1[rsp], 0
	jmp	SHORT $LN9@FatLocateD
$LN8@FatLocateD:
	mov	eax, DWORD PTR sector$1[rsp]
	inc	eax
	mov	DWORD PTR sector$1[rsp], eax
$LN9@FatLocateD:
	mov	rax, QWORD PTR fs$[rsp]
	movzx	eax, BYTE PTR [rax+33]
	cmp	DWORD PTR sector$1[rsp], eax
	jae	$LN7@FatLocateD

; 392  : 
; 393  : 		memset(buf, 0, PAGE_SIZE);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR buf$[rsp]
	call	memset

; 394  : 		//ata_read_28 (root_sector + sector,1, buf);
; 395  : 		AuVDiskRead(vdisk, FatClusterToSector32(fs,fs->__RootDirFirstCluster) + sector, 1, (uint64_t*)V2P((uint64_t)buf));

	mov	rcx, QWORD PTR buf$[rsp]
	call	V2P
	mov	QWORD PTR tv91[rsp], rax
	mov	rcx, QWORD PTR fs$[rsp]
	mov	ecx, DWORD PTR [rcx+34]
	mov	edx, ecx
	mov	rcx, QWORD PTR fs$[rsp]
	call	?FatClusterToSector32@@YA_KPEAU_FatFS_@@_K@Z ; FatClusterToSector32
	mov	ecx, DWORD PTR sector$1[rsp]
	add	rax, rcx
	mov	rcx, QWORD PTR tv91[rsp]
	mov	r9, rcx
	mov	r8d, 1
	mov	rdx, rax
	mov	rcx, QWORD PTR vdisk$[rsp]
	call	AuVDiskRead

; 396  : 
; 397  : 		dirent = (FatDir*)buf;

	mov	rax, QWORD PTR buf$[rsp]
	mov	QWORD PTR dirent$[rsp], rax

; 398  : 
; 399  : 		for (int i = 0; i < 16; i++) {

	mov	DWORD PTR i$2[rsp], 0
	jmp	SHORT $LN6@FatLocateD
$LN5@FatLocateD:
	mov	eax, DWORD PTR i$2[rsp]
	inc	eax
	mov	DWORD PTR i$2[rsp], eax
$LN6@FatLocateD:
	cmp	DWORD PTR i$2[rsp], 16
	jge	$LN4@FatLocateD

; 400  : 			char name[11];
; 401  : 			memcpy(name, dirent->filename, 11);

	mov	rax, QWORD PTR dirent$[rsp]
	mov	r8d, 11
	mov	rdx, rax
	lea	rcx, QWORD PTR name$3[rsp]
	call	memcpy

; 402  : 			name[11] = 0;

	mov	eax, 1
	imul	rax, rax, 11
	mov	BYTE PTR name$3[rsp+rax], 0

; 403  : 			if (strcmp(dos_file_name, name) == 0) {

	lea	rdx, QWORD PTR name$3[rsp]
	lea	rcx, QWORD PTR dos_file_name$[rsp]
	call	strcmp
	test	eax, eax
	jne	$LN3@FatLocateD

; 404  : 				
; 405  : 				strcpy(file->filename, dir);

	mov	rax, QWORD PTR file$[rsp]
	mov	rdx, QWORD PTR dir$[rsp]
	mov	rcx, rax
	call	strcpy

; 406  : 				file->current = dirent->first_cluster;

	mov	rax, QWORD PTR dirent$[rsp]
	movzx	eax, WORD PTR [rax+26]
	mov	rcx, QWORD PTR file$[rsp]
	mov	QWORD PTR [rcx+56], rax

; 407  : 				file->size = dirent->file_size;

	mov	rax, QWORD PTR file$[rsp]
	mov	rcx, QWORD PTR dirent$[rsp]
	mov	ecx, DWORD PTR [rcx+28]
	mov	DWORD PTR [rax+32], ecx

; 408  : 				file->eof = 0;

	mov	rax, QWORD PTR file$[rsp]
	mov	BYTE PTR [rax+36], 0

; 409  : 				file->status = FS_STATUS_FOUND;

	mov	rax, QWORD PTR file$[rsp]
	mov	BYTE PTR [rax+66], 1

; 410  : 				file->close = 0;

	mov	rax, QWORD PTR file$[rsp]
	mov	QWORD PTR [rax+152], 0

; 411  : 				file->first_block = file->current;

	mov	rax, QWORD PTR file$[rsp]
	mov	rcx, QWORD PTR file$[rsp]
	mov	rcx, QWORD PTR [rcx+56]
	mov	QWORD PTR [rax+48], rcx

; 412  : 				file->pos = 0;

	mov	rax, QWORD PTR file$[rsp]
	mov	DWORD PTR [rax+40], 0

; 413  : 				file->device = fsys;

	mov	rax, QWORD PTR file$[rsp]
	mov	rcx, QWORD PTR fsys$[rsp]
	mov	QWORD PTR [rax+72], rcx

; 414  : 				file->parent_block = fs->__RootDirFirstCluster;

	mov	rax, QWORD PTR file$[rsp]
	mov	rcx, QWORD PTR fs$[rsp]
	mov	ecx, DWORD PTR [rcx+34]
	mov	DWORD PTR [rax+44], ecx

; 415  : 				if (dirent->attrib & 0x10)

	mov	rax, QWORD PTR dirent$[rsp]
	movzx	eax, BYTE PTR [rax+11]
	and	eax, 16
	test	eax, eax
	je	SHORT $LN2@FatLocateD

; 416  : 					file->flags |= FS_FLAG_DIRECTORY;

	mov	rax, QWORD PTR file$[rsp]
	movzx	eax, WORD PTR [rax+64]
	or	eax, 2
	mov	rcx, QWORD PTR file$[rsp]
	mov	WORD PTR [rcx+64], ax

; 417  : 				else

	jmp	SHORT $LN1@FatLocateD
$LN2@FatLocateD:

; 418  : 					file->flags |= FS_FLAG_GENERAL;

	mov	rax, QWORD PTR file$[rsp]
	movzx	eax, WORD PTR [rax+64]
	or	eax, 4
	mov	rcx, QWORD PTR file$[rsp]
	mov	WORD PTR [rcx+64], ax
$LN1@FatLocateD:

; 419  : 
; 420  : 				AuPmmngrFree((void*)V2P((size_t)buf));

	mov	rcx, QWORD PTR buf$[rsp]
	call	V2P
	mov	rcx, rax
	call	AuPmmngrFree

; 421  : 				return file;

	mov	rax, QWORD PTR file$[rsp]
	jmp	SHORT $LN11@FatLocateD
$LN3@FatLocateD:

; 422  : 			}
; 423  : 			dirent++;

	mov	rax, QWORD PTR dirent$[rsp]
	add	rax, 32					; 00000020H
	mov	QWORD PTR dirent$[rsp], rax

; 424  : 		}

	jmp	$LN5@FatLocateD
$LN4@FatLocateD:

; 425  : 	}

	jmp	$LN8@FatLocateD
$LN7@FatLocateD:

; 426  : 
; 427  : 	AuPmmngrFree((void*)V2P((size_t)buf));

	mov	rcx, QWORD PTR buf$[rsp]
	call	V2P
	mov	rcx, rax
	call	AuPmmngrFree

; 428  : 	kfree(file);

	mov	rcx, QWORD PTR file$[rsp]
	call	kfree

; 429  : 	return NULL;

	xor	eax, eax
$LN11@FatLocateD:

; 430  : }

	add	rsp, 136				; 00000088H
	ret	0
?FatLocateDir@@YAPEAU__VFS_NODE__@@PEAU1@PEBD@Z ENDP	; FatLocateDir
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\fs\fat\fat.cpp
_TEXT	SEGMENT
tv66 = 32
tv70 = 36
?FatFormatTime@@YAGXZ PROC				; FatFormatTime

; 613  : uint16_t FatFormatTime() {

$LN3:
	sub	rsp, 56					; 00000038H

; 614  : 	return (uint16_t)(AuRTCGetHour() << 11 | AuRTCGetMinutes() << 5 | AuRTCGetSecond() / 2);

	call	AuRTCGetHour
	movzx	eax, al
	shl	eax, 11
	mov	DWORD PTR tv66[rsp], eax
	call	AuRTCGetMinutes
	movzx	eax, al
	shl	eax, 5
	mov	ecx, DWORD PTR tv66[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR tv70[rsp], eax
	call	AuRTCGetSecond
	movzx	eax, al
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR tv70[rsp]
	or	ecx, eax
	mov	eax, ecx

; 615  : }

	add	rsp, 56					; 00000038H
	ret	0
?FatFormatTime@@YAGXZ ENDP				; FatFormatTime
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\fs\fat\fat.cpp
_TEXT	SEGMENT
tv68 = 32
tv72 = 36
?FatFormatDate@@YAGXZ PROC				; FatFormatDate

; 606  : uint16_t FatFormatDate() {

$LN3:
	sub	rsp, 56					; 00000038H

; 607  : 	return (uint16_t)((2000 + AuRTCGetYear() - 1980) << 9 | AuRTCGetMonth() << 5 | AuRTCGetDay());

	call	AuRTCGetYear
	movzx	eax, al
	add	eax, 20
	shl	eax, 9
	mov	DWORD PTR tv68[rsp], eax
	call	AuRTCGetMonth
	movzx	eax, al
	shl	eax, 5
	mov	ecx, DWORD PTR tv68[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR tv72[rsp], eax
	call	AuRTCGetDay
	movzx	eax, al
	mov	ecx, DWORD PTR tv72[rsp]
	or	ecx, eax
	mov	eax, ecx

; 608  : }

	add	rsp, 56					; 00000038H
	ret	0
?FatFormatDate@@YAGXZ ENDP				; FatFormatDate
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\fs\fat\fat.cpp
_TEXT	SEGMENT
root_dir$ = 32
i$1 = 36
p$ = 40
cur_dir$ = 48
path$ = 56
_fs$ = 64
vdisk$ = 72
pathname$2 = 80
fsys$ = 112
filename$ = 120
?FatOpen@@YAPEAU__VFS_NODE__@@PEAU1@PEAD@Z PROC		; FatOpen

; 436  : AuVFSNode * FatOpen(AuVFSNode * fsys, char* filename) {

$LN18:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 437  : 	if (!fsys)

	cmp	QWORD PTR fsys$[rsp], 0
	jne	SHORT $LN15@FatOpen

; 438  : 		return NULL;

	xor	eax, eax
	jmp	$LN16@FatOpen
$LN15@FatOpen:

; 439  : 	FatFS* _fs = (FatFS*)fsys->device;

	mov	rax, QWORD PTR fsys$[rsp]
	mov	rax, QWORD PTR [rax+72]
	mov	QWORD PTR _fs$[rsp], rax

; 440  : 	AuVFSNode *cur_dir = NULL;

	mov	QWORD PTR cur_dir$[rsp], 0

; 441  : 	AuVDisk *vdisk = (AuVDisk*)fsys->device;

	mov	rax, QWORD PTR fsys$[rsp]
	mov	rax, QWORD PTR [rax+72]
	mov	QWORD PTR vdisk$[rsp], rax

; 442  : 	char* p = 0;

	mov	QWORD PTR p$[rsp], 0

; 443  : 	bool  root_dir = true;

	mov	BYTE PTR root_dir$[rsp], 1

; 444  : 	char* path = (char*)filename;

	mov	rax, QWORD PTR filename$[rsp]
	mov	QWORD PTR path$[rsp], rax

; 445  : 	
; 446  : 	//! any '\'s in path ?
; 447  : 	p = strchr(path, '/');

	mov	edx, 47					; 0000002fH
	mov	rcx, QWORD PTR path$[rsp]
	call	strchr
	mov	QWORD PTR p$[rsp], rax

; 448  : 	if (!p) {

	cmp	QWORD PTR p$[rsp], 0
	jne	SHORT $LN14@FatOpen

; 449  : 
; 450  : 		//! nope, must be in root directory, search it
; 451  : 		cur_dir = FatLocateDir(fsys,path);

	mov	rdx, QWORD PTR path$[rsp]
	mov	rcx, QWORD PTR fsys$[rsp]
	call	?FatLocateDir@@YAPEAU__VFS_NODE__@@PEAU1@PEBD@Z ; FatLocateDir
	mov	QWORD PTR cur_dir$[rsp], rax

; 452  : 
; 453  : 		//! found file ?
; 454  : 		if (cur_dir != NULL) {

	cmp	QWORD PTR cur_dir$[rsp], 0
	je	SHORT $LN13@FatOpen

; 455  : 			return cur_dir;

	mov	rax, QWORD PTR cur_dir$[rsp]
	jmp	$LN16@FatOpen
$LN13@FatOpen:

; 456  : 		}
; 457  : 		//! unable to find
; 458  : 		return NULL;

	xor	eax, eax
	jmp	$LN16@FatOpen
$LN14@FatOpen:

; 459  : 	}
; 460  : 
; 461  : 	//! go to next character after first '\'
; 462  : 	p++;

	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax
$LN12@FatOpen:

; 463  : 	while (p) {

	cmp	QWORD PTR p$[rsp], 0
	je	$LN11@FatOpen

; 464  : 
; 465  : 		//! get pathname
; 466  : 		char pathname[16];
; 467  : 		int i = 0;

	mov	DWORD PTR i$1[rsp], 0

; 468  : 		for (i = 0; i < 16; i++) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN10@FatOpen
$LN9@FatOpen:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN10@FatOpen:
	cmp	DWORD PTR i$1[rsp], 16
	jge	SHORT $LN8@FatOpen

; 469  : 
; 470  : 			//! if another '\' or end of line is reached, we are done
; 471  : 			if (p[i] == '/' || p[i] == '\0')

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 47					; 0000002fH
	je	SHORT $LN6@FatOpen
	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	jne	SHORT $LN7@FatOpen
$LN6@FatOpen:

; 472  : 				break;

	jmp	SHORT $LN8@FatOpen
$LN7@FatOpen:

; 473  : 
; 474  : 			//! copy character
; 475  : 			pathname[i] = p[i];

	movsxd	rax, DWORD PTR i$1[rsp]
	movsxd	rcx, DWORD PTR i$1[rsp]
	mov	rdx, QWORD PTR p$[rsp]
	movzx	eax, BYTE PTR [rdx+rax]
	mov	BYTE PTR pathname$2[rsp+rcx], al

; 476  : 		}

	jmp	SHORT $LN9@FatOpen
$LN8@FatOpen:

; 477  : 		pathname[i] = 0; //null terminate

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	BYTE PTR pathname$2[rsp+rax], 0

; 478  : 
; 479  : 		//! open subdirectory or file
; 480  : 		if (root_dir) {

	movzx	eax, BYTE PTR root_dir$[rsp]
	test	eax, eax
	je	SHORT $LN5@FatOpen

; 481  : 			//! search root dir -- open pathname
; 482  : 			cur_dir = FatLocateDir(fsys,pathname);

	lea	rdx, QWORD PTR pathname$2[rsp]
	mov	rcx, QWORD PTR fsys$[rsp]
	call	?FatLocateDir@@YAPEAU__VFS_NODE__@@PEAU1@PEBD@Z ; FatLocateDir
	mov	QWORD PTR cur_dir$[rsp], rax

; 483  : 			root_dir = false;

	mov	BYTE PTR root_dir$[rsp], 0

; 484  : 		}
; 485  : 		else {

	jmp	SHORT $LN4@FatOpen
$LN5@FatOpen:

; 486  : 			//! search a sub directory instead for pathname
; 487  : 			cur_dir = FatLocateSubDir(fsys,cur_dir, pathname);

	lea	r8, QWORD PTR pathname$2[rsp]
	mov	rdx, QWORD PTR cur_dir$[rsp]
	mov	rcx, QWORD PTR fsys$[rsp]
	call	?FatLocateSubDir@@YAPEAU__VFS_NODE__@@PEAU1@0PEBD@Z ; FatLocateSubDir
	mov	QWORD PTR cur_dir$[rsp], rax
$LN4@FatOpen:

; 488  : 		}
; 489  : 
; 490  : 		//! found directory or file?
; 491  : 		if (cur_dir == NULL)

	cmp	QWORD PTR cur_dir$[rsp], 0
	jne	SHORT $LN3@FatOpen

; 492  : 			break;

	jmp	SHORT $LN11@FatOpen
$LN3@FatOpen:

; 493  : 
; 494  : 		//! find next '\'
; 495  : 		p = strchr(p + 1, '/');

	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	edx, 47					; 0000002fH
	mov	rcx, rax
	call	strchr
	mov	QWORD PTR p$[rsp], rax

; 496  : 		if (p)

	cmp	QWORD PTR p$[rsp], 0
	je	SHORT $LN2@FatOpen

; 497  : 			p++;

	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax
$LN2@FatOpen:

; 498  : 	}

	jmp	$LN12@FatOpen
$LN11@FatOpen:

; 499  : 
; 500  : 	//! found file?
; 501  : 	if (cur_dir)

	cmp	QWORD PTR cur_dir$[rsp], 0
	je	SHORT $LN1@FatOpen

; 502  : 		return cur_dir;

	mov	rax, QWORD PTR cur_dir$[rsp]
	jmp	SHORT $LN16@FatOpen
$LN1@FatOpen:

; 503  : 	//! unable to find
; 504  : 	return NULL;

	xor	eax, eax
$LN16@FatOpen:

; 505  : }

	add	rsp, 104				; 00000068H
	ret	0
?FatOpen@@YAPEAU__VFS_NODE__@@PEAU1@PEAD@Z ENDP		; FatOpen
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\fs\fat\fat.cpp
_TEXT	SEGMENT
fat_offset$ = 32
value$ = 36
BuffArea$ = 40
fs$ = 48
vdisk$ = 56
fat_sector$ = 64
ent_offset$ = 72
buf$ = 80
node$ = 112
cluster_index$ = 120
?FatReadFAT@@YAIPEAU__VFS_NODE__@@I@Z PROC		; FatReadFAT

; 139  : uint32_t FatReadFAT(AuVFSNode *node, uint32_t cluster_index) {

$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 140  : 	FatFS *fs = (FatFS*)node->device;

	mov	rax, QWORD PTR node$[rsp]
	mov	rax, QWORD PTR [rax+72]
	mov	QWORD PTR fs$[rsp], rax

; 141  : 	AuVDisk *vdisk = (AuVDisk*)fs->vdisk;

	mov	rax, QWORD PTR fs$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR vdisk$[rsp], rax

; 142  : 	if (!vdisk){

	cmp	QWORD PTR vdisk$[rsp], 0
	jne	SHORT $LN1@FatReadFAT

; 143  : 		return NULL;

	xor	eax, eax
	jmp	$LN2@FatReadFAT
$LN1@FatReadFAT:

; 144  : 	}
; 145  : 
; 146  : 	auto fat_offset = cluster_index * 4;

	mov	eax, DWORD PTR cluster_index$[rsp]
	shl	eax, 2
	mov	DWORD PTR fat_offset$[rsp], eax

; 147  : 	uint64_t fat_sector = fs->__FatBeginLBA + (fat_offset / 512);

	xor	edx, edx
	mov	eax, DWORD PTR fat_offset$[rsp]
	mov	ecx, 512				; 00000200H
	div	ecx
	mov	rcx, QWORD PTR fs$[rsp]
	mov	ecx, DWORD PTR [rcx+25]
	add	ecx, eax
	mov	eax, ecx
	mov	eax, eax
	mov	QWORD PTR fat_sector$[rsp], rax

; 148  : 	size_t ent_offset = fat_offset % 512;

	xor	edx, edx
	mov	eax, DWORD PTR fat_offset$[rsp]
	mov	ecx, 512				; 00000200H
	div	ecx
	mov	eax, edx
	mov	eax, eax
	mov	QWORD PTR ent_offset$[rsp], rax

; 149  : 	uint64_t *BuffArea = (uint64_t*)P2V((size_t)AuPmmngrAlloc());

	call	AuPmmngrAlloc
	mov	rcx, rax
	call	P2V
	mov	QWORD PTR BuffArea$[rsp], rax

; 150  : 	memset(BuffArea, 0, 4096);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR BuffArea$[rsp]
	call	memset

; 151  : 	AuVDiskRead(vdisk, fat_sector, 4096/512, (uint64_t*)V2P((size_t)BuffArea));

	mov	rcx, QWORD PTR BuffArea$[rsp]
	call	V2P
	mov	r9, rax
	mov	r8d, 8
	mov	rdx, QWORD PTR fat_sector$[rsp]
	mov	rcx, QWORD PTR vdisk$[rsp]
	call	AuVDiskRead

; 152  : 	unsigned char* buf = (unsigned char*)BuffArea;

	mov	rax, QWORD PTR BuffArea$[rsp]
	mov	QWORD PTR buf$[rsp], rax

; 153  : 	uint32_t value = *(uint32_t*)&buf[ent_offset];

	mov	rax, QWORD PTR ent_offset$[rsp]
	mov	rcx, QWORD PTR buf$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR value$[rsp], eax

; 154  : 	AuPmmngrFree((void*)V2P((size_t)BuffArea));

	mov	rcx, QWORD PTR BuffArea$[rsp]
	call	V2P
	mov	rcx, rax
	call	AuPmmngrFree

; 155  : 	return value & 0x0FFFFFFF;

	mov	eax, DWORD PTR value$[rsp]
	and	eax, 268435455				; 0fffffffH
$LN2@FatReadFAT:

; 156  : }

	add	rsp, 104				; 00000068H
	ret	0
?FatReadFAT@@YAIPEAU__VFS_NODE__@@I@Z ENDP		; FatReadFAT
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\fs\fat\fat.cpp
_TEXT	SEGMENT
sector$ = 32
fs$ = 40
buffer$ = 48
vdisk$ = 56
node$ = 80
cluster$ = 88
?FatClearCluster@@YAXPEAU__VFS_NODE__@@I@Z PROC		; FatClearCluster

; 238  : void FatClearCluster(AuVFSNode* node, uint32_t cluster) {

$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 239  : 	FatFS* fs = (FatFS*)node->device;

	mov	rax, QWORD PTR node$[rsp]
	mov	rax, QWORD PTR [rax+72]
	mov	QWORD PTR fs$[rsp], rax

; 240  : 	AuVDisk* vdisk = (AuVDisk*)fs->vdisk;

	mov	rax, QWORD PTR fs$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR vdisk$[rsp], rax

; 241  : 	if (!vdisk)

	cmp	QWORD PTR vdisk$[rsp], 0
	jne	SHORT $LN1@FatClearCl

; 242  : 		return;

	jmp	SHORT $LN2@FatClearCl
$LN1@FatClearCl:

; 243  : 
; 244  : 	uint64_t *buffer = (uint64_t*)P2V((size_t)AuPmmngrAlloc());

	call	AuPmmngrAlloc
	mov	rcx, rax
	call	P2V
	mov	QWORD PTR buffer$[rsp], rax

; 245  : 	memset(buffer, 0, PAGE_SIZE);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR buffer$[rsp]
	call	memset

; 246  : 	//update_cluster (buffer,cluster);
; 247  : 	uint32_t sector = FatClusterToSector32(fs, cluster);

	mov	eax, DWORD PTR cluster$[rsp]
	mov	edx, eax
	mov	rcx, QWORD PTR fs$[rsp]
	call	?FatClusterToSector32@@YA_KPEAU_FatFS_@@_K@Z ; FatClusterToSector32
	mov	DWORD PTR sector$[rsp], eax

; 248  : 	AuVDiskWrite(vdisk, sector, fs->__SectorPerCluster, (uint64_t*)V2P((size_t)buffer));

	mov	rcx, QWORD PTR buffer$[rsp]
	call	V2P
	mov	rcx, QWORD PTR fs$[rsp]
	movzx	ecx, BYTE PTR [rcx+33]
	mov	edx, DWORD PTR sector$[rsp]
	mov	r9, rax
	mov	r8d, ecx
	mov	rcx, QWORD PTR vdisk$[rsp]
	call	AuVDiskWrite

; 249  : 	AuPmmngrFree((void*)V2P((size_t)buffer));

	mov	rcx, QWORD PTR buffer$[rsp]
	call	V2P
	mov	rcx, rax
	call	AuPmmngrFree
$LN2@FatClearCl:

; 250  : }

	add	rsp, 72					; 00000048H
	ret	0
?FatClearCluster@@YAXPEAU__VFS_NODE__@@I@Z ENDP		; FatClearCluster
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\fs\fat\fat.cpp
_TEXT	SEGMENT
fat_offset$ = 32
buffer$ = 40
ent_offset$ = 48
buf$ = 56
vdisk$ = 64
fat_sector$ = 72
fs$ = 80
value2$ = 88
value$ = 92
fsys$ = 112
position$ = 120
n_value$ = 128
?FatAllocCluster@@YAXPEAU__VFS_NODE__@@HI@Z PROC	; FatAllocCluster

; 195  : void FatAllocCluster(AuVFSNode* fsys, int position, uint32_t n_value) {

$LN4:
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 196  : 	FatFS *fs = (FatFS*)fsys->device;

	mov	rax, QWORD PTR fsys$[rsp]
	mov	rax, QWORD PTR [rax+72]
	mov	QWORD PTR fs$[rsp], rax

; 197  : 	AuVDisk* vdisk = (AuVDisk*)fs->vdisk;

	mov	rax, QWORD PTR fs$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR vdisk$[rsp], rax

; 198  : 	if (!vdisk)

	cmp	QWORD PTR vdisk$[rsp], 0
	jne	SHORT $LN1@FatAllocCl

; 199  : 		return;

	jmp	$LN2@FatAllocCl
$LN1@FatAllocCl:

; 200  : 
; 201  : 	auto fat_offset = position * 4;

	mov	eax, DWORD PTR position$[rsp]
	shl	eax, 2
	mov	DWORD PTR fat_offset$[rsp], eax

; 202  : 	uint64_t fat_sector = fs->__FatBeginLBA + (fat_offset / 512);

	mov	eax, DWORD PTR fat_offset$[rsp]
	cdq
	and	edx, 511				; 000001ffH
	add	eax, edx
	sar	eax, 9
	mov	rcx, QWORD PTR fs$[rsp]
	mov	ecx, DWORD PTR [rcx+25]
	add	ecx, eax
	mov	eax, ecx
	mov	eax, eax
	mov	QWORD PTR fat_sector$[rsp], rax

; 203  : 	size_t ent_offset = fat_offset % 512;

	mov	eax, DWORD PTR fat_offset$[rsp]
	cdq
	and	edx, 511				; 000001ffH
	add	eax, edx
	and	eax, 511				; 000001ffH
	sub	eax, edx
	cdqe
	mov	QWORD PTR ent_offset$[rsp], rax

; 204  : 	uint64_t *buffer = (uint64_t*)P2V((size_t)AuPmmngrAlloc());

	call	AuPmmngrAlloc
	mov	rcx, rax
	call	P2V
	mov	QWORD PTR buffer$[rsp], rax

; 205  : 	memset(buffer, 0, PAGE_SIZE);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR buffer$[rsp]
	call	memset

; 206  : 	AuVDiskRead(vdisk, fat_sector, 1, (uint64_t*)V2P((size_t)buffer));

	mov	rcx, QWORD PTR buffer$[rsp]
	call	V2P
	mov	r9, rax
	mov	r8d, 1
	mov	rdx, QWORD PTR fat_sector$[rsp]
	mov	rcx, QWORD PTR vdisk$[rsp]
	call	AuVDiskRead

; 207  : 
; 208  : 	uint8_t* buf = (uint8_t*)buffer;

	mov	rax, QWORD PTR buffer$[rsp]
	mov	QWORD PTR buf$[rsp], rax

; 209  : 	uint32_t value = *(uint32_t*)&buf[ent_offset];

	mov	rax, QWORD PTR ent_offset$[rsp]
	mov	rcx, QWORD PTR buf$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR value$[rsp], eax

; 210  : 	*(uint32_t*)&buf[ent_offset] = n_value & 0x0FFFFFFF;

	mov	eax, DWORD PTR n_value$[rsp]
	and	eax, 268435455				; 0fffffffH
	mov	rcx, QWORD PTR ent_offset$[rsp]
	mov	rdx, QWORD PTR buf$[rsp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	DWORD PTR [rcx], eax

; 211  : 
; 212  : 	uint32_t value2 = *(uint32_t*)&buf[ent_offset];

	mov	rax, QWORD PTR ent_offset$[rsp]
	mov	rcx, QWORD PTR buf$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR value2$[rsp], eax

; 213  : 	AuVDiskWrite(vdisk, fat_sector, 1, (uint64_t*)V2P((size_t)buffer));

	mov	rcx, QWORD PTR buffer$[rsp]
	call	V2P
	mov	r9, rax
	mov	r8d, 1
	mov	rdx, QWORD PTR fat_sector$[rsp]
	mov	rcx, QWORD PTR vdisk$[rsp]
	call	AuVDiskWrite

; 214  : 	AuPmmngrFree((void*)V2P((size_t)buffer));

	mov	rcx, QWORD PTR buffer$[rsp]
	call	V2P
	mov	rcx, rax
	call	AuPmmngrFree
$LN2@FatAllocCl:

; 215  : }

	add	rsp, 104				; 00000068H
	ret	0
?FatAllocCluster@@YAXPEAU__VFS_NODE__@@HI@Z ENDP	; FatAllocCluster
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\fs\fat\fat.cpp
_TEXT	SEGMENT
i$1 = 32
fat_offset$2 = 36
buffer$3 = 40
fs$ = 48
value$4 = 56
vdisk$ = 64
fat_sector$5 = 72
ent_offset$6 = 80
buf$7 = 88
node$ = 112
?FatFindFreeCluster@@YAIPEAU__VFS_NODE__@@@Z PROC	; FatFindFreeCluster

; 163  : uint32_t FatFindFreeCluster(AuVFSNode* node) {

$LN8:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 164  : 	FatFS *fs = (FatFS*)node->device;

	mov	rax, QWORD PTR node$[rsp]
	mov	rax, QWORD PTR [rax+72]
	mov	QWORD PTR fs$[rsp], rax

; 165  : 	AuVDisk *vdisk = (AuVDisk*)fs->vdisk;

	mov	rax, QWORD PTR fs$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR vdisk$[rsp], rax

; 166  : 	if (!vdisk)

	cmp	QWORD PTR vdisk$[rsp], 0
	jne	SHORT $LN5@FatFindFre

; 167  : 		return NULL;

	xor	eax, eax
	jmp	$LN6@FatFindFre
$LN5@FatFindFre:

; 168  : 
; 169  : 	for (int i = 2; i < fs->__TotalClusters; i++) {

	mov	DWORD PTR i$1[rsp], 2
	jmp	SHORT $LN4@FatFindFre
$LN3@FatFindFre:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN4@FatFindFre:
	mov	rax, QWORD PTR fs$[rsp]
	mov	eax, DWORD PTR [rax+46]
	cmp	DWORD PTR i$1[rsp], eax
	jae	$LN2@FatFindFre

; 170  : 		auto fat_offset = i * 4;

	mov	eax, DWORD PTR i$1[rsp]
	shl	eax, 2
	mov	DWORD PTR fat_offset$2[rsp], eax

; 171  : 		uint64_t fat_sector = fs->__FatBeginLBA + (fat_offset / 512);

	mov	eax, DWORD PTR fat_offset$2[rsp]
	cdq
	and	edx, 511				; 000001ffH
	add	eax, edx
	sar	eax, 9
	mov	rcx, QWORD PTR fs$[rsp]
	mov	ecx, DWORD PTR [rcx+25]
	add	ecx, eax
	mov	eax, ecx
	mov	eax, eax
	mov	QWORD PTR fat_sector$5[rsp], rax

; 172  : 		size_t ent_offset = fat_offset % 512;

	mov	eax, DWORD PTR fat_offset$2[rsp]
	cdq
	and	edx, 511				; 000001ffH
	add	eax, edx
	and	eax, 511				; 000001ffH
	sub	eax, edx
	cdqe
	mov	QWORD PTR ent_offset$6[rsp], rax

; 173  : 		uint64_t *buffer = (uint64_t*)P2V((size_t)AuPmmngrAlloc());

	call	AuPmmngrAlloc
	mov	rcx, rax
	call	P2V
	mov	QWORD PTR buffer$3[rsp], rax

; 174  : 		memset(buffer, 0, PAGE_SIZE);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR buffer$3[rsp]
	call	memset

; 175  : 		AuVDiskRead(vdisk, fat_sector, 1, (uint64_t*)V2P((size_t)buffer));

	mov	rcx, QWORD PTR buffer$3[rsp]
	call	V2P
	mov	r9, rax
	mov	r8d, 1
	mov	rdx, QWORD PTR fat_sector$5[rsp]
	mov	rcx, QWORD PTR vdisk$[rsp]
	call	AuVDiskRead

; 176  : 		uint8_t* buf = (uint8_t*)buffer;

	mov	rax, QWORD PTR buffer$3[rsp]
	mov	QWORD PTR buf$7[rsp], rax

; 177  : 		uint32_t value = *(uint32_t*)&buf[ent_offset];

	mov	rax, QWORD PTR ent_offset$6[rsp]
	mov	rcx, QWORD PTR buf$7[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR value$4[rsp], eax

; 178  : 
; 179  : 		AuPmmngrFree((void*)V2P((size_t)buffer));

	mov	rcx, QWORD PTR buffer$3[rsp]
	call	V2P
	mov	rcx, rax
	call	AuPmmngrFree

; 180  : 		//! Found a free cluster return the value
; 181  : 		if (value == 0x00) {

	cmp	DWORD PTR value$4[rsp], 0
	jne	SHORT $LN1@FatFindFre

; 182  : 			return i;

	mov	eax, DWORD PTR i$1[rsp]
	jmp	SHORT $LN6@FatFindFre
$LN1@FatFindFre:

; 183  : 		}
; 184  : 	}

	jmp	$LN3@FatFindFre
$LN2@FatFindFre:

; 185  : 	return 0;

	xor	eax, eax
$LN6@FatFindFre:

; 186  : }

	add	rsp, 104				; 00000068H
	ret	0
?FatFindFreeCluster@@YAIPEAU__VFS_NODE__@@@Z ENDP	; FatFindFreeCluster
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\fs\fat\fat.cpp
_TEXT	SEGMENT
i$ = 32
k$1 = 36
tv71 = 40
filename$ = 64
fname$ = 72
fname_length$ = 80
?FatToDOSFilename@@YAXPEBDPEADI@Z PROC			; FatToDOSFilename

; 74   : {

$LN19:
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 75   : 	unsigned int i = 0;

	mov	DWORD PTR i$[rsp], 0

; 76   : 
; 77   : 	if (fname_length > 11)

	cmp	DWORD PTR fname_length$[rsp], 11
	jbe	SHORT $LN16@FatToDOSFi

; 78   : 		return;

	jmp	$LN17@FatToDOSFi
$LN16@FatToDOSFi:

; 79   : 
; 80   : 	if (!fname || !filename)

	cmp	QWORD PTR fname$[rsp], 0
	je	SHORT $LN14@FatToDOSFi
	cmp	QWORD PTR filename$[rsp], 0
	jne	SHORT $LN15@FatToDOSFi
$LN14@FatToDOSFi:

; 81   : 		return;

	jmp	$LN17@FatToDOSFi
$LN15@FatToDOSFi:

; 82   : 
; 83   : 	memset(fname, ' ', fname_length);

	mov	r8d, DWORD PTR fname_length$[rsp]
	mov	dl, 32					; 00000020H
	mov	rcx, QWORD PTR fname$[rsp]
	call	memset

; 84   : 
; 85   : 	for (i = 0; i < strlen(filename) - 1 && i < fname_length; i++)

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN13@FatToDOSFi
$LN12@FatToDOSFi:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN13@FatToDOSFi:
	mov	eax, DWORD PTR i$[rsp]
	mov	QWORD PTR tv71[rsp], rax
	mov	rcx, QWORD PTR filename$[rsp]
	call	strlen
	dec	rax
	mov	rcx, QWORD PTR tv71[rsp]
	cmp	rcx, rax
	jae	SHORT $LN11@FatToDOSFi
	mov	eax, DWORD PTR fname_length$[rsp]
	cmp	DWORD PTR i$[rsp], eax
	jae	SHORT $LN11@FatToDOSFi

; 86   : 	{
; 87   : 		if (filename[i] == '.' || i == 8)

	mov	eax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR filename$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 46					; 0000002eH
	je	SHORT $LN9@FatToDOSFi
	cmp	DWORD PTR i$[rsp], 8
	jne	SHORT $LN10@FatToDOSFi
$LN9@FatToDOSFi:

; 88   : 			break;

	jmp	SHORT $LN11@FatToDOSFi
$LN10@FatToDOSFi:

; 89   : 
; 90   : 		fname[i] = toupper(filename[i]);

	mov	eax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR filename$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	mov	ecx, eax
	call	toupper
	mov	ecx, DWORD PTR i$[rsp]
	mov	rdx, QWORD PTR fname$[rsp]
	mov	BYTE PTR [rdx+rcx], al

; 91   : 	}

	jmp	SHORT $LN12@FatToDOSFi
$LN11@FatToDOSFi:

; 92   : 
; 93   : 	if (filename[i] == '.')

	mov	eax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR filename$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 46					; 0000002eH
	jne	SHORT $LN8@FatToDOSFi

; 94   : 	{
; 95   : 		for (int k = 0; k < 3; k++)

	mov	DWORD PTR k$1[rsp], 0
	jmp	SHORT $LN7@FatToDOSFi
$LN6@FatToDOSFi:
	mov	eax, DWORD PTR k$1[rsp]
	inc	eax
	mov	DWORD PTR k$1[rsp], eax
$LN7@FatToDOSFi:
	cmp	DWORD PTR k$1[rsp], 3
	jge	SHORT $LN5@FatToDOSFi

; 96   : 		{
; 97   : 			++i;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 98   : 			if (filename[i])

	mov	eax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR filename$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN4@FatToDOSFi

; 99   : 				fname[8 + k] = filename[i];

	mov	eax, DWORD PTR i$[rsp]
	mov	ecx, DWORD PTR k$1[rsp]
	add	ecx, 8
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR fname$[rsp]
	mov	r8, QWORD PTR filename$[rsp]
	movzx	eax, BYTE PTR [r8+rax]
	mov	BYTE PTR [rdx+rcx], al
$LN4@FatToDOSFi:

; 100  : 		}

	jmp	SHORT $LN6@FatToDOSFi
$LN5@FatToDOSFi:
$LN8@FatToDOSFi:

; 101  : 	}
; 102  : 
; 103  : 	for (i = 0; i < 3; i++)

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN3@FatToDOSFi
$LN2@FatToDOSFi:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN3@FatToDOSFi:
	cmp	DWORD PTR i$[rsp], 3
	jae	SHORT $LN1@FatToDOSFi

; 104  : 		fname[8 + i] = toupper(fname[8 + i]);

	mov	eax, DWORD PTR i$[rsp]
	add	eax, 8
	mov	eax, eax
	mov	rcx, QWORD PTR fname$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	mov	ecx, eax
	call	toupper
	mov	ecx, DWORD PTR i$[rsp]
	add	ecx, 8
	mov	ecx, ecx
	mov	rdx, QWORD PTR fname$[rsp]
	mov	BYTE PTR [rdx+rcx], al
	jmp	SHORT $LN2@FatToDOSFi
$LN1@FatToDOSFi:
$LN17@FatToDOSFi:

; 105  : }

	add	rsp, 56					; 00000038H
	ret	0
?FatToDOSFilename@@YAXPEBDPEADI@Z ENDP			; FatToDOSFilename
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\fs\fat\fat.cpp
_TEXT	SEGMENT
fs$ = 8
cluster$ = 16
?FatClusterToSector32@@YA_KPEAU_FatFS_@@_K@Z PROC	; FatClusterToSector32

; 62   : uint64_t FatClusterToSector32(FatFS *fs, uint64_t cluster) {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 63   : 	return fs->__ClusterBeginLBA + (cluster - 2) * fs->__SectorPerCluster;

	mov	rax, QWORD PTR fs$[rsp]
	mov	eax, DWORD PTR [rax+29]
	mov	rcx, QWORD PTR cluster$[rsp]
	sub	rcx, 2
	mov	rdx, QWORD PTR fs$[rsp]
	movzx	edx, BYTE PTR [rdx+33]
	imul	rcx, rdx
	add	rax, rcx

; 64   : }

	ret	0
?FatClusterToSector32@@YA_KPEAU_FatFS_@@_K@Z ENDP	; FatClusterToSector32
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\fs\fat\fat.cpp
_TEXT	SEGMENT
fs$ = 32
bpb$ = 40
fsys$ = 48
i$1 = 56
buffer$ = 64
tv198 = 72
tv208 = 76
_dataSectors$ = 80
tv179 = 88
fatsize$ = 96
_root_dir_sectors$ = 104
_TotalSectors$ = 112
vdisk$ = 144
mountname$ = 152
?FatInitialise@@YAPEAU__VFS_NODE__@@PEAU_VDISK_@@PEAD@Z PROC ; FatInitialise

; 531  : AuVFSNode* FatInitialise(AuVDisk *vdisk, char* mountname){

$LN16:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 136				; 00000088H

; 532  : 	uint64_t* buffer = (uint64_t*)AuPmmngrAlloc();

	call	AuPmmngrAlloc
	mov	QWORD PTR buffer$[rsp], rax

; 533  : 	memset(buffer, 0, 4096);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR buffer$[rsp]
	call	memset

; 534  : 	AuVDiskRead(vdisk, 0, 1, buffer);

	mov	r9, QWORD PTR buffer$[rsp]
	mov	r8d, 1
	xor	edx, edx
	mov	rcx, QWORD PTR vdisk$[rsp]
	call	AuVDiskRead

; 535  : 
; 536  : 	FatBPB* bpb = (FatBPB*)buffer;

	mov	rax, QWORD PTR buffer$[rsp]
	mov	QWORD PTR bpb$[rsp], rax

; 537  : 
; 538  : 	FatFS *fs = (FatFS*)kmalloc(sizeof(FatFS));

	mov	ecx, 92					; 0000005cH
	call	kmalloc
	mov	QWORD PTR fs$[rsp], rax

; 539  : 	memset(fs, 0, sizeof(FatFS));

	mov	r8d, 92					; 0000005cH
	xor	edx, edx
	mov	rcx, QWORD PTR fs$[rsp]
	call	memset

; 540  : 
; 541  : 	fs->bpb = bpb;

	mov	rax, QWORD PTR fs$[rsp]
	mov	rcx, QWORD PTR bpb$[rsp]
	mov	QWORD PTR [rax], rcx

; 542  : 	fs->vdisk = vdisk;

	mov	rax, QWORD PTR fs$[rsp]
	mov	rcx, QWORD PTR vdisk$[rsp]
	mov	QWORD PTR [rax+8], rcx

; 543  : 
; 544  : 	for (int i = 0; i < 8; i++) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN9@FatInitial
$LN8@FatInitial:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN9@FatInitial:
	cmp	DWORD PTR i$1[rsp], 8
	jge	SHORT $LN7@FatInitial

; 545  : 		AuTextOut("%c", bpb->oemid[i]);

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR bpb$[rsp]
	movsx	eax, BYTE PTR [rcx+rax+3]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG4114
	call	AuTextOut

; 546  : 		fs->oemid[i] = bpb->oemid[i];

	movsxd	rax, DWORD PTR i$1[rsp]
	movsxd	rcx, DWORD PTR i$1[rsp]
	mov	rdx, QWORD PTR fs$[rsp]
	mov	r8, QWORD PTR bpb$[rsp]
	movzx	eax, BYTE PTR [r8+rax+3]
	mov	BYTE PTR [rdx+rcx+16], al

; 547  : 	}

	jmp	SHORT $LN8@FatInitial
$LN7@FatInitial:

; 548  : 	fs->oemid[8] = '\0';

	mov	eax, 1
	imul	rax, rax, 8
	mov	rcx, QWORD PTR fs$[rsp]
	mov	BYTE PTR [rcx+rax+16], 0

; 549  : 	fs->__FatBeginLBA = bpb->reserved_sectors;

	mov	rax, QWORD PTR bpb$[rsp]
	movzx	eax, WORD PTR [rax+14]
	mov	rcx, QWORD PTR fs$[rsp]
	mov	DWORD PTR [rcx+25], eax

; 550  : 	fs->__ClusterBeginLBA = bpb->reserved_sectors + (bpb->num_fats* bpb->info.FAT32.sect_per_fat32);

	mov	rax, QWORD PTR bpb$[rsp]
	movzx	eax, WORD PTR [rax+14]
	mov	rcx, QWORD PTR bpb$[rsp]
	movzx	ecx, BYTE PTR [rcx+16]
	mov	rdx, QWORD PTR bpb$[rsp]
	imul	ecx, DWORD PTR [rdx+36]
	add	eax, ecx
	mov	rcx, QWORD PTR fs$[rsp]
	mov	DWORD PTR [rcx+29], eax

; 551  : 	fs->__SectorPerCluster = bpb->sectors_per_cluster;

	mov	rax, QWORD PTR fs$[rsp]
	mov	rcx, QWORD PTR bpb$[rsp]
	movzx	ecx, BYTE PTR [rcx+13]
	mov	BYTE PTR [rax+33], cl

; 552  : 	fs->__RootDirFirstCluster = bpb->info.FAT32.root_dir_cluster;

	mov	rax, QWORD PTR fs$[rsp]
	mov	rcx, QWORD PTR bpb$[rsp]
	mov	ecx, DWORD PTR [rcx+44]
	mov	DWORD PTR [rax+34], ecx

; 553  : 	fs->__RootSector = FatClusterToSector32(fs, fs->__RootDirFirstCluster);

	mov	rax, QWORD PTR fs$[rsp]
	mov	eax, DWORD PTR [rax+34]
	mov	edx, eax
	mov	rcx, QWORD PTR fs$[rsp]
	call	?FatClusterToSector32@@YA_KPEAU_FatFS_@@_K@Z ; FatClusterToSector32
	mov	rcx, QWORD PTR fs$[rsp]
	mov	DWORD PTR [rcx+38], eax

; 554  : 	fs->__SectorPerFAT32 = bpb->info.FAT32.sect_per_fat32;

	mov	rax, QWORD PTR fs$[rsp]
	mov	rcx, QWORD PTR bpb$[rsp]
	mov	ecx, DWORD PTR [rcx+36]
	mov	DWORD PTR [rax+42], ecx

; 555  : 	fs->cluster_sz_in_bytes = fs->__SectorPerCluster * bpb->bytes_per_sector;

	mov	rax, QWORD PTR fs$[rsp]
	movzx	eax, BYTE PTR [rax+33]
	mov	rcx, QWORD PTR bpb$[rsp]
	movzx	ecx, WORD PTR [rcx+11]
	imul	eax, ecx
	cdqe
	mov	rcx, QWORD PTR fs$[rsp]
	mov	QWORD PTR [rcx+60], rax

; 556  : 	fs->__BytesPerSector = bpb->bytes_per_sector;

	mov	rax, QWORD PTR fs$[rsp]
	mov	rcx, QWORD PTR bpb$[rsp]
	movzx	ecx, WORD PTR [rcx+11]
	mov	WORD PTR [rax+58], cx

; 557  : 	fs->fat_mutex = AuCreateMutex();

	call	AuCreateMutex
	mov	rcx, QWORD PTR fs$[rsp]
	mov	QWORD PTR [rcx+68], rax

; 558  : 	fs->fat_write_mutex = AuCreateMutex();

	call	AuCreateMutex
	mov	rcx, QWORD PTR fs$[rsp]
	mov	QWORD PTR [rcx+76], rax

; 559  : 	fs->fat_read_mutex = AuCreateMutex();

	call	AuCreateMutex
	mov	rcx, QWORD PTR fs$[rsp]
	mov	QWORD PTR [rcx+84], rax

; 560  : 	fs->__TotalClusters = bpb->large_sector_count / fs->__SectorPerCluster;

	mov	rax, QWORD PTR fs$[rsp]
	movzx	eax, BYTE PTR [rax+33]
	mov	DWORD PTR tv179[rsp], eax
	xor	edx, edx
	mov	rcx, QWORD PTR bpb$[rsp]
	mov	eax, DWORD PTR [rcx+32]
	mov	ecx, DWORD PTR tv179[rsp]
	div	ecx
	mov	rcx, QWORD PTR fs$[rsp]
	mov	DWORD PTR [rcx+46], eax

; 561  : 	size_t _root_dir_sectors = ((bpb->num_dir_entries * 32) + bpb->bytes_per_sector - 1) / bpb->bytes_per_sector;

	mov	rax, QWORD PTR bpb$[rsp]
	movzx	eax, WORD PTR [rax+17]
	imul	eax, eax, 32				; 00000020H
	mov	rcx, QWORD PTR bpb$[rsp]
	movzx	ecx, WORD PTR [rcx+11]
	lea	eax, DWORD PTR [rax+rcx-1]
	mov	rcx, QWORD PTR bpb$[rsp]
	movzx	ecx, WORD PTR [rcx+11]
	cdq
	idiv	ecx
	cdqe
	mov	QWORD PTR _root_dir_sectors$[rsp], rax

; 562  : 	size_t _TotalSectors = (bpb->total_sectors_short == 0) ? bpb->large_sector_count : bpb->total_sectors_short;

	mov	rax, QWORD PTR bpb$[rsp]
	movzx	eax, WORD PTR [rax+19]
	test	eax, eax
	jne	SHORT $LN12@FatInitial
	mov	rax, QWORD PTR bpb$[rsp]
	mov	eax, DWORD PTR [rax+32]
	mov	DWORD PTR tv198[rsp], eax
	jmp	SHORT $LN13@FatInitial
$LN12@FatInitial:
	mov	rax, QWORD PTR bpb$[rsp]
	movzx	eax, WORD PTR [rax+19]
	mov	DWORD PTR tv198[rsp], eax
$LN13@FatInitial:
	mov	eax, DWORD PTR tv198[rsp]
	mov	QWORD PTR _TotalSectors$[rsp], rax

; 563  : 	size_t fatsize = (bpb->sectors_per_fat == 0) ? bpb->info.FAT32.sect_per_fat32 : bpb->sectors_per_fat;

	mov	rax, QWORD PTR bpb$[rsp]
	movzx	eax, WORD PTR [rax+22]
	test	eax, eax
	jne	SHORT $LN14@FatInitial
	mov	rax, QWORD PTR bpb$[rsp]
	mov	eax, DWORD PTR [rax+36]
	mov	DWORD PTR tv208[rsp], eax
	jmp	SHORT $LN15@FatInitial
$LN14@FatInitial:
	mov	rax, QWORD PTR bpb$[rsp]
	movzx	eax, WORD PTR [rax+22]
	mov	DWORD PTR tv208[rsp], eax
$LN15@FatInitial:
	mov	eax, DWORD PTR tv208[rsp]
	mov	QWORD PTR fatsize$[rsp], rax

; 564  : 	size_t _dataSectors = _TotalSectors - (bpb->reserved_sectors + bpb->num_fats * fatsize + _root_dir_sectors);

	mov	rax, QWORD PTR bpb$[rsp]
	movzx	eax, WORD PTR [rax+14]
	mov	rcx, QWORD PTR bpb$[rsp]
	movzx	ecx, BYTE PTR [rcx+16]
	imul	rcx, QWORD PTR fatsize$[rsp]
	mov	rdx, QWORD PTR _root_dir_sectors$[rsp]
	add	rdx, rax
	mov	rax, rdx
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR _TotalSectors$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _dataSectors$[rsp], rax

; 565  : 
; 566  : 	if (_dataSectors < 4085)

	cmp	QWORD PTR _dataSectors$[rsp], 4085	; 00000ff5H
	jae	SHORT $LN6@FatInitial

; 567  : 		fs->fatType = FSTYPE_FAT12;

	mov	rax, QWORD PTR fs$[rsp]
	mov	BYTE PTR [rax+24], 1
	jmp	SHORT $LN5@FatInitial
$LN6@FatInitial:

; 568  : 	else if (_dataSectors < 65525)

	cmp	QWORD PTR _dataSectors$[rsp], 65525	; 0000fff5H
	jae	SHORT $LN4@FatInitial

; 569  : 		fs->fatType = FSTYPE_FAT16;

	mov	rax, QWORD PTR fs$[rsp]
	mov	BYTE PTR [rax+24], 2
	jmp	SHORT $LN3@FatInitial
$LN4@FatInitial:

; 570  : 	else if (_dataSectors < 268435445)

	cmp	QWORD PTR _dataSectors$[rsp], 268435445	; 0ffffff5H
	jae	SHORT $LN2@FatInitial

; 571  : 		fs->fatType = FSTYPE_FAT32;

	mov	rax, QWORD PTR fs$[rsp]
	mov	BYTE PTR [rax+24], 3
$LN2@FatInitial:
$LN3@FatInitial:
$LN5@FatInitial:

; 572  : 
; 573  : 	if (fs->fatType != FSTYPE_FAT32) {

	mov	rax, QWORD PTR fs$[rsp]
	movzx	eax, BYTE PTR [rax+24]
	cmp	eax, 3
	je	SHORT $LN1@FatInitial

; 574  : 		AuPmmngrFree(buffer);

	mov	rcx, QWORD PTR buffer$[rsp]
	call	AuPmmngrFree

; 575  : 		kfree(fs);

	mov	rcx, QWORD PTR fs$[rsp]
	call	kfree

; 576  : 		return NULL;

	xor	eax, eax
	jmp	$LN10@FatInitial
$LN1@FatInitial:

; 577  : 	}
; 578  : 
; 579  : 	AuVFSNode* fsys = (AuVFSNode*)kmalloc(sizeof(AuVFSNode));

	mov	ecx, 192				; 000000c0H
	call	kmalloc
	mov	QWORD PTR fsys$[rsp], rax

; 580  : 	memset(fsys, 0, sizeof(AuVFSNode));

	mov	r8d, 192				; 000000c0H
	xor	edx, edx
	mov	rcx, QWORD PTR fsys$[rsp]
	call	memset

; 581  : 	strcpy(fsys->filename, mountname);

	mov	rax, QWORD PTR fsys$[rsp]
	mov	rdx, QWORD PTR mountname$[rsp]
	mov	rcx, rax
	call	strcpy

; 582  : 	fsys->flags |= FS_FLAG_FILE_SYSTEM;

	mov	rax, QWORD PTR fsys$[rsp]
	movzx	eax, WORD PTR [rax+64]
	or	eax, 64					; 00000040H
	mov	rcx, QWORD PTR fsys$[rsp]
	mov	WORD PTR [rcx+64], ax

; 583  : 	fsys->open = FatOpen;

	mov	rax, QWORD PTR fsys$[rsp]
	lea	rcx, OFFSET FLAT:?FatOpen@@YAPEAU__VFS_NODE__@@PEAU1@PEAD@Z ; FatOpen
	mov	QWORD PTR [rax+88], rcx

; 584  : 	fsys->device = fs;

	mov	rax, QWORD PTR fsys$[rsp]
	mov	rcx, QWORD PTR fs$[rsp]
	mov	QWORD PTR [rax+72], rcx

; 585  : 	fsys->read = FatReadFile;

	mov	rax, QWORD PTR fsys$[rsp]
	lea	rcx, OFFSET FLAT:?FatReadFile@@YA_KPEAU__VFS_NODE__@@0PEA_KI@Z ; FatReadFile
	mov	QWORD PTR [rax+104], rcx

; 586  : 	fsys->read_block = FatRead;

	mov	rax, QWORD PTR fsys$[rsp]
	lea	rcx, OFFSET FLAT:?FatRead@@YA_KPEAU__VFS_NODE__@@0PEA_K@Z ; FatRead
	mov	QWORD PTR [rax+160], rcx

; 587  : 	fsys->remove_dir = FatRemoveDir;

	mov	rax, QWORD PTR fsys$[rsp]
	lea	rcx, OFFSET FLAT:?FatRemoveDir@@YAHPEAU__VFS_NODE__@@0@Z ; FatRemoveDir
	mov	QWORD PTR [rax+136], rcx

; 588  : 	fsys->remove_file = FatFileRemove;

	mov	rax, QWORD PTR fsys$[rsp]
	lea	rcx, OFFSET FLAT:?FatFileRemove@@YAHPEAU__VFS_NODE__@@0@Z ; FatFileRemove
	mov	QWORD PTR [rax+144], rcx

; 589  : 	fsys->write = FatWrite;

	mov	rax, QWORD PTR fsys$[rsp]
	lea	rcx, OFFSET FLAT:?FatWrite@@YA_KPEAU__VFS_NODE__@@0PEA_KI@Z ; FatWrite
	mov	QWORD PTR [rax+112], rcx

; 590  : 	fsys->create_dir = FatCreateDir;

	mov	rax, QWORD PTR fsys$[rsp]
	lea	rcx, OFFSET FLAT:?FatCreateDir@@YAPEAU__VFS_NODE__@@PEAU1@PEAD@Z ; FatCreateDir
	mov	QWORD PTR [rax+120], rcx

; 591  : 	fsys->create_file = FatCreateFile;

	mov	rax, QWORD PTR fsys$[rsp]
	lea	rcx, OFFSET FLAT:?FatCreateFile@@YAPEAU__VFS_NODE__@@PEAU1@PEAD@Z ; FatCreateFile
	mov	QWORD PTR [rax+128], rcx

; 592  : 	fsys->get_blockfor = FatGetClusterFor;

	mov	rax, QWORD PTR fsys$[rsp]
	lea	rcx, OFFSET FLAT:?FatGetClusterFor@@YA_KPEAU__VFS_NODE__@@0_K@Z ; FatGetClusterFor
	mov	QWORD PTR [rax+176], rcx

; 593  : 	fsys->opendir = FatOpenDir;

	mov	rax, QWORD PTR fsys$[rsp]
	lea	rcx, OFFSET FLAT:?FatOpenDir@@YAPEAU__VFS_NODE__@@PEAU1@PEAD@Z ; FatOpenDir
	mov	QWORD PTR [rax+96], rcx

; 594  : 	fsys->read_dir = FatDirectoryRead;

	mov	rax, QWORD PTR fsys$[rsp]
	lea	rcx, OFFSET FLAT:?FatDirectoryRead@@YAHPEAU__VFS_NODE__@@0PEAU_AuDirectoryEnty_@@@Z ; FatDirectoryRead
	mov	QWORD PTR [rax+168], rcx

; 595  : 	AuVFSAddFileSystem(fsys);

	mov	rcx, QWORD PTR fsys$[rsp]
	call	AuVFSAddFileSystem

; 596  : 	AuVFSRegisterRoot(fsys);

	mov	rcx, QWORD PTR fsys$[rsp]
	call	AuVFSRegisterRoot

; 597  : 
; 598  : 	AuPmmngrFree(buffer);

	mov	rcx, QWORD PTR buffer$[rsp]
	call	AuPmmngrFree

; 599  : 
; 600  : 	return fsys;

	mov	rax, QWORD PTR fsys$[rsp]
$LN10@FatInitial:

; 601  : }

	add	rsp, 136				; 00000088H
	ret	0
?FatInitialise@@YAPEAU__VFS_NODE__@@PEAU_VDISK_@@PEAD@Z ENDP ; FatInitialise
_TEXT	ENDS
END
