; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30154.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

msvcjmc	SEGMENT
__7C2BBDAD_Fat@cpp DB 01H
msvcjmc	ENDS
PUBLIC	?FatInitialise@@YAPEAU__VFS_NODE__@@PEAU_VDISK_@@PEAD@Z ; FatInitialise
PUBLIC	?FatClusterToSector32@@YA_KPEAU_FatFS_@@_K@Z	; FatClusterToSector32
PUBLIC	?FatToDOSFilename@@YAXPEBDPEADI@Z		; FatToDOSFilename
PUBLIC	?FatFindFreeCluster@@YAIPEAU__VFS_NODE__@@@Z	; FatFindFreeCluster
PUBLIC	?FatAllocCluster@@YAXPEAU__VFS_NODE__@@HI@Z	; FatAllocCluster
PUBLIC	?FatClearCluster@@YAXPEAU__VFS_NODE__@@I@Z	; FatClearCluster
PUBLIC	?FatReadFAT@@YAIPEAU__VFS_NODE__@@_K@Z		; FatReadFAT
PUBLIC	?FatOpen@@YAPEAU__VFS_NODE__@@PEAU1@PEAD@Z	; FatOpen
PUBLIC	?FatFormatDate@@YAGXZ				; FatFormatDate
PUBLIC	?FatFormatTime@@YAGXZ				; FatFormatTime
PUBLIC	?FatLocateDir@@YAPEAU__VFS_NODE__@@PEAU1@PEBD@Z	; FatLocateDir
PUBLIC	?FatLocateSubDir@@YAPEAU__VFS_NODE__@@PEAU1@0PEBD@Z ; FatLocateSubDir
PUBLIC	?FatFromDosToFilename@@YAXPEAD0@Z		; FatFromDosToFilename
PUBLIC	?FatCalculateCheckSum@@YAEPEAE@Z		; FatCalculateCheckSum
PUBLIC	?FatRead@@YA_KPEAU__VFS_NODE__@@0PEA_K@Z	; FatRead
PUBLIC	?FatReadFile@@YA_KPEAU__VFS_NODE__@@0PEA_KI@Z	; FatReadFile
PUBLIC	?FatGetClusterFor@@YA_KPEAU__VFS_NODE__@@0_K@Z	; FatGetClusterFor
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_02HAOIJKIC@?$CFc@				; `string'
EXTRN	AuVFSAddFileSystem:PROC
EXTRN	AuVFSRegisterRoot:PROC
EXTRN	AuVDiskRead:PROC
EXTRN	AuVDiskWrite:PROC
EXTRN	AuCreateMutex:PROC
EXTRN	?FatCreateFile@@YAPEAU__VFS_NODE__@@PEAU1@PEAD@Z:PROC ; FatCreateFile
EXTRN	?FatWrite@@YA_KPEAU__VFS_NODE__@@0PEA_KI@Z:PROC	; FatWrite
EXTRN	?FatFileRemove@@YAHPEAU__VFS_NODE__@@0@Z:PROC	; FatFileRemove
EXTRN	?FatCreateDir@@YAPEAU__VFS_NODE__@@PEAU1@PEAD@Z:PROC ; FatCreateDir
EXTRN	?FatRemoveDir@@YAHPEAU__VFS_NODE__@@0@Z:PROC	; FatRemoveDir
EXTRN	?FatOpenDir@@YAPEAU__VFS_NODE__@@PEAU1@PEAD@Z:PROC ; FatOpenDir
EXTRN	?FatDirectoryRead@@YAHPEAU__VFS_NODE__@@0PEAU_AuDirectoryEnty_@@@Z:PROC ; FatDirectoryRead
EXTRN	AuPmmngrAlloc:PROC
EXTRN	AuPmmngrFree:PROC
EXTRN	P2V:PROC
EXTRN	V2P:PROC
EXTRN	strcmp:PROC
EXTRN	strcpy:PROC
EXTRN	strlen:PROC
EXTRN	strchr:PROC
EXTRN	memset:PROC
EXTRN	memcpy:PROC
EXTRN	AuTextOut:PROC
EXTRN	toupper:PROC
EXTRN	kmalloc:PROC
EXTRN	kfree:PROC
EXTRN	AuRTCGetYear:PROC
EXTRN	AuRTCGetMinutes:PROC
EXTRN	AuRTCGetSecond:PROC
EXTRN	AuRTCGetDay:PROC
EXTRN	AuRTCGetHour:PROC
EXTRN	AuRTCGetMonth:PROC
EXTRN	__CheckForDebuggerJustMyCode:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$?FatInitialise@@YAPEAU__VFS_NODE__@@PEAU_VDISK_@@PEAD@Z DD imagerel $LN16
	DD	imagerel $LN16+1088
	DD	imagerel $unwind$?FatInitialise@@YAPEAU__VFS_NODE__@@PEAU_VDISK_@@PEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?FatClusterToSector32@@YA_KPEAU_FatFS_@@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$?FatClusterToSector32@@YA_KPEAU_FatFS_@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?FatToDOSFilename@@YAXPEBDPEADI@Z DD imagerel $LN19
	DD	imagerel $LN19+354
	DD	imagerel $unwind$?FatToDOSFilename@@YAXPEBDPEADI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?FatFindFreeCluster@@YAIPEAU__VFS_NODE__@@@Z DD imagerel $LN8
	DD	imagerel $LN8+332
	DD	imagerel $unwind$?FatFindFreeCluster@@YAIPEAU__VFS_NODE__@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?FatAllocCluster@@YAXPEAU__VFS_NODE__@@HI@Z DD imagerel $LN4
	DD	imagerel $LN4+368
	DD	imagerel $unwind$?FatAllocCluster@@YAXPEAU__VFS_NODE__@@HI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?FatClearCluster@@YAXPEAU__VFS_NODE__@@I@Z DD imagerel $LN4
	DD	imagerel $LN4+176
	DD	imagerel $unwind$?FatClearCluster@@YAXPEAU__VFS_NODE__@@I@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?FatReadFAT@@YAIPEAU__VFS_NODE__@@_K@Z DD imagerel $LN4
	DD	imagerel $LN4+303
	DD	imagerel $unwind$?FatReadFAT@@YAIPEAU__VFS_NODE__@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?FatOpen@@YAPEAU__VFS_NODE__@@PEAU1@PEAD@Z DD imagerel $LN18
	DD	imagerel $LN18+437
	DD	imagerel $unwind$?FatOpen@@YAPEAU__VFS_NODE__@@PEAU1@PEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?FatFormatDate@@YAGXZ DD imagerel $LN3
	DD	imagerel $LN3+82
	DD	imagerel $unwind$?FatFormatDate@@YAGXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?FatFormatTime@@YAGXZ DD imagerel $LN3
	DD	imagerel $LN3+84
	DD	imagerel $unwind$?FatFormatTime@@YAGXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?FatLocateDir@@YAPEAU__VFS_NODE__@@PEAU1@PEBD@Z DD imagerel $LN13
	DD	imagerel $LN13+661
	DD	imagerel $unwind$?FatLocateDir@@YAPEAU__VFS_NODE__@@PEAU1@PEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?FatLocateSubDir@@YAPEAU__VFS_NODE__@@PEAU1@0PEBD@Z DD imagerel $LN14
	DD	imagerel $LN14+652
	DD	imagerel $unwind$?FatLocateSubDir@@YAPEAU__VFS_NODE__@@PEAU1@0PEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?FatFromDosToFilename@@YAXPEAD0@Z DD imagerel $LN12
	DD	imagerel $LN12+293
	DD	imagerel $unwind$?FatFromDosToFilename@@YAXPEAD0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?FatCalculateCheckSum@@YAEPEAE@Z DD imagerel $LN8
	DD	imagerel $LN8+136
	DD	imagerel $unwind$?FatCalculateCheckSum@@YAEPEAE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?FatRead@@YA_KPEAU__VFS_NODE__@@0PEA_K@Z DD imagerel $LN6
	DD	imagerel $LN6+287
	DD	imagerel $unwind$?FatRead@@YA_KPEAU__VFS_NODE__@@0PEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?FatReadFile@@YA_KPEAU__VFS_NODE__@@0PEA_KI@Z DD imagerel $LN11
	DD	imagerel $LN11+394
	DD	imagerel $unwind$?FatReadFile@@YA_KPEAU__VFS_NODE__@@0PEA_KI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?FatGetClusterFor@@YA_KPEAU__VFS_NODE__@@0_K@Z DD imagerel $LN6
	DD	imagerel $LN6+138
	DD	imagerel $unwind$?FatGetClusterFor@@YA_KPEAU__VFS_NODE__@@0_K@Z
pdata	ENDS
;	COMDAT ??_C@_02HAOIJKIC@?$CFc@
CONST	SEGMENT
??_C@_02HAOIJKIC@?$CFc@ DB '%c', 00H			; `string'
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?FatGetClusterFor@@YA_KPEAU__VFS_NODE__@@0_K@Z DD 025031c01H
	DD	0f217231cH
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?FatReadFile@@YA_KPEAU__VFS_NODE__@@0PEA_KI@Z DD 025042101H
	DD	011c2321H
	DD	050150014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?FatRead@@YA_KPEAU__VFS_NODE__@@0PEA_K@Z DD 025031c01H
	DD	0f217231cH
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?FatCalculateCheckSum@@YAEPEAE@Z DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?FatFromDosToFilename@@YAXPEAD0@Z DD 025031701H
	DD	0f2122317H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?FatLocateSubDir@@YAPEAU__VFS_NODE__@@PEAU1@0PEBD@Z DD 025041c01H
	DD	0117231cH
	DD	050100016H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?FatLocateDir@@YAPEAU__VFS_NODE__@@PEAU1@PEBD@Z DD 025041701H
	DD	01122317H
	DD	0500b0018H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?FatFormatTime@@YAGXZ DD 025030b01H
	DD	0d206230bH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?FatFormatDate@@YAGXZ DD 025030b01H
	DD	0d206230bH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?FatOpen@@YAPEAU__VFS_NODE__@@PEAU1@PEAD@Z DD 025041701H
	DD	01122317H
	DD	0500b0016H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?FatReadFAT@@YAIPEAU__VFS_NODE__@@_K@Z DD 025041701H
	DD	01122317H
	DD	0500b0016H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?FatClearCluster@@YAXPEAU__VFS_NODE__@@I@Z DD 025031601H
	DD	0f2112316H
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?FatAllocCluster@@YAXPEAU__VFS_NODE__@@HI@Z DD 025041b01H
	DD	0116231bH
	DD	0500f0016H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?FatFindFreeCluster@@YAIPEAU__VFS_NODE__@@@Z DD 025041201H
	DD	010d2312H
	DD	050060016H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?FatToDOSFilename@@YAXPEBDPEADI@Z DD 025031901H
	DD	0d2142319H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?FatClusterToSector32@@YA_KPEAU_FatFS_@@_K@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?FatInitialise@@YAPEAU__VFS_NODE__@@PEAU_VDISK_@@PEAD@Z DD 025041701H
	DD	01122317H
	DD	0500b0016H
xdata	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Fs\Fat\Fat.cpp
;	COMDAT ?FatGetClusterFor@@YA_KPEAU__VFS_NODE__@@0_K@Z
_TEXT	SEGMENT
fatfs$ = 0
index$ = 8
cluster$ = 16
i$1 = 20
fs$ = 112
file$ = 120
offset$ = 128
?FatGetClusterFor@@YA_KPEAU__VFS_NODE__@@0_K@Z PROC	; FatGetClusterFor, COMDAT

; 527  : size_t FatGetClusterFor(AuVFSNode* fs,AuVFSNode* file, uint64_t offset){

$LN6:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 128				; 00000080H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__7C2BBDAD_Fat@cpp
	call	__CheckForDebuggerJustMyCode

; 528  : 	FatFS *fatfs = (FatFS*)fs->device;

	mov	rax, QWORD PTR fs$[rbp]
	mov	rax, QWORD PTR [rax+64]
	mov	QWORD PTR fatfs$[rbp], rax

; 529  : 	size_t index = offset / fatfs->cluster_sz_in_bytes;

	xor	edx, edx
	mov	rax, QWORD PTR offset$[rbp]
	mov	rcx, QWORD PTR fatfs$[rbp]
	div	QWORD PTR [rcx+72]
	mov	QWORD PTR index$[rbp], rax

; 530  : 	uint32_t cluster = file->first_block;

	mov	rax, QWORD PTR file$[rbp]
	mov	eax, DWORD PTR [rax+45]
	mov	DWORD PTR cluster$[rbp], eax

; 531  : 	for (int i = 0; i < index; i++) 

	mov	DWORD PTR i$1[rbp], 0
	jmp	SHORT $LN4@FatGetClus
$LN2@FatGetClus:
	mov	eax, DWORD PTR i$1[rbp]
	inc	eax
	mov	DWORD PTR i$1[rbp], eax
$LN4@FatGetClus:
	movsxd	rax, DWORD PTR i$1[rbp]
	cmp	rax, QWORD PTR index$[rbp]
	jae	SHORT $LN3@FatGetClus

; 532  : 		cluster = FatReadFAT(fs, cluster);

	mov	eax, DWORD PTR cluster$[rbp]
	mov	edx, eax
	mov	rcx, QWORD PTR fs$[rbp]
	call	?FatReadFAT@@YAIPEAU__VFS_NODE__@@_K@Z	; FatReadFAT
	mov	DWORD PTR cluster$[rbp], eax
	jmp	SHORT $LN2@FatGetClus
$LN3@FatGetClus:

; 533  : 	return cluster;

	mov	eax, DWORD PTR cluster$[rbp]

; 534  : }

	lea	rsp, QWORD PTR [rbp+96]
	pop	rbp
	ret	0
?FatGetClusterFor@@YA_KPEAU__VFS_NODE__@@0_K@Z ENDP	; FatGetClusterFor
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Fs\Fat\Fat.cpp
;	COMDAT ?FatReadFile@@YA_KPEAU__VFS_NODE__@@0PEA_KI@Z
_TEXT	SEGMENT
fs$ = 0
read_bytes$ = 8
ret_bytes$ = 16
aligned_buffer$ = 24
num_blocks$ = 32
i$1 = 40
buff$2 = 48
tv74 = 120
fsys$ = 144
file$ = 152
buffer$ = 160
length$ = 168
?FatReadFile@@YA_KPEAU__VFS_NODE__@@0PEA_KI@Z PROC	; FatReadFile, COMDAT

; 294  : size_t FatReadFile(AuVFSNode* fsys, AuVFSNode* file, uint64_t* buffer, uint32_t length) {

$LN11:
	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 160				; 000000a0H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__7C2BBDAD_Fat@cpp
	call	__CheckForDebuggerJustMyCode

; 295  : 	if (!fsys)

	cmp	QWORD PTR fsys$[rbp], 0
	jne	SHORT $LN5@FatReadFil

; 296  : 		return 0;

	xor	eax, eax
	jmp	$LN1@FatReadFil
$LN5@FatReadFil:

; 297  : 
; 298  : 	if (!file)

	cmp	QWORD PTR file$[rbp], 0
	jne	SHORT $LN6@FatReadFil

; 299  : 		return 0;

	xor	eax, eax
	jmp	$LN1@FatReadFil
$LN6@FatReadFil:

; 300  : 
; 301  : 	FatFS* fs = (FatFS*)fsys->device;

	mov	rax, QWORD PTR fsys$[rbp]
	mov	rax, QWORD PTR [rax+64]
	mov	QWORD PTR fs$[rbp], rax

; 302  : 
; 303  : 	uint64_t read_bytes = 0;

	mov	QWORD PTR read_bytes$[rbp], 0

; 304  : 	size_t ret_bytes = 0;

	mov	QWORD PTR ret_bytes$[rbp], 0

; 305  : 	uint8_t* aligned_buffer = (uint8_t*)buffer;

	mov	rax, QWORD PTR buffer$[rbp]
	mov	QWORD PTR aligned_buffer$[rbp], rax

; 306  : 
; 307  : 	size_t num_blocks = length / fs->cluster_sz_in_bytes +

	mov	eax, DWORD PTR length$[rbp]
	xor	edx, edx
	mov	rcx, QWORD PTR fs$[rbp]
	div	QWORD PTR [rcx+72]
	mov	rax, rdx
	test	rax, rax
	je	SHORT $LN9@FatReadFil
	mov	DWORD PTR tv74[rbp], 1
	jmp	SHORT $LN10@FatReadFil
$LN9@FatReadFil:
	mov	DWORD PTR tv74[rbp], 0
$LN10@FatReadFil:
	mov	eax, DWORD PTR length$[rbp]
	xor	edx, edx
	mov	rcx, QWORD PTR fs$[rbp]
	div	QWORD PTR [rcx+72]
	movsxd	rcx, DWORD PTR tv74[rbp]
	add	rax, rcx
	mov	QWORD PTR num_blocks$[rbp], rax

; 308  : 		((length % fs->cluster_sz_in_bytes) ? 1 : 0);
; 309  : 
; 310  : 
; 311  : 	for (int i = 0; i < num_blocks; i++) {

	mov	DWORD PTR i$1[rbp], 0
	jmp	SHORT $LN4@FatReadFil
$LN2@FatReadFil:
	mov	eax, DWORD PTR i$1[rbp]
	inc	eax
	mov	DWORD PTR i$1[rbp], eax
$LN4@FatReadFil:
	movsxd	rax, DWORD PTR i$1[rbp]
	cmp	rax, QWORD PTR num_blocks$[rbp]
	jae	$LN3@FatReadFil

; 312  : 		if (file->eof)

	mov	rax, QWORD PTR file$[rbp]
	movzx	eax, BYTE PTR [rax+36]
	test	eax, eax
	je	SHORT $LN7@FatReadFil

; 313  : 			break;

	jmp	$LN3@FatReadFil
$LN7@FatReadFil:

; 314  : 		uint64_t* buff = (uint64_t*)P2V((size_t)AuPmmngrAlloc());

	call	AuPmmngrAlloc
	mov	rcx, rax
	call	P2V
	mov	QWORD PTR buff$2[rbp], rax

; 315  : 		memset(buff, 0, PAGE_SIZE);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR buff$2[rbp]
	call	memset

; 316  : 		read_bytes = FatRead(fsys, file, (uint64_t*)V2P((size_t)buff));

	mov	rcx, QWORD PTR buff$2[rbp]
	call	V2P
	mov	r8, rax
	mov	rdx, QWORD PTR file$[rbp]
	mov	rcx, QWORD PTR fsys$[rbp]
	call	?FatRead@@YA_KPEAU__VFS_NODE__@@0PEA_K@Z ; FatRead
	mov	QWORD PTR read_bytes$[rbp], rax

; 317  : 		memcpy(aligned_buffer, buff, PAGE_SIZE);

	mov	r8d, 4096				; 00001000H
	mov	rdx, QWORD PTR buff$2[rbp]
	mov	rcx, QWORD PTR aligned_buffer$[rbp]
	call	memcpy

; 318  : 		AuPmmngrFree((void*)V2P((size_t)buff));

	mov	rcx, QWORD PTR buff$2[rbp]
	call	V2P
	mov	rcx, rax
	call	AuPmmngrFree

; 319  : 		aligned_buffer += PAGE_SIZE;

	mov	rax, QWORD PTR aligned_buffer$[rbp]
	add	rax, 4096				; 00001000H
	mov	QWORD PTR aligned_buffer$[rbp], rax

; 320  : 		ret_bytes += read_bytes;

	mov	rax, QWORD PTR read_bytes$[rbp]
	mov	rcx, QWORD PTR ret_bytes$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR ret_bytes$[rbp], rax

; 321  : 		
; 322  : 	}

	jmp	$LN2@FatReadFil
$LN3@FatReadFil:

; 323  : 
; 324  : 	return ret_bytes;

	mov	rax, QWORD PTR ret_bytes$[rbp]
$LN1@FatReadFil:

; 325  : }

	lea	rsp, QWORD PTR [rbp+128]
	pop	rbp
	ret	0
?FatReadFile@@YA_KPEAU__VFS_NODE__@@0PEA_KI@Z ENDP	; FatReadFile
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Fs\Fat\Fat.cpp
;	COMDAT ?FatRead@@YA_KPEAU__VFS_NODE__@@0PEA_K@Z
_TEXT	SEGMENT
fs$ = 0
vdisk$ = 8
lba$ = 16
value$ = 24
fsys$ = 112
file$ = 120
buf$ = 128
?FatRead@@YA_KPEAU__VFS_NODE__@@0PEA_K@Z PROC		; FatRead, COMDAT

; 259  : size_t FatRead(AuVFSNode* fsys, AuVFSNode *file, uint64_t* buf) {

$LN6:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 128				; 00000080H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__7C2BBDAD_Fat@cpp
	call	__CheckForDebuggerJustMyCode

; 260  : 	FatFS* fs = (FatFS*)fsys->device;

	mov	rax, QWORD PTR fsys$[rbp]
	mov	rax, QWORD PTR [rax+64]
	mov	QWORD PTR fs$[rbp], rax

; 261  : 	AuVDisk* vdisk = (AuVDisk*)fs->vdisk;

	mov	rax, QWORD PTR fs$[rbp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR vdisk$[rbp], rax

; 262  : 	if (!vdisk) {

	cmp	QWORD PTR vdisk$[rbp], 0
	jne	SHORT $LN2@FatRead

; 263  : 		return NULL;

	xor	eax, eax
	jmp	$LN1@FatRead
$LN2@FatRead:

; 264  : 	}
; 265  : 
; 266  : 	auto lba = FatClusterToSector32(fs, file->current);

	mov	rax, QWORD PTR file$[rbp]
	mov	rdx, QWORD PTR [rax+53]
	mov	rcx, QWORD PTR fs$[rbp]
	call	?FatClusterToSector32@@YA_KPEAU_FatFS_@@_K@Z ; FatClusterToSector32
	mov	QWORD PTR lba$[rbp], rax

; 267  : 	AuVDiskRead(vdisk, lba, fs->__SectorPerCluster, buf);

	mov	rax, QWORD PTR fs$[rbp]
	movzx	eax, BYTE PTR [rax+36]
	mov	r9, QWORD PTR buf$[rbp]
	mov	r8d, eax
	mov	rdx, QWORD PTR lba$[rbp]
	mov	rcx, QWORD PTR vdisk$[rbp]
	call	AuVDiskRead

; 268  : 
; 269  : 	uint32_t value = FatReadFAT(fsys,file->current);

	mov	rax, QWORD PTR file$[rbp]
	mov	rdx, QWORD PTR [rax+53]
	mov	rcx, QWORD PTR fsys$[rbp]
	call	?FatReadFAT@@YAIPEAU__VFS_NODE__@@_K@Z	; FatReadFAT
	mov	DWORD PTR value$[rbp], eax

; 270  : 	
; 271  : 	if (value >= (FAT_EOC_MARK & 0x0FFFFFFF)) {

	cmp	DWORD PTR value$[rbp], 268435448	; 0ffffff8H
	jb	SHORT $LN3@FatRead

; 272  : 		file->eof = 1;

	mov	rax, QWORD PTR file$[rbp]
	mov	BYTE PTR [rax+36], 1

; 273  : 		file->current = value;

	mov	eax, DWORD PTR value$[rbp]
	mov	rcx, QWORD PTR file$[rbp]
	mov	QWORD PTR [rcx+53], rax

; 274  : 		return static_cast<int64_t>(fs->__SectorPerCluster) * fs->__BytesPerSector;

	mov	rax, QWORD PTR fs$[rbp]
	movzx	eax, BYTE PTR [rax+36]
	mov	rcx, QWORD PTR fs$[rbp]
	movzx	ecx, WORD PTR [rcx+64]
	imul	rax, rcx
	jmp	SHORT $LN1@FatRead
$LN3@FatRead:

; 275  : 	}
; 276  : 
; 277  : 	if (value >= 0x0FFFFFF7) {

	cmp	DWORD PTR value$[rbp], 268435447	; 0ffffff7H
	jb	SHORT $LN4@FatRead

; 278  : 		file->eof = 1;

	mov	rax, QWORD PTR file$[rbp]
	mov	BYTE PTR [rax+36], 1

; 279  : 		file->current = value;

	mov	eax, DWORD PTR value$[rbp]
	mov	rcx, QWORD PTR file$[rbp]
	mov	QWORD PTR [rcx+53], rax

; 280  : 		return static_cast<int64_t>(fs->__SectorPerCluster) * fs->__BytesPerSector;

	mov	rax, QWORD PTR fs$[rbp]
	movzx	eax, BYTE PTR [rax+36]
	mov	rcx, QWORD PTR fs$[rbp]
	movzx	ecx, WORD PTR [rcx+64]
	imul	rax, rcx
	jmp	SHORT $LN1@FatRead
$LN4@FatRead:

; 281  : 	}
; 282  : 
; 283  : 	file->current = value;

	mov	eax, DWORD PTR value$[rbp]
	mov	rcx, QWORD PTR file$[rbp]
	mov	QWORD PTR [rcx+53], rax

; 284  : 	return static_cast<int64_t>(fs->__SectorPerCluster) * fs->__BytesPerSector;

	mov	rax, QWORD PTR fs$[rbp]
	movzx	eax, BYTE PTR [rax+36]
	mov	rcx, QWORD PTR fs$[rbp]
	movzx	ecx, WORD PTR [rcx+64]
	imul	rax, rcx
$LN1@FatRead:

; 285  : }

	lea	rsp, QWORD PTR [rbp+96]
	pop	rbp
	ret	0
?FatRead@@YA_KPEAU__VFS_NODE__@@0PEA_K@Z ENDP		; FatRead
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Fs\Fat\Fat.cpp
;	COMDAT ?FatCalculateCheckSum@@YAEPEAE@Z
_TEXT	SEGMENT
fnameLen$ = 0
sum$ = 4
tv70 = 72
fname$ = 96
?FatCalculateCheckSum@@YAEPEAE@Z PROC			; FatCalculateCheckSum, COMDAT

; 223  : uint8_t FatCalculateCheckSum(uint8_t* fname) {

$LN8:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__7C2BBDAD_Fat@cpp
	call	__CheckForDebuggerJustMyCode

; 224  : 	short fnameLen;
; 225  : 	uint8_t sum = 0;

	mov	BYTE PTR sum$[rbp], 0

; 226  : 
; 227  : 	for (fnameLen = 11; fnameLen != 0; fnameLen--){

	mov	eax, 11
	mov	WORD PTR fnameLen$[rbp], ax
	jmp	SHORT $LN4@FatCalcula
$LN2@FatCalcula:
	movzx	eax, WORD PTR fnameLen$[rbp]
	dec	ax
	mov	WORD PTR fnameLen$[rbp], ax
$LN4@FatCalcula:
	movsx	eax, WORD PTR fnameLen$[rbp]
	test	eax, eax
	je	SHORT $LN3@FatCalcula

; 228  : 		sum = ((sum & 1) ? 0x80 : 0) + (sum >> 1) + *fname++;

	movzx	eax, BYTE PTR sum$[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN6@FatCalcula
	mov	DWORD PTR tv70[rbp], 128		; 00000080H
	jmp	SHORT $LN7@FatCalcula
$LN6@FatCalcula:
	mov	DWORD PTR tv70[rbp], 0
$LN7@FatCalcula:
	movzx	eax, BYTE PTR sum$[rbp]
	sar	eax, 1
	mov	ecx, DWORD PTR tv70[rbp]
	add	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR fname$[rbp]
	movzx	ecx, BYTE PTR [rcx]
	add	eax, ecx
	mov	BYTE PTR sum$[rbp], al
	mov	rax, QWORD PTR fname$[rbp]
	inc	rax
	mov	QWORD PTR fname$[rbp], rax

; 229  : 	}

	jmp	SHORT $LN2@FatCalcula
$LN3@FatCalcula:

; 230  : 
; 231  : 	return sum;

	movzx	eax, BYTE PTR sum$[rbp]

; 232  : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
?FatCalculateCheckSum@@YAEPEAE@Z ENDP			; FatCalculateCheckSum
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Fs\Fat\Fat.cpp
;	COMDAT ?FatFromDosToFilename@@YAXPEAD0@Z
_TEXT	SEGMENT
index$ = 0
i$1 = 4
extension$ = 8
_contain_ext$ = 12
i$2 = 16
filename$ = 112
dirfname$ = 120
?FatFromDosToFilename@@YAXPEAD0@Z PROC			; FatFromDosToFilename, COMDAT

; 111  : void FatFromDosToFilename(char* filename, char* dirfname) {

$LN12:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 128				; 00000080H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__7C2BBDAD_Fat@cpp
	call	__CheckForDebuggerJustMyCode

; 112  : 	memset(filename, 0, 11);

	mov	r8d, 11
	xor	edx, edx
	mov	rcx, QWORD PTR filename$[rbp]
	call	memset

; 113  : 	int index = 0;

	mov	DWORD PTR index$[rbp], 0

; 114  : 	for (int i = 0; i < 8; i++) {

	mov	DWORD PTR i$1[rbp], 0
	jmp	SHORT $LN4@FatFromDos
$LN2@FatFromDos:
	mov	eax, DWORD PTR i$1[rbp]
	inc	eax
	mov	DWORD PTR i$1[rbp], eax
$LN4@FatFromDos:
	cmp	DWORD PTR i$1[rbp], 8
	jge	SHORT $LN3@FatFromDos

; 115  : 		if (dirfname[i] != 0x20 && dirfname[i] > 0x20) {

	movsxd	rax, DWORD PTR i$1[rbp]
	mov	rcx, QWORD PTR dirfname$[rbp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 32					; 00000020H
	je	SHORT $LN8@FatFromDos
	movsxd	rax, DWORD PTR i$1[rbp]
	mov	rcx, QWORD PTR dirfname$[rbp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 32					; 00000020H
	jle	SHORT $LN8@FatFromDos

; 116  : 			filename[i] = dirfname[i];

	movsxd	rax, DWORD PTR i$1[rbp]
	movsxd	rcx, DWORD PTR i$1[rbp]
	mov	rdx, QWORD PTR filename$[rbp]
	mov	r8, QWORD PTR dirfname$[rbp]
	movzx	eax, BYTE PTR [r8+rax]
	mov	BYTE PTR [rdx+rcx], al

; 117  : 			index++;

	mov	eax, DWORD PTR index$[rbp]
	inc	eax
	mov	DWORD PTR index$[rbp], eax
$LN8@FatFromDos:

; 118  : 		}
; 119  : 	}

	jmp	SHORT $LN2@FatFromDos
$LN3@FatFromDos:

; 120  : 	int extension = index;

	mov	eax, DWORD PTR index$[rbp]
	mov	DWORD PTR extension$[rbp], eax

; 121  : 	filename[index] = '.';

	movsxd	rax, DWORD PTR index$[rbp]
	mov	rcx, QWORD PTR filename$[rbp]
	mov	BYTE PTR [rcx+rax], 46			; 0000002eH

; 122  : 	index++;

	mov	eax, DWORD PTR index$[rbp]
	inc	eax
	mov	DWORD PTR index$[rbp], eax

; 123  : 	bool _contain_ext = false;

	mov	BYTE PTR _contain_ext$[rbp], 0

; 124  : 	for (int i = 0; i < 3; i++) {

	mov	DWORD PTR i$2[rbp], 0
	jmp	SHORT $LN7@FatFromDos
$LN5@FatFromDos:
	mov	eax, DWORD PTR i$2[rbp]
	inc	eax
	mov	DWORD PTR i$2[rbp], eax
$LN7@FatFromDos:
	cmp	DWORD PTR i$2[rbp], 3
	jge	SHORT $LN6@FatFromDos

; 125  : 		if (dirfname[8 + i] != 0x20) {

	mov	eax, DWORD PTR i$2[rbp]
	add	eax, 8
	cdqe
	mov	rcx, QWORD PTR dirfname$[rbp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 32					; 00000020H
	je	SHORT $LN9@FatFromDos

; 126  : 			_contain_ext = true;

	mov	BYTE PTR _contain_ext$[rbp], 1

; 127  : 			filename[index + i] = dirfname[8 + i];

	mov	eax, DWORD PTR i$2[rbp]
	add	eax, 8
	cdqe
	mov	ecx, DWORD PTR i$2[rbp]
	mov	edx, DWORD PTR index$[rbp]
	add	edx, ecx
	mov	ecx, edx
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR filename$[rbp]
	mov	r8, QWORD PTR dirfname$[rbp]
	movzx	eax, BYTE PTR [r8+rax]
	mov	BYTE PTR [rdx+rcx], al
$LN9@FatFromDos:

; 128  : 		}
; 129  : 	}

	jmp	SHORT $LN5@FatFromDos
$LN6@FatFromDos:

; 130  : 	if (!_contain_ext)

	movzx	eax, BYTE PTR _contain_ext$[rbp]
	test	eax, eax
	jne	SHORT $LN10@FatFromDos

; 131  : 		filename[extension] = '\0';

	movsxd	rax, DWORD PTR extension$[rbp]
	mov	rcx, QWORD PTR filename$[rbp]
	mov	BYTE PTR [rcx+rax], 0
$LN10@FatFromDos:

; 132  : }

	lea	rsp, QWORD PTR [rbp+96]
	pop	rbp
	ret	0
?FatFromDosToFilename@@YAXPEAD0@Z ENDP			; FatFromDosToFilename
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Fs\Fat\Fat.cpp
;	COMDAT ?FatLocateSubDir@@YAPEAU__VFS_NODE__@@PEAU1@0PEBD@Z
_TEXT	SEGMENT
_fs$ = 0
file$ = 8
dos_file_name$ = 16
buf$ = 32
pkDir$1 = 40
i$2 = 48
name$3 = 56
fsys$ = 160
kfile$ = 168
filename$ = 176
?FatLocateSubDir@@YAPEAU__VFS_NODE__@@PEAU1@0PEBD@Z PROC ; FatLocateSubDir, COMDAT

; 327  : AuVFSNode* FatLocateSubDir(AuVFSNode* fsys,AuVFSNode* kfile, const char* filename) {

$LN14:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 176				; 000000b0H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__7C2BBDAD_Fat@cpp
	call	__CheckForDebuggerJustMyCode

; 328  : 	FatFS* _fs = (FatFS*)fsys->device;

	mov	rax, QWORD PTR fsys$[rbp]
	mov	rax, QWORD PTR [rax+64]
	mov	QWORD PTR _fs$[rbp], rax

; 329  : 
; 330  : 	AuVFSNode* file = (AuVFSNode*)kmalloc(sizeof(AuVFSNode));

	mov	ecx, 178				; 000000b2H
	call	kmalloc
	mov	QWORD PTR file$[rbp], rax

; 331  : 	memset(file, 0, sizeof(AuVFSNode));

	mov	r8d, 178				; 000000b2H
	xor	edx, edx
	mov	rcx, QWORD PTR file$[rbp]
	call	memset

; 332  : 
; 333  : 	char dos_file_name[11];
; 334  : 	memset(dos_file_name, 0, 11);

	mov	r8d, 11
	xor	edx, edx
	lea	rcx, QWORD PTR dos_file_name$[rbp]
	call	memset

; 335  : 	FatToDOSFilename(filename, dos_file_name, 11);

	mov	r8d, 11
	lea	rdx, QWORD PTR dos_file_name$[rbp]
	mov	rcx, QWORD PTR filename$[rbp]
	call	?FatToDOSFilename@@YAXPEBDPEADI@Z	; FatToDOSFilename

; 336  : 	dos_file_name[10] = 0;

	mov	eax, 1
	imul	rax, rax, 10
	mov	BYTE PTR dos_file_name$[rbp+rax], 0

; 337  : 
; 338  : 	uint64_t* buf = (uint64_t*)P2V((size_t)AuPmmngrAlloc());

	call	AuPmmngrAlloc
	mov	rcx, rax
	call	P2V
	mov	QWORD PTR buf$[rbp], rax

; 339  : 	if (kfile->flags != FS_FLAG_INVALID) {

	mov	rax, QWORD PTR kfile$[rbp]
	movzx	eax, WORD PTR [rax+61]
	cmp	eax, 32					; 00000020H
	je	$LN7@FatLocateS
$LN2@FatLocateS:

; 340  : 		while (1){

	xor	eax, eax
	cmp	eax, 1
	je	$LN3@FatLocateS

; 341  : 			if (kfile->eof){

	mov	rax, QWORD PTR kfile$[rbp]
	movzx	eax, BYTE PTR [rax+36]
	test	eax, eax
	je	SHORT $LN8@FatLocateS

; 342  : 				break;

	jmp	$LN3@FatLocateS
$LN8@FatLocateS:

; 343  : 			}
; 344  : 			memset(buf, 0, PAGE_SIZE);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR buf$[rbp]
	call	memset

; 345  : 		
; 346  : 			FatRead(fsys, kfile, (uint64_t*)V2P((size_t)buf));

	mov	rcx, QWORD PTR buf$[rbp]
	call	V2P
	mov	r8, rax
	mov	rdx, QWORD PTR kfile$[rbp]
	mov	rcx, QWORD PTR fsys$[rbp]
	call	?FatRead@@YA_KPEAU__VFS_NODE__@@0PEA_K@Z ; FatRead

; 347  : 			
; 348  : 			FatDir* pkDir = (FatDir*)buf;

	mov	rax, QWORD PTR buf$[rbp]
	mov	QWORD PTR pkDir$1[rbp], rax

; 349  : 			for (unsigned int i = 0; i < (16*_fs->__SectorPerCluster); ++i) {

	mov	DWORD PTR i$2[rbp], 0
	jmp	SHORT $LN6@FatLocateS
$LN4@FatLocateS:
	mov	eax, DWORD PTR i$2[rbp]
	inc	eax
	mov	DWORD PTR i$2[rbp], eax
$LN6@FatLocateS:
	mov	rax, QWORD PTR _fs$[rbp]
	movzx	eax, BYTE PTR [rax+36]
	imul	eax, eax, 16
	cmp	DWORD PTR i$2[rbp], eax
	jae	$LN5@FatLocateS

; 350  : 				char name[11];
; 351  : 				memcpy(name, pkDir->filename, 11);

	mov	rax, QWORD PTR pkDir$1[rbp]
	mov	r8d, 11
	mov	rdx, rax
	lea	rcx, QWORD PTR name$3[rbp]
	call	memcpy

; 352  : 				name[10] = '\0';

	mov	eax, 1
	imul	rax, rax, 10
	mov	BYTE PTR name$3[rbp+rax], 0

; 353  : 
; 354  : 				if (strcmp(name, dos_file_name) == 0) {

	lea	rdx, QWORD PTR dos_file_name$[rbp]
	lea	rcx, QWORD PTR name$3[rbp]
	call	strcmp
	test	eax, eax
	jne	$LN9@FatLocateS

; 355  : 					strcpy(file->filename, filename);

	mov	rax, QWORD PTR file$[rbp]
	mov	rdx, QWORD PTR filename$[rbp]
	mov	rcx, rax
	call	strcpy

; 356  : 					file->current = pkDir->first_cluster;

	mov	rax, QWORD PTR pkDir$1[rbp]
	movzx	eax, WORD PTR [rax+26]
	mov	rcx, QWORD PTR file$[rbp]
	mov	QWORD PTR [rcx+53], rax

; 357  : 					file->size = pkDir->file_size;

	mov	rax, QWORD PTR file$[rbp]
	mov	rcx, QWORD PTR pkDir$1[rbp]
	mov	ecx, DWORD PTR [rcx+28]
	mov	DWORD PTR [rax+32], ecx

; 358  : 					file->eof = 0;

	mov	rax, QWORD PTR file$[rbp]
	mov	BYTE PTR [rax+36], 0

; 359  : 					file->pos = 0;

	mov	rax, QWORD PTR file$[rbp]
	mov	DWORD PTR [rax+37], 0

; 360  : 					file->status = FS_STATUS_FOUND;

	mov	rax, QWORD PTR file$[rbp]
	mov	BYTE PTR [rax+63], 1

; 361  : 					file->first_block = file->current;

	mov	rax, QWORD PTR file$[rbp]
	mov	rcx, QWORD PTR file$[rbp]
	mov	rcx, QWORD PTR [rcx+53]
	mov	QWORD PTR [rax+45], rcx

; 362  : 					file->device = fsys;

	mov	rax, QWORD PTR file$[rbp]
	mov	rcx, QWORD PTR fsys$[rbp]
	mov	QWORD PTR [rax+64], rcx

; 363  : 					file->parent_block = kfile->current;

	mov	rax, QWORD PTR file$[rbp]
	mov	rcx, QWORD PTR kfile$[rbp]
	mov	ecx, DWORD PTR [rcx+53]
	mov	DWORD PTR [rax+41], ecx

; 364  : 					if (pkDir->attrib & 0x10)

	mov	rax, QWORD PTR pkDir$1[rbp]
	movzx	eax, BYTE PTR [rax+11]
	and	eax, 16
	test	eax, eax
	je	SHORT $LN10@FatLocateS

; 365  : 						file->flags |= FS_FLAG_DIRECTORY;

	mov	rax, QWORD PTR file$[rbp]
	movzx	eax, WORD PTR [rax+61]
	or	eax, 2
	mov	rcx, QWORD PTR file$[rbp]
	mov	WORD PTR [rcx+61], ax
	jmp	SHORT $LN11@FatLocateS
$LN10@FatLocateS:

; 366  : 					else
; 367  : 						file->flags |= FS_FLAG_GENERAL;

	mov	rax, QWORD PTR file$[rbp]
	movzx	eax, WORD PTR [rax+61]
	or	eax, 4
	mov	rcx, QWORD PTR file$[rbp]
	mov	WORD PTR [rcx+61], ax
$LN11@FatLocateS:

; 368  : 
; 369  : 					AuPmmngrFree((void*)V2P((size_t)buf));

	mov	rcx, QWORD PTR buf$[rbp]
	call	V2P
	mov	rcx, rax
	call	AuPmmngrFree

; 370  : 					kfree(kfile);

	mov	rcx, QWORD PTR kfile$[rbp]
	call	kfree

; 371  : 					return file;

	mov	rax, QWORD PTR file$[rbp]
	jmp	SHORT $LN1@FatLocateS
$LN9@FatLocateS:

; 372  : 				}
; 373  : 
; 374  : 				pkDir++;

	mov	rax, QWORD PTR pkDir$1[rbp]
	add	rax, 32					; 00000020H
	mov	QWORD PTR pkDir$1[rbp], rax

; 375  : 			}

	jmp	$LN4@FatLocateS
$LN5@FatLocateS:

; 376  : 		}

	jmp	$LN2@FatLocateS
$LN3@FatLocateS:
$LN7@FatLocateS:

; 377  : 	}
; 378  : 
; 379  : 	AuPmmngrFree((void*)V2P((size_t)buf));

	mov	rcx, QWORD PTR buf$[rbp]
	call	V2P
	mov	rcx, rax
	call	AuPmmngrFree

; 380  : 	kfree(file);

	mov	rcx, QWORD PTR file$[rbp]
	call	kfree

; 381  : 	if (kfile)

	cmp	QWORD PTR kfile$[rbp], 0
	je	SHORT $LN12@FatLocateS

; 382  : 		kfree(kfile);

	mov	rcx, QWORD PTR kfile$[rbp]
	call	kfree
$LN12@FatLocateS:

; 383  : 	return NULL;

	xor	eax, eax
$LN1@FatLocateS:

; 384  : }

	lea	rsp, QWORD PTR [rbp+144]
	pop	rbp
	ret	0
?FatLocateSubDir@@YAPEAU__VFS_NODE__@@PEAU1@0PEBD@Z ENDP ; FatLocateSubDir
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Fs\Fat\Fat.cpp
;	COMDAT ?FatLocateDir@@YAPEAU__VFS_NODE__@@PEAU1@PEBD@Z
_TEXT	SEGMENT
file$ = 0
fs$ = 8
vdisk$ = 16
buf$ = 24
dirent$ = 32
dos_file_name$ = 40
sector$1 = 56
i$2 = 60
name$3 = 64
tv91 = 144
fsys$ = 176
dir$ = 184
?FatLocateDir@@YAPEAU__VFS_NODE__@@PEAU1@PEBD@Z PROC	; FatLocateDir, COMDAT

; 387  : AuVFSNode* FatLocateDir(AuVFSNode* fsys, const char* dir) {

$LN13:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 192				; 000000c0H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__7C2BBDAD_Fat@cpp
	call	__CheckForDebuggerJustMyCode

; 388  : 	AuVFSNode* file = (AuVFSNode*)kmalloc(sizeof(AuVFSNode));

	mov	ecx, 178				; 000000b2H
	call	kmalloc
	mov	QWORD PTR file$[rbp], rax

; 389  : 	memset(file, 0, sizeof(AuVFSNode));

	mov	r8d, 178				; 000000b2H
	xor	edx, edx
	mov	rcx, QWORD PTR file$[rbp]
	call	memset

; 390  : 
; 391  : 	FatFS* fs = (FatFS*)fsys->device;

	mov	rax, QWORD PTR fsys$[rbp]
	mov	rax, QWORD PTR [rax+64]
	mov	QWORD PTR fs$[rbp], rax

; 392  : 	AuVDisk *vdisk = (AuVDisk*)fs->vdisk;

	mov	rax, QWORD PTR fs$[rbp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR vdisk$[rbp], rax

; 393  : 	if (!vdisk)

	cmp	QWORD PTR vdisk$[rbp], 0
	jne	SHORT $LN8@FatLocateD

; 394  : 		return NULL;

	xor	eax, eax
	jmp	$LN1@FatLocateD
$LN8@FatLocateD:

; 395  : 
; 396  : 	uint64_t* buf;
; 397  : 	FatDir *dirent;
; 398  : 	char dos_file_name[11];
; 399  : 	FatToDOSFilename(dir, dos_file_name, 11);

	mov	r8d, 11
	lea	rdx, QWORD PTR dos_file_name$[rbp]
	mov	rcx, QWORD PTR dir$[rbp]
	call	?FatToDOSFilename@@YAXPEBDPEADI@Z	; FatToDOSFilename

; 400  : 	dos_file_name[10] = 0;

	mov	eax, 1
	imul	rax, rax, 10
	mov	BYTE PTR dos_file_name$[rbp+rax], 0

; 401  : 	
; 402  : 	buf = (uint64_t*)P2V((uint64_t)AuPmmngrAlloc());

	call	AuPmmngrAlloc
	mov	rcx, rax
	call	P2V
	mov	QWORD PTR buf$[rbp], rax

; 403  : 	memset(buf, 0, PAGE_SIZE);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR buf$[rbp]
	call	memset

; 404  : 	for (unsigned int sector = 0; sector < fs->__SectorPerCluster; sector++) {

	mov	DWORD PTR sector$1[rbp], 0
	jmp	SHORT $LN4@FatLocateD
$LN2@FatLocateD:
	mov	eax, DWORD PTR sector$1[rbp]
	inc	eax
	mov	DWORD PTR sector$1[rbp], eax
$LN4@FatLocateD:
	mov	rax, QWORD PTR fs$[rbp]
	movzx	eax, BYTE PTR [rax+36]
	cmp	DWORD PTR sector$1[rbp], eax
	jae	$LN3@FatLocateD

; 405  : 
; 406  : 		memset(buf, 0, PAGE_SIZE);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR buf$[rbp]
	call	memset

; 407  : 		//ata_read_28 (root_sector + sector,1, buf);
; 408  : 		AuVDiskRead(vdisk, FatClusterToSector32(fs,fs->__RootDirFirstCluster) + sector, 1, (uint64_t*)V2P((uint64_t)buf));

	mov	rcx, QWORD PTR buf$[rbp]
	call	V2P
	mov	QWORD PTR tv91[rbp], rax
	mov	rcx, QWORD PTR fs$[rbp]
	mov	ecx, DWORD PTR [rcx+40]
	mov	edx, ecx
	mov	rcx, QWORD PTR fs$[rbp]
	call	?FatClusterToSector32@@YA_KPEAU_FatFS_@@_K@Z ; FatClusterToSector32
	mov	ecx, DWORD PTR sector$1[rbp]
	add	rax, rcx
	mov	rcx, QWORD PTR tv91[rbp]
	mov	r9, rcx
	mov	r8d, 1
	mov	rdx, rax
	mov	rcx, QWORD PTR vdisk$[rbp]
	call	AuVDiskRead

; 409  : 
; 410  : 		dirent = (FatDir*)buf;

	mov	rax, QWORD PTR buf$[rbp]
	mov	QWORD PTR dirent$[rbp], rax

; 411  : 
; 412  : 		for (int i = 0; i < 16; i++) {

	mov	DWORD PTR i$2[rbp], 0
	jmp	SHORT $LN7@FatLocateD
$LN5@FatLocateD:
	mov	eax, DWORD PTR i$2[rbp]
	inc	eax
	mov	DWORD PTR i$2[rbp], eax
$LN7@FatLocateD:
	cmp	DWORD PTR i$2[rbp], 16
	jge	$LN6@FatLocateD

; 413  : 			char name[11];
; 414  : 			memcpy(name, dirent->filename, 11);

	mov	rax, QWORD PTR dirent$[rbp]
	mov	r8d, 11
	mov	rdx, rax
	lea	rcx, QWORD PTR name$3[rbp]
	call	memcpy

; 415  : 			name[10] = 0;

	mov	eax, 1
	imul	rax, rax, 10
	mov	BYTE PTR name$3[rbp+rax], 0

; 416  : 			if (strcmp(dos_file_name, name) == 0) {

	lea	rdx, QWORD PTR name$3[rbp]
	lea	rcx, QWORD PTR dos_file_name$[rbp]
	call	strcmp
	test	eax, eax
	jne	$LN9@FatLocateD

; 417  : 				
; 418  : 				strcpy(file->filename, dir);

	mov	rax, QWORD PTR file$[rbp]
	mov	rdx, QWORD PTR dir$[rbp]
	mov	rcx, rax
	call	strcpy

; 419  : 				file->current = dirent->first_cluster;

	mov	rax, QWORD PTR dirent$[rbp]
	movzx	eax, WORD PTR [rax+26]
	mov	rcx, QWORD PTR file$[rbp]
	mov	QWORD PTR [rcx+53], rax

; 420  : 				file->size = dirent->file_size;

	mov	rax, QWORD PTR file$[rbp]
	mov	rcx, QWORD PTR dirent$[rbp]
	mov	ecx, DWORD PTR [rcx+28]
	mov	DWORD PTR [rax+32], ecx

; 421  : 				file->eof = 0;

	mov	rax, QWORD PTR file$[rbp]
	mov	BYTE PTR [rax+36], 0

; 422  : 				file->status = FS_STATUS_FOUND;

	mov	rax, QWORD PTR file$[rbp]
	mov	BYTE PTR [rax+63], 1

; 423  : 				file->close = 0;

	mov	rax, QWORD PTR file$[rbp]
	mov	QWORD PTR [rax+138], 0

; 424  : 				file->first_block = file->current;

	mov	rax, QWORD PTR file$[rbp]
	mov	rcx, QWORD PTR file$[rbp]
	mov	rcx, QWORD PTR [rcx+53]
	mov	QWORD PTR [rax+45], rcx

; 425  : 				file->pos = 0;

	mov	rax, QWORD PTR file$[rbp]
	mov	DWORD PTR [rax+37], 0

; 426  : 				file->device = fsys;

	mov	rax, QWORD PTR file$[rbp]
	mov	rcx, QWORD PTR fsys$[rbp]
	mov	QWORD PTR [rax+64], rcx

; 427  : 				file->parent_block = fs->__RootDirFirstCluster;

	mov	rax, QWORD PTR file$[rbp]
	mov	rcx, QWORD PTR fs$[rbp]
	mov	ecx, DWORD PTR [rcx+40]
	mov	DWORD PTR [rax+41], ecx

; 428  : 				if (dirent->attrib & 0x10)

	mov	rax, QWORD PTR dirent$[rbp]
	movzx	eax, BYTE PTR [rax+11]
	and	eax, 16
	test	eax, eax
	je	SHORT $LN10@FatLocateD

; 429  : 					file->flags |= FS_FLAG_DIRECTORY;

	mov	rax, QWORD PTR file$[rbp]
	movzx	eax, WORD PTR [rax+61]
	or	eax, 2
	mov	rcx, QWORD PTR file$[rbp]
	mov	WORD PTR [rcx+61], ax
	jmp	SHORT $LN11@FatLocateD
$LN10@FatLocateD:

; 430  : 				else
; 431  : 					file->flags |= FS_FLAG_GENERAL;

	mov	rax, QWORD PTR file$[rbp]
	movzx	eax, WORD PTR [rax+61]
	or	eax, 4
	mov	rcx, QWORD PTR file$[rbp]
	mov	WORD PTR [rcx+61], ax
$LN11@FatLocateD:

; 432  : 
; 433  : 				AuPmmngrFree((void*)V2P((size_t)buf));

	mov	rcx, QWORD PTR buf$[rbp]
	call	V2P
	mov	rcx, rax
	call	AuPmmngrFree

; 434  : 				return file;

	mov	rax, QWORD PTR file$[rbp]
	jmp	SHORT $LN1@FatLocateD
$LN9@FatLocateD:

; 435  : 			}
; 436  : 			dirent++;

	mov	rax, QWORD PTR dirent$[rbp]
	add	rax, 32					; 00000020H
	mov	QWORD PTR dirent$[rbp], rax

; 437  : 		}

	jmp	$LN5@FatLocateD
$LN6@FatLocateD:

; 438  : 	}

	jmp	$LN2@FatLocateD
$LN3@FatLocateD:

; 439  : 
; 440  : 	AuPmmngrFree((void*)V2P((size_t)buf));

	mov	rcx, QWORD PTR buf$[rbp]
	call	V2P
	mov	rcx, rax
	call	AuPmmngrFree

; 441  : 	kfree(file);

	mov	rcx, QWORD PTR file$[rbp]
	call	kfree

; 442  : 	return NULL;

	xor	eax, eax
$LN1@FatLocateD:

; 443  : }

	lea	rsp, QWORD PTR [rbp+160]
	pop	rbp
	ret	0
?FatLocateDir@@YAPEAU__VFS_NODE__@@PEAU1@PEBD@Z ENDP	; FatLocateDir
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Fs\Fat\Fat.cpp
;	COMDAT ?FatFormatTime@@YAGXZ
_TEXT	SEGMENT
tv66 = 64
tv70 = 68
?FatFormatTime@@YAGXZ PROC				; FatFormatTime, COMDAT

; 627  : uint16_t FatFormatTime() {

$LN3:
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__7C2BBDAD_Fat@cpp
	call	__CheckForDebuggerJustMyCode

; 628  : 	return (uint16_t)(AuRTCGetHour() << 11 | AuRTCGetMinutes() << 5 | AuRTCGetSecond() / 2);

	call	AuRTCGetHour
	movzx	eax, al
	shl	eax, 11
	mov	DWORD PTR tv66[rbp], eax
	call	AuRTCGetMinutes
	movzx	eax, al
	shl	eax, 5
	mov	ecx, DWORD PTR tv66[rbp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR tv70[rbp], eax
	call	AuRTCGetSecond
	movzx	eax, al
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR tv70[rbp]
	or	ecx, eax
	mov	eax, ecx

; 629  : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
?FatFormatTime@@YAGXZ ENDP				; FatFormatTime
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Fs\Fat\Fat.cpp
;	COMDAT ?FatFormatDate@@YAGXZ
_TEXT	SEGMENT
tv68 = 64
tv72 = 68
?FatFormatDate@@YAGXZ PROC				; FatFormatDate, COMDAT

; 620  : uint16_t FatFormatDate() {

$LN3:
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__7C2BBDAD_Fat@cpp
	call	__CheckForDebuggerJustMyCode

; 621  : 	return (uint16_t)((2000 + AuRTCGetYear() - 1980) << 9 | AuRTCGetMonth() << 5 | AuRTCGetDay());

	call	AuRTCGetYear
	movzx	eax, al
	add	eax, 20
	shl	eax, 9
	mov	DWORD PTR tv68[rbp], eax
	call	AuRTCGetMonth
	movzx	eax, al
	shl	eax, 5
	mov	ecx, DWORD PTR tv68[rbp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR tv72[rbp], eax
	call	AuRTCGetDay
	movzx	eax, al
	mov	ecx, DWORD PTR tv72[rbp]
	or	ecx, eax
	mov	eax, ecx

; 622  : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
?FatFormatDate@@YAGXZ ENDP				; FatFormatDate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Fs\Fat\Fat.cpp
;	COMDAT ?FatOpen@@YAPEAU__VFS_NODE__@@PEAU1@PEAD@Z
_TEXT	SEGMENT
_fs$ = 0
cur_dir$ = 8
vdisk$ = 16
p$ = 24
root_dir$ = 32
path$ = 40
pathname$1 = 48
i$2 = 64
fsys$ = 160
filename$ = 168
?FatOpen@@YAPEAU__VFS_NODE__@@PEAU1@PEAD@Z PROC		; FatOpen, COMDAT

; 449  : AuVFSNode * FatOpen(AuVFSNode * fsys, char* filename) {

$LN18:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 176				; 000000b0H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__7C2BBDAD_Fat@cpp
	call	__CheckForDebuggerJustMyCode

; 450  : 	if (!fsys)

	cmp	QWORD PTR fsys$[rbp], 0
	jne	SHORT $LN7@FatOpen

; 451  : 		return NULL;

	xor	eax, eax
	jmp	$LN1@FatOpen
$LN7@FatOpen:

; 452  : 	FatFS* _fs = (FatFS*)fsys->device;

	mov	rax, QWORD PTR fsys$[rbp]
	mov	rax, QWORD PTR [rax+64]
	mov	QWORD PTR _fs$[rbp], rax

; 453  : 	AuVFSNode *cur_dir = NULL;

	mov	QWORD PTR cur_dir$[rbp], 0

; 454  : 	AuVDisk *vdisk = (AuVDisk*)fsys->device;

	mov	rax, QWORD PTR fsys$[rbp]
	mov	rax, QWORD PTR [rax+64]
	mov	QWORD PTR vdisk$[rbp], rax

; 455  : 	char* p = 0;

	mov	QWORD PTR p$[rbp], 0

; 456  : 	bool  root_dir = true;

	mov	BYTE PTR root_dir$[rbp], 1

; 457  : 	char* path = (char*)filename;

	mov	rax, QWORD PTR filename$[rbp]
	mov	QWORD PTR path$[rbp], rax

; 458  : 	
; 459  : 	//! any '\'s in path ?
; 460  : 	p = strchr(path, '/');

	mov	edx, 47					; 0000002fH
	mov	rcx, QWORD PTR path$[rbp]
	call	strchr
	mov	QWORD PTR p$[rbp], rax

; 461  : 	if (!p) {

	cmp	QWORD PTR p$[rbp], 0
	jne	SHORT $LN8@FatOpen

; 462  : 
; 463  : 		//! nope, must be in root directory, search it
; 464  : 		cur_dir = FatLocateDir(fsys,path);

	mov	rdx, QWORD PTR path$[rbp]
	mov	rcx, QWORD PTR fsys$[rbp]
	call	?FatLocateDir@@YAPEAU__VFS_NODE__@@PEAU1@PEBD@Z ; FatLocateDir
	mov	QWORD PTR cur_dir$[rbp], rax

; 465  : 
; 466  : 		//! found file ?
; 467  : 		if (cur_dir != NULL) {

	cmp	QWORD PTR cur_dir$[rbp], 0
	je	SHORT $LN9@FatOpen

; 468  : 			return cur_dir;

	mov	rax, QWORD PTR cur_dir$[rbp]
	jmp	$LN1@FatOpen
$LN9@FatOpen:

; 469  : 		}
; 470  : 		//! unable to find
; 471  : 		return NULL;

	xor	eax, eax
	jmp	$LN1@FatOpen
$LN8@FatOpen:

; 472  : 	}
; 473  : 
; 474  : 	//! go to next character after first '\'
; 475  : 	p++;

	mov	rax, QWORD PTR p$[rbp]
	inc	rax
	mov	QWORD PTR p$[rbp], rax
$LN2@FatOpen:

; 476  : 	while (p) {

	cmp	QWORD PTR p$[rbp], 0
	je	$LN3@FatOpen

; 477  : 
; 478  : 		//! get pathname
; 479  : 		char pathname[16];
; 480  : 		int i = 0;

	mov	DWORD PTR i$2[rbp], 0

; 481  : 		for (i = 0; i < 16; i++) {

	mov	DWORD PTR i$2[rbp], 0
	jmp	SHORT $LN6@FatOpen
$LN4@FatOpen:
	mov	eax, DWORD PTR i$2[rbp]
	inc	eax
	mov	DWORD PTR i$2[rbp], eax
$LN6@FatOpen:
	cmp	DWORD PTR i$2[rbp], 16
	jge	SHORT $LN5@FatOpen

; 482  : 
; 483  : 			//! if another '\' or end of line is reached, we are done
; 484  : 			if (p[i] == '/' || p[i] == '\0')

	movsxd	rax, DWORD PTR i$2[rbp]
	mov	rcx, QWORD PTR p$[rbp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 47					; 0000002fH
	je	SHORT $LN11@FatOpen
	movsxd	rax, DWORD PTR i$2[rbp]
	mov	rcx, QWORD PTR p$[rbp]
	movsx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	jne	SHORT $LN10@FatOpen
$LN11@FatOpen:

; 485  : 				break;

	jmp	SHORT $LN5@FatOpen
$LN10@FatOpen:

; 486  : 
; 487  : 			//! copy character
; 488  : 			pathname[i] = p[i];

	movsxd	rax, DWORD PTR i$2[rbp]
	movsxd	rcx, DWORD PTR i$2[rbp]
	mov	rdx, QWORD PTR p$[rbp]
	movzx	eax, BYTE PTR [rdx+rax]
	mov	BYTE PTR pathname$1[rbp+rcx], al

; 489  : 		}

	jmp	SHORT $LN4@FatOpen
$LN5@FatOpen:

; 490  : 		pathname[i] = 0; //null terminate

	movsxd	rax, DWORD PTR i$2[rbp]
	mov	BYTE PTR pathname$1[rbp+rax], 0

; 491  : 
; 492  : 		//! open subdirectory or file
; 493  : 		if (root_dir) {

	movzx	eax, BYTE PTR root_dir$[rbp]
	test	eax, eax
	je	SHORT $LN12@FatOpen

; 494  : 			//! search root dir -- open pathname
; 495  : 			cur_dir = FatLocateDir(fsys,pathname);

	lea	rdx, QWORD PTR pathname$1[rbp]
	mov	rcx, QWORD PTR fsys$[rbp]
	call	?FatLocateDir@@YAPEAU__VFS_NODE__@@PEAU1@PEBD@Z ; FatLocateDir
	mov	QWORD PTR cur_dir$[rbp], rax

; 496  : 			root_dir = false;

	mov	BYTE PTR root_dir$[rbp], 0

; 497  : 		}

	jmp	SHORT $LN13@FatOpen
$LN12@FatOpen:

; 498  : 		else {
; 499  : 			//! search a sub directory instead for pathname
; 500  : 			cur_dir = FatLocateSubDir(fsys,cur_dir, pathname);

	lea	r8, QWORD PTR pathname$1[rbp]
	mov	rdx, QWORD PTR cur_dir$[rbp]
	mov	rcx, QWORD PTR fsys$[rbp]
	call	?FatLocateSubDir@@YAPEAU__VFS_NODE__@@PEAU1@0PEBD@Z ; FatLocateSubDir
	mov	QWORD PTR cur_dir$[rbp], rax
$LN13@FatOpen:

; 501  : 		}
; 502  : 
; 503  : 		//! found directory or file?
; 504  : 		if (cur_dir == NULL)

	cmp	QWORD PTR cur_dir$[rbp], 0
	jne	SHORT $LN14@FatOpen

; 505  : 			break;

	jmp	SHORT $LN3@FatOpen
$LN14@FatOpen:

; 506  : 
; 507  : 		//! find next '\'
; 508  : 		p = strchr(p + 1, '/');

	mov	rax, QWORD PTR p$[rbp]
	inc	rax
	mov	edx, 47					; 0000002fH
	mov	rcx, rax
	call	strchr
	mov	QWORD PTR p$[rbp], rax

; 509  : 		if (p)

	cmp	QWORD PTR p$[rbp], 0
	je	SHORT $LN15@FatOpen

; 510  : 			p++;

	mov	rax, QWORD PTR p$[rbp]
	inc	rax
	mov	QWORD PTR p$[rbp], rax
$LN15@FatOpen:

; 511  : 	}

	jmp	$LN2@FatOpen
$LN3@FatOpen:

; 512  : 
; 513  : 	//! found file?
; 514  : 	if (cur_dir)

	cmp	QWORD PTR cur_dir$[rbp], 0
	je	SHORT $LN16@FatOpen

; 515  : 		return cur_dir;

	mov	rax, QWORD PTR cur_dir$[rbp]
	jmp	SHORT $LN1@FatOpen
$LN16@FatOpen:

; 516  : 	//! unable to find
; 517  : 	return NULL;

	xor	eax, eax
$LN1@FatOpen:

; 518  : }

	lea	rsp, QWORD PTR [rbp+144]
	pop	rbp
	ret	0
?FatOpen@@YAPEAU__VFS_NODE__@@PEAU1@PEAD@Z ENDP		; FatOpen
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Fs\Fat\Fat.cpp
;	COMDAT ?FatReadFAT@@YAIPEAU__VFS_NODE__@@_K@Z
_TEXT	SEGMENT
fs$ = 0
vdisk$ = 8
fat_offset$ = 16
fat_sector$ = 24
ent_offset$ = 32
BuffArea$ = 40
buf$ = 48
value$ = 56
tv75 = 128
tv69 = 128
node$ = 160
cluster_index$ = 168
?FatReadFAT@@YAIPEAU__VFS_NODE__@@_K@Z PROC		; FatReadFAT, COMDAT

; 139  : uint32_t FatReadFAT(AuVFSNode *node, uint64_t cluster_index) {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 176				; 000000b0H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__7C2BBDAD_Fat@cpp
	call	__CheckForDebuggerJustMyCode

; 140  : 	FatFS *fs = (FatFS*)node->device;

	mov	rax, QWORD PTR node$[rbp]
	mov	rax, QWORD PTR [rax+64]
	mov	QWORD PTR fs$[rbp], rax

; 141  : 	AuVDisk *vdisk = (AuVDisk*)fs->vdisk;

	mov	rax, QWORD PTR fs$[rbp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR vdisk$[rbp], rax

; 142  : 	if (!vdisk){

	cmp	QWORD PTR vdisk$[rbp], 0
	jne	SHORT $LN2@FatReadFAT

; 143  : 		return NULL;

	xor	eax, eax
	jmp	$LN1@FatReadFAT
$LN2@FatReadFAT:

; 144  : 	}
; 145  : 
; 146  : 	uint64_t fat_offset = cluster_index * 4;

	mov	rax, QWORD PTR cluster_index$[rbp]
	shl	rax, 2
	mov	QWORD PTR fat_offset$[rbp], rax

; 147  : 	uint64_t fat_sector = fs->__FatBeginLBA + (fat_offset / fs->__BytesPerSector);

	mov	rax, QWORD PTR fs$[rbp]
	mov	eax, DWORD PTR [rax+28]
	mov	QWORD PTR tv69[rbp], rax
	mov	rcx, QWORD PTR fs$[rbp]
	movzx	ecx, WORD PTR [rcx+64]
	xor	edx, edx
	mov	rax, QWORD PTR fat_offset$[rbp]
	div	rcx
	mov	rcx, QWORD PTR tv69[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR fat_sector$[rbp], rax

; 148  : 	
; 149  : 	size_t ent_offset = fat_offset % fs->__BytesPerSector;

	mov	rax, QWORD PTR fs$[rbp]
	movzx	eax, WORD PTR [rax+64]
	mov	QWORD PTR tv75[rbp], rax
	xor	edx, edx
	mov	rax, QWORD PTR fat_offset$[rbp]
	mov	rcx, QWORD PTR tv75[rbp]
	div	rcx
	mov	rax, rdx
	mov	QWORD PTR ent_offset$[rbp], rax

; 150  : 	uint32_t *BuffArea = (uint32_t*)P2V((size_t)AuPmmngrAlloc());

	call	AuPmmngrAlloc
	mov	rcx, rax
	call	P2V
	mov	QWORD PTR BuffArea$[rbp], rax

; 151  : 	memset(BuffArea, 0, 4096);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR BuffArea$[rbp]
	call	memset

; 152  : 	AuVDiskRead(vdisk, fat_sector, 1, (uint64_t*)V2P((size_t)BuffArea));

	mov	rcx, QWORD PTR BuffArea$[rbp]
	call	V2P
	mov	r9, rax
	mov	r8d, 1
	mov	rdx, QWORD PTR fat_sector$[rbp]
	mov	rcx, QWORD PTR vdisk$[rbp]
	call	AuVDiskRead

; 153  : 	unsigned char* buf = (unsigned char*)BuffArea;

	mov	rax, QWORD PTR BuffArea$[rbp]
	mov	QWORD PTR buf$[rbp], rax

; 154  : 	uint32_t value = *(uint32_t*)&buf[ent_offset];

	mov	rax, QWORD PTR ent_offset$[rbp]
	mov	rcx, QWORD PTR buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR value$[rbp], eax

; 155  : 	AuPmmngrFree((void*)V2P((size_t)BuffArea));

	mov	rcx, QWORD PTR BuffArea$[rbp]
	call	V2P
	mov	rcx, rax
	call	AuPmmngrFree

; 156  : 	return (value & 0x0FFFFFFF);

	mov	eax, DWORD PTR value$[rbp]
	and	eax, 268435455				; 0fffffffH
$LN1@FatReadFAT:

; 157  : }

	lea	rsp, QWORD PTR [rbp+144]
	pop	rbp
	ret	0
?FatReadFAT@@YAIPEAU__VFS_NODE__@@_K@Z ENDP		; FatReadFAT
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Fs\Fat\Fat.cpp
;	COMDAT ?FatClearCluster@@YAXPEAU__VFS_NODE__@@I@Z
_TEXT	SEGMENT
fs$ = 0
vdisk$ = 8
buffer$ = 16
sector$ = 24
node$ = 112
cluster$ = 120
?FatClearCluster@@YAXPEAU__VFS_NODE__@@I@Z PROC		; FatClearCluster, COMDAT

; 239  : void FatClearCluster(AuVFSNode* node, uint32_t cluster) {

$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 128				; 00000080H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__7C2BBDAD_Fat@cpp
	call	__CheckForDebuggerJustMyCode

; 240  : 	FatFS* fs = (FatFS*)node->device;

	mov	rax, QWORD PTR node$[rbp]
	mov	rax, QWORD PTR [rax+64]
	mov	QWORD PTR fs$[rbp], rax

; 241  : 	AuVDisk* vdisk = (AuVDisk*)fs->vdisk;

	mov	rax, QWORD PTR fs$[rbp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR vdisk$[rbp], rax

; 242  : 	if (!vdisk)

	cmp	QWORD PTR vdisk$[rbp], 0
	jne	SHORT $LN2@FatClearCl

; 243  : 		return;

	jmp	SHORT $LN1@FatClearCl
$LN2@FatClearCl:

; 244  : 
; 245  : 	uint64_t *buffer = (uint64_t*)P2V((size_t)AuPmmngrAlloc());

	call	AuPmmngrAlloc
	mov	rcx, rax
	call	P2V
	mov	QWORD PTR buffer$[rbp], rax

; 246  : 	memset(buffer, 0, PAGE_SIZE);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR buffer$[rbp]
	call	memset

; 247  : 	//update_cluster (buffer,cluster);
; 248  : 	uint32_t sector = FatClusterToSector32(fs, cluster);

	mov	eax, DWORD PTR cluster$[rbp]
	mov	edx, eax
	mov	rcx, QWORD PTR fs$[rbp]
	call	?FatClusterToSector32@@YA_KPEAU_FatFS_@@_K@Z ; FatClusterToSector32
	mov	DWORD PTR sector$[rbp], eax

; 249  : 	AuVDiskWrite(vdisk, sector, fs->__SectorPerCluster, (uint64_t*)V2P((size_t)buffer));

	mov	rcx, QWORD PTR buffer$[rbp]
	call	V2P
	mov	rcx, QWORD PTR fs$[rbp]
	movzx	ecx, BYTE PTR [rcx+36]
	mov	edx, DWORD PTR sector$[rbp]
	mov	r9, rax
	mov	r8d, ecx
	mov	rcx, QWORD PTR vdisk$[rbp]
	call	AuVDiskWrite

; 250  : 	AuPmmngrFree((void*)V2P((size_t)buffer));

	mov	rcx, QWORD PTR buffer$[rbp]
	call	V2P
	mov	rcx, rax
	call	AuPmmngrFree
$LN1@FatClearCl:

; 251  : }

	lea	rsp, QWORD PTR [rbp+96]
	pop	rbp
	ret	0
?FatClearCluster@@YAXPEAU__VFS_NODE__@@I@Z ENDP		; FatClearCluster
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Fs\Fat\Fat.cpp
;	COMDAT ?FatAllocCluster@@YAXPEAU__VFS_NODE__@@HI@Z
_TEXT	SEGMENT
fs$ = 0
vdisk$ = 8
fat_offset$ = 16
fat_sector$ = 24
ent_offset$ = 32
buffer$ = 40
buf$ = 48
value$ = 56
value2$ = 60
tv70 = 128
fsys$ = 160
position$ = 168
n_value$ = 176
?FatAllocCluster@@YAXPEAU__VFS_NODE__@@HI@Z PROC	; FatAllocCluster, COMDAT

; 196  : void FatAllocCluster(AuVFSNode* fsys, int position, uint32_t n_value) {

$LN4:
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 176				; 000000b0H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__7C2BBDAD_Fat@cpp
	call	__CheckForDebuggerJustMyCode

; 197  : 	FatFS *fs = (FatFS*)fsys->device;

	mov	rax, QWORD PTR fsys$[rbp]
	mov	rax, QWORD PTR [rax+64]
	mov	QWORD PTR fs$[rbp], rax

; 198  : 	AuVDisk* vdisk = (AuVDisk*)fs->vdisk;

	mov	rax, QWORD PTR fs$[rbp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR vdisk$[rbp], rax

; 199  : 	if (!vdisk)

	cmp	QWORD PTR vdisk$[rbp], 0
	jne	SHORT $LN2@FatAllocCl

; 200  : 		return;

	jmp	$LN1@FatAllocCl
$LN2@FatAllocCl:

; 201  : 
; 202  : 	int64_t fat_offset = static_cast<int64_t>(position) * 4;

	movsxd	rax, DWORD PTR position$[rbp]
	shl	rax, 2
	mov	QWORD PTR fat_offset$[rbp], rax

; 203  : 	uint64_t fat_sector = fs->__FatBeginLBA + (fat_offset / 512);

	mov	rax, QWORD PTR fs$[rbp]
	mov	eax, DWORD PTR [rax+28]
	mov	QWORD PTR tv70[rbp], rax
	mov	rax, QWORD PTR fat_offset$[rbp]
	cdq
	and	rdx, 511				; 000001ffH
	add	rax, rdx
	sar	rax, 9
	mov	rcx, QWORD PTR tv70[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR fat_sector$[rbp], rax

; 204  : 	size_t ent_offset = fat_offset % 512;

	mov	rax, QWORD PTR fat_offset$[rbp]
	cdq
	and	rdx, 511				; 000001ffH
	add	rax, rdx
	and	rax, 511				; 000001ffH
	sub	rax, rdx
	mov	QWORD PTR ent_offset$[rbp], rax

; 205  : 	uint64_t *buffer = (uint64_t*)P2V((size_t)AuPmmngrAlloc());

	call	AuPmmngrAlloc
	mov	rcx, rax
	call	P2V
	mov	QWORD PTR buffer$[rbp], rax

; 206  : 	memset(buffer, 0, PAGE_SIZE);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR buffer$[rbp]
	call	memset

; 207  : 	AuVDiskRead(vdisk, fat_sector, 1, (uint64_t*)V2P((size_t)buffer));

	mov	rcx, QWORD PTR buffer$[rbp]
	call	V2P
	mov	r9, rax
	mov	r8d, 1
	mov	rdx, QWORD PTR fat_sector$[rbp]
	mov	rcx, QWORD PTR vdisk$[rbp]
	call	AuVDiskRead

; 208  : 
; 209  : 	uint8_t* buf = (uint8_t*)buffer;

	mov	rax, QWORD PTR buffer$[rbp]
	mov	QWORD PTR buf$[rbp], rax

; 210  : 	uint32_t value = *(uint32_t*)&buf[ent_offset];

	mov	rax, QWORD PTR ent_offset$[rbp]
	mov	rcx, QWORD PTR buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR value$[rbp], eax

; 211  : 	*(uint32_t*)&buf[ent_offset] = n_value & 0x0FFFFFFF;

	mov	eax, DWORD PTR n_value$[rbp]
	and	eax, 268435455				; 0fffffffH
	mov	rcx, QWORD PTR ent_offset$[rbp]
	mov	rdx, QWORD PTR buf$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	DWORD PTR [rcx], eax

; 212  : 
; 213  : 	uint32_t value2 = *(uint32_t*)&buf[ent_offset];

	mov	rax, QWORD PTR ent_offset$[rbp]
	mov	rcx, QWORD PTR buf$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR value2$[rbp], eax

; 214  : 	AuVDiskWrite(vdisk, fat_sector, 1, (uint64_t*)V2P((size_t)buffer));

	mov	rcx, QWORD PTR buffer$[rbp]
	call	V2P
	mov	r9, rax
	mov	r8d, 1
	mov	rdx, QWORD PTR fat_sector$[rbp]
	mov	rcx, QWORD PTR vdisk$[rbp]
	call	AuVDiskWrite

; 215  : 	AuPmmngrFree((void*)V2P((size_t)buffer));

	mov	rcx, QWORD PTR buffer$[rbp]
	call	V2P
	mov	rcx, rax
	call	AuPmmngrFree
$LN1@FatAllocCl:

; 216  : }

	lea	rsp, QWORD PTR [rbp+144]
	pop	rbp
	ret	0
?FatAllocCluster@@YAXPEAU__VFS_NODE__@@HI@Z ENDP	; FatAllocCluster
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Fs\Fat\Fat.cpp
;	COMDAT ?FatFindFreeCluster@@YAIPEAU__VFS_NODE__@@@Z
_TEXT	SEGMENT
fs$ = 0
vdisk$ = 8
i$1 = 16
fat_offset$2 = 24
fat_sector$3 = 32
ent_offset$4 = 40
buffer$5 = 48
buf$6 = 56
value$7 = 64
tv73 = 136
node$ = 160
?FatFindFreeCluster@@YAIPEAU__VFS_NODE__@@@Z PROC	; FatFindFreeCluster, COMDAT

; 164  : uint32_t FatFindFreeCluster(AuVFSNode* node) {

$LN8:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 176				; 000000b0H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__7C2BBDAD_Fat@cpp
	call	__CheckForDebuggerJustMyCode

; 165  : 	FatFS *fs = (FatFS*)node->device;

	mov	rax, QWORD PTR node$[rbp]
	mov	rax, QWORD PTR [rax+64]
	mov	QWORD PTR fs$[rbp], rax

; 166  : 	AuVDisk *vdisk = (AuVDisk*)fs->vdisk;

	mov	rax, QWORD PTR fs$[rbp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR vdisk$[rbp], rax

; 167  : 	if (!vdisk)

	cmp	QWORD PTR vdisk$[rbp], 0
	jne	SHORT $LN5@FatFindFre

; 168  : 		return NULL;

	xor	eax, eax
	jmp	$LN1@FatFindFre
$LN5@FatFindFre:

; 169  : 
; 170  : 	for (int i = 2; i < fs->__TotalClusters; i++) {

	mov	DWORD PTR i$1[rbp], 2
	jmp	SHORT $LN4@FatFindFre
$LN2@FatFindFre:
	mov	eax, DWORD PTR i$1[rbp]
	inc	eax
	mov	DWORD PTR i$1[rbp], eax
$LN4@FatFindFre:
	mov	rax, QWORD PTR fs$[rbp]
	mov	eax, DWORD PTR [rax+52]
	cmp	DWORD PTR i$1[rbp], eax
	jae	$LN3@FatFindFre

; 171  : 		int64_t fat_offset = static_cast<int64>(i) * 4;

	movsxd	rax, DWORD PTR i$1[rbp]
	shl	rax, 2
	mov	QWORD PTR fat_offset$2[rbp], rax

; 172  : 		uint64_t fat_sector = fs->__FatBeginLBA + (fat_offset / 512);

	mov	rax, QWORD PTR fs$[rbp]
	mov	eax, DWORD PTR [rax+28]
	mov	QWORD PTR tv73[rbp], rax
	mov	rax, QWORD PTR fat_offset$2[rbp]
	cdq
	and	rdx, 511				; 000001ffH
	add	rax, rdx
	sar	rax, 9
	mov	rcx, QWORD PTR tv73[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR fat_sector$3[rbp], rax

; 173  : 		size_t ent_offset = fat_offset % 512;

	mov	rax, QWORD PTR fat_offset$2[rbp]
	cdq
	and	rdx, 511				; 000001ffH
	add	rax, rdx
	and	rax, 511				; 000001ffH
	sub	rax, rdx
	mov	QWORD PTR ent_offset$4[rbp], rax

; 174  : 		uint64_t *buffer = (uint64_t*)P2V((size_t)AuPmmngrAlloc());

	call	AuPmmngrAlloc
	mov	rcx, rax
	call	P2V
	mov	QWORD PTR buffer$5[rbp], rax

; 175  : 		memset(buffer, 0, PAGE_SIZE);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR buffer$5[rbp]
	call	memset

; 176  : 		AuVDiskRead(vdisk, fat_sector, 1, (uint64_t*)V2P((size_t)buffer));

	mov	rcx, QWORD PTR buffer$5[rbp]
	call	V2P
	mov	r9, rax
	mov	r8d, 1
	mov	rdx, QWORD PTR fat_sector$3[rbp]
	mov	rcx, QWORD PTR vdisk$[rbp]
	call	AuVDiskRead

; 177  : 		uint8_t* buf = (uint8_t*)buffer;

	mov	rax, QWORD PTR buffer$5[rbp]
	mov	QWORD PTR buf$6[rbp], rax

; 178  : 		uint32_t value = *(uint32_t*)&buf[ent_offset];

	mov	rax, QWORD PTR ent_offset$4[rbp]
	mov	rcx, QWORD PTR buf$6[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR value$7[rbp], eax

; 179  : 
; 180  : 		AuPmmngrFree((void*)V2P((size_t)buffer));

	mov	rcx, QWORD PTR buffer$5[rbp]
	call	V2P
	mov	rcx, rax
	call	AuPmmngrFree

; 181  : 		//! Found a free cluster return the value
; 182  : 		if (value == 0x00) {

	cmp	DWORD PTR value$7[rbp], 0
	jne	SHORT $LN6@FatFindFre

; 183  : 			return i;

	mov	eax, DWORD PTR i$1[rbp]
	jmp	SHORT $LN1@FatFindFre
$LN6@FatFindFre:

; 184  : 		}
; 185  : 	}

	jmp	$LN2@FatFindFre
$LN3@FatFindFre:

; 186  : 	return 0;

	xor	eax, eax
$LN1@FatFindFre:

; 187  : }

	lea	rsp, QWORD PTR [rbp+144]
	pop	rbp
	ret	0
?FatFindFreeCluster@@YAIPEAU__VFS_NODE__@@@Z ENDP	; FatFindFreeCluster
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Fs\Fat\Fat.cpp
;	COMDAT ?FatToDOSFilename@@YAXPEBDPEADI@Z
_TEXT	SEGMENT
i$ = 0
k$1 = 4
tv71 = 72
filename$ = 96
fname$ = 104
fname_length$ = 112
?FatToDOSFilename@@YAXPEBDPEADI@Z PROC			; FatToDOSFilename, COMDAT

; 74   : {

$LN19:
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__7C2BBDAD_Fat@cpp
	call	__CheckForDebuggerJustMyCode

; 75   : 	unsigned int i = 0;

	mov	DWORD PTR i$[rbp], 0

; 76   : 
; 77   : 	if (fname_length > 11)

	cmp	DWORD PTR fname_length$[rbp], 11
	jbe	SHORT $LN11@FatToDOSFi

; 78   : 		return;

	jmp	$LN1@FatToDOSFi
$LN11@FatToDOSFi:

; 79   : 
; 80   : 	if (!fname || !filename)

	cmp	QWORD PTR fname$[rbp], 0
	je	SHORT $LN13@FatToDOSFi
	cmp	QWORD PTR filename$[rbp], 0
	jne	SHORT $LN12@FatToDOSFi
$LN13@FatToDOSFi:

; 81   : 		return;

	jmp	$LN1@FatToDOSFi
$LN12@FatToDOSFi:

; 82   : 
; 83   : 	memset(fname, ' ', fname_length);

	mov	r8d, DWORD PTR fname_length$[rbp]
	mov	dl, 32					; 00000020H
	mov	rcx, QWORD PTR fname$[rbp]
	call	memset

; 84   : 
; 85   : 	for (i = 0; i < strlen(filename) && i < fname_length; i++)

	mov	DWORD PTR i$[rbp], 0
	jmp	SHORT $LN4@FatToDOSFi
$LN2@FatToDOSFi:
	mov	eax, DWORD PTR i$[rbp]
	inc	eax
	mov	DWORD PTR i$[rbp], eax
$LN4@FatToDOSFi:
	mov	eax, DWORD PTR i$[rbp]
	mov	QWORD PTR tv71[rbp], rax
	mov	rcx, QWORD PTR filename$[rbp]
	call	strlen
	mov	rcx, QWORD PTR tv71[rbp]
	cmp	rcx, rax
	jae	SHORT $LN3@FatToDOSFi
	mov	eax, DWORD PTR fname_length$[rbp]
	cmp	DWORD PTR i$[rbp], eax
	jae	SHORT $LN3@FatToDOSFi

; 86   : 	{
; 87   : 		if (filename[i] == '.' || i == 8)

	mov	eax, DWORD PTR i$[rbp]
	mov	rcx, QWORD PTR filename$[rbp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 46					; 0000002eH
	je	SHORT $LN15@FatToDOSFi
	cmp	DWORD PTR i$[rbp], 8
	jne	SHORT $LN14@FatToDOSFi
$LN15@FatToDOSFi:

; 88   : 			break;

	jmp	SHORT $LN3@FatToDOSFi
$LN14@FatToDOSFi:

; 89   : 
; 90   : 		fname[i] = toupper(filename[i]);

	mov	eax, DWORD PTR i$[rbp]
	mov	rcx, QWORD PTR filename$[rbp]
	movsx	eax, BYTE PTR [rcx+rax]
	mov	ecx, eax
	call	toupper
	mov	ecx, DWORD PTR i$[rbp]
	mov	rdx, QWORD PTR fname$[rbp]
	mov	BYTE PTR [rdx+rcx], al

; 91   : 	}

	jmp	SHORT $LN2@FatToDOSFi
$LN3@FatToDOSFi:

; 92   : 
; 93   : 	if (filename[i] == '.')

	mov	eax, DWORD PTR i$[rbp]
	mov	rcx, QWORD PTR filename$[rbp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 46					; 0000002eH
	jne	SHORT $LN16@FatToDOSFi

; 94   : 	{
; 95   : 		for (int k = 0; k < 3; k++)

	mov	DWORD PTR k$1[rbp], 0
	jmp	SHORT $LN7@FatToDOSFi
$LN5@FatToDOSFi:
	mov	eax, DWORD PTR k$1[rbp]
	inc	eax
	mov	DWORD PTR k$1[rbp], eax
$LN7@FatToDOSFi:
	cmp	DWORD PTR k$1[rbp], 3
	jge	SHORT $LN6@FatToDOSFi

; 96   : 		{
; 97   : 			++i;

	mov	eax, DWORD PTR i$[rbp]
	inc	eax
	mov	DWORD PTR i$[rbp], eax

; 98   : 			if (filename[i])

	mov	eax, DWORD PTR i$[rbp]
	mov	rcx, QWORD PTR filename$[rbp]
	movsx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN17@FatToDOSFi

; 99   : 				fname[8 + k] = filename[i];

	mov	eax, DWORD PTR i$[rbp]
	mov	ecx, DWORD PTR k$1[rbp]
	add	ecx, 8
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR fname$[rbp]
	mov	r8, QWORD PTR filename$[rbp]
	movzx	eax, BYTE PTR [r8+rax]
	mov	BYTE PTR [rdx+rcx], al
$LN17@FatToDOSFi:

; 100  : 		}

	jmp	SHORT $LN5@FatToDOSFi
$LN6@FatToDOSFi:
$LN16@FatToDOSFi:

; 101  : 	}
; 102  : 
; 103  : 	for (i = 0; i < 3; i++)

	mov	DWORD PTR i$[rbp], 0
	jmp	SHORT $LN10@FatToDOSFi
$LN8@FatToDOSFi:
	mov	eax, DWORD PTR i$[rbp]
	inc	eax
	mov	DWORD PTR i$[rbp], eax
$LN10@FatToDOSFi:
	cmp	DWORD PTR i$[rbp], 3
	jae	SHORT $LN9@FatToDOSFi

; 104  : 		fname[8 + i] = toupper(fname[8 + i]);

	mov	eax, DWORD PTR i$[rbp]
	add	eax, 8
	mov	eax, eax
	mov	rcx, QWORD PTR fname$[rbp]
	movsx	eax, BYTE PTR [rcx+rax]
	mov	ecx, eax
	call	toupper
	mov	ecx, DWORD PTR i$[rbp]
	add	ecx, 8
	mov	ecx, ecx
	mov	rdx, QWORD PTR fname$[rbp]
	mov	BYTE PTR [rdx+rcx], al
	jmp	SHORT $LN8@FatToDOSFi
$LN9@FatToDOSFi:
$LN1@FatToDOSFi:

; 105  : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
?FatToDOSFilename@@YAXPEBDPEADI@Z ENDP			; FatToDOSFilename
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Fs\Fat\Fat.cpp
;	COMDAT ?FatClusterToSector32@@YA_KPEAU_FatFS_@@_K@Z
_TEXT	SEGMENT
fs$ = 80
cluster$ = 88
?FatClusterToSector32@@YA_KPEAU_FatFS_@@_K@Z PROC	; FatClusterToSector32, COMDAT

; 62   : uint64_t FatClusterToSector32(FatFS *fs, uint64_t cluster) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__7C2BBDAD_Fat@cpp
	call	__CheckForDebuggerJustMyCode

; 63   : 	return fs->__ClusterBeginLBA + (cluster - 2) * fs->__SectorPerCluster;

	mov	rax, QWORD PTR fs$[rbp]
	mov	eax, DWORD PTR [rax+32]
	mov	rcx, QWORD PTR cluster$[rbp]
	sub	rcx, 2
	mov	rdx, QWORD PTR fs$[rbp]
	movzx	edx, BYTE PTR [rdx+36]
	imul	rcx, rdx
	add	rax, rcx

; 64   : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
?FatClusterToSector32@@YA_KPEAU_FatFS_@@_K@Z ENDP	; FatClusterToSector32
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Fs\Fat\Fat.cpp
;	COMDAT ?FatInitialise@@YAPEAU__VFS_NODE__@@PEAU_VDISK_@@PEAD@Z
_TEXT	SEGMENT
buffer$ = 0
bpb$ = 8
fs$ = 16
i$1 = 24
_root_dir_sectors$ = 32
_TotalSectors$ = 40
fatsize$ = 48
_dataSectors$ = 56
fsys$ = 64
tv207 = 136
tv197 = 136
tv178 = 136
vdisk$ = 160
mountname$ = 168
?FatInitialise@@YAPEAU__VFS_NODE__@@PEAU_VDISK_@@PEAD@Z PROC ; FatInitialise, COMDAT

; 544  : AuVFSNode* FatInitialise(AuVDisk *vdisk, char* mountname){

$LN16:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 176				; 000000b0H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__7C2BBDAD_Fat@cpp
	call	__CheckForDebuggerJustMyCode

; 545  : 	uint64_t* buffer = (uint64_t*)AuPmmngrAlloc();

	call	AuPmmngrAlloc
	mov	QWORD PTR buffer$[rbp], rax

; 546  : 	memset(buffer, 0, 4096);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR buffer$[rbp]
	call	memset

; 547  : 	AuVDiskRead(vdisk, 0, 1, buffer);

	mov	r9, QWORD PTR buffer$[rbp]
	mov	r8d, 1
	xor	edx, edx
	mov	rcx, QWORD PTR vdisk$[rbp]
	call	AuVDiskRead

; 548  : 
; 549  : 	FatBPB* bpb = (FatBPB*)buffer;

	mov	rax, QWORD PTR buffer$[rbp]
	mov	QWORD PTR bpb$[rbp], rax

; 550  : 
; 551  : 	FatFS *fs = (FatFS*)kmalloc(sizeof(FatFS));

	mov	ecx, 104				; 00000068H
	call	kmalloc
	mov	QWORD PTR fs$[rbp], rax

; 552  : 	memset(fs, 0, sizeof(FatFS));

	mov	r8d, 104				; 00000068H
	xor	edx, edx
	mov	rcx, QWORD PTR fs$[rbp]
	call	memset

; 553  : 
; 554  : 	fs->bpb = bpb;

	mov	rax, QWORD PTR fs$[rbp]
	mov	rcx, QWORD PTR bpb$[rbp]
	mov	QWORD PTR [rax], rcx

; 555  : 	fs->vdisk = vdisk;

	mov	rax, QWORD PTR fs$[rbp]
	mov	rcx, QWORD PTR vdisk$[rbp]
	mov	QWORD PTR [rax+8], rcx

; 556  : 
; 557  : 	for (int i = 0; i < 8; i++) {

	mov	DWORD PTR i$1[rbp], 0
	jmp	SHORT $LN4@FatInitial
$LN2@FatInitial:
	mov	eax, DWORD PTR i$1[rbp]
	inc	eax
	mov	DWORD PTR i$1[rbp], eax
$LN4@FatInitial:
	cmp	DWORD PTR i$1[rbp], 8
	jge	SHORT $LN3@FatInitial

; 558  : 		AuTextOut("%c", bpb->oemid[i]);

	movsxd	rax, DWORD PTR i$1[rbp]
	mov	rcx, QWORD PTR bpb$[rbp]
	movsx	eax, BYTE PTR [rcx+rax+3]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:??_C@_02HAOIJKIC@?$CFc@
	call	AuTextOut

; 559  : 		fs->oemid[i] = bpb->oemid[i];

	movsxd	rax, DWORD PTR i$1[rbp]
	movsxd	rcx, DWORD PTR i$1[rbp]
	mov	rdx, QWORD PTR fs$[rbp]
	mov	r8, QWORD PTR bpb$[rbp]
	movzx	eax, BYTE PTR [r8+rax+3]
	mov	BYTE PTR [rdx+rcx+16], al

; 560  : 	}

	jmp	SHORT $LN2@FatInitial
$LN3@FatInitial:

; 561  : 	fs->oemid[7] = '\0';

	mov	eax, 1
	imul	rax, rax, 7
	mov	rcx, QWORD PTR fs$[rbp]
	mov	BYTE PTR [rcx+rax+16], 0

; 562  : 	fs->__FatBeginLBA = bpb->reserved_sectors;

	mov	rax, QWORD PTR bpb$[rbp]
	movzx	eax, WORD PTR [rax+14]
	mov	rcx, QWORD PTR fs$[rbp]
	mov	DWORD PTR [rcx+28], eax

; 563  : 	fs->__ClusterBeginLBA = bpb->reserved_sectors + (bpb->num_fats* bpb->info.FAT32.sect_per_fat32);

	mov	rax, QWORD PTR bpb$[rbp]
	movzx	eax, WORD PTR [rax+14]
	mov	rcx, QWORD PTR bpb$[rbp]
	movzx	ecx, BYTE PTR [rcx+16]
	mov	rdx, QWORD PTR bpb$[rbp]
	imul	ecx, DWORD PTR [rdx+36]
	add	eax, ecx
	mov	rcx, QWORD PTR fs$[rbp]
	mov	DWORD PTR [rcx+32], eax

; 564  : 	fs->__SectorPerCluster = bpb->sectors_per_cluster;

	mov	rax, QWORD PTR fs$[rbp]
	mov	rcx, QWORD PTR bpb$[rbp]
	movzx	ecx, BYTE PTR [rcx+13]
	mov	BYTE PTR [rax+36], cl

; 565  : 	fs->__RootDirFirstCluster = bpb->info.FAT32.root_dir_cluster;

	mov	rax, QWORD PTR fs$[rbp]
	mov	rcx, QWORD PTR bpb$[rbp]
	mov	ecx, DWORD PTR [rcx+44]
	mov	DWORD PTR [rax+40], ecx

; 566  : 	fs->__RootSector = FatClusterToSector32(fs, fs->__RootDirFirstCluster);

	mov	rax, QWORD PTR fs$[rbp]
	mov	eax, DWORD PTR [rax+40]
	mov	edx, eax
	mov	rcx, QWORD PTR fs$[rbp]
	call	?FatClusterToSector32@@YA_KPEAU_FatFS_@@_K@Z ; FatClusterToSector32
	mov	rcx, QWORD PTR fs$[rbp]
	mov	DWORD PTR [rcx+44], eax

; 567  : 	fs->__SectorPerFAT32 = bpb->info.FAT32.sect_per_fat32;

	mov	rax, QWORD PTR fs$[rbp]
	mov	rcx, QWORD PTR bpb$[rbp]
	mov	ecx, DWORD PTR [rcx+36]
	mov	DWORD PTR [rax+48], ecx

; 568  : 	fs->cluster_sz_in_bytes = static_cast<int64_t>(fs->__SectorPerCluster) * bpb->bytes_per_sector;

	mov	rax, QWORD PTR fs$[rbp]
	movzx	eax, BYTE PTR [rax+36]
	mov	rcx, QWORD PTR bpb$[rbp]
	movzx	ecx, WORD PTR [rcx+11]
	imul	rax, rcx
	mov	rcx, QWORD PTR fs$[rbp]
	mov	QWORD PTR [rcx+72], rax

; 569  : 	fs->__BytesPerSector = bpb->bytes_per_sector;

	mov	rax, QWORD PTR fs$[rbp]
	mov	rcx, QWORD PTR bpb$[rbp]
	movzx	ecx, WORD PTR [rcx+11]
	mov	WORD PTR [rax+64], cx

; 570  : 	fs->fat_mutex = AuCreateMutex();

	call	AuCreateMutex
	mov	rcx, QWORD PTR fs$[rbp]
	mov	QWORD PTR [rcx+80], rax

; 571  : 	fs->fat_write_mutex = AuCreateMutex();

	call	AuCreateMutex
	mov	rcx, QWORD PTR fs$[rbp]
	mov	QWORD PTR [rcx+88], rax

; 572  : 	fs->fat_read_mutex = AuCreateMutex();

	call	AuCreateMutex
	mov	rcx, QWORD PTR fs$[rbp]
	mov	QWORD PTR [rcx+96], rax

; 573  : 	fs->__TotalClusters = bpb->large_sector_count / fs->__SectorPerCluster;

	mov	rax, QWORD PTR fs$[rbp]
	movzx	eax, BYTE PTR [rax+36]
	mov	DWORD PTR tv178[rbp], eax
	xor	edx, edx
	mov	rcx, QWORD PTR bpb$[rbp]
	mov	eax, DWORD PTR [rcx+32]
	mov	ecx, DWORD PTR tv178[rbp]
	div	ecx
	mov	rcx, QWORD PTR fs$[rbp]
	mov	DWORD PTR [rcx+52], eax

; 574  : 	size_t _root_dir_sectors = ((bpb->num_dir_entries * 32) + bpb->bytes_per_sector - 1) / bpb->bytes_per_sector;

	mov	rax, QWORD PTR bpb$[rbp]
	movzx	eax, WORD PTR [rax+17]
	imul	eax, eax, 32				; 00000020H
	mov	rcx, QWORD PTR bpb$[rbp]
	movzx	ecx, WORD PTR [rcx+11]
	lea	eax, DWORD PTR [rax+rcx-1]
	mov	rcx, QWORD PTR bpb$[rbp]
	movzx	ecx, WORD PTR [rcx+11]
	cdq
	idiv	ecx
	cdqe
	mov	QWORD PTR _root_dir_sectors$[rbp], rax

; 575  : 	size_t _TotalSectors = (bpb->total_sectors_short == 0) ? bpb->large_sector_count : bpb->total_sectors_short;

	mov	rax, QWORD PTR bpb$[rbp]
	movzx	eax, WORD PTR [rax+19]
	test	eax, eax
	jne	SHORT $LN12@FatInitial
	mov	rax, QWORD PTR bpb$[rbp]
	mov	eax, DWORD PTR [rax+32]
	mov	DWORD PTR tv197[rbp], eax
	jmp	SHORT $LN13@FatInitial
$LN12@FatInitial:
	mov	rax, QWORD PTR bpb$[rbp]
	movzx	eax, WORD PTR [rax+19]
	mov	DWORD PTR tv197[rbp], eax
$LN13@FatInitial:
	mov	eax, DWORD PTR tv197[rbp]
	mov	QWORD PTR _TotalSectors$[rbp], rax

; 576  : 	size_t fatsize = (bpb->sectors_per_fat == 0) ? bpb->info.FAT32.sect_per_fat32 : bpb->sectors_per_fat;

	mov	rax, QWORD PTR bpb$[rbp]
	movzx	eax, WORD PTR [rax+22]
	test	eax, eax
	jne	SHORT $LN14@FatInitial
	mov	rax, QWORD PTR bpb$[rbp]
	mov	eax, DWORD PTR [rax+36]
	mov	DWORD PTR tv207[rbp], eax
	jmp	SHORT $LN15@FatInitial
$LN14@FatInitial:
	mov	rax, QWORD PTR bpb$[rbp]
	movzx	eax, WORD PTR [rax+22]
	mov	DWORD PTR tv207[rbp], eax
$LN15@FatInitial:
	mov	eax, DWORD PTR tv207[rbp]
	mov	QWORD PTR fatsize$[rbp], rax

; 577  : 	size_t _dataSectors = _TotalSectors - (bpb->reserved_sectors + bpb->num_fats * fatsize + _root_dir_sectors);

	mov	rax, QWORD PTR bpb$[rbp]
	movzx	eax, WORD PTR [rax+14]
	mov	rcx, QWORD PTR bpb$[rbp]
	movzx	ecx, BYTE PTR [rcx+16]
	imul	rcx, QWORD PTR fatsize$[rbp]
	mov	rdx, QWORD PTR _root_dir_sectors$[rbp]
	add	rdx, rax
	mov	rax, rdx
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR _TotalSectors$[rbp]
	sub	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _dataSectors$[rbp], rax

; 578  : 	
; 579  : 	if (_dataSectors < 4085)

	cmp	QWORD PTR _dataSectors$[rbp], 4085	; 00000ff5H
	jae	SHORT $LN5@FatInitial

; 580  : 		fs->fatType = FSTYPE_FAT12;

	mov	rax, QWORD PTR fs$[rbp]
	mov	BYTE PTR [rax+24], 1
	jmp	SHORT $LN6@FatInitial
$LN5@FatInitial:

; 581  : 	else if (_dataSectors < 65525)

	cmp	QWORD PTR _dataSectors$[rbp], 65525	; 0000fff5H
	jae	SHORT $LN7@FatInitial

; 582  : 		fs->fatType = FSTYPE_FAT16;

	mov	rax, QWORD PTR fs$[rbp]
	mov	BYTE PTR [rax+24], 2
	jmp	SHORT $LN8@FatInitial
$LN7@FatInitial:

; 583  : 	else if (_dataSectors < 268435445)

	cmp	QWORD PTR _dataSectors$[rbp], 268435445	; 0ffffff5H
	jae	SHORT $LN9@FatInitial

; 584  : 		fs->fatType = FSTYPE_FAT32;

	mov	rax, QWORD PTR fs$[rbp]
	mov	BYTE PTR [rax+24], 3
$LN9@FatInitial:
$LN8@FatInitial:
$LN6@FatInitial:

; 585  : 
; 586  : 	if (fs->fatType != FSTYPE_FAT32) {

	mov	rax, QWORD PTR fs$[rbp]
	movzx	eax, BYTE PTR [rax+24]
	cmp	eax, 3
	je	SHORT $LN10@FatInitial

; 587  : 		AuPmmngrFree(buffer);

	mov	rcx, QWORD PTR buffer$[rbp]
	call	AuPmmngrFree

; 588  : 		kfree(fs);

	mov	rcx, QWORD PTR fs$[rbp]
	call	kfree

; 589  : 		return NULL;

	xor	eax, eax
	jmp	$LN1@FatInitial
$LN10@FatInitial:

; 590  : 	}
; 591  : 
; 592  : 	AuVFSNode* fsys = (AuVFSNode*)kmalloc(sizeof(AuVFSNode));

	mov	ecx, 178				; 000000b2H
	call	kmalloc
	mov	QWORD PTR fsys$[rbp], rax

; 593  : 	memset(fsys, 0, sizeof(AuVFSNode));

	mov	r8d, 178				; 000000b2H
	xor	edx, edx
	mov	rcx, QWORD PTR fsys$[rbp]
	call	memset

; 594  : 	strcpy(fsys->filename, mountname);

	mov	rax, QWORD PTR fsys$[rbp]
	mov	rdx, QWORD PTR mountname$[rbp]
	mov	rcx, rax
	call	strcpy

; 595  : 	fsys->flags |= FS_FLAG_FILE_SYSTEM;

	mov	rax, QWORD PTR fsys$[rbp]
	movzx	eax, WORD PTR [rax+61]
	or	eax, 64					; 00000040H
	mov	rcx, QWORD PTR fsys$[rbp]
	mov	WORD PTR [rcx+61], ax

; 596  : 	fsys->open = FatOpen;

	mov	rax, QWORD PTR fsys$[rbp]
	lea	rcx, OFFSET FLAT:?FatOpen@@YAPEAU__VFS_NODE__@@PEAU1@PEAD@Z ; FatOpen
	mov	QWORD PTR [rax+74], rcx

; 597  : 	fsys->device = fs;

	mov	rax, QWORD PTR fsys$[rbp]
	mov	rcx, QWORD PTR fs$[rbp]
	mov	QWORD PTR [rax+64], rcx

; 598  : 	fsys->read = FatReadFile;

	mov	rax, QWORD PTR fsys$[rbp]
	lea	rcx, OFFSET FLAT:?FatReadFile@@YA_KPEAU__VFS_NODE__@@0PEA_KI@Z ; FatReadFile
	mov	QWORD PTR [rax+90], rcx

; 599  : 	fsys->read_block = FatRead;

	mov	rax, QWORD PTR fsys$[rbp]
	lea	rcx, OFFSET FLAT:?FatRead@@YA_KPEAU__VFS_NODE__@@0PEA_K@Z ; FatRead
	mov	QWORD PTR [rax+146], rcx

; 600  : 	fsys->remove_dir = FatRemoveDir;

	mov	rax, QWORD PTR fsys$[rbp]
	lea	rcx, OFFSET FLAT:?FatRemoveDir@@YAHPEAU__VFS_NODE__@@0@Z ; FatRemoveDir
	mov	QWORD PTR [rax+122], rcx

; 601  : 	fsys->remove_file = FatFileRemove;

	mov	rax, QWORD PTR fsys$[rbp]
	lea	rcx, OFFSET FLAT:?FatFileRemove@@YAHPEAU__VFS_NODE__@@0@Z ; FatFileRemove
	mov	QWORD PTR [rax+130], rcx

; 602  : 	fsys->write = FatWrite;

	mov	rax, QWORD PTR fsys$[rbp]
	lea	rcx, OFFSET FLAT:?FatWrite@@YA_KPEAU__VFS_NODE__@@0PEA_KI@Z ; FatWrite
	mov	QWORD PTR [rax+98], rcx

; 603  : 	fsys->create_dir = FatCreateDir;

	mov	rax, QWORD PTR fsys$[rbp]
	lea	rcx, OFFSET FLAT:?FatCreateDir@@YAPEAU__VFS_NODE__@@PEAU1@PEAD@Z ; FatCreateDir
	mov	QWORD PTR [rax+106], rcx

; 604  : 	fsys->create_file = FatCreateFile;

	mov	rax, QWORD PTR fsys$[rbp]
	lea	rcx, OFFSET FLAT:?FatCreateFile@@YAPEAU__VFS_NODE__@@PEAU1@PEAD@Z ; FatCreateFile
	mov	QWORD PTR [rax+114], rcx

; 605  : 	fsys->get_blockfor = FatGetClusterFor;

	mov	rax, QWORD PTR fsys$[rbp]
	lea	rcx, OFFSET FLAT:?FatGetClusterFor@@YA_KPEAU__VFS_NODE__@@0_K@Z ; FatGetClusterFor
	mov	QWORD PTR [rax+162], rcx

; 606  : 	fsys->opendir = FatOpenDir;

	mov	rax, QWORD PTR fsys$[rbp]
	lea	rcx, OFFSET FLAT:?FatOpenDir@@YAPEAU__VFS_NODE__@@PEAU1@PEAD@Z ; FatOpenDir
	mov	QWORD PTR [rax+82], rcx

; 607  : 	fsys->read_dir = FatDirectoryRead;

	mov	rax, QWORD PTR fsys$[rbp]
	lea	rcx, OFFSET FLAT:?FatDirectoryRead@@YAHPEAU__VFS_NODE__@@0PEAU_AuDirectoryEnty_@@@Z ; FatDirectoryRead
	mov	QWORD PTR [rax+154], rcx

; 608  : 	vdisk->fsys = fsys;

	mov	rax, QWORD PTR vdisk$[rbp]
	mov	rcx, QWORD PTR fsys$[rbp]
	mov	QWORD PTR [rax+134], rcx

; 609  : 	AuVFSAddFileSystem(fsys);

	mov	rcx, QWORD PTR fsys$[rbp]
	call	AuVFSAddFileSystem

; 610  : 	AuVFSRegisterRoot(fsys);

	mov	rcx, QWORD PTR fsys$[rbp]
	call	AuVFSRegisterRoot

; 611  : 
; 612  : 	AuPmmngrFree(buffer);

	mov	rcx, QWORD PTR buffer$[rbp]
	call	AuPmmngrFree

; 613  : 
; 614  : 	return fsys;

	mov	rax, QWORD PTR fsys$[rbp]
$LN1@FatInitial:

; 615  : }

	lea	rsp, QWORD PTR [rbp+144]
	pop	rbp
	ret	0
?FatInitialise@@YAPEAU__VFS_NODE__@@PEAU_VDISK_@@PEAD@Z ENDP ; FatInitialise
_TEXT	ENDS
END
