; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30154.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?__RootContainer@@3PEAU__VFS_Container__@@EA	; __RootContainer
PUBLIC	?__RootFS@@3PEAU__VFS_NODE__@@EA		; __RootFS
PUBLIC	?_vfs_debug_on@@3_NA				; _vfs_debug_on
_BSS	SEGMENT
?__RootContainer@@3PEAU__VFS_Container__@@EA DQ 01H DUP (?) ; __RootContainer
?__RootFS@@3PEAU__VFS_NODE__@@EA DQ 01H DUP (?)		; __RootFS
?_vfs_debug_on@@3_NA DB 01H DUP (?)			; _vfs_debug_on
_BSS	ENDS
msvcjmc	SEGMENT
__D2E1A71C_vfs@cpp DB 01H
msvcjmc	ENDS
PUBLIC	?AuVFSInitialise@@YAXXZ				; AuVFSInitialise
PUBLIC	AuVFSOpen
PUBLIC	AuVFSNodeIOControl
PUBLIC	AuVFSAddFileSystem
PUBLIC	AuVFSRegisterRoot
PUBLIC	AuVFSFind
PUBLIC	AuVFSNodeRead
PUBLIC	AuVFSNodeReadBlock
PUBLIC	AuVFSCreateDir
PUBLIC	AuVFSCreateFile
PUBLIC	?AuVFSRemoveFile@@YAHPEAU__VFS_NODE__@@0@Z	; AuVFSRemoveFile
PUBLIC	?AuVFSRemoveDir@@YAHPEAU__VFS_NODE__@@0@Z	; AuVFSRemoveDir
PUBLIC	AuVFSNodeWrite
PUBLIC	AuVFSNodeClose
PUBLIC	AuVFSGetBlockFor
PUBLIC	AuVFSRemoveFileSystem
PUBLIC	__JustMyCode_Default
EXTRN	initialize_list:PROC
EXTRN	list_add:PROC
EXTRN	list_remove:PROC
EXTRN	list_get_at:PROC
EXTRN	kmalloc:PROC
EXTRN	kfree:PROC
EXTRN	?AuDeviceFsInitialize@@YAXXZ:PROC		; AuDeviceFsInitialize
EXTRN	strcmp:PROC
EXTRN	strchr:PROC
EXTRN	?AuPipeFSInitialise@@YAXXZ:PROC			; AuPipeFSInitialise
EXTRN	__CheckForDebuggerJustMyCode:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuVFSInitialise@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+94
	DD	imagerel $unwind$?AuVFSInitialise@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AuVFSOpen DD imagerel $LN16
	DD	imagerel $LN16+374
	DD	imagerel $unwind$AuVFSOpen
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AuVFSNodeIOControl DD imagerel $LN4
	DD	imagerel $LN4+87
	DD	imagerel $unwind$AuVFSNodeIOControl
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AuVFSAddFileSystem DD imagerel $LN7
	DD	imagerel $LN7+122
	DD	imagerel $unwind$AuVFSAddFileSystem
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AuVFSRegisterRoot DD imagerel $LN4
	DD	imagerel $LN4+56
	DD	imagerel $unwind$AuVFSRegisterRoot
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AuVFSFind DD imagerel $LN14
	DD	imagerel $LN14+297
	DD	imagerel $unwind$AuVFSFind
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AuVFSNodeRead DD imagerel $LN5
	DD	imagerel $LN5+98
	DD	imagerel $unwind$AuVFSNodeRead
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AuVFSNodeReadBlock DD imagerel $LN5
	DD	imagerel $LN5+108
	DD	imagerel $unwind$AuVFSNodeReadBlock
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AuVFSCreateDir DD imagerel $LN5
	DD	imagerel $LN5+91
	DD	imagerel $unwind$AuVFSCreateDir
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AuVFSCreateFile DD imagerel $LN5
	DD	imagerel $LN5+91
	DD	imagerel $unwind$AuVFSCreateFile
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuVFSRemoveFile@@YAHPEAU__VFS_NODE__@@0@Z DD imagerel $LN9
	DD	imagerel $LN9+167
	DD	imagerel $unwind$?AuVFSRemoveFile@@YAHPEAU__VFS_NODE__@@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuVFSRemoveDir@@YAHPEAU__VFS_NODE__@@0@Z DD imagerel $LN8
	DD	imagerel $LN8+144
	DD	imagerel $unwind$?AuVFSRemoveDir@@YAHPEAU__VFS_NODE__@@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AuVFSNodeWrite DD imagerel $LN5
	DD	imagerel $LN5+91
	DD	imagerel $unwind$AuVFSNodeWrite
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AuVFSNodeClose DD imagerel $LN4
	DD	imagerel $LN4+70
	DD	imagerel $unwind$AuVFSNodeClose
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AuVFSGetBlockFor DD imagerel $LN5
	DD	imagerel $LN5+95
	DD	imagerel $unwind$AuVFSGetBlockFor
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AuVFSRemoveFileSystem DD imagerel $LN9
	DD	imagerel $LN9+179
	DD	imagerel $unwind$AuVFSRemoveFileSystem
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AuVFSRemoveFileSystem DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AuVFSGetBlockFor DD 025031901H
	DD	0b2142319H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AuVFSNodeClose DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AuVFSNodeWrite DD 025031e01H
	DD	0b219231eH
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuVFSRemoveDir@@YAHPEAU__VFS_NODE__@@0@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuVFSRemoveFile@@YAHPEAU__VFS_NODE__@@0@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AuVFSCreateFile DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AuVFSCreateDir DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AuVFSNodeReadBlock DD 025031901H
	DD	0d2142319H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AuVFSNodeRead DD 025031e01H
	DD	0b219231eH
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AuVFSFind DD 025041201H
	DD	010d2312H
	DD	050060012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AuVFSRegisterRoot DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AuVFSAddFileSystem DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AuVFSNodeIOControl DD 025031801H
	DD	0d2132318H
	DD	0500fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AuVFSOpen DD 025041201H
	DD	010d2312H
	DD	050060014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuVFSInitialise@@YAXXZ DD 025030b01H
	DD	0d206230bH
	DD	05002H
xdata	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Fs\vfs.cpp
;	COMDAT AuVFSRemoveFileSystem
_TEXT	SEGMENT
index$ = 0
i$1 = 4
_node$2 = 8
node$ = 96
AuVFSRemoveFileSystem PROC				; COMDAT

; 311  : AU_EXTERN AU_EXPORT int AuVFSRemoveFileSystem(AuVFSNode* node) {

$LN9:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__D2E1A71C_vfs@cpp
	call	__CheckForDebuggerJustMyCode

; 312  : 	int index = 0;

	mov	DWORD PTR index$[rbp], 0

; 313  : 	for (int i = 0; i < __RootContainer->childs->pointer; i++) {

	mov	DWORD PTR i$1[rbp], 0
	jmp	SHORT $LN4@AuVFSRemov
$LN2@AuVFSRemov:
	mov	eax, DWORD PTR i$1[rbp]
	inc	eax
	mov	DWORD PTR i$1[rbp], eax
$LN4@AuVFSRemov:
	mov	rax, QWORD PTR ?__RootContainer@@3PEAU__VFS_Container__@@EA ; __RootContainer
	mov	rax, QWORD PTR [rax]
	mov	eax, DWORD PTR [rax]
	cmp	DWORD PTR i$1[rbp], eax
	jae	SHORT $LN3@AuVFSRemov

; 314  : 		AuVFSNode *_node = (AuVFSNode*)list_get_at(__RootContainer->childs, i);

	mov	edx, DWORD PTR i$1[rbp]
	mov	rax, QWORD PTR ?__RootContainer@@3PEAU__VFS_Container__@@EA ; __RootContainer
	mov	rcx, QWORD PTR [rax]
	call	list_get_at
	mov	QWORD PTR _node$2[rbp], rax

; 315  : 		if (_node == node){

	mov	rax, QWORD PTR node$[rbp]
	cmp	QWORD PTR _node$2[rbp], rax
	jne	SHORT $LN5@AuVFSRemov

; 316  : 			index = i;

	mov	eax, DWORD PTR i$1[rbp]
	mov	DWORD PTR index$[rbp], eax

; 317  : 			break;

	jmp	SHORT $LN3@AuVFSRemov
$LN5@AuVFSRemov:

; 318  : 		}
; 319  : 	}

	jmp	SHORT $LN2@AuVFSRemov
$LN3@AuVFSRemov:

; 320  : 	list_remove(__RootContainer->childs, index);

	mov	edx, DWORD PTR index$[rbp]
	mov	rax, QWORD PTR ?__RootContainer@@3PEAU__VFS_Container__@@EA ; __RootContainer
	mov	rcx, QWORD PTR [rax]
	call	list_remove

; 321  : 	if (node->close)

	mov	rax, QWORD PTR node$[rbp]
	cmp	QWORD PTR [rax+138], 0
	je	SHORT $LN6@AuVFSRemov

; 322  : 		return node->close(node, NULL);

	xor	edx, edx
	mov	rcx, QWORD PTR node$[rbp]
	mov	rax, QWORD PTR node$[rbp]
	call	QWORD PTR [rax+138]
	jmp	SHORT $LN1@AuVFSRemov
	jmp	SHORT $LN7@AuVFSRemov
$LN6@AuVFSRemov:

; 323  : 	else {
; 324  : 		kfree(node);

	mov	rcx, QWORD PTR node$[rbp]
	call	kfree

; 325  : 		return 0;

	xor	eax, eax
$LN7@AuVFSRemov:
$LN1@AuVFSRemov:

; 326  : 	}
; 327  : 
; 328  : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
AuVFSRemoveFileSystem ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Fs\vfs.cpp
;	COMDAT AuVFSGetBlockFor
_TEXT	SEGMENT
node$ = 80
file$ = 88
offset$ = 96
AuVFSGetBlockFor PROC					; COMDAT

; 337  : AU_EXTERN AU_EXPORT size_t AuVFSGetBlockFor(AuVFSNode* node, AuVFSNode* file, uint64_t offset) {

$LN5:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__D2E1A71C_vfs@cpp
	call	__CheckForDebuggerJustMyCode

; 338  : 	if (node){

	cmp	QWORD PTR node$[rbp], 0
	je	SHORT $LN2@AuVFSGetBl

; 339  : 		if (node->get_blockfor)

	mov	rax, QWORD PTR node$[rbp]
	cmp	QWORD PTR [rax+162], 0
	je	SHORT $LN3@AuVFSGetBl

; 340  : 			return node->get_blockfor(node, file, offset);

	mov	r8, QWORD PTR offset$[rbp]
	mov	rdx, QWORD PTR file$[rbp]
	mov	rcx, QWORD PTR node$[rbp]
	mov	rax, QWORD PTR node$[rbp]
	call	QWORD PTR [rax+162]
	jmp	SHORT $LN1@AuVFSGetBl
$LN3@AuVFSGetBl:
$LN2@AuVFSGetBl:

; 341  : 	}
; 342  : 	return -1;

	mov	rax, -1
$LN1@AuVFSGetBl:

; 343  : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
AuVFSGetBlockFor ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Fs\vfs.cpp
;	COMDAT AuVFSNodeClose
_TEXT	SEGMENT
node$ = 80
file$ = 88
AuVFSNodeClose PROC					; COMDAT

; 302  : AU_EXTERN AU_EXPORT void AuVFSNodeClose(AuVFSNode* node, AuVFSNode* file) {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__D2E1A71C_vfs@cpp
	call	__CheckForDebuggerJustMyCode

; 303  : 	if (node->close)

	mov	rax, QWORD PTR node$[rbp]
	cmp	QWORD PTR [rax+138], 0
	je	SHORT $LN2@AuVFSNodeC

; 304  : 		node->close(node, file);

	mov	rdx, QWORD PTR file$[rbp]
	mov	rcx, QWORD PTR node$[rbp]
	mov	rax, QWORD PTR node$[rbp]
	call	QWORD PTR [rax+138]
$LN2@AuVFSNodeC:

; 305  : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
AuVFSNodeClose ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Fs\vfs.cpp
;	COMDAT AuVFSNodeWrite
_TEXT	SEGMENT
node$ = 80
file$ = 88
buffer$ = 96
length$ = 104
AuVFSNodeWrite PROC					; COMDAT

; 210  : AU_EXTERN AU_EXPORT void AuVFSNodeWrite(AuVFSNode* node, AuVFSNode * file, uint64_t *buffer, uint32_t length) {

$LN5:
	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__D2E1A71C_vfs@cpp
	call	__CheckForDebuggerJustMyCode

; 211  : 	if (!node)

	cmp	QWORD PTR node$[rbp], 0
	jne	SHORT $LN2@AuVFSNodeW

; 212  : 		return;

	jmp	SHORT $LN1@AuVFSNodeW
$LN2@AuVFSNodeW:

; 213  : 	if (node->write)

	mov	rax, QWORD PTR node$[rbp]
	cmp	QWORD PTR [rax+98], 0
	je	SHORT $LN3@AuVFSNodeW

; 214  : 		node->write(node, file, buffer, length);

	mov	r9d, DWORD PTR length$[rbp]
	mov	r8, QWORD PTR buffer$[rbp]
	mov	rdx, QWORD PTR file$[rbp]
	mov	rcx, QWORD PTR node$[rbp]
	mov	rax, QWORD PTR node$[rbp]
	call	QWORD PTR [rax+98]
$LN3@AuVFSNodeW:
$LN1@AuVFSNodeW:

; 215  : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
AuVFSNodeWrite ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Fs\vfs.cpp
;	COMDAT ?AuVFSRemoveDir@@YAHPEAU__VFS_NODE__@@0@Z
_TEXT	SEGMENT
fsys$ = 80
file$ = 88
?AuVFSRemoveDir@@YAHPEAU__VFS_NODE__@@0@Z PROC		; AuVFSRemoveDir, COMDAT

; 285  : int AuVFSRemoveDir(AuVFSNode* fsys, AuVFSNode* file) {

$LN8:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__D2E1A71C_vfs@cpp
	call	__CheckForDebuggerJustMyCode

; 286  : 	if (!fsys)

	cmp	QWORD PTR fsys$[rbp], 0
	jne	SHORT $LN2@AuVFSRemov

; 287  : 		return -1;

	mov	eax, -1
	jmp	SHORT $LN1@AuVFSRemov
$LN2@AuVFSRemov:

; 288  : 	if (!file)

	cmp	QWORD PTR file$[rbp], 0
	jne	SHORT $LN3@AuVFSRemov

; 289  : 		return -1;

	mov	eax, -1
	jmp	SHORT $LN1@AuVFSRemov
$LN3@AuVFSRemov:

; 290  : 	if ((file->flags & FS_FLAG_DEVICE) || (file->flags & FS_FLAG_FILE_SYSTEM))

	mov	rax, QWORD PTR file$[rbp]
	movzx	eax, WORD PTR [rax+61]
	and	eax, 8
	test	eax, eax
	jne	SHORT $LN5@AuVFSRemov
	mov	rax, QWORD PTR file$[rbp]
	movzx	eax, WORD PTR [rax+61]
	and	eax, 64					; 00000040H
	test	eax, eax
	je	SHORT $LN4@AuVFSRemov
$LN5@AuVFSRemov:

; 291  : 		return -1;

	mov	eax, -1
	jmp	SHORT $LN1@AuVFSRemov
$LN4@AuVFSRemov:

; 292  : 	if (fsys->remove_dir && (file->flags & FS_FLAG_DIRECTORY))

	mov	rax, QWORD PTR fsys$[rbp]
	cmp	QWORD PTR [rax+122], 0
	je	SHORT $LN6@AuVFSRemov
	mov	rax, QWORD PTR file$[rbp]
	movzx	eax, WORD PTR [rax+61]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN6@AuVFSRemov

; 293  : 		return fsys->remove_dir(fsys, file);

	mov	rdx, QWORD PTR file$[rbp]
	mov	rcx, QWORD PTR fsys$[rbp]
	mov	rax, QWORD PTR fsys$[rbp]
	call	QWORD PTR [rax+122]
$LN6@AuVFSRemov:
$LN1@AuVFSRemov:

; 294  : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
?AuVFSRemoveDir@@YAHPEAU__VFS_NODE__@@0@Z ENDP		; AuVFSRemoveDir
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Fs\vfs.cpp
;	COMDAT ?AuVFSRemoveFile@@YAHPEAU__VFS_NODE__@@0@Z
_TEXT	SEGMENT
ret$ = 0
fsys$ = 96
file$ = 104
?AuVFSRemoveFile@@YAHPEAU__VFS_NODE__@@0@Z PROC		; AuVFSRemoveFile, COMDAT

; 265  : int AuVFSRemoveFile(AuVFSNode* fsys, AuVFSNode* file) {

$LN9:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__D2E1A71C_vfs@cpp
	call	__CheckForDebuggerJustMyCode

; 266  : 	if (!fsys)

	cmp	QWORD PTR fsys$[rbp], 0
	jne	SHORT $LN2@AuVFSRemov

; 267  : 		return -1;

	mov	eax, -1
	jmp	SHORT $LN1@AuVFSRemov
$LN2@AuVFSRemov:

; 268  : 	if (!file)

	cmp	QWORD PTR file$[rbp], 0
	jne	SHORT $LN3@AuVFSRemov

; 269  : 		return -1;

	mov	eax, -1
	jmp	SHORT $LN1@AuVFSRemov
$LN3@AuVFSRemov:

; 270  : 	if (!(file->flags & FS_FLAG_GENERAL))

	mov	rax, QWORD PTR file$[rbp]
	movzx	eax, WORD PTR [rax+61]
	and	eax, 4
	test	eax, eax
	jne	SHORT $LN4@AuVFSRemov

; 271  : 		return -1;

	mov	eax, -1
	jmp	SHORT $LN1@AuVFSRemov
$LN4@AuVFSRemov:

; 272  : 	if ((file->flags & FS_FLAG_DEVICE) || (file->flags & FS_FLAG_FILE_SYSTEM))

	mov	rax, QWORD PTR file$[rbp]
	movzx	eax, WORD PTR [rax+61]
	and	eax, 8
	test	eax, eax
	jne	SHORT $LN6@AuVFSRemov
	mov	rax, QWORD PTR file$[rbp]
	movzx	eax, WORD PTR [rax+61]
	and	eax, 64					; 00000040H
	test	eax, eax
	je	SHORT $LN5@AuVFSRemov
$LN6@AuVFSRemov:

; 273  : 		return -1;

	mov	eax, -1
	jmp	SHORT $LN1@AuVFSRemov
$LN5@AuVFSRemov:

; 274  : 	int ret = -1;

	mov	DWORD PTR ret$[rbp], -1

; 275  : 	if (fsys->remove_file) 

	mov	rax, QWORD PTR fsys$[rbp]
	cmp	QWORD PTR [rax+130], 0
	je	SHORT $LN7@AuVFSRemov

; 276  : 		ret = fsys->remove_file(fsys, file);

	mov	rdx, QWORD PTR file$[rbp]
	mov	rcx, QWORD PTR fsys$[rbp]
	mov	rax, QWORD PTR fsys$[rbp]
	call	QWORD PTR [rax+130]
	mov	DWORD PTR ret$[rbp], eax
$LN7@AuVFSRemov:
$LN1@AuVFSRemov:

; 277  : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
?AuVFSRemoveFile@@YAHPEAU__VFS_NODE__@@0@Z ENDP		; AuVFSRemoveFile
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Fs\vfs.cpp
;	COMDAT AuVFSCreateFile
_TEXT	SEGMENT
ret$ = 0
fsys$ = 96
filename$ = 104
AuVFSCreateFile PROC					; COMDAT

; 251  : AU_EXTERN AU_EXPORT AuVFSNode* AuVFSCreateFile(AuVFSNode* fsys, char* filename){

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__D2E1A71C_vfs@cpp
	call	__CheckForDebuggerJustMyCode

; 252  : 	if (!fsys)

	cmp	QWORD PTR fsys$[rbp], 0
	jne	SHORT $LN2@AuVFSCreat

; 253  : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@AuVFSCreat
$LN2@AuVFSCreat:

; 254  : 	AuVFSNode* ret = NULL;

	mov	QWORD PTR ret$[rbp], 0

; 255  : 	if (fsys->create_file)

	mov	rax, QWORD PTR fsys$[rbp]
	cmp	QWORD PTR [rax+114], 0
	je	SHORT $LN3@AuVFSCreat

; 256  : 		ret = fsys->create_file(fsys, filename);

	mov	rdx, QWORD PTR filename$[rbp]
	mov	rcx, QWORD PTR fsys$[rbp]
	mov	rax, QWORD PTR fsys$[rbp]
	call	QWORD PTR [rax+114]
	mov	QWORD PTR ret$[rbp], rax
$LN3@AuVFSCreat:

; 257  : 	return ret;

	mov	rax, QWORD PTR ret$[rbp]
$LN1@AuVFSCreat:

; 258  : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
AuVFSCreateFile ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Fs\vfs.cpp
;	COMDAT AuVFSCreateDir
_TEXT	SEGMENT
ret$ = 0
fsys$ = 96
dirname$ = 104
AuVFSCreateDir PROC					; COMDAT

; 237  : AU_EXTERN AU_EXPORT AuVFSNode* AuVFSCreateDir(AuVFSNode* fsys, char* dirname) {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__D2E1A71C_vfs@cpp
	call	__CheckForDebuggerJustMyCode

; 238  : 	if (!fsys)

	cmp	QWORD PTR fsys$[rbp], 0
	jne	SHORT $LN2@AuVFSCreat

; 239  : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@AuVFSCreat
$LN2@AuVFSCreat:

; 240  : 	AuVFSNode* ret = NULL;

	mov	QWORD PTR ret$[rbp], 0

; 241  : 	if (fsys->create_dir)

	mov	rax, QWORD PTR fsys$[rbp]
	cmp	QWORD PTR [rax+106], 0
	je	SHORT $LN3@AuVFSCreat

; 242  : 		ret = fsys->create_dir(fsys, dirname);

	mov	rdx, QWORD PTR dirname$[rbp]
	mov	rcx, QWORD PTR fsys$[rbp]
	mov	rax, QWORD PTR fsys$[rbp]
	call	QWORD PTR [rax+106]
	mov	QWORD PTR ret$[rbp], rax
$LN3@AuVFSCreat:

; 243  : 	return ret;

	mov	rax, QWORD PTR ret$[rbp]
$LN1@AuVFSCreat:

; 244  : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
AuVFSCreateDir ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Fs\vfs.cpp
;	COMDAT AuVFSNodeReadBlock
_TEXT	SEGMENT
read_bytes$ = 0
node$ = 96
file$ = 104
buffer$ = 112
AuVFSNodeReadBlock PROC					; COMDAT

; 223  : AU_EXTERN AU_EXPORT size_t AuVFSNodeReadBlock(AuVFSNode* node, AuVFSNode* file, uint64_t *buffer) {

$LN5:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__D2E1A71C_vfs@cpp
	call	__CheckForDebuggerJustMyCode

; 224  : 	size_t read_bytes = 0;

	mov	QWORD PTR read_bytes$[rbp], 0

; 225  : 	if (!node)

	cmp	QWORD PTR node$[rbp], 0
	jne	SHORT $LN2@AuVFSNodeR

; 226  : 		return read_bytes;

	mov	rax, QWORD PTR read_bytes$[rbp]
	jmp	SHORT $LN1@AuVFSNodeR
$LN2@AuVFSNodeR:

; 227  : 	if (node->read_block)

	mov	rax, QWORD PTR node$[rbp]
	cmp	QWORD PTR [rax+146], 0
	je	SHORT $LN3@AuVFSNodeR

; 228  : 		read_bytes = node->read_block(node, file, buffer);

	mov	r8, QWORD PTR buffer$[rbp]
	mov	rdx, QWORD PTR file$[rbp]
	mov	rcx, QWORD PTR node$[rbp]
	mov	rax, QWORD PTR node$[rbp]
	call	QWORD PTR [rax+146]
	mov	QWORD PTR read_bytes$[rbp], rax
$LN3@AuVFSNodeR:

; 229  : 	return read_bytes;

	mov	rax, QWORD PTR read_bytes$[rbp]
$LN1@AuVFSNodeR:

; 230  : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
AuVFSNodeReadBlock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Fs\vfs.cpp
;	COMDAT AuVFSNodeRead
_TEXT	SEGMENT
node$ = 80
file$ = 88
buffer$ = 96
length$ = 104
AuVFSNodeRead PROC					; COMDAT

; 195  : AU_EXTERN AU_EXPORT size_t AuVFSNodeRead(AuVFSNode* node, AuVFSNode* file, uint64_t* buffer, uint32_t length) {

$LN5:
	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__D2E1A71C_vfs@cpp
	call	__CheckForDebuggerJustMyCode

; 196  : 	if (node) {

	cmp	QWORD PTR node$[rbp], 0
	je	SHORT $LN2@AuVFSNodeR

; 197  : 		if (node->read)

	mov	rax, QWORD PTR node$[rbp]
	cmp	QWORD PTR [rax+90], 0
	je	SHORT $LN3@AuVFSNodeR

; 198  : 			return node->read(node, file, buffer, length);

	mov	r9d, DWORD PTR length$[rbp]
	mov	r8, QWORD PTR buffer$[rbp]
	mov	rdx, QWORD PTR file$[rbp]
	mov	rcx, QWORD PTR node$[rbp]
	mov	rax, QWORD PTR node$[rbp]
	call	QWORD PTR [rax+90]
	jmp	SHORT $LN1@AuVFSNodeR
$LN3@AuVFSNodeR:
$LN2@AuVFSNodeR:

; 199  : 	}
; 200  : 	return -1;

	mov	rax, -1
$LN1@AuVFSNodeR:

; 201  : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
AuVFSNodeRead ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Fs\vfs.cpp
;	COMDAT AuVFSFind
_TEXT	SEGMENT
Returnable$ = 0
next$ = 8
pathname$ = 16
i$ = 32
j$1 = 36
node$2 = 40
path$ = 128
AuVFSFind PROC						; COMDAT

; 68   : AuVFSNode* AuVFSFind(char* path) {

$LN14:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 144				; 00000090H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__D2E1A71C_vfs@cpp
	call	__CheckForDebuggerJustMyCode

; 69   : 
; 70   : 	AuVFSNode* Returnable = NULL;

	mov	QWORD PTR Returnable$[rbp], 0

; 71   : 	/* first of all search all file system 
; 72   : 	 * skipping '/' of the path 
; 73   : 	 */
; 74   : 	char* next = strchr(path, '/');

	mov	edx, 47					; 0000002fH
	mov	rcx, QWORD PTR path$[rbp]
	call	strchr
	mov	QWORD PTR next$[rbp], rax

; 75   : 	if (next)

	cmp	QWORD PTR next$[rbp], 0
	je	SHORT $LN8@AuVFSFind

; 76   : 		next++;

	mov	rax, QWORD PTR next$[rbp]
	inc	rax
	mov	QWORD PTR next$[rbp], rax
$LN8@AuVFSFind:

; 77   : 
; 78   : 	char pathname[16];
; 79   : 	int i;
; 80   : 	for (i = 0; i < 16; i++) {

	mov	DWORD PTR i$[rbp], 0
	jmp	SHORT $LN4@AuVFSFind
$LN2@AuVFSFind:
	mov	eax, DWORD PTR i$[rbp]
	inc	eax
	mov	DWORD PTR i$[rbp], eax
$LN4@AuVFSFind:
	cmp	DWORD PTR i$[rbp], 16
	jge	SHORT $LN3@AuVFSFind

; 81   : 		if (next[i] == '/' || next[i] == '\0')

	movsxd	rax, DWORD PTR i$[rbp]
	mov	rcx, QWORD PTR next$[rbp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 47					; 0000002fH
	je	SHORT $LN10@AuVFSFind
	movsxd	rax, DWORD PTR i$[rbp]
	mov	rcx, QWORD PTR next$[rbp]
	movsx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	jne	SHORT $LN9@AuVFSFind
$LN10@AuVFSFind:

; 82   : 			break;

	jmp	SHORT $LN3@AuVFSFind
$LN9@AuVFSFind:

; 83   : 		pathname[i] = next[i];

	movsxd	rax, DWORD PTR i$[rbp]
	movsxd	rcx, DWORD PTR i$[rbp]
	mov	rdx, QWORD PTR next$[rbp]
	movzx	eax, BYTE PTR [rdx+rax]
	mov	BYTE PTR pathname$[rbp+rcx], al

; 84   : 	}

	jmp	SHORT $LN2@AuVFSFind
$LN3@AuVFSFind:

; 85   : 	pathname[i] = 0;

	movsxd	rax, DWORD PTR i$[rbp]
	mov	BYTE PTR pathname$[rbp+rax], 0

; 86   : 
; 87   : 	for (int j = 0; j < __RootContainer->childs->pointer; j++) {

	mov	DWORD PTR j$1[rbp], 0
	jmp	SHORT $LN7@AuVFSFind
$LN5@AuVFSFind:
	mov	eax, DWORD PTR j$1[rbp]
	inc	eax
	mov	DWORD PTR j$1[rbp], eax
$LN7@AuVFSFind:
	mov	rax, QWORD PTR ?__RootContainer@@3PEAU__VFS_Container__@@EA ; __RootContainer
	mov	rax, QWORD PTR [rax]
	mov	eax, DWORD PTR [rax]
	cmp	DWORD PTR j$1[rbp], eax
	jae	SHORT $LN6@AuVFSFind

; 88   : 		AuVFSNode* node = (AuVFSNode*)list_get_at(__RootContainer->childs, j);

	mov	edx, DWORD PTR j$1[rbp]
	mov	rax, QWORD PTR ?__RootContainer@@3PEAU__VFS_Container__@@EA ; __RootContainer
	mov	rcx, QWORD PTR [rax]
	call	list_get_at
	mov	QWORD PTR node$2[rbp], rax

; 89   : 		if ((strcmp(node->filename, pathname) == 0) && (node->flags & FS_FLAG_FILE_SYSTEM)) {

	mov	rax, QWORD PTR node$2[rbp]
	lea	rdx, QWORD PTR pathname$[rbp]
	mov	rcx, rax
	call	strcmp
	test	eax, eax
	jne	SHORT $LN11@AuVFSFind
	mov	rax, QWORD PTR node$2[rbp]
	movzx	eax, WORD PTR [rax+61]
	and	eax, 64					; 00000040H
	test	eax, eax
	je	SHORT $LN11@AuVFSFind

; 90   : 			Returnable = node;

	mov	rax, QWORD PTR node$2[rbp]
	mov	QWORD PTR Returnable$[rbp], rax

; 91   : 			break;

	jmp	SHORT $LN6@AuVFSFind
$LN11@AuVFSFind:

; 92   : 		}
; 93   : 	}

	jmp	SHORT $LN5@AuVFSFind
$LN6@AuVFSFind:

; 94   : 
; 95   : 	if (!Returnable)

	cmp	QWORD PTR Returnable$[rbp], 0
	jne	SHORT $LN12@AuVFSFind

; 96   : 		Returnable = __RootFS;

	mov	rax, QWORD PTR ?__RootFS@@3PEAU__VFS_NODE__@@EA ; __RootFS
	mov	QWORD PTR Returnable$[rbp], rax
$LN12@AuVFSFind:

; 97   : 
; 98   : 	return Returnable;

	mov	rax, QWORD PTR Returnable$[rbp]

; 99   : }

	lea	rsp, QWORD PTR [rbp+112]
	pop	rbp
	ret	0
AuVFSFind ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Fs\vfs.cpp
;	COMDAT AuVFSRegisterRoot
_TEXT	SEGMENT
fs$ = 80
AuVFSRegisterRoot PROC					; COMDAT

; 122  : void AuVFSRegisterRoot(AuVFSNode *fs) {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__D2E1A71C_vfs@cpp
	call	__CheckForDebuggerJustMyCode

; 123  : 	if (__RootFS)

	cmp	QWORD PTR ?__RootFS@@3PEAU__VFS_NODE__@@EA, 0 ; __RootFS
	je	SHORT $LN2@AuVFSRegis

; 124  : 		return;

	jmp	SHORT $LN1@AuVFSRegis
$LN2@AuVFSRegis:

; 125  : 	__RootFS = fs;

	mov	rax, QWORD PTR fs$[rbp]
	mov	QWORD PTR ?__RootFS@@3PEAU__VFS_NODE__@@EA, rax ; __RootFS
$LN1@AuVFSRegis:

; 126  : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
AuVFSRegisterRoot ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Fs\vfs.cpp
;	COMDAT AuVFSAddFileSystem
_TEXT	SEGMENT
i$1 = 0
node_$2 = 8
node$ = 96
AuVFSAddFileSystem PROC					; COMDAT

; 107  : AU_EXTERN AU_EXPORT void AuVFSAddFileSystem(AuVFSNode* node) {

$LN7:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__D2E1A71C_vfs@cpp
	call	__CheckForDebuggerJustMyCode

; 108  : 	for (int i = 0; i < __RootContainer->childs->pointer; i++) {

	mov	DWORD PTR i$1[rbp], 0
	jmp	SHORT $LN4@AuVFSAddFi
$LN2@AuVFSAddFi:
	mov	eax, DWORD PTR i$1[rbp]
	inc	eax
	mov	DWORD PTR i$1[rbp], eax
$LN4@AuVFSAddFi:
	mov	rax, QWORD PTR ?__RootContainer@@3PEAU__VFS_Container__@@EA ; __RootContainer
	mov	rax, QWORD PTR [rax]
	mov	eax, DWORD PTR [rax]
	cmp	DWORD PTR i$1[rbp], eax
	jae	SHORT $LN3@AuVFSAddFi

; 109  : 		AuVFSNode* node_ = (AuVFSNode*)list_get_at(__RootContainer->childs, i);

	mov	edx, DWORD PTR i$1[rbp]
	mov	rax, QWORD PTR ?__RootContainer@@3PEAU__VFS_Container__@@EA ; __RootContainer
	mov	rcx, QWORD PTR [rax]
	call	list_get_at
	mov	QWORD PTR node_$2[rbp], rax

; 110  : 		if (node_ == node)

	mov	rax, QWORD PTR node$[rbp]
	cmp	QWORD PTR node_$2[rbp], rax
	jne	SHORT $LN5@AuVFSAddFi

; 111  : 			return;

	jmp	SHORT $LN1@AuVFSAddFi
$LN5@AuVFSAddFi:

; 112  : 	}

	jmp	SHORT $LN2@AuVFSAddFi
$LN3@AuVFSAddFi:

; 113  : 	list_add(__RootContainer->childs, node);

	mov	rdx, QWORD PTR node$[rbp]
	mov	rax, QWORD PTR ?__RootContainer@@3PEAU__VFS_Container__@@EA ; __RootContainer
	mov	rcx, QWORD PTR [rax]
	call	list_add
$LN1@AuVFSAddFi:

; 114  : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
AuVFSAddFileSystem ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Fs\vfs.cpp
;	COMDAT AuVFSNodeIOControl
_TEXT	SEGMENT
val$1 = 0
node$ = 96
code$ = 104
arg$ = 112
AuVFSNodeIOControl PROC					; COMDAT

; 180  : AU_EXTERN AU_EXPORT int AuVFSNodeIOControl(AuVFSNode* node, int code, void* arg) {

$LN4:
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__D2E1A71C_vfs@cpp
	call	__CheckForDebuggerJustMyCode

; 181  : 	if (node->iocontrol){

	mov	rax, QWORD PTR node$[rbp]
	cmp	QWORD PTR [rax+170], 0
	je	SHORT $LN2@AuVFSNodeI

; 182  : 		int val = node->iocontrol(node, code, arg);

	mov	r8, QWORD PTR arg$[rbp]
	mov	edx, DWORD PTR code$[rbp]
	mov	rcx, QWORD PTR node$[rbp]
	mov	rax, QWORD PTR node$[rbp]
	call	QWORD PTR [rax+170]
	mov	DWORD PTR val$1[rbp], eax

; 183  : 		return val;

	mov	eax, DWORD PTR val$1[rbp]
	jmp	SHORT $LN1@AuVFSNodeI
$LN2@AuVFSNodeI:

; 184  : 	}
; 185  : 	return 0;

	xor	eax, eax
$LN1@AuVFSNodeI:

; 186  : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
AuVFSNodeIOControl ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Fs\vfs.cpp
;	COMDAT AuVFSOpen
_TEXT	SEGMENT
Returnable$ = 0
fs$ = 8
next$1 = 16
next$2 = 24
pathname$3 = 32
i$4 = 48
path$ = 144
AuVFSOpen PROC						; COMDAT

; 133  : AU_EXTERN AU_EXPORT AuVFSNode* AuVFSOpen(char* path){

$LN16:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 160				; 000000a0H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__D2E1A71C_vfs@cpp
	call	__CheckForDebuggerJustMyCode

; 134  : 	AuVFSNode *Returnable = NULL;

	mov	QWORD PTR Returnable$[rbp], 0

; 135  : 	AuVFSNode* fs = AuVFSFind(path);

	mov	rcx, QWORD PTR path$[rbp]
	call	AuVFSFind
	mov	QWORD PTR fs$[rbp], rax

; 136  : 	
; 137  : 	if (!fs)

	cmp	QWORD PTR fs$[rbp], 0
	jne	SHORT $LN5@AuVFSOpen

; 138  : 		return NULL;

	xor	eax, eax
	jmp	$LN1@AuVFSOpen
$LN5@AuVFSOpen:

; 139  : 	if (fs == __RootFS) {

	mov	rax, QWORD PTR ?__RootFS@@3PEAU__VFS_NODE__@@EA ; __RootFS
	cmp	QWORD PTR fs$[rbp], rax
	jne	SHORT $LN6@AuVFSOpen

; 140  : 		
; 141  : 		/* just skip the '/' from the path */
; 142  : 		char* next = strchr(path, '/');

	mov	edx, 47					; 0000002fH
	mov	rcx, QWORD PTR path$[rbp]
	call	strchr
	mov	QWORD PTR next$1[rbp], rax

; 143  : 		if (next)

	cmp	QWORD PTR next$1[rbp], 0
	je	SHORT $LN8@AuVFSOpen

; 144  : 			next++;

	mov	rax, QWORD PTR next$1[rbp]
	inc	rax
	mov	QWORD PTR next$1[rbp], rax
$LN8@AuVFSOpen:

; 145  : 
; 146  : 		if (fs->open)

	mov	rax, QWORD PTR fs$[rbp]
	cmp	QWORD PTR [rax+74], 0
	je	SHORT $LN9@AuVFSOpen

; 147  : 			Returnable = fs->open(fs, path);

	mov	rdx, QWORD PTR path$[rbp]
	mov	rcx, QWORD PTR fs$[rbp]
	mov	rax, QWORD PTR fs$[rbp]
	call	QWORD PTR [rax+74]
	mov	QWORD PTR Returnable$[rbp], rax
$LN9@AuVFSOpen:

; 148  : 
; 149  : 	}

	jmp	$LN7@AuVFSOpen
$LN6@AuVFSOpen:

; 150  : 	else {
; 151  : 		char* next = strchr(path, '/');

	mov	edx, 47					; 0000002fH
	mov	rcx, QWORD PTR path$[rbp]
	call	strchr
	mov	QWORD PTR next$2[rbp], rax

; 152  : 		if (next)

	cmp	QWORD PTR next$2[rbp], 0
	je	SHORT $LN10@AuVFSOpen

; 153  : 			next++;

	mov	rax, QWORD PTR next$2[rbp]
	inc	rax
	mov	QWORD PTR next$2[rbp], rax
$LN10@AuVFSOpen:

; 154  : 
; 155  : 		char pathname[16];
; 156  : 		int i = 0;

	mov	DWORD PTR i$4[rbp], 0

; 157  : 		for (i = 0; i < 16; i++) {

	mov	DWORD PTR i$4[rbp], 0
	jmp	SHORT $LN4@AuVFSOpen
$LN2@AuVFSOpen:
	mov	eax, DWORD PTR i$4[rbp]
	inc	eax
	mov	DWORD PTR i$4[rbp], eax
$LN4@AuVFSOpen:
	cmp	DWORD PTR i$4[rbp], 16
	jge	SHORT $LN3@AuVFSOpen

; 158  : 			if ((next[i] == '/') || (next[i] == '\0'))

	movsxd	rax, DWORD PTR i$4[rbp]
	mov	rcx, QWORD PTR next$2[rbp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 47					; 0000002fH
	je	SHORT $LN12@AuVFSOpen
	movsxd	rax, DWORD PTR i$4[rbp]
	mov	rcx, QWORD PTR next$2[rbp]
	movsx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	jne	SHORT $LN11@AuVFSOpen
$LN12@AuVFSOpen:

; 159  : 				break;

	jmp	SHORT $LN3@AuVFSOpen
$LN11@AuVFSOpen:

; 160  : 			pathname[i] = next[i];

	movsxd	rax, DWORD PTR i$4[rbp]
	movsxd	rcx, DWORD PTR i$4[rbp]
	mov	rdx, QWORD PTR next$2[rbp]
	movzx	eax, BYTE PTR [rdx+rax]
	mov	BYTE PTR pathname$3[rbp+rcx], al

; 161  : 		}

	jmp	SHORT $LN2@AuVFSOpen
$LN3@AuVFSOpen:

; 162  : 		pathname[i] = 0;

	movsxd	rax, DWORD PTR i$4[rbp]
	mov	BYTE PTR pathname$3[rbp+rax], 0

; 163  : 
; 164  : 		/* skip the fs filename, from the path
; 165  : 		 * and just pass the required path */
; 166  : 		if (strcmp(fs->filename, pathname) == 0) 

	mov	rax, QWORD PTR fs$[rbp]
	lea	rdx, QWORD PTR pathname$3[rbp]
	mov	rcx, rax
	call	strcmp
	test	eax, eax
	jne	SHORT $LN13@AuVFSOpen

; 167  : 			next += i;

	movsxd	rax, DWORD PTR i$4[rbp]
	mov	rcx, QWORD PTR next$2[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR next$2[rbp], rax
$LN13@AuVFSOpen:

; 168  : 		if (fs->open)

	mov	rax, QWORD PTR fs$[rbp]
	cmp	QWORD PTR [rax+74], 0
	je	SHORT $LN14@AuVFSOpen

; 169  : 			Returnable = fs->open(fs,next);

	mov	rdx, QWORD PTR next$2[rbp]
	mov	rcx, QWORD PTR fs$[rbp]
	mov	rax, QWORD PTR fs$[rbp]
	call	QWORD PTR [rax+74]
	mov	QWORD PTR Returnable$[rbp], rax
$LN14@AuVFSOpen:
$LN7@AuVFSOpen:

; 170  : 	}
; 171  : 	return Returnable;

	mov	rax, QWORD PTR Returnable$[rbp]
$LN1@AuVFSOpen:

; 172  : }

	lea	rsp, QWORD PTR [rbp+128]
	pop	rbp
	ret	0
AuVFSOpen ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Fs\vfs.cpp
;	COMDAT ?AuVFSInitialise@@YAXXZ
_TEXT	SEGMENT
_root$ = 0
?AuVFSInitialise@@YAXXZ PROC				; AuVFSInitialise, COMDAT

; 48   : void AuVFSInitialise() {

$LN3:
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__D2E1A71C_vfs@cpp
	call	__CheckForDebuggerJustMyCode

; 49   : 	AuVFSContainer* _root = (AuVFSContainer*)kmalloc(sizeof(AuVFSContainer));

	mov	ecx, 8
	call	kmalloc
	mov	QWORD PTR _root$[rbp], rax

; 50   : 	_root->childs = initialize_list();

	call	initialize_list
	mov	rcx, QWORD PTR _root$[rbp]
	mov	QWORD PTR [rcx], rax

; 51   : 	__RootContainer = _root;

	mov	rax, QWORD PTR _root$[rbp]
	mov	QWORD PTR ?__RootContainer@@3PEAU__VFS_Container__@@EA, rax ; __RootContainer

; 52   : 	__RootFS = NULL;

	mov	QWORD PTR ?__RootFS@@3PEAU__VFS_NODE__@@EA, 0 ; __RootFS

; 53   : 	_vfs_debug_on = false;

	mov	BYTE PTR ?_vfs_debug_on@@3_NA, 0	; _vfs_debug_on

; 54   : 	/* initialise the device file system */
; 55   : 	AuDeviceFsInitialize();

	call	?AuDeviceFsInitialize@@YAXXZ		; AuDeviceFsInitialize

; 56   : 	AuPipeFSInitialise();

	call	?AuPipeFSInitialise@@YAXXZ		; AuPipeFSInitialise

; 57   : 	/* here we need to mount the
; 58   : 	 * root file system
; 59   : 	 */
; 60   : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
?AuVFSInitialise@@YAXXZ ENDP				; AuVFSInitialise
_TEXT	ENDS
END
