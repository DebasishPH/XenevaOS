; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.21005.1 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG3242	DB	'GPT Partition with Windows Partition data ', 0aH, 00H
$SG3243	DB	'/', 00H
CONST	ENDS
PUBLIC	AuGUIDVerify
PUBLIC	?AuGPTInitialise_FileSystem@@YAXPEAU_VDISK_@@@Z	; AuGPTInitialise_FileSystem
EXTRN	?FatInitialise@@YAPEAU__VFS_NODE__@@PEAU_VDISK_@@PEAD@Z:PROC ; FatInitialise
EXTRN	AuTextOut:PROC
pdata	SEGMENT
$pdata$AuGUIDVerify DD imagerel $LN10
	DD	imagerel $LN10+186
	DD	imagerel $unwind$AuGUIDVerify
$pdata$?AuGPTInitialise_FileSystem@@YAXPEAU_VDISK_@@@Z DD imagerel $LN4
	DD	imagerel $LN4+184
	DD	imagerel $unwind$?AuGPTInitialise_FileSystem@@YAXPEAU_VDISK_@@@Z
pdata	ENDS
xdata	SEGMENT
$unwind$AuGUIDVerify DD 010e01H
	DD	0220eH
$unwind$?AuGPTInitialise_FileSystem@@YAXPEAU_VDISK_@@@Z DD 030b01H
	DD	07007a20bH
	DD	06006H
xdata	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\fs\_gpt.cpp
_TEXT	SEGMENT
guid$ = 32
$T1 = 48
$T2 = 64
vdisk$ = 112
?AuGPTInitialise_FileSystem@@YAXPEAU_VDISK_@@@Z PROC	; AuGPTInitialise_FileSystem

; 62   : void AuGPTInitialise_FileSystem(AuVDisk *vdisk) {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 88					; 00000058H

; 63   : 	GUID guid = WINDOWS_PARTITION_DATA_GUID;

	mov	DWORD PTR guid$[rsp], -338648926	; ebd0a0a2H
	mov	eax, 47589				; 0000b9e5H
	mov	WORD PTR guid$[rsp+4], ax
	mov	eax, 17459				; 00004433H
	mov	WORD PTR guid$[rsp+6], ax
	mov	BYTE PTR guid$[rsp+8], 135		; 00000087H
	mov	BYTE PTR guid$[rsp+9], 192		; 000000c0H
	mov	BYTE PTR guid$[rsp+10], 104		; 00000068H
	mov	BYTE PTR guid$[rsp+11], 182		; 000000b6H
	mov	BYTE PTR guid$[rsp+12], 183		; 000000b7H
	mov	BYTE PTR guid$[rsp+13], 38		; 00000026H
	mov	BYTE PTR guid$[rsp+14], 153		; 00000099H
	mov	BYTE PTR guid$[rsp+15], 199		; 000000c7H

; 64   : 	
; 65   : 	if (AuGUIDVerify(vdisk->part_guid, guid)) {

	lea	rax, QWORD PTR $T1[rsp]
	lea	rcx, QWORD PTR guid$[rsp]
	mov	rdi, rax
	mov	rsi, rcx
	mov	ecx, 16
	rep movsb
	lea	rax, QWORD PTR $T2[rsp]
	mov	rcx, QWORD PTR vdisk$[rsp]
	mov	rdi, rax
	lea	rsi, QWORD PTR [rcx+74]
	mov	ecx, 16
	rep movsb
	lea	rdx, QWORD PTR $T1[rsp]
	lea	rcx, QWORD PTR $T2[rsp]
	call	AuGUIDVerify
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@AuGPTIniti

; 66   : 		AuTextOut("GPT Partition with Windows Partition data \n");

	lea	rcx, OFFSET FLAT:$SG3242
	call	AuTextOut

; 67   : 
; 68   : 		/* Now we need to call all Microsoft file systems
; 69   : 		 * detect routine to verify what type of ms file system
; 70   : 		 * it includes, for now we only support FAT file system */
; 71   : 		FatInitialise(vdisk, "/");

	lea	rdx, OFFSET FLAT:$SG3243
	mov	rcx, QWORD PTR vdisk$[rsp]
	call	?FatInitialise@@YAPEAU__VFS_NODE__@@PEAU_VDISK_@@PEAD@Z ; FatInitialise
$LN1@AuGPTIniti:

; 72   : 	}
; 73   : 
; 74   : 	//guid = LINUX_HOME_PARTITION_GUID;
; 75   : 
; 76   : 	//if (AuGUIDVerify(vdisk->part_guid, guid)) {
; 77   : 	//	AuTextOut("GPT Partition with Linux file systems \n");
; 78   : 	//	/*
; 79   : 	//	 * Now call ext fs detect routine to verify ext version
; 80   : 	//	 * and initialise it
; 81   : 	//	 */
; 82   : 	//}
; 83   : 
; 84   : }

	add	rsp, 88					; 00000058H
	pop	rdi
	pop	rsi
	ret	0
?AuGPTInitialise_FileSystem@@YAXPEAU_VDISK_@@@Z ENDP	; AuGPTInitialise_FileSystem
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\fs\_gpt.cpp
_TEXT	SEGMENT
first_part_good$ = 0
i$1 = 4
tv77 = 8
g1$ = 32
g2$ = 40
AuGUIDVerify PROC

; 43   : bool AuGUIDVerify(GUID g1, GUID g2) {

$LN10:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 44   : 	bool first_part_good = (g1.Data1 == g2.Data1 && g1.Data2 == g2.Data2 &&
; 45   : 		g1.Data3 == g2.Data3);

	mov	rax, QWORD PTR g1$[rsp]
	mov	rcx, QWORD PTR g2$[rsp]
	mov	ecx, DWORD PTR [rcx]
	cmp	DWORD PTR [rax], ecx
	jne	SHORT $LN8@AuGUIDVeri
	mov	rax, QWORD PTR g1$[rsp]
	movzx	eax, WORD PTR [rax+4]
	mov	rcx, QWORD PTR g2$[rsp]
	movzx	ecx, WORD PTR [rcx+4]
	cmp	eax, ecx
	jne	SHORT $LN8@AuGUIDVeri
	mov	rax, QWORD PTR g1$[rsp]
	movzx	eax, WORD PTR [rax+6]
	mov	rcx, QWORD PTR g2$[rsp]
	movzx	ecx, WORD PTR [rcx+6]
	cmp	eax, ecx
	jne	SHORT $LN8@AuGUIDVeri
	mov	DWORD PTR tv77[rsp], 1
	jmp	SHORT $LN9@AuGUIDVeri
$LN8@AuGUIDVeri:
	mov	DWORD PTR tv77[rsp], 0
$LN9@AuGUIDVeri:
	movzx	eax, BYTE PTR tv77[rsp]
	mov	BYTE PTR first_part_good$[rsp], al

; 46   : 	if (!first_part_good) return false;

	movzx	eax, BYTE PTR first_part_good$[rsp]
	test	eax, eax
	jne	SHORT $LN5@AuGUIDVeri
	xor	al, al
	jmp	SHORT $LN6@AuGUIDVeri
$LN5@AuGUIDVeri:

; 47   : 
; 48   : 	for (int i = 0; i < 8; ++i){

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN4@AuGUIDVeri
$LN3@AuGUIDVeri:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN4@AuGUIDVeri:
	cmp	DWORD PTR i$1[rsp], 8
	jge	SHORT $LN2@AuGUIDVeri

; 49   : 		if (g1.Data4[i] != g2.Data4[i]) 

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR g1$[rsp]
	movzx	eax, BYTE PTR [rcx+rax+8]
	movsxd	rcx, DWORD PTR i$1[rsp]
	mov	rdx, QWORD PTR g2$[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx+8]
	cmp	eax, ecx
	je	SHORT $LN1@AuGUIDVeri

; 50   : 			return false;

	xor	al, al
	jmp	SHORT $LN6@AuGUIDVeri
$LN1@AuGUIDVeri:

; 51   : 	}

	jmp	SHORT $LN3@AuGUIDVeri
$LN2@AuGUIDVeri:

; 52   : 
; 53   : 	return true;

	mov	al, 1
$LN6@AuGUIDVeri:

; 54   : }

	add	rsp, 24
	ret	0
AuGUIDVerify ENDP
_TEXT	ENDS
END
