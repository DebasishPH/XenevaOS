; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.21005.1 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG3811	DB	0dH, 0aH, ' ***ARCH x86_64 : Kernel Panic!!! *** ', 0dH, 0aH
	DB	00H
	ORG $+5
$SG3812	DB	'[Aurora Kernel]: We are sorry to say that, a processor i'
	DB	'nvalid exception has occured ', 0dH, 0aH, 00H
$SG3814	DB	'[Aurora Kernel]: Below is the code of exception ', 0dH, 0aH
	DB	00H
	ORG $+5
$SG3813	DB	'[Aurora Kernel]: please inform it to the master of the k'
	DB	'ernel ', 0dH, 0aH, 00H
	ORG $+3
$SG3816	DB	' %s ', 0dH, 0aH, 00H
	ORG $+5
$SG3815	DB	'[Aurora Kernel]: Current Processor id -> %d ', 0dH, 0aH, 00H
	ORG $+1
$SG3823	DB	0aH, 'Divide by 0', 00H
	ORG $+3
$SG3824	DB	'Divide by 0 ', 0dH, 0aH, 00H
	ORG $+1
$SG3825	DB	'__PROCESSOR_DATA__ ', 0dH, 0aH, 00H
	ORG $+2
$SG3826	DB	'RIP -> %x ', 0dH, 0aH, 00H
	ORG $+3
$SG3827	DB	'RSP -> %x ', 0dH, 0aH, 00H
	ORG $+3
$SG3828	DB	'RFLAGS -> %x ', 0dH, 0aH, 00H
$SG3838	DB	0aH, 'Single Step Trap', 00H
	ORG $+6
$SG3846	DB	0aH, 'NMI [Non-Muskable-Interrupt] Trap', 00H
	ORG $+5
$SG3854	DB	0aH, 'Breakpoint Trap', 00H
	ORG $+7
$SG3862	DB	0aH, 'Overflow Trap', 00H
	ORG $+1
$SG3870	DB	0aH, 'Bound Check Fault', 00H
	ORG $+5
$SG3880	DB	'Invalid Opcode Fault ', 0dH, 0aH, 00H
$SG3881	DB	'Invalid Opcode Fault ', 0dH, 0aH, 00H
$SG3882	DB	'__PROCESSOR TRACE__ ', 0dH, 0aH, 00H
	ORG $+1
$SG3883	DB	'RIP -> %x', 0aH, 00H
	ORG $+5
$SG3884	DB	'Stack -> %x', 0aH, 00H
	ORG $+3
$SG3885	DB	'RFLAGS -> %x', 0aH, 00H
	ORG $+2
$SG3886	DB	'CS -> %x', 0aH, 00H
	ORG $+6
$SG3887	DB	'SS -> %x', 0aH, 00H
	ORG $+6
$SG3895	DB	0aH, 'No Device Fault', 00H
	ORG $+7
$SG3903	DB	0aH, 'Double Fault Abort', 00H
	ORG $+4
$SG3911	DB	0aH, 'Invalid TSS Fault ', 00H
	ORG $+4
$SG3919	DB	0aH, 'No Segment Fault', 00H
	ORG $+6
$SG3927	DB	0aH, 'Stack Fault at ', 00H
	ORG $+7
$SG3937	DB	'Genral Protection Fault ', 0dH, 0aH, 00H
	ORG $+5
$SG3938	DB	'General Protection Fault ', 0dH, 0aH, 00H
	ORG $+4
$SG3939	DB	'__PROCESSOR TRACE__ ', 0dH, 0aH, 00H
	ORG $+1
$SG3940	DB	'RIP -> %x ', 0dH, 0aH, 00H
	ORG $+3
$SG3941	DB	'Stack -> %x ', 0dH, 0aH, 00H
	ORG $+1
$SG3942	DB	'RFLAGS -> %x ', 0dH, 0aH, 00H
$SG3943	DB	'CS -> %x, SS -> %x ', 0dH, 0aH, 00H
	ORG $+2
$SG3944	DB	'Current thread ->id %d ', 0dH, 0aH, 00H
	ORG $+6
$SG3961	DB	'Page Fault !! ', 0dH, 0aH, 00H
	ORG $+7
$SG3966	DB	'Process pid -> %d ', 0dH, 0aH, 00H
	ORG $+3
$SG3972	DB	'Page Not Present ', 0dH, 0aH, 00H
	ORG $+4
$SG3975	DB	'Read/Write ', 0dH, 0aH, 00H
	ORG $+2
$SG3978	DB	'VPage rw -> %d , user -> %d ', 0dH, 0aH, 00H
	ORG $+1
$SG3979	DB	'VPage phys1-> %x, phys2-> %x ', 0dH, 0aH, 00H
$SG3982	DB	'User bit not set ', 0dH, 0aH, 00H
	ORG $+4
$SG3985	DB	'Reserved page ', 0dH, 0aH, 00H
	ORG $+7
$SG3988	DB	'Invalid page ', 0dH, 0aH, 00H
$SG3989	DB	'Virtual Address -> %x ', 0dH, 0aH, 00H
	ORG $+7
$SG3990	DB	'Virtual Address aligned -> %x ', 0dH, 0aH, 00H
	ORG $+7
$SG3991	DB	'RSP -> %x ', 0dH, 0aH, 00H
	ORG $+3
$SG3992	DB	'RIP -> %x ', 0dH, 0aH, 00H
	ORG $+3
$SG3993	DB	'CS -> %x, SS -> %x ', 0dH, 0aH, 00H
	ORG $+2
$SG4002	DB	0aH, 'FPU Fault', 00H
	ORG $+5
$SG4010	DB	0aH, 'Alignment Check Fault at address ', 00H
	ORG $+5
$SG4018	DB	0aH, 'Machine Check Abort', 00H
	ORG $+3
$SG4028	DB	0aH, ' SIMD FPU Faul ', 0dH, 0aH, 't', 00H
	ORG $+4
$SG4029	DB	0aH, '__CPU Informations__ ', 0aH, 00H
$SG4030	DB	' RIP -> %x ', 0aH, 00H
	ORG $+3
$SG4031	DB	' RSP -> %x ', 0aH, 00H
	ORG $+3
$SG4032	DB	' RFLAGS -> %x ', 0aH, 00H
$SG4033	DB	' MXCSR bit  -- ', 00H
CONST	ENDS
PUBLIC	?x86_64_exception_init@@YAXXZ			; x86_64_exception_init
PUBLIC	?panic@@YAXPEBDZZ				; panic
PUBLIC	?divide_by_zero_fault@@YAX_KPEAX@Z		; divide_by_zero_fault
PUBLIC	?single_step_trap@@YAX_KPEAX@Z			; single_step_trap
PUBLIC	?nmi_trap@@YAX_KPEAX@Z				; nmi_trap
PUBLIC	?breakpoint_trap@@YAX_KPEAX@Z			; breakpoint_trap
PUBLIC	?overflow_trap@@YAX_KPEAX@Z			; overflow_trap
PUBLIC	?bounds_check_fault@@YAX_KPEAX@Z		; bounds_check_fault
PUBLIC	?invalid_opcode_fault@@YAX_KPEAX@Z		; invalid_opcode_fault
PUBLIC	?no_device_fault@@YAX_KPEAX@Z			; no_device_fault
PUBLIC	?double_fault_abort@@YAX_KPEAX@Z		; double_fault_abort
PUBLIC	?invalid_tss_fault@@YAX_KPEAX@Z			; invalid_tss_fault
PUBLIC	?no_segment_fault@@YAX_KPEAX@Z			; no_segment_fault
PUBLIC	?stack_fault@@YAX_KPEAX@Z			; stack_fault
PUBLIC	?general_protection_fault@@YAX_KPEAX@Z		; general_protection_fault
PUBLIC	?page_fault@@YAX_KPEAX@Z			; page_fault
PUBLIC	?fpu_fault@@YAX_KPEAX@Z				; fpu_fault
PUBLIC	?alignment_check_fault@@YAX_KPEAX@Z		; alignment_check_fault
PUBLIC	?machine_check_abort@@YAX_KPEAX@Z		; machine_check_abort
PUBLIC	?simd_fpu_fault@@YAX_KPEAX@Z			; simd_fpu_fault
EXTRN	AuGetCurrentThread:PROC
EXTRN	?AuProcessFindThread@@YAPEAU_au_proc_@@PEAU_au_thread_@@@Z:PROC ; AuProcessFindThread
EXTRN	?AuPerCPUGetCpuID@@YAEXZ:PROC			; AuPerCPUGetCpuID
EXTRN	x64_cli:PROC
EXTRN	x64_read_cr2:PROC
EXTRN	AuVmmngrGetPage:PROC
EXTRN	AuGetPhysicalAddress:PROC
EXTRN	setvect:PROC
EXTRN	SeTextOut:PROC
pdata	SEGMENT
$pdata$?x86_64_exception_init@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+312
	DD	imagerel $unwind$?x86_64_exception_init@@YAXXZ
$pdata$?panic@@YAXPEBDZZ DD imagerel $LN3
	DD	imagerel $LN3+116
	DD	imagerel $unwind$?panic@@YAXPEBDZZ
$pdata$?divide_by_zero_fault@@YAX_KPEAX@Z DD imagerel $LN5
	DD	imagerel $LN5+135
	DD	imagerel $unwind$?divide_by_zero_fault@@YAX_KPEAX@Z
$pdata$?single_step_trap@@YAX_KPEAX@Z DD imagerel $LN5
	DD	imagerel $LN5+48
	DD	imagerel $unwind$?single_step_trap@@YAX_KPEAX@Z
$pdata$?nmi_trap@@YAX_KPEAX@Z DD imagerel $LN5
	DD	imagerel $LN5+38
	DD	imagerel $unwind$?nmi_trap@@YAX_KPEAX@Z
$pdata$?breakpoint_trap@@YAX_KPEAX@Z DD imagerel $LN5
	DD	imagerel $LN5+38
	DD	imagerel $unwind$?breakpoint_trap@@YAX_KPEAX@Z
$pdata$?overflow_trap@@YAX_KPEAX@Z DD imagerel $LN5
	DD	imagerel $LN5+38
	DD	imagerel $unwind$?overflow_trap@@YAX_KPEAX@Z
$pdata$?bounds_check_fault@@YAX_KPEAX@Z DD imagerel $LN5
	DD	imagerel $LN5+38
	DD	imagerel $unwind$?bounds_check_fault@@YAX_KPEAX@Z
$pdata$?invalid_opcode_fault@@YAX_KPEAX@Z DD imagerel $LN5
	DD	imagerel $LN5+177
	DD	imagerel $unwind$?invalid_opcode_fault@@YAX_KPEAX@Z
$pdata$?no_device_fault@@YAX_KPEAX@Z DD imagerel $LN5
	DD	imagerel $LN5+38
	DD	imagerel $unwind$?no_device_fault@@YAX_KPEAX@Z
$pdata$?double_fault_abort@@YAX_KPEAX@Z DD imagerel $LN5
	DD	imagerel $LN5+38
	DD	imagerel $unwind$?double_fault_abort@@YAX_KPEAX@Z
$pdata$?invalid_tss_fault@@YAX_KPEAX@Z DD imagerel $LN5
	DD	imagerel $LN5+38
	DD	imagerel $unwind$?invalid_tss_fault@@YAX_KPEAX@Z
$pdata$?no_segment_fault@@YAX_KPEAX@Z DD imagerel $LN5
	DD	imagerel $LN5+38
	DD	imagerel $unwind$?no_segment_fault@@YAX_KPEAX@Z
$pdata$?stack_fault@@YAX_KPEAX@Z DD imagerel $LN5
	DD	imagerel $LN5+38
	DD	imagerel $unwind$?stack_fault@@YAX_KPEAX@Z
$pdata$?general_protection_fault@@YAX_KPEAX@Z DD imagerel $LN5
	DD	imagerel $LN5+191
	DD	imagerel $unwind$?general_protection_fault@@YAX_KPEAX@Z
$pdata$?page_fault@@YAX_KPEAX@Z DD imagerel $LN19
	DD	imagerel $LN19+636
	DD	imagerel $unwind$?page_fault@@YAX_KPEAX@Z
$pdata$?fpu_fault@@YAX_KPEAX@Z DD imagerel $LN5
	DD	imagerel $LN5+38
	DD	imagerel $unwind$?fpu_fault@@YAX_KPEAX@Z
$pdata$?alignment_check_fault@@YAX_KPEAX@Z DD imagerel $LN5
	DD	imagerel $LN5+38
	DD	imagerel $unwind$?alignment_check_fault@@YAX_KPEAX@Z
$pdata$?machine_check_abort@@YAX_KPEAX@Z DD imagerel $LN5
	DD	imagerel $LN5+38
	DD	imagerel $unwind$?machine_check_abort@@YAX_KPEAX@Z
$pdata$?simd_fpu_fault@@YAX_KPEAX@Z DD imagerel $LN5
	DD	imagerel $LN5+135
	DD	imagerel $unwind$?simd_fpu_fault@@YAX_KPEAX@Z
pdata	ENDS
xdata	SEGMENT
$unwind$?x86_64_exception_init@@YAXXZ DD 010401H
	DD	04204H
$unwind$?panic@@YAXPEBDZZ DD 011801H
	DD	04218H
$unwind$?divide_by_zero_fault@@YAX_KPEAX@Z DD 010e01H
	DD	0620eH
$unwind$?single_step_trap@@YAX_KPEAX@Z DD 010e01H
	DD	0620eH
$unwind$?nmi_trap@@YAX_KPEAX@Z DD 010e01H
	DD	0420eH
$unwind$?breakpoint_trap@@YAX_KPEAX@Z DD 010e01H
	DD	0420eH
$unwind$?overflow_trap@@YAX_KPEAX@Z DD 010e01H
	DD	0420eH
$unwind$?bounds_check_fault@@YAX_KPEAX@Z DD 010e01H
	DD	0420eH
$unwind$?invalid_opcode_fault@@YAX_KPEAX@Z DD 010e01H
	DD	0620eH
$unwind$?no_device_fault@@YAX_KPEAX@Z DD 010e01H
	DD	0420eH
$unwind$?double_fault_abort@@YAX_KPEAX@Z DD 010e01H
	DD	0420eH
$unwind$?invalid_tss_fault@@YAX_KPEAX@Z DD 010e01H
	DD	0420eH
$unwind$?no_segment_fault@@YAX_KPEAX@Z DD 010e01H
	DD	0420eH
$unwind$?stack_fault@@YAX_KPEAX@Z DD 010e01H
	DD	0420eH
$unwind$?general_protection_fault@@YAX_KPEAX@Z DD 010e01H
	DD	0620eH
$unwind$?page_fault@@YAX_KPEAX@Z DD 021101H
	DD	0130111H
$unwind$?fpu_fault@@YAX_KPEAX@Z DD 010e01H
	DD	0420eH
$unwind$?alignment_check_fault@@YAX_KPEAX@Z DD 010e01H
	DD	0420eH
$unwind$?machine_check_abort@@YAX_KPEAX@Z DD 010e01H
	DD	0420eH
$unwind$?simd_fpu_fault@@YAX_KPEAX@Z DD 010e01H
	DD	0620eH
xdata	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\hal\x86_64_exception.cpp
_TEXT	SEGMENT
frame$ = 32
v$ = 64
p$ = 72
?simd_fpu_fault@@YAX_KPEAX@Z PROC			; simd_fpu_fault

; 247  : void simd_fpu_fault(size_t v, void* p){

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 248  : 	x64_cli();

	call	x64_cli

; 249  : 	interrupt_stack_frame *frame = (interrupt_stack_frame*)p;

	mov	rax, QWORD PTR p$[rsp]
	mov	QWORD PTR frame$[rsp], rax

; 250  : 	panic("\n SIMD FPU Faul \r\nt");

	lea	rcx, OFFSET FLAT:$SG4028
	call	?panic@@YAXPEBDZZ			; panic

; 251  : 	SeTextOut("\n__CPU Informations__ \n");

	lea	rcx, OFFSET FLAT:$SG4029
	call	SeTextOut

; 252  : 	SeTextOut(" RIP -> %x \n", frame->rip);

	mov	rax, QWORD PTR frame$[rsp]
	mov	rdx, QWORD PTR [rax+16]
	lea	rcx, OFFSET FLAT:$SG4030
	call	SeTextOut

; 253  : 	SeTextOut(" RSP -> %x \n", frame->rsp);

	mov	rax, QWORD PTR frame$[rsp]
	mov	rdx, QWORD PTR [rax+40]
	lea	rcx, OFFSET FLAT:$SG4031
	call	SeTextOut

; 254  : 	SeTextOut(" RFLAGS -> %x \n", frame->rflags);

	mov	rax, QWORD PTR frame$[rsp]
	mov	rdx, QWORD PTR [rax+32]
	lea	rcx, OFFSET FLAT:$SG4032
	call	SeTextOut

; 255  : 	SeTextOut(" MXCSR bit  -- ");

	lea	rcx, OFFSET FLAT:$SG4033
	call	SeTextOut
$LN2@simd_fpu_f:

; 256  : 	for (;;);

	jmp	SHORT $LN2@simd_fpu_f

; 257  : }

	add	rsp, 56					; 00000038H
	ret	0
?simd_fpu_fault@@YAX_KPEAX@Z ENDP			; simd_fpu_fault
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\hal\x86_64_exception.cpp
_TEXT	SEGMENT
v$ = 48
p$ = 56
?machine_check_abort@@YAX_KPEAX@Z PROC			; machine_check_abort

; 240  : void machine_check_abort(size_t v, void* p){

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 241  : 	x64_cli();

	call	x64_cli

; 242  : 	panic("\nMachine Check Abort");

	lea	rcx, OFFSET FLAT:$SG4018
	call	?panic@@YAXPEBDZZ			; panic
$LN2@machine_ch:

; 243  : 	for (;;);

	jmp	SHORT $LN2@machine_ch

; 244  : }

	add	rsp, 40					; 00000028H
	ret	0
?machine_check_abort@@YAX_KPEAX@Z ENDP			; machine_check_abort
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\hal\x86_64_exception.cpp
_TEXT	SEGMENT
v$ = 48
p$ = 56
?alignment_check_fault@@YAX_KPEAX@Z PROC		; alignment_check_fault

; 233  : void alignment_check_fault(size_t v, void* p){

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 234  : 	x64_cli();

	call	x64_cli

; 235  : 	panic("\nAlignment Check Fault at address ");

	lea	rcx, OFFSET FLAT:$SG4010
	call	?panic@@YAXPEBDZZ			; panic
$LN2@alignment_:

; 236  : 	for (;;);

	jmp	SHORT $LN2@alignment_

; 237  : }

	add	rsp, 40					; 00000028H
	ret	0
?alignment_check_fault@@YAX_KPEAX@Z ENDP		; alignment_check_fault
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\hal\x86_64_exception.cpp
_TEXT	SEGMENT
vector$ = 48
p$ = 56
?fpu_fault@@YAX_KPEAX@Z PROC				; fpu_fault

; 225  : void fpu_fault(size_t vector, void* p){

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 226  : 	x64_cli();

	call	x64_cli

; 227  : 	panic("\nFPU Fault");

	lea	rcx, OFFSET FLAT:$SG4002
	call	?panic@@YAXPEBDZZ			; panic
$LN2@fpu_fault:

; 228  : 	for (;;);

	jmp	SHORT $LN2@fpu_fault

; 229  : }

	add	rsp, 40					; 00000028H
	ret	0
?fpu_fault@@YAX_KPEAX@Z ENDP				; fpu_fault
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\hal\x86_64_exception.cpp
_TEXT	SEGMENT
_mapped$ = 32
frame$ = 40
tv68 = 48
proc$ = 56
vpage$1 = 64
us$ = 72
vaddr_aligned$ = 80
id$ = 88
resv$ = 92
present$ = 96
rw$ = 100
thr$ = 104
vaddr_$ = 112
vaddr$ = 120
phys$2 = 128
vector$ = 160
param$ = 168
?page_fault@@YAX_KPEAX@Z PROC				; page_fault

; 172  : void page_fault(size_t vector, void* param){

$LN19:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 152				; 00000098H

; 173  : 	x64_cli();

	call	x64_cli

; 174  : 	interrupt_stack_frame *frame = (interrupt_stack_frame*)param;

	mov	rax, QWORD PTR param$[rsp]
	mov	QWORD PTR frame$[rsp], rax

; 175  : 	void* vaddr = (void*)x64_read_cr2();

	call	x64_read_cr2
	mov	QWORD PTR vaddr$[rsp], rax

; 176  : 
; 177  : 	int present = !(frame->error & 0x1);

	mov	rax, QWORD PTR frame$[rsp]
	mov	rax, QWORD PTR [rax+8]
	and	rax, 1
	test	rax, rax
	jne	SHORT $LN17@page_fault
	mov	DWORD PTR tv68[rsp], 1
	jmp	SHORT $LN18@page_fault
$LN17@page_fault:
	mov	DWORD PTR tv68[rsp], 0
$LN18@page_fault:
	mov	eax, DWORD PTR tv68[rsp]
	mov	DWORD PTR present$[rsp], eax

; 178  : 	int rw = frame->error & 0x2;

	mov	rax, QWORD PTR frame$[rsp]
	mov	rax, QWORD PTR [rax+8]
	and	rax, 2
	mov	DWORD PTR rw$[rsp], eax

; 179  : 	int us = frame->error & 0x4;

	mov	rax, QWORD PTR frame$[rsp]
	mov	rax, QWORD PTR [rax+8]
	and	rax, 4
	mov	DWORD PTR us$[rsp], eax

; 180  : 	int resv = frame->error & 0x8;

	mov	rax, QWORD PTR frame$[rsp]
	mov	rax, QWORD PTR [rax+8]
	and	rax, 8
	mov	DWORD PTR resv$[rsp], eax

; 181  : 	int id = frame->error & 0x10;

	mov	rax, QWORD PTR frame$[rsp]
	mov	rax, QWORD PTR [rax+8]
	and	rax, 16
	mov	DWORD PTR id$[rsp], eax

; 182  : 
; 183  : 	panic("Page Fault !! \r\n");

	lea	rcx, OFFSET FLAT:$SG3961
	call	?panic@@YAXPEBDZZ			; panic

; 184  : 	
; 185  : 	AuThread* thr = AuGetCurrentThread();

	call	AuGetCurrentThread
	mov	QWORD PTR thr$[rsp], rax

; 186  : 	AuProcess *proc = NULL;

	mov	QWORD PTR proc$[rsp], 0

; 187  : 	if (thr) {

	cmp	QWORD PTR thr$[rsp], 0
	je	SHORT $LN14@page_fault

; 188  : 		proc = AuProcessFindThread(thr);

	mov	rcx, QWORD PTR thr$[rsp]
	call	?AuProcessFindThread@@YAPEAU_au_proc_@@PEAU_au_thread_@@@Z ; AuProcessFindThread
	mov	QWORD PTR proc$[rsp], rax

; 189  : 		if (proc)

	cmp	QWORD PTR proc$[rsp], 0
	je	SHORT $LN13@page_fault

; 190  : 			SeTextOut("Process pid -> %d \r\n", proc->proc_id);

	mov	rax, QWORD PTR proc$[rsp]
	mov	edx, DWORD PTR [rax]
	lea	rcx, OFFSET FLAT:$SG3966
	call	SeTextOut
$LN13@page_fault:
$LN14@page_fault:

; 191  : 	}
; 192  : 	
; 193  : 	uint64_t vaddr_ = (uint64_t)vaddr;

	mov	rax, QWORD PTR vaddr$[rsp]
	mov	QWORD PTR vaddr_$[rsp], rax

; 194  : 	uint64_t vaddr_aligned = VIRT_ADDR_ALIGN(vaddr_);

	mov	rax, QWORD PTR vaddr_$[rsp]
	and	rax, -4096				; fffffffffffff000H
	mov	QWORD PTR vaddr_aligned$[rsp], rax

; 195  : 	bool _mapped = false;

	mov	BYTE PTR _mapped$[rsp], 0

; 196  : 	if (present) {

	cmp	DWORD PTR present$[rsp], 0
	je	SHORT $LN12@page_fault

; 197  : 		SeTextOut("Page Not Present \r\n");

	lea	rcx, OFFSET FLAT:$SG3972
	call	SeTextOut
	jmp	$LN11@page_fault
$LN12@page_fault:

; 198  : 	}
; 199  : 	else if (rw) {

	cmp	DWORD PTR rw$[rsp], 0
	je	$LN10@page_fault

; 200  : 		SeTextOut("Read/Write \r\n");

	lea	rcx, OFFSET FLAT:$SG3975
	call	SeTextOut

; 201  : 		void* phys = AuGetPhysicalAddress(vaddr_aligned);

	mov	rcx, QWORD PTR vaddr_aligned$[rsp]
	call	AuGetPhysicalAddress
	mov	QWORD PTR phys$2[rsp], rax

; 202  : 		AuVPage *vpage = AuVmmngrGetPage(vaddr_aligned, 0, 0);

	xor	r8d, r8d
	xor	edx, edx
	mov	rcx, QWORD PTR vaddr_aligned$[rsp]
	call	AuVmmngrGetPage
	mov	QWORD PTR vpage$1[rsp], rax

; 203  : 		SeTextOut("VPage rw -> %d , user -> %d \r\n", vpage->bits.writable, vpage->bits.user);

	mov	rax, QWORD PTR vpage$1[rsp]
	mov	rax, QWORD PTR [rax]
	shr	rax, 2
	and	rax, 1
	mov	rcx, QWORD PTR vpage$1[rsp]
	mov	rcx, QWORD PTR [rcx]
	shr	rcx, 1
	and	rcx, 1
	mov	r8, rax
	mov	rdx, rcx
	lea	rcx, OFFSET FLAT:$SG3978
	call	SeTextOut

; 204  : 		SeTextOut("VPage phys1-> %x, phys2-> %x \r\n", phys, (vpage->bits.page << PAGE_SHIFT));

	mov	rax, QWORD PTR vpage$1[rsp]
	mov	rax, QWORD PTR [rax]
	shr	rax, 12
	and	rax, 268435455				; 0fffffffH
	shl	rax, 12
	mov	r8, rax
	mov	rdx, QWORD PTR phys$2[rsp]
	lea	rcx, OFFSET FLAT:$SG3979
	call	SeTextOut
	jmp	SHORT $LN9@page_fault
$LN10@page_fault:

; 205  : 	}
; 206  : 	else if (us)

	cmp	DWORD PTR us$[rsp], 0
	je	SHORT $LN8@page_fault

; 207  : 		SeTextOut("User bit not set \r\n");

	lea	rcx, OFFSET FLAT:$SG3982
	call	SeTextOut
	jmp	SHORT $LN7@page_fault
$LN8@page_fault:

; 208  : 	else if (resv)

	cmp	DWORD PTR resv$[rsp], 0
	je	SHORT $LN6@page_fault

; 209  : 		SeTextOut("Reserved page \r\n");

	lea	rcx, OFFSET FLAT:$SG3985
	call	SeTextOut
	jmp	SHORT $LN5@page_fault
$LN6@page_fault:

; 210  : 	else if (id)

	cmp	DWORD PTR id$[rsp], 0
	je	SHORT $LN4@page_fault

; 211  : 		SeTextOut("Invalid page \r\n");

	lea	rcx, OFFSET FLAT:$SG3988
	call	SeTextOut
$LN4@page_fault:
$LN5@page_fault:
$LN7@page_fault:
$LN9@page_fault:
$LN11@page_fault:

; 212  : 
; 213  : 	SeTextOut("Virtual Address -> %x \r\n", vaddr_);

	mov	rdx, QWORD PTR vaddr_$[rsp]
	lea	rcx, OFFSET FLAT:$SG3989
	call	SeTextOut

; 214  : 	SeTextOut("Virtual Address aligned -> %x \r\n", vaddr_aligned);

	mov	rdx, QWORD PTR vaddr_aligned$[rsp]
	lea	rcx, OFFSET FLAT:$SG3990
	call	SeTextOut

; 215  : 	SeTextOut("RSP -> %x \r\n", frame->rsp);

	mov	rax, QWORD PTR frame$[rsp]
	mov	rdx, QWORD PTR [rax+40]
	lea	rcx, OFFSET FLAT:$SG3991
	call	SeTextOut

; 216  : 	SeTextOut("RIP -> %x \r\n", frame->rip);

	mov	rax, QWORD PTR frame$[rsp]
	mov	rdx, QWORD PTR [rax+16]
	lea	rcx, OFFSET FLAT:$SG3992
	call	SeTextOut

; 217  : 	SeTextOut("CS -> %x, SS -> %x \r\n", frame->cs, frame->ss);

	mov	rax, QWORD PTR frame$[rsp]
	mov	r8, QWORD PTR [rax+48]
	mov	rax, QWORD PTR frame$[rsp]
	mov	rdx, QWORD PTR [rax+24]
	lea	rcx, OFFSET FLAT:$SG3993
	call	SeTextOut

; 218  : 	if (!_mapped) {

	movzx	eax, BYTE PTR _mapped$[rsp]
	test	eax, eax
	jne	SHORT $LN3@page_fault
$LN2@page_fault:

; 219  : 		for (;;);

	jmp	SHORT $LN2@page_fault
$LN3@page_fault:

; 220  : 	}
; 221  : }

	add	rsp, 152				; 00000098H
	ret	0
?page_fault@@YAX_KPEAX@Z ENDP				; page_fault
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\hal\x86_64_exception.cpp
_TEXT	SEGMENT
frame$ = 32
v$ = 64
p$ = 72
?general_protection_fault@@YAX_KPEAX@Z PROC		; general_protection_fault

; 155  : void general_protection_fault(size_t v, void* p){

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 156  : 	x64_cli();

	call	x64_cli

; 157  : 	interrupt_stack_frame *frame = (interrupt_stack_frame*)p;

	mov	rax, QWORD PTR p$[rsp]
	mov	QWORD PTR frame$[rsp], rax

; 158  : 	panic("Genral Protection Fault \r\n");

	lea	rcx, OFFSET FLAT:$SG3937
	call	?panic@@YAXPEBDZZ			; panic

; 159  : 	SeTextOut("General Protection Fault \r\n");

	lea	rcx, OFFSET FLAT:$SG3938
	call	SeTextOut

; 160  : 	SeTextOut("__PROCESSOR TRACE__ \r\n");

	lea	rcx, OFFSET FLAT:$SG3939
	call	SeTextOut

; 161  : 	SeTextOut("RIP -> %x \r\n", frame->rip);

	mov	rax, QWORD PTR frame$[rsp]
	mov	rdx, QWORD PTR [rax+16]
	lea	rcx, OFFSET FLAT:$SG3940
	call	SeTextOut

; 162  : 	SeTextOut("Stack -> %x \r\n", frame->rsp);

	mov	rax, QWORD PTR frame$[rsp]
	mov	rdx, QWORD PTR [rax+40]
	lea	rcx, OFFSET FLAT:$SG3941
	call	SeTextOut

; 163  : 	SeTextOut("RFLAGS -> %x \r\n", frame->rflags);

	mov	rax, QWORD PTR frame$[rsp]
	mov	rdx, QWORD PTR [rax+32]
	lea	rcx, OFFSET FLAT:$SG3942
	call	SeTextOut

; 164  : 	SeTextOut("CS -> %x, SS -> %x \r\n", frame->cs, frame->ss);

	mov	rax, QWORD PTR frame$[rsp]
	mov	r8, QWORD PTR [rax+48]
	mov	rax, QWORD PTR frame$[rsp]
	mov	rdx, QWORD PTR [rax+24]
	lea	rcx, OFFSET FLAT:$SG3943
	call	SeTextOut

; 165  : 	SeTextOut("Current thread ->id %d \r\n", AuGetCurrentThread()->id);

	call	AuGetCurrentThread
	movzx	eax, WORD PTR [rax+293]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG3944
	call	SeTextOut
$LN2@general_pr:

; 166  : 	for (;;);

	jmp	SHORT $LN2@general_pr

; 167  : }

	add	rsp, 56					; 00000038H
	ret	0
?general_protection_fault@@YAX_KPEAX@Z ENDP		; general_protection_fault
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\hal\x86_64_exception.cpp
_TEXT	SEGMENT
v$ = 48
p$ = 56
?stack_fault@@YAX_KPEAX@Z PROC				; stack_fault

; 147  : void stack_fault(size_t v, void* p){

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 148  : 	x64_cli();

	call	x64_cli

; 149  : 	panic("\nStack Fault at ");

	lea	rcx, OFFSET FLAT:$SG3927
	call	?panic@@YAXPEBDZZ			; panic
$LN2@stack_faul:

; 150  : 	for (;;);

	jmp	SHORT $LN2@stack_faul

; 151  : }

	add	rsp, 40					; 00000028H
	ret	0
?stack_fault@@YAX_KPEAX@Z ENDP				; stack_fault
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\hal\x86_64_exception.cpp
_TEXT	SEGMENT
v$ = 48
p$ = 56
?no_segment_fault@@YAX_KPEAX@Z PROC			; no_segment_fault

; 140  : void no_segment_fault(size_t v, void* p){

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 141  : 	x64_cli();

	call	x64_cli

; 142  : 	panic("\nNo Segment Fault");

	lea	rcx, OFFSET FLAT:$SG3919
	call	?panic@@YAXPEBDZZ			; panic
$LN2@no_segment:

; 143  : 	for (;;);

	jmp	SHORT $LN2@no_segment

; 144  : }

	add	rsp, 40					; 00000028H
	ret	0
?no_segment_fault@@YAX_KPEAX@Z ENDP			; no_segment_fault
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\hal\x86_64_exception.cpp
_TEXT	SEGMENT
v$ = 48
p$ = 56
?invalid_tss_fault@@YAX_KPEAX@Z PROC			; invalid_tss_fault

; 133  : void invalid_tss_fault(size_t v, void* p){

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 134  : 	x64_cli();

	call	x64_cli

; 135  : 	panic("\nInvalid TSS Fault ");

	lea	rcx, OFFSET FLAT:$SG3911
	call	?panic@@YAXPEBDZZ			; panic
$LN2@invalid_ts:

; 136  : 	for (;;);

	jmp	SHORT $LN2@invalid_ts

; 137  : }

	add	rsp, 40					; 00000028H
	ret	0
?invalid_tss_fault@@YAX_KPEAX@Z ENDP			; invalid_tss_fault
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\hal\x86_64_exception.cpp
_TEXT	SEGMENT
v$ = 48
p$ = 56
?double_fault_abort@@YAX_KPEAX@Z PROC			; double_fault_abort

; 126  : void double_fault_abort(size_t v, void* p){

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 127  : 	x64_cli();

	call	x64_cli

; 128  : 	panic("\nDouble Fault Abort");

	lea	rcx, OFFSET FLAT:$SG3903
	call	?panic@@YAXPEBDZZ			; panic
$LN2@double_fau:

; 129  : 	for (;;);

	jmp	SHORT $LN2@double_fau

; 130  : }

	add	rsp, 40					; 00000028H
	ret	0
?double_fault_abort@@YAX_KPEAX@Z ENDP			; double_fault_abort
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\hal\x86_64_exception.cpp
_TEXT	SEGMENT
v$ = 48
p$ = 56
?no_device_fault@@YAX_KPEAX@Z PROC			; no_device_fault

; 119  : void no_device_fault(size_t v, void* p){

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 120  : 	x64_cli();

	call	x64_cli

; 121  : 	panic("\nNo Device Fault");

	lea	rcx, OFFSET FLAT:$SG3895
	call	?panic@@YAXPEBDZZ			; panic
$LN2@no_device_:

; 122  : 	for (;;);

	jmp	SHORT $LN2@no_device_

; 123  : }

	add	rsp, 40					; 00000028H
	ret	0
?no_device_fault@@YAX_KPEAX@Z ENDP			; no_device_fault
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\hal\x86_64_exception.cpp
_TEXT	SEGMENT
frame$ = 32
v$ = 64
p$ = 72
?invalid_opcode_fault@@YAX_KPEAX@Z PROC			; invalid_opcode_fault

; 104  : void invalid_opcode_fault(size_t v, void* p){

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 105  : 	x64_cli();

	call	x64_cli

; 106  : 	interrupt_stack_frame *frame = (interrupt_stack_frame*)p;

	mov	rax, QWORD PTR p$[rsp]
	mov	QWORD PTR frame$[rsp], rax

; 107  : 	panic("Invalid Opcode Fault \r\n");

	lea	rcx, OFFSET FLAT:$SG3880
	call	?panic@@YAXPEBDZZ			; panic

; 108  : 	SeTextOut("Invalid Opcode Fault \r\n");

	lea	rcx, OFFSET FLAT:$SG3881
	call	SeTextOut

; 109  : 	SeTextOut("__PROCESSOR TRACE__ \r\n");

	lea	rcx, OFFSET FLAT:$SG3882
	call	SeTextOut

; 110  : 	SeTextOut("RIP -> %x\n", frame->rip);

	mov	rax, QWORD PTR frame$[rsp]
	mov	rdx, QWORD PTR [rax+16]
	lea	rcx, OFFSET FLAT:$SG3883
	call	SeTextOut

; 111  : 	SeTextOut("Stack -> %x\n", frame->rsp);

	mov	rax, QWORD PTR frame$[rsp]
	mov	rdx, QWORD PTR [rax+40]
	lea	rcx, OFFSET FLAT:$SG3884
	call	SeTextOut

; 112  : 	SeTextOut("RFLAGS -> %x\n", frame->rflags);

	mov	rax, QWORD PTR frame$[rsp]
	mov	rdx, QWORD PTR [rax+32]
	lea	rcx, OFFSET FLAT:$SG3885
	call	SeTextOut

; 113  : 	SeTextOut("CS -> %x\n", frame->cs);

	mov	rax, QWORD PTR frame$[rsp]
	mov	rdx, QWORD PTR [rax+24]
	lea	rcx, OFFSET FLAT:$SG3886
	call	SeTextOut

; 114  : 	SeTextOut("SS -> %x\n", frame->ss);

	mov	rax, QWORD PTR frame$[rsp]
	mov	rdx, QWORD PTR [rax+48]
	lea	rcx, OFFSET FLAT:$SG3887
	call	SeTextOut
$LN2@invalid_op:

; 115  : 	for (;;);

	jmp	SHORT $LN2@invalid_op

; 116  : }

	add	rsp, 56					; 00000038H
	ret	0
?invalid_opcode_fault@@YAX_KPEAX@Z ENDP			; invalid_opcode_fault
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\hal\x86_64_exception.cpp
_TEXT	SEGMENT
v$ = 48
p$ = 56
?bounds_check_fault@@YAX_KPEAX@Z PROC			; bounds_check_fault

; 97   : void bounds_check_fault(size_t v, void* p){

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 98   : 	x64_cli();

	call	x64_cli

; 99   : 	panic("\nBound Check Fault");

	lea	rcx, OFFSET FLAT:$SG3870
	call	?panic@@YAXPEBDZZ			; panic
$LN2@bounds_che:

; 100  : 	for (;;);

	jmp	SHORT $LN2@bounds_che

; 101  : }

	add	rsp, 40					; 00000028H
	ret	0
?bounds_check_fault@@YAX_KPEAX@Z ENDP			; bounds_check_fault
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\hal\x86_64_exception.cpp
_TEXT	SEGMENT
v$ = 48
p$ = 56
?overflow_trap@@YAX_KPEAX@Z PROC			; overflow_trap

; 90   : void overflow_trap(size_t v, void* p){

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 91   : 	x64_cli();

	call	x64_cli

; 92   : 	panic("\nOverflow Trap");

	lea	rcx, OFFSET FLAT:$SG3862
	call	?panic@@YAXPEBDZZ			; panic
$LN2@overflow_t:

; 93   : 	for (;;);

	jmp	SHORT $LN2@overflow_t

; 94   : }

	add	rsp, 40					; 00000028H
	ret	0
?overflow_trap@@YAX_KPEAX@Z ENDP			; overflow_trap
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\hal\x86_64_exception.cpp
_TEXT	SEGMENT
vector$ = 48
param$ = 56
?breakpoint_trap@@YAX_KPEAX@Z PROC			; breakpoint_trap

; 83   : void breakpoint_trap(size_t vector, void* param){

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 84   : 	x64_cli();

	call	x64_cli

; 85   : 	panic("\nBreakpoint Trap");

	lea	rcx, OFFSET FLAT:$SG3854
	call	?panic@@YAXPEBDZZ			; panic
$LN2@breakpoint:

; 86   : 	for (;;);

	jmp	SHORT $LN2@breakpoint

; 87   : }

	add	rsp, 40					; 00000028H
	ret	0
?breakpoint_trap@@YAX_KPEAX@Z ENDP			; breakpoint_trap
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\hal\x86_64_exception.cpp
_TEXT	SEGMENT
vector$ = 48
param$ = 56
?nmi_trap@@YAX_KPEAX@Z PROC				; nmi_trap

; 75   : void nmi_trap(size_t vector, void* param){

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 76   : 	x64_cli();

	call	x64_cli

; 77   : 	panic("\nNMI [Non-Muskable-Interrupt] Trap");

	lea	rcx, OFFSET FLAT:$SG3846
	call	?panic@@YAXPEBDZZ			; panic
$LN2@nmi_trap:

; 78   : 	for (;;);

	jmp	SHORT $LN2@nmi_trap

; 79   : 
; 80   : }

	add	rsp, 40					; 00000028H
	ret	0
?nmi_trap@@YAX_KPEAX@Z ENDP				; nmi_trap
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\hal\x86_64_exception.cpp
_TEXT	SEGMENT
frame$ = 32
vector$ = 64
param$ = 72
?single_step_trap@@YAX_KPEAX@Z PROC			; single_step_trap

; 68   : void single_step_trap(size_t vector, void* param) {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 69   : 	x64_cli();

	call	x64_cli

; 70   : 	interrupt_stack_frame *frame = (interrupt_stack_frame*)param;

	mov	rax, QWORD PTR param$[rsp]
	mov	QWORD PTR frame$[rsp], rax

; 71   : 	panic("\nSingle Step Trap");

	lea	rcx, OFFSET FLAT:$SG3838
	call	?panic@@YAXPEBDZZ			; panic
$LN2@single_ste:

; 72   : 	for (;;);

	jmp	SHORT $LN2@single_ste

; 73   : }

	add	rsp, 56					; 00000038H
	ret	0
?single_step_trap@@YAX_KPEAX@Z ENDP			; single_step_trap
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\hal\x86_64_exception.cpp
_TEXT	SEGMENT
frame$ = 32
vector$ = 64
param$ = 72
?divide_by_zero_fault@@YAX_KPEAX@Z PROC			; divide_by_zero_fault

; 55   : void divide_by_zero_fault(size_t vector, void* param) {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 56   : 	x64_cli();

	call	x64_cli

; 57   : 	interrupt_stack_frame *frame = (interrupt_stack_frame*)param;

	mov	rax, QWORD PTR param$[rsp]
	mov	QWORD PTR frame$[rsp], rax

; 58   : 	panic("\nDivide by 0");

	lea	rcx, OFFSET FLAT:$SG3823
	call	?panic@@YAXPEBDZZ			; panic

; 59   : 	SeTextOut("Divide by 0 \r\n");

	lea	rcx, OFFSET FLAT:$SG3824
	call	SeTextOut

; 60   : 	SeTextOut("__PROCESSOR_DATA__ \r\n");

	lea	rcx, OFFSET FLAT:$SG3825
	call	SeTextOut

; 61   : 	SeTextOut("RIP -> %x \r\n", frame->rip);

	mov	rax, QWORD PTR frame$[rsp]
	mov	rdx, QWORD PTR [rax+16]
	lea	rcx, OFFSET FLAT:$SG3826
	call	SeTextOut

; 62   : 	SeTextOut("RSP -> %x \r\n", frame->rsp);

	mov	rax, QWORD PTR frame$[rsp]
	mov	rdx, QWORD PTR [rax+40]
	lea	rcx, OFFSET FLAT:$SG3827
	call	SeTextOut

; 63   : 	SeTextOut("RFLAGS -> %x \r\n", frame->rflags);

	mov	rax, QWORD PTR frame$[rsp]
	mov	rdx, QWORD PTR [rax+32]
	lea	rcx, OFFSET FLAT:$SG3828
	call	SeTextOut
$LN2@divide_by_:

; 64   : 
; 65   : 	for (;;);

	jmp	SHORT $LN2@divide_by_

; 66   : }

	add	rsp, 56					; 00000038H
	ret	0
?divide_by_zero_fault@@YAX_KPEAX@Z ENDP			; divide_by_zero_fault
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\hal\x86_64_exception.cpp
_TEXT	SEGMENT
msg$ = 48
?panic@@YAXPEBDZZ PROC					; panic

; 46   : void panic(const char* msg, ...) {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	sub	rsp, 40					; 00000028H

; 47   : 	SeTextOut("\r\n ***ARCH x86_64 : Kernel Panic!!! *** \r\n");

	lea	rcx, OFFSET FLAT:$SG3811
	call	SeTextOut

; 48   : 	SeTextOut("[Aurora Kernel]: We are sorry to say that, a processor invalid exception has occured \r\n");

	lea	rcx, OFFSET FLAT:$SG3812
	call	SeTextOut

; 49   : 	SeTextOut("[Aurora Kernel]: please inform it to the master of the kernel \r\n");

	lea	rcx, OFFSET FLAT:$SG3813
	call	SeTextOut

; 50   : 	SeTextOut("[Aurora Kernel]: Below is the code of exception \r\n");

	lea	rcx, OFFSET FLAT:$SG3814
	call	SeTextOut

; 51   : 	SeTextOut("[Aurora Kernel]: Current Processor id -> %d \r\n", AuPerCPUGetCpuID());

	call	?AuPerCPUGetCpuID@@YAEXZ		; AuPerCPUGetCpuID
	movzx	eax, al
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG3815
	call	SeTextOut

; 52   : 	SeTextOut(" %s \r\n", msg);

	mov	rdx, QWORD PTR msg$[rsp]
	lea	rcx, OFFSET FLAT:$SG3816
	call	SeTextOut

; 53   : }

	add	rsp, 40					; 00000028H
	ret	0
?panic@@YAXPEBDZZ ENDP					; panic
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\hal\x86_64_exception.cpp
_TEXT	SEGMENT
?x86_64_exception_init@@YAXXZ PROC			; x86_64_exception_init

; 263  : void x86_64_exception_init() {

$LN3:
	sub	rsp, 40					; 00000028H

; 264  : 	setvect(0, divide_by_zero_fault);

	lea	rdx, OFFSET FLAT:?divide_by_zero_fault@@YAX_KPEAX@Z ; divide_by_zero_fault
	xor	ecx, ecx
	call	setvect

; 265  : 	setvect(1, single_step_trap);

	lea	rdx, OFFSET FLAT:?single_step_trap@@YAX_KPEAX@Z ; single_step_trap
	mov	ecx, 1
	call	setvect

; 266  : 	setvect(2, nmi_trap);

	lea	rdx, OFFSET FLAT:?nmi_trap@@YAX_KPEAX@Z	; nmi_trap
	mov	ecx, 2
	call	setvect

; 267  : 	setvect(3, breakpoint_trap);

	lea	rdx, OFFSET FLAT:?breakpoint_trap@@YAX_KPEAX@Z ; breakpoint_trap
	mov	ecx, 3
	call	setvect

; 268  : 	setvect(4, overflow_trap);

	lea	rdx, OFFSET FLAT:?overflow_trap@@YAX_KPEAX@Z ; overflow_trap
	mov	ecx, 4
	call	setvect

; 269  : 	setvect(5, bounds_check_fault);

	lea	rdx, OFFSET FLAT:?bounds_check_fault@@YAX_KPEAX@Z ; bounds_check_fault
	mov	ecx, 5
	call	setvect

; 270  : 	setvect(6, invalid_opcode_fault);

	lea	rdx, OFFSET FLAT:?invalid_opcode_fault@@YAX_KPEAX@Z ; invalid_opcode_fault
	mov	ecx, 6
	call	setvect

; 271  : 	setvect(7, no_device_fault);

	lea	rdx, OFFSET FLAT:?no_device_fault@@YAX_KPEAX@Z ; no_device_fault
	mov	ecx, 7
	call	setvect

; 272  : 	setvect(8, double_fault_abort);

	lea	rdx, OFFSET FLAT:?double_fault_abort@@YAX_KPEAX@Z ; double_fault_abort
	mov	ecx, 8
	call	setvect

; 273  : 	setvect(10, invalid_tss_fault);

	lea	rdx, OFFSET FLAT:?invalid_tss_fault@@YAX_KPEAX@Z ; invalid_tss_fault
	mov	ecx, 10
	call	setvect

; 274  : 	setvect(11, no_segment_fault);

	lea	rdx, OFFSET FLAT:?no_segment_fault@@YAX_KPEAX@Z ; no_segment_fault
	mov	ecx, 11
	call	setvect

; 275  : 	setvect(12, stack_fault);

	lea	rdx, OFFSET FLAT:?stack_fault@@YAX_KPEAX@Z ; stack_fault
	mov	ecx, 12
	call	setvect

; 276  : 	setvect(13, general_protection_fault);

	lea	rdx, OFFSET FLAT:?general_protection_fault@@YAX_KPEAX@Z ; general_protection_fault
	mov	ecx, 13
	call	setvect

; 277  : 	setvect(14, page_fault);

	lea	rdx, OFFSET FLAT:?page_fault@@YAX_KPEAX@Z ; page_fault
	mov	ecx, 14
	call	setvect

; 278  : 	setvect(16, fpu_fault);

	lea	rdx, OFFSET FLAT:?fpu_fault@@YAX_KPEAX@Z ; fpu_fault
	mov	ecx, 16
	call	setvect

; 279  : 	setvect(17, alignment_check_fault);

	lea	rdx, OFFSET FLAT:?alignment_check_fault@@YAX_KPEAX@Z ; alignment_check_fault
	mov	ecx, 17
	call	setvect

; 280  : 	setvect(18, machine_check_abort);

	lea	rdx, OFFSET FLAT:?machine_check_abort@@YAX_KPEAX@Z ; machine_check_abort
	mov	ecx, 18
	call	setvect

; 281  : 	setvect(19, simd_fpu_fault);

	lea	rdx, OFFSET FLAT:?simd_fpu_fault@@YAX_KPEAX@Z ; simd_fpu_fault
	mov	ecx, 19
	call	setvect

; 282  : }

	add	rsp, 40					; 00000028H
	ret	0
?x86_64_exception_init@@YAXXZ ENDP			; x86_64_exception_init
_TEXT	ENDS
END
