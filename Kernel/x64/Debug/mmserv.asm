; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.21005.1 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG3468	DB	'Returning error heap mem -> %d ', 0dH, 0aH, 00H
CONST	ENDS
PUBLIC	?CreateSharedMem@@YAHG_KE@Z			; CreateSharedMem
PUBLIC	?ObtainSharedMem@@YAPEAXGPEAXH@Z		; ObtainSharedMem
PUBLIC	?UnmapSharedMem@@YAXG@Z				; UnmapSharedMem
PUBLIC	?GetProcessHeapMem@@YA_K_K@Z			; GetProcessHeapMem
EXTRN	AuGetCurrentThread:PROC
EXTRN	?AuProcessFindThread@@YAPEAU_au_proc_@@PEAU_au_thread_@@@Z:PROC ; AuProcessFindThread
EXTRN	?AuProcessFindSubThread@@YAPEAU_au_proc_@@PEAU_au_thread_@@@Z:PROC ; AuProcessFindSubThread
EXTRN	?AuCreateSHM@@YAHPEAU_au_proc_@@G_KE@Z:PROC	; AuCreateSHM
EXTRN	?AuSHMObtainMem@@YAPEAXPEAU_au_proc_@@GPEAXH@Z:PROC ; AuSHMObtainMem
EXTRN	?AuSHMUnmap@@YAXGPEAU_au_proc_@@@Z:PROC		; AuSHMUnmap
EXTRN	AuMapPage:PROC
EXTRN	AuPmmngrAlloc:PROC
EXTRN	AuTextOut:PROC
EXTRN	x64_cli:PROC
pdata	SEGMENT
$pdata$?CreateSharedMem@@YAHG_KE@Z DD imagerel $LN6
	DD	imagerel $LN6+136
	DD	imagerel $unwind$?CreateSharedMem@@YAHG_KE@Z
$pdata$?ObtainSharedMem@@YAPEAXGPEAXH@Z DD imagerel $LN6
	DD	imagerel $LN6+121
	DD	imagerel $unwind$?ObtainSharedMem@@YAPEAXGPEAXH@Z
$pdata$?UnmapSharedMem@@YAXG@Z DD imagerel $LN6
	DD	imagerel $LN6+102
	DD	imagerel $unwind$?UnmapSharedMem@@YAXG@Z
$pdata$?GetProcessHeapMem@@YA_K_K@Z DD imagerel $LN12
	DD	imagerel $LN12+374
	DD	imagerel $unwind$?GetProcessHeapMem@@YA_K_K@Z
pdata	ENDS
xdata	SEGMENT
$unwind$?CreateSharedMem@@YAHG_KE@Z DD 011301H
	DD	08213H
$unwind$?ObtainSharedMem@@YAPEAXGPEAXH@Z DD 011301H
	DD	06213H
$unwind$?UnmapSharedMem@@YAXG@Z DD 010901H
	DD	06209H
$unwind$?GetProcessHeapMem@@YA_K_K@Z DD 010901H
	DD	0c209H
xdata	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\serv\mmserv.cpp
_TEXT	SEGMENT
i$1 = 32
proc$ = 40
thr$ = 48
tv72 = 56
start_addr$ = 64
tv83 = 72
phys$2 = 80
sz$ = 112
?GetProcessHeapMem@@YA_K_K@Z PROC			; GetProcessHeapMem

; 106  : uint64_t GetProcessHeapMem(size_t sz) {

$LN12:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 107  : 	x64_cli();

	call	x64_cli

; 108  : 	/* check if size is page aligned */
; 109  : 	if ((sz % PAGE_SIZE) != 0){

	xor	edx, edx
	mov	rax, QWORD PTR sz$[rsp]
	mov	ecx, 4096				; 00001000H
	div	rcx
	mov	rax, rdx
	test	rax, rax
	je	SHORT $LN7@GetProcess

; 110  : 		AuTextOut("Returning error heap mem -> %d \r\n", sz);

	mov	rdx, QWORD PTR sz$[rsp]
	lea	rcx, OFFSET FLAT:$SG3468
	call	AuTextOut

; 111  : 		return -1;

	mov	rax, -1
	jmp	$LN8@GetProcess

; 112  : 		sz = PAGE_ALIGN(sz);

	mov	rax, QWORD PTR sz$[rsp]
	and	rax, 4095				; 00000fffH
	test	rax, rax
	je	SHORT $LN10@GetProcess
	mov	rax, QWORD PTR sz$[rsp]
	add	rax, 4096				; 00001000H
	and	rax, -4096				; fffffffffffff000H
	mov	QWORD PTR tv72[rsp], rax
	jmp	SHORT $LN11@GetProcess
$LN10@GetProcess:
	mov	rax, QWORD PTR sz$[rsp]
	mov	QWORD PTR tv72[rsp], rax
$LN11@GetProcess:
	mov	rax, QWORD PTR tv72[rsp]
	mov	QWORD PTR sz$[rsp], rax
$LN7@GetProcess:

; 113  : 	}
; 114  : 	
; 115  : 	AuThread* thr = AuGetCurrentThread();

	call	AuGetCurrentThread
	mov	QWORD PTR thr$[rsp], rax

; 116  : 	if (!thr)

	cmp	QWORD PTR thr$[rsp], 0
	jne	SHORT $LN6@GetProcess

; 117  : 		return -1;

	mov	rax, -1
	jmp	$LN8@GetProcess
$LN6@GetProcess:

; 118  : 	AuProcess* proc = AuProcessFindThread(thr);

	mov	rcx, QWORD PTR thr$[rsp]
	call	?AuProcessFindThread@@YAPEAU_au_proc_@@PEAU_au_thread_@@@Z ; AuProcessFindThread
	mov	QWORD PTR proc$[rsp], rax

; 119  : 	if (!proc){

	cmp	QWORD PTR proc$[rsp], 0
	jne	SHORT $LN5@GetProcess

; 120  : 		proc = AuProcessFindSubThread(thr);

	mov	rcx, QWORD PTR thr$[rsp]
	call	?AuProcessFindSubThread@@YAPEAU_au_proc_@@PEAU_au_thread_@@@Z ; AuProcessFindSubThread
	mov	QWORD PTR proc$[rsp], rax

; 121  : 		if (!proc) {

	cmp	QWORD PTR proc$[rsp], 0
	jne	SHORT $LN4@GetProcess

; 122  : 			return -1;

	mov	rax, -1
	jmp	$LN8@GetProcess
$LN4@GetProcess:
$LN5@GetProcess:

; 123  : 		}
; 124  : 	}
; 125  : 	uint64_t start_addr = proc->proc_mem_heap;

	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+1096]
	mov	QWORD PTR start_addr$[rsp], rax

; 126  : 
; 127  : 	for (int i = 0; i < sz / PAGE_SIZE; i++) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN3@GetProcess
$LN2@GetProcess:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN3@GetProcess:
	movsxd	rax, DWORD PTR i$1[rsp]
	mov	QWORD PTR tv83[rsp], rax
	xor	edx, edx
	mov	rax, QWORD PTR sz$[rsp]
	mov	ecx, 4096				; 00001000H
	div	rcx
	mov	rcx, QWORD PTR tv83[rsp]
	cmp	rcx, rax
	jae	SHORT $LN1@GetProcess

; 128  : 		void* phys = AuPmmngrAlloc();

	call	AuPmmngrAlloc
	mov	QWORD PTR phys$2[rsp], rax

; 129  : 		AuMapPage((size_t)phys, start_addr + i * PAGE_SIZE, X86_64_PAGING_USER);

	imul	eax, DWORD PTR i$1[rsp], 4096		; 00001000H
	cdqe
	mov	rcx, QWORD PTR start_addr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	r8b, 4
	mov	rdx, rax
	mov	rcx, QWORD PTR phys$2[rsp]
	call	AuMapPage

; 130  : 	}

	jmp	SHORT $LN2@GetProcess
$LN1@GetProcess:

; 131  : 	proc->proc_mem_heap += sz;

	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+1096]
	add	rax, QWORD PTR sz$[rsp]
	mov	rcx, QWORD PTR proc$[rsp]
	mov	QWORD PTR [rcx+1096], rax

; 132  : 	return start_addr;

	mov	rax, QWORD PTR start_addr$[rsp]
$LN8@GetProcess:

; 133  : }

	add	rsp, 104				; 00000068H
	ret	0
?GetProcessHeapMem@@YA_K_K@Z ENDP			; GetProcessHeapMem
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\serv\mmserv.cpp
_TEXT	SEGMENT
proc$ = 32
thr$ = 40
key$ = 64
?UnmapSharedMem@@YAXG@Z PROC				; UnmapSharedMem

; 87   : void UnmapSharedMem(uint16_t key) {

$LN6:
	mov	WORD PTR [rsp+8], cx
	sub	rsp, 56					; 00000038H

; 88   : 	x64_cli();

	call	x64_cli

; 89   : 	AuThread* thr = AuGetCurrentThread();

	call	AuGetCurrentThread
	mov	QWORD PTR thr$[rsp], rax

; 90   : 	if (!thr)  //some serious memory problem

	cmp	QWORD PTR thr$[rsp], 0
	jne	SHORT $LN3@UnmapShare

; 91   : 		return;

	jmp	SHORT $LN4@UnmapShare
$LN3@UnmapShare:

; 92   : 	AuProcess* proc = AuProcessFindThread(thr);

	mov	rcx, QWORD PTR thr$[rsp]
	call	?AuProcessFindThread@@YAPEAU_au_proc_@@PEAU_au_thread_@@@Z ; AuProcessFindThread
	mov	QWORD PTR proc$[rsp], rax

; 93   : 	if (!proc) {

	cmp	QWORD PTR proc$[rsp], 0
	jne	SHORT $LN2@UnmapShare

; 94   : 		proc = AuProcessFindSubThread(thr);

	mov	rcx, QWORD PTR thr$[rsp]
	call	?AuProcessFindSubThread@@YAPEAU_au_proc_@@PEAU_au_thread_@@@Z ; AuProcessFindSubThread
	mov	QWORD PTR proc$[rsp], rax

; 95   : 		if (!proc)

	cmp	QWORD PTR proc$[rsp], 0
	jne	SHORT $LN1@UnmapShare

; 96   : 			return;

	jmp	SHORT $LN4@UnmapShare
$LN1@UnmapShare:
$LN2@UnmapShare:

; 97   : 	}
; 98   : 	AuSHMUnmap(key, proc);

	mov	rdx, QWORD PTR proc$[rsp]
	movzx	ecx, WORD PTR key$[rsp]
	call	?AuSHMUnmap@@YAXGPEAU_au_proc_@@@Z	; AuSHMUnmap
$LN4@UnmapShare:

; 99   : }

	add	rsp, 56					; 00000038H
	ret	0
?UnmapSharedMem@@YAXG@Z ENDP				; UnmapSharedMem
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\serv\mmserv.cpp
_TEXT	SEGMENT
proc$ = 32
thr$ = 40
id$ = 64
shmaddr$ = 72
shmflg$ = 80
?ObtainSharedMem@@YAPEAXGPEAXH@Z PROC			; ObtainSharedMem

; 70   : void* ObtainSharedMem(uint16_t id, void* shmaddr, int shmflg) {

$LN6:
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	WORD PTR [rsp+8], cx
	sub	rsp, 56					; 00000038H

; 71   : 	AuThread* thr = AuGetCurrentThread();

	call	AuGetCurrentThread
	mov	QWORD PTR thr$[rsp], rax

; 72   : 	if (!thr)

	cmp	QWORD PTR thr$[rsp], 0
	jne	SHORT $LN3@ObtainShar

; 73   : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN4@ObtainShar
$LN3@ObtainShar:

; 74   : 	AuProcess* proc = AuProcessFindThread(thr);

	mov	rcx, QWORD PTR thr$[rsp]
	call	?AuProcessFindThread@@YAPEAU_au_proc_@@PEAU_au_thread_@@@Z ; AuProcessFindThread
	mov	QWORD PTR proc$[rsp], rax

; 75   : 	if (!proc) {

	cmp	QWORD PTR proc$[rsp], 0
	jne	SHORT $LN2@ObtainShar

; 76   : 		proc = AuProcessFindSubThread(thr);

	mov	rcx, QWORD PTR thr$[rsp]
	call	?AuProcessFindSubThread@@YAPEAU_au_proc_@@PEAU_au_thread_@@@Z ; AuProcessFindSubThread
	mov	QWORD PTR proc$[rsp], rax

; 77   : 		if (!proc)

	cmp	QWORD PTR proc$[rsp], 0
	jne	SHORT $LN1@ObtainShar

; 78   : 			return NULL;

	xor	eax, eax
	jmp	SHORT $LN4@ObtainShar
$LN1@ObtainShar:
$LN2@ObtainShar:

; 79   : 	}
; 80   : 	return AuSHMObtainMem(proc,id, shmaddr, shmflg);

	mov	r9d, DWORD PTR shmflg$[rsp]
	mov	r8, QWORD PTR shmaddr$[rsp]
	movzx	edx, WORD PTR id$[rsp]
	mov	rcx, QWORD PTR proc$[rsp]
	call	?AuSHMObtainMem@@YAPEAXPEAU_au_proc_@@GPEAXH@Z ; AuSHMObtainMem
$LN4@ObtainShar:

; 81   : }

	add	rsp, 56					; 00000038H
	ret	0
?ObtainSharedMem@@YAPEAXGPEAXH@Z ENDP			; ObtainSharedMem
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\serv\mmserv.cpp
_TEXT	SEGMENT
id$ = 32
proc$ = 40
thr$ = 48
key$ = 80
sz$ = 88
flags$ = 96
?CreateSharedMem@@YAHG_KE@Z PROC			; CreateSharedMem

; 49   : int CreateSharedMem(uint16_t key, size_t sz, uint8_t flags){

$LN6:
	mov	BYTE PTR [rsp+24], r8b
	mov	QWORD PTR [rsp+16], rdx
	mov	WORD PTR [rsp+8], cx
	sub	rsp, 72					; 00000048H

; 50   : 	AuThread* thr = AuGetCurrentThread();

	call	AuGetCurrentThread
	mov	QWORD PTR thr$[rsp], rax

; 51   : 	if (!thr)

	cmp	QWORD PTR thr$[rsp], 0
	jne	SHORT $LN3@CreateShar

; 52   : 		return -1;

	mov	eax, -1
	jmp	SHORT $LN4@CreateShar
$LN3@CreateShar:

; 53   : 	AuProcess* proc = AuProcessFindThread(thr);

	mov	rcx, QWORD PTR thr$[rsp]
	call	?AuProcessFindThread@@YAPEAU_au_proc_@@PEAU_au_thread_@@@Z ; AuProcessFindThread
	mov	QWORD PTR proc$[rsp], rax

; 54   : 	if (!proc){

	cmp	QWORD PTR proc$[rsp], 0
	jne	SHORT $LN2@CreateShar

; 55   : 		proc = AuProcessFindSubThread(thr);

	mov	rcx, QWORD PTR thr$[rsp]
	call	?AuProcessFindSubThread@@YAPEAU_au_proc_@@PEAU_au_thread_@@@Z ; AuProcessFindSubThread
	mov	QWORD PTR proc$[rsp], rax

; 56   : 		if (!proc){

	cmp	QWORD PTR proc$[rsp], 0
	jne	SHORT $LN1@CreateShar

; 57   : 			return -1;

	mov	eax, -1
	jmp	SHORT $LN4@CreateShar
$LN1@CreateShar:
$LN2@CreateShar:

; 58   : 		}
; 59   : 	}
; 60   : 	int id = AuCreateSHM(proc, key, sz, flags);

	movzx	r9d, BYTE PTR flags$[rsp]
	mov	r8, QWORD PTR sz$[rsp]
	movzx	edx, WORD PTR key$[rsp]
	mov	rcx, QWORD PTR proc$[rsp]
	call	?AuCreateSHM@@YAHPEAU_au_proc_@@G_KE@Z	; AuCreateSHM
	mov	DWORD PTR id$[rsp], eax

; 61   : 	return id;

	mov	eax, DWORD PTR id$[rsp]
$LN4@CreateShar:

; 62   : }

	add	rsp, 72					; 00000048H
	ret	0
?CreateSharedMem@@YAHG_KE@Z ENDP			; CreateSharedMem
_TEXT	ENDS
END
