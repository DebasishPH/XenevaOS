; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.21005.1 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG3474	DB	'Creating shared mem for thr -> %s ', 0dH, 0aH, 00H
	ORG $+3
$SG3498	DB	'Returning error heap mem -> %d ', 0dH, 0aH, 00H
	ORG $+6
$SG3514	DB	'Failed to map %x ', 0dH, 0aH, 00H
	ORG $+4
$SG3520	DB	'Returning error heap unmap -> %d ', 0dH, 0aH, 00H
CONST	ENDS
PUBLIC	?CreateSharedMem@@YAHG_KE@Z			; CreateSharedMem
PUBLIC	?ObtainSharedMem@@YAPEAXGPEAXH@Z		; ObtainSharedMem
PUBLIC	?UnmapSharedMem@@YAXG@Z				; UnmapSharedMem
PUBLIC	?GetProcessHeapMem@@YA_K_K@Z			; GetProcessHeapMem
PUBLIC	?ProcessHeapUnmap@@YAHPEAX_K@Z			; ProcessHeapUnmap
EXTRN	AuGetCurrentThread:PROC
EXTRN	?AuProcessFindThread@@YAPEAU_au_proc_@@PEAU_au_thread_@@@Z:PROC ; AuProcessFindThread
EXTRN	?AuProcessFindSubThread@@YAPEAU_au_proc_@@PEAU_au_thread_@@@Z:PROC ; AuProcessFindSubThread
EXTRN	?AuCreateSHM@@YAHPEAU_au_proc_@@G_KE@Z:PROC	; AuCreateSHM
EXTRN	?AuSHMObtainMem@@YAPEAXPEAU_au_proc_@@GPEAXH@Z:PROC ; AuSHMObtainMem
EXTRN	?AuSHMUnmap@@YAXGPEAU_au_proc_@@@Z:PROC		; AuSHMUnmap
EXTRN	AuVmmngrGetPage:PROC
EXTRN	AuMapPage:PROC
EXTRN	AuGetFreePage:PROC
EXTRN	AuPmmngrAlloc:PROC
EXTRN	AuPmmngrFree:PROC
EXTRN	AuTextOut:PROC
EXTRN	x64_cli:PROC
EXTRN	SeTextOut:PROC
pdata	SEGMENT
$pdata$?CreateSharedMem@@YAHG_KE@Z DD imagerel $LN6
	DD	imagerel $LN6+167
	DD	imagerel $unwind$?CreateSharedMem@@YAHG_KE@Z
$pdata$?ObtainSharedMem@@YAPEAXGPEAXH@Z DD imagerel $LN6
	DD	imagerel $LN6+126
	DD	imagerel $unwind$?ObtainSharedMem@@YAPEAXGPEAXH@Z
$pdata$?UnmapSharedMem@@YAXG@Z DD imagerel $LN6
	DD	imagerel $LN6+102
	DD	imagerel $unwind$?UnmapSharedMem@@YAXG@Z
$pdata$?GetProcessHeapMem@@YA_K_K@Z DD imagerel $LN13
	DD	imagerel $LN13+456
	DD	imagerel $unwind$?GetProcessHeapMem@@YA_K_K@Z
$pdata$?ProcessHeapUnmap@@YAHPEAX_K@Z DD imagerel $LN14
	DD	imagerel $LN14+464
	DD	imagerel $unwind$?ProcessHeapUnmap@@YAHPEAX_K@Z
pdata	ENDS
xdata	SEGMENT
$unwind$?CreateSharedMem@@YAHG_KE@Z DD 011301H
	DD	08213H
$unwind$?ObtainSharedMem@@YAPEAXGPEAXH@Z DD 011301H
	DD	06213H
$unwind$?UnmapSharedMem@@YAXG@Z DD 010901H
	DD	06209H
$unwind$?GetProcessHeapMem@@YA_K_K@Z DD 010901H
	DD	0c209H
$unwind$?ProcessHeapUnmap@@YAHPEAX_K@Z DD 010e01H
	DD	0c20eH
xdata	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\serv\mmserv.cpp
_TEXT	SEGMENT
i$1 = 32
page_$2 = 40
proc$ = 48
thr$ = 56
tv72 = 64
phys_page$3 = 72
start_addr$ = 80
tv82 = 88
ptr$ = 112
sz$ = 120
?ProcessHeapUnmap@@YAHPEAX_K@Z PROC			; ProcessHeapUnmap

; 152  : int ProcessHeapUnmap(void* ptr, size_t sz) {

$LN14:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 153  : 	x64_cli();

	call	x64_cli

; 154  : 	/* check if size is page aligned */
; 155  : 	if ((sz % PAGE_SIZE) != 0){

	xor	edx, edx
	mov	rax, QWORD PTR sz$[rsp]
	mov	ecx, 4096				; 00001000H
	div	rcx
	mov	rax, rdx
	test	rax, rax
	je	SHORT $LN9@ProcessHea

; 156  : 		AuTextOut("Returning error heap unmap -> %d \r\n", sz);

	mov	rdx, QWORD PTR sz$[rsp]
	lea	rcx, OFFSET FLAT:$SG3520
	call	AuTextOut

; 157  : 		return -1;

	mov	eax, -1
	jmp	$LN10@ProcessHea

; 158  : 		sz = PAGE_ALIGN(sz);

	mov	rax, QWORD PTR sz$[rsp]
	and	rax, 4095				; 00000fffH
	test	rax, rax
	je	SHORT $LN12@ProcessHea
	mov	rax, QWORD PTR sz$[rsp]
	add	rax, 4096				; 00001000H
	and	rax, -4096				; fffffffffffff000H
	mov	QWORD PTR tv72[rsp], rax
	jmp	SHORT $LN13@ProcessHea
$LN12@ProcessHea:
	mov	rax, QWORD PTR sz$[rsp]
	mov	QWORD PTR tv72[rsp], rax
$LN13@ProcessHea:
	mov	rax, QWORD PTR tv72[rsp]
	mov	QWORD PTR sz$[rsp], rax
$LN9@ProcessHea:

; 159  : 	}
; 160  : 
; 161  : 	AuThread* thr = AuGetCurrentThread();

	call	AuGetCurrentThread
	mov	QWORD PTR thr$[rsp], rax

; 162  : 	if (!thr)

	cmp	QWORD PTR thr$[rsp], 0
	jne	SHORT $LN8@ProcessHea

; 163  : 		return -1;

	mov	eax, -1
	jmp	$LN10@ProcessHea
$LN8@ProcessHea:

; 164  : 	AuProcess* proc = AuProcessFindThread(thr);

	mov	rcx, QWORD PTR thr$[rsp]
	call	?AuProcessFindThread@@YAPEAU_au_proc_@@PEAU_au_thread_@@@Z ; AuProcessFindThread
	mov	QWORD PTR proc$[rsp], rax

; 165  : 	if (!proc){

	cmp	QWORD PTR proc$[rsp], 0
	jne	SHORT $LN7@ProcessHea

; 166  : 		proc = AuProcessFindSubThread(thr);

	mov	rcx, QWORD PTR thr$[rsp]
	call	?AuProcessFindSubThread@@YAPEAU_au_proc_@@PEAU_au_thread_@@@Z ; AuProcessFindSubThread
	mov	QWORD PTR proc$[rsp], rax

; 167  : 		if (!proc) {

	cmp	QWORD PTR proc$[rsp], 0
	jne	SHORT $LN6@ProcessHea

; 168  : 			return -1;

	mov	eax, -1
	jmp	$LN10@ProcessHea
$LN6@ProcessHea:
$LN7@ProcessHea:

; 169  : 		}
; 170  : 	}
; 171  : 	uint64_t start_addr = (uint64_t)ptr;

	mov	rax, QWORD PTR ptr$[rsp]
	mov	QWORD PTR start_addr$[rsp], rax

; 172  : 	for (int i = 0; i < sz / PAGE_SIZE; i++) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN5@ProcessHea
$LN4@ProcessHea:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN5@ProcessHea:
	movsxd	rax, DWORD PTR i$1[rsp]
	mov	QWORD PTR tv82[rsp], rax
	xor	edx, edx
	mov	rax, QWORD PTR sz$[rsp]
	mov	ecx, 4096				; 00001000H
	div	rcx
	mov	rcx, QWORD PTR tv82[rsp]
	cmp	rcx, rax
	jae	$LN3@ProcessHea

; 173  : 		AuVPage* page_ = AuVmmngrGetPage(start_addr + i * PAGE_SIZE, VIRT_GETPAGE_ONLY_RET, VIRT_GETPAGE_ONLY_RET);

	imul	eax, DWORD PTR i$1[rsp], 4096		; 00001000H
	cdqe
	mov	rcx, QWORD PTR start_addr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	r8b, 2
	mov	dl, 2
	mov	rcx, rax
	call	AuVmmngrGetPage
	mov	QWORD PTR page_$2[rsp], rax

; 174  : 		if (page_) {

	cmp	QWORD PTR page_$2[rsp], 0
	je	SHORT $LN2@ProcessHea

; 175  : 			uint64_t phys_page = page_->bits.page << PAGE_SHIFT;

	mov	rax, QWORD PTR page_$2[rsp]
	mov	rax, QWORD PTR [rax]
	shr	rax, 12
	and	rax, 268435455				; 0fffffffH
	shl	rax, 12
	mov	QWORD PTR phys_page$3[rsp], rax

; 176  : 			if (phys_page){

	cmp	QWORD PTR phys_page$3[rsp], 0
	je	SHORT $LN1@ProcessHea

; 177  : 				AuPmmngrFree((void*)phys_page);

	mov	rcx, QWORD PTR phys_page$3[rsp]
	call	AuPmmngrFree

; 178  : 				page_->bits.page = 0;

	mov	rax, QWORD PTR page_$2[rsp]
	mov	rcx, -1099511623681			; ffffff0000000fffH
	mov	rax, QWORD PTR [rax]
	and	rax, rcx
	mov	rcx, QWORD PTR page_$2[rsp]
	mov	QWORD PTR [rcx], rax

; 179  : 				page_->bits.present = 0;

	mov	rax, QWORD PTR page_$2[rsp]
	mov	rax, QWORD PTR [rax]
	and	rax, -2
	mov	rcx, QWORD PTR page_$2[rsp]
	mov	QWORD PTR [rcx], rax

; 180  : 				page_->raw = 0;

	mov	rax, QWORD PTR page_$2[rsp]
	mov	QWORD PTR [rax], 0
$LN1@ProcessHea:
$LN2@ProcessHea:

; 181  : 			}
; 182  : 		}
; 183  : 	}

	jmp	$LN4@ProcessHea
$LN3@ProcessHea:

; 184  : 	/*if (start_addr < proc->proc_mem_heap)*/
; 185  : 	proc->proc_mem_heap = start_addr;

	mov	rax, QWORD PTR proc$[rsp]
	mov	rcx, QWORD PTR start_addr$[rsp]
	mov	QWORD PTR [rax+1104], rcx

; 186  : 	return 0;

	xor	eax, eax
$LN10@ProcessHea:

; 187  : }

	add	rsp, 104				; 00000068H
	ret	0
?ProcessHeapUnmap@@YAHPEAX_K@Z ENDP			; ProcessHeapUnmap
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\serv\mmserv.cpp
_TEXT	SEGMENT
i$1 = 32
proc$ = 40
thr$ = 48
start_addr$ = 56
tv72 = 64
tv86 = 72
phys$2 = 80
sz$ = 112
?GetProcessHeapMem@@YA_K_K@Z PROC			; GetProcessHeapMem

; 109  : uint64_t GetProcessHeapMem(size_t sz) {

$LN13:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 110  : 	x64_cli();

	call	x64_cli

; 111  : 	/* check if size is page aligned */
; 112  : 	if ((sz % PAGE_SIZE) != 0){

	xor	edx, edx
	mov	rax, QWORD PTR sz$[rsp]
	mov	ecx, 4096				; 00001000H
	div	rcx
	mov	rax, rdx
	test	rax, rax
	je	SHORT $LN8@GetProcess

; 113  : 		AuTextOut("Returning error heap mem -> %d \r\n", sz);

	mov	rdx, QWORD PTR sz$[rsp]
	lea	rcx, OFFSET FLAT:$SG3498
	call	AuTextOut

; 114  : 		return -1;

	mov	rax, -1
	jmp	$LN9@GetProcess

; 115  : 		sz = PAGE_ALIGN(sz);

	mov	rax, QWORD PTR sz$[rsp]
	and	rax, 4095				; 00000fffH
	test	rax, rax
	je	SHORT $LN11@GetProcess
	mov	rax, QWORD PTR sz$[rsp]
	add	rax, 4096				; 00001000H
	and	rax, -4096				; fffffffffffff000H
	mov	QWORD PTR tv72[rsp], rax
	jmp	SHORT $LN12@GetProcess
$LN11@GetProcess:
	mov	rax, QWORD PTR sz$[rsp]
	mov	QWORD PTR tv72[rsp], rax
$LN12@GetProcess:
	mov	rax, QWORD PTR tv72[rsp]
	mov	QWORD PTR sz$[rsp], rax
$LN8@GetProcess:

; 116  : 	}
; 117  : 	
; 118  : 	AuThread* thr = AuGetCurrentThread();

	call	AuGetCurrentThread
	mov	QWORD PTR thr$[rsp], rax

; 119  : 	if (!thr)

	cmp	QWORD PTR thr$[rsp], 0
	jne	SHORT $LN7@GetProcess

; 120  : 		return -1;

	mov	rax, -1
	jmp	$LN9@GetProcess
$LN7@GetProcess:

; 121  : 	AuProcess* proc = AuProcessFindThread(thr);

	mov	rcx, QWORD PTR thr$[rsp]
	call	?AuProcessFindThread@@YAPEAU_au_proc_@@PEAU_au_thread_@@@Z ; AuProcessFindThread
	mov	QWORD PTR proc$[rsp], rax

; 122  : 	if (!proc){

	cmp	QWORD PTR proc$[rsp], 0
	jne	SHORT $LN6@GetProcess

; 123  : 		proc = AuProcessFindSubThread(thr);

	mov	rcx, QWORD PTR thr$[rsp]
	call	?AuProcessFindSubThread@@YAPEAU_au_proc_@@PEAU_au_thread_@@@Z ; AuProcessFindSubThread
	mov	QWORD PTR proc$[rsp], rax

; 124  : 		if (!proc) {

	cmp	QWORD PTR proc$[rsp], 0
	jne	SHORT $LN5@GetProcess

; 125  : 			return -1;

	mov	rax, -1
	jmp	$LN9@GetProcess
$LN5@GetProcess:
$LN6@GetProcess:

; 126  : 		}
; 127  : 	}
; 128  : 
; 129  : 	uint64_t start_addr = (uint64_t)AuGetFreePage(false, (void*)proc->proc_mem_heap);

	mov	rax, QWORD PTR proc$[rsp]
	mov	rdx, QWORD PTR [rax+1104]
	xor	ecx, ecx
	call	AuGetFreePage
	mov	QWORD PTR start_addr$[rsp], rax

; 130  : 
; 131  : 	for (int i = 0; i < sz / PAGE_SIZE; i++) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN4@GetProcess
$LN3@GetProcess:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN4@GetProcess:
	movsxd	rax, DWORD PTR i$1[rsp]
	mov	QWORD PTR tv86[rsp], rax
	xor	edx, edx
	mov	rax, QWORD PTR sz$[rsp]
	mov	ecx, 4096				; 00001000H
	div	rcx
	mov	rcx, QWORD PTR tv86[rsp]
	cmp	rcx, rax
	jae	SHORT $LN2@GetProcess

; 132  : 		/*AuVPage* vpage = AuVmmngrGetPage(start_addr + i * PAGE_SIZE, VIRT_GETPAGE_ONLY_RET, VIRT_GETPAGE_ONLY_RET);
; 133  : 		if (vpage->bits.page != 0)
; 134  : 			continue;*/
; 135  : 		void* phys = AuPmmngrAlloc();

	call	AuPmmngrAlloc
	mov	QWORD PTR phys$2[rsp], rax

; 136  : 		if (!AuMapPage((size_t)phys, start_addr + i * PAGE_SIZE, X86_64_PAGING_USER)) {

	imul	eax, DWORD PTR i$1[rsp], 4096		; 00001000H
	cdqe
	mov	rcx, QWORD PTR start_addr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	r8b, 4
	mov	rdx, rax
	mov	rcx, QWORD PTR phys$2[rsp]
	call	AuMapPage
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN1@GetProcess

; 137  : 			SeTextOut("Failed to map %x \r\n", (start_addr + i * PAGE_SIZE));

	imul	eax, DWORD PTR i$1[rsp], 4096		; 00001000H
	cdqe
	mov	rcx, QWORD PTR start_addr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG3514
	call	SeTextOut
$LN1@GetProcess:

; 138  : 		}
; 139  : 	}

	jmp	$LN3@GetProcess
$LN2@GetProcess:

; 140  : 	//SeTextOut("Mapped \r\n");
; 141  : 	proc->proc_mem_heap += sz;

	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+1104]
	add	rax, QWORD PTR sz$[rsp]
	mov	rcx, QWORD PTR proc$[rsp]
	mov	QWORD PTR [rcx+1104], rax

; 142  : 	proc->proc_heapmem_len += sz;

	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+1112]
	add	rax, QWORD PTR sz$[rsp]
	mov	rcx, QWORD PTR proc$[rsp]
	mov	QWORD PTR [rcx+1112], rax

; 143  : 	return start_addr;

	mov	rax, QWORD PTR start_addr$[rsp]
$LN9@GetProcess:

; 144  : }

	add	rsp, 104				; 00000068H
	ret	0
?GetProcessHeapMem@@YA_K_K@Z ENDP			; GetProcessHeapMem
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\serv\mmserv.cpp
_TEXT	SEGMENT
proc$ = 32
thr$ = 40
key$ = 64
?UnmapSharedMem@@YAXG@Z PROC				; UnmapSharedMem

; 90   : void UnmapSharedMem(uint16_t key) {

$LN6:
	mov	WORD PTR [rsp+8], cx
	sub	rsp, 56					; 00000038H

; 91   : 	x64_cli();

	call	x64_cli

; 92   : 	AuThread* thr = AuGetCurrentThread();

	call	AuGetCurrentThread
	mov	QWORD PTR thr$[rsp], rax

; 93   : 	if (!thr)  //some serious memory problem

	cmp	QWORD PTR thr$[rsp], 0
	jne	SHORT $LN3@UnmapShare

; 94   : 		return;

	jmp	SHORT $LN4@UnmapShare
$LN3@UnmapShare:

; 95   : 	AuProcess* proc = AuProcessFindThread(thr);

	mov	rcx, QWORD PTR thr$[rsp]
	call	?AuProcessFindThread@@YAPEAU_au_proc_@@PEAU_au_thread_@@@Z ; AuProcessFindThread
	mov	QWORD PTR proc$[rsp], rax

; 96   : 	if (!proc) {

	cmp	QWORD PTR proc$[rsp], 0
	jne	SHORT $LN2@UnmapShare

; 97   : 		proc = AuProcessFindSubThread(thr);

	mov	rcx, QWORD PTR thr$[rsp]
	call	?AuProcessFindSubThread@@YAPEAU_au_proc_@@PEAU_au_thread_@@@Z ; AuProcessFindSubThread
	mov	QWORD PTR proc$[rsp], rax

; 98   : 		if (!proc)

	cmp	QWORD PTR proc$[rsp], 0
	jne	SHORT $LN1@UnmapShare

; 99   : 			return;

	jmp	SHORT $LN4@UnmapShare
$LN1@UnmapShare:
$LN2@UnmapShare:

; 100  : 	}
; 101  : 	AuSHMUnmap(key, proc);

	mov	rdx, QWORD PTR proc$[rsp]
	movzx	ecx, WORD PTR key$[rsp]
	call	?AuSHMUnmap@@YAXGPEAU_au_proc_@@@Z	; AuSHMUnmap
$LN4@UnmapShare:

; 102  : }

	add	rsp, 56					; 00000038H
	ret	0
?UnmapSharedMem@@YAXG@Z ENDP				; UnmapSharedMem
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\serv\mmserv.cpp
_TEXT	SEGMENT
proc$ = 32
thr$ = 40
id$ = 64
shmaddr$ = 72
shmflg$ = 80
?ObtainSharedMem@@YAPEAXGPEAXH@Z PROC			; ObtainSharedMem

; 72   : void* ObtainSharedMem(uint16_t id, void* shmaddr, int shmflg) {

$LN6:
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	WORD PTR [rsp+8], cx
	sub	rsp, 56					; 00000038H

; 73   : 	x64_cli();

	call	x64_cli

; 74   : 	AuThread* thr = AuGetCurrentThread();

	call	AuGetCurrentThread
	mov	QWORD PTR thr$[rsp], rax

; 75   : 	if (!thr)

	cmp	QWORD PTR thr$[rsp], 0
	jne	SHORT $LN3@ObtainShar

; 76   : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN4@ObtainShar
$LN3@ObtainShar:

; 77   : 	AuProcess* proc = AuProcessFindThread(thr);

	mov	rcx, QWORD PTR thr$[rsp]
	call	?AuProcessFindThread@@YAPEAU_au_proc_@@PEAU_au_thread_@@@Z ; AuProcessFindThread
	mov	QWORD PTR proc$[rsp], rax

; 78   : 	if (!proc) {

	cmp	QWORD PTR proc$[rsp], 0
	jne	SHORT $LN2@ObtainShar

; 79   : 		proc = AuProcessFindSubThread(thr);

	mov	rcx, QWORD PTR thr$[rsp]
	call	?AuProcessFindSubThread@@YAPEAU_au_proc_@@PEAU_au_thread_@@@Z ; AuProcessFindSubThread
	mov	QWORD PTR proc$[rsp], rax

; 80   : 		if (!proc)

	cmp	QWORD PTR proc$[rsp], 0
	jne	SHORT $LN1@ObtainShar

; 81   : 			return NULL;

	xor	eax, eax
	jmp	SHORT $LN4@ObtainShar
$LN1@ObtainShar:
$LN2@ObtainShar:

; 82   : 	}
; 83   : 	return AuSHMObtainMem(proc,id, shmaddr, shmflg);

	mov	r9d, DWORD PTR shmflg$[rsp]
	mov	r8, QWORD PTR shmaddr$[rsp]
	movzx	edx, WORD PTR id$[rsp]
	mov	rcx, QWORD PTR proc$[rsp]
	call	?AuSHMObtainMem@@YAPEAXPEAU_au_proc_@@GPEAXH@Z ; AuSHMObtainMem
$LN4@ObtainShar:

; 84   : }

	add	rsp, 56					; 00000038H
	ret	0
?ObtainSharedMem@@YAPEAXGPEAXH@Z ENDP			; ObtainSharedMem
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\serv\mmserv.cpp
_TEXT	SEGMENT
id$ = 32
thr$ = 40
proc$ = 48
key$ = 80
sz$ = 88
flags$ = 96
?CreateSharedMem@@YAHG_KE@Z PROC			; CreateSharedMem

; 49   : int CreateSharedMem(uint16_t key, size_t sz, uint8_t flags){

$LN6:
	mov	BYTE PTR [rsp+24], r8b
	mov	QWORD PTR [rsp+16], rdx
	mov	WORD PTR [rsp+8], cx
	sub	rsp, 72					; 00000048H

; 50   : 	x64_cli();

	call	x64_cli

; 51   : 	AuThread* thr = AuGetCurrentThread();

	call	AuGetCurrentThread
	mov	QWORD PTR thr$[rsp], rax

; 52   : 	if (!thr)

	cmp	QWORD PTR thr$[rsp], 0
	jne	SHORT $LN3@CreateShar

; 53   : 		return -1;

	mov	eax, -1
	jmp	SHORT $LN4@CreateShar
$LN3@CreateShar:

; 54   : 	AuProcess* proc = AuProcessFindThread(thr);

	mov	rcx, QWORD PTR thr$[rsp]
	call	?AuProcessFindThread@@YAPEAU_au_proc_@@PEAU_au_thread_@@@Z ; AuProcessFindThread
	mov	QWORD PTR proc$[rsp], rax

; 55   : 	if (!proc){

	cmp	QWORD PTR proc$[rsp], 0
	jne	SHORT $LN2@CreateShar

; 56   : 		proc = AuProcessFindSubThread(thr);

	mov	rcx, QWORD PTR thr$[rsp]
	call	?AuProcessFindSubThread@@YAPEAU_au_proc_@@PEAU_au_thread_@@@Z ; AuProcessFindSubThread
	mov	QWORD PTR proc$[rsp], rax

; 57   : 		if (!proc){

	cmp	QWORD PTR proc$[rsp], 0
	jne	SHORT $LN1@CreateShar

; 58   : 			return -1;

	mov	eax, -1
	jmp	SHORT $LN4@CreateShar
$LN1@CreateShar:
$LN2@CreateShar:

; 59   : 		}
; 60   : 	}
; 61   : 	SeTextOut("Creating shared mem for thr -> %s \r\n", thr->name);

	mov	rax, QWORD PTR thr$[rsp]
	add	rax, 284				; 0000011cH
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG3474
	call	SeTextOut

; 62   : 	int id = AuCreateSHM(proc, key, sz, flags);

	movzx	r9d, BYTE PTR flags$[rsp]
	mov	r8, QWORD PTR sz$[rsp]
	movzx	edx, WORD PTR key$[rsp]
	mov	rcx, QWORD PTR proc$[rsp]
	call	?AuCreateSHM@@YAHPEAU_au_proc_@@G_KE@Z	; AuCreateSHM
	mov	DWORD PTR id$[rsp], eax

; 63   : 	return id;

	mov	eax, DWORD PTR id$[rsp]
$LN4@CreateShar:

; 64   : }

	add	rsp, 72					; 00000048H
	ret	0
?CreateSharedMem@@YAHG_KE@Z ENDP			; CreateSharedMem
_TEXT	ENDS
END
