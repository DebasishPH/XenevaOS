; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30154.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

msvcjmc	SEGMENT
__6D71769A_ipv4@cpp DB 01H
msvcjmc	ENDS
PUBLIC	?CreateIPv4Socket@@YAHHH@Z			; CreateIPv4Socket
PUBLIC	?IPv4HandlePacket@@YAXPEAX@Z			; IPv4HandlePacket
PUBLIC	?IPv4CalculateChecksum@@YAGPEAU_ipv4head_@@@Z	; IPv4CalculateChecksum
PUBLIC	?ip_ntoa@@YAXI@Z				; ip_ntoa
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_0BA@MLEJAGLE@IP?5?9?$DO?5?$CFd?4?$CFd?4?$CFd?4@ ; `string'
PUBLIC	??_C@_05CHOLMPLD@?$CFd?5?$AN?6@			; `string'
PUBLIC	??_C@_0CH@GFMJMPBD@UDP?5Packet?5received?5dest?5port?5?9@ ; `string'
EXTRN	?CreateTCPSocket@@YAHXZ:PROC			; CreateTCPSocket
EXTRN	?CreateICMPSocket@@YAHXZ:PROC			; CreateICMPSocket
EXTRN	?CreateUDPSocket@@YAHXZ:PROC			; CreateUDPSocket
EXTRN	SeTextOut:PROC
EXTRN	__CheckForDebuggerJustMyCode:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$?CreateIPv4Socket@@YAHHH@Z DD imagerel $LN11
	DD	imagerel $LN11+107
	DD	imagerel $unwind$?CreateIPv4Socket@@YAHHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?IPv4HandlePacket@@YAXPEAX@Z DD imagerel $LN7
	DD	imagerel $LN7+297
	DD	imagerel $unwind$?IPv4HandlePacket@@YAXPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?IPv4CalculateChecksum@@YAGPEAU_ipv4head_@@@Z DD imagerel $LN7
	DD	imagerel $LN7+162
	DD	imagerel $unwind$?IPv4CalculateChecksum@@YAGPEAU_ipv4head_@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ip_ntoa@@YAXI@Z DD imagerel $LN3
	DD	imagerel $LN3+135
	DD	imagerel $unwind$?ip_ntoa@@YAXI@Z
pdata	ENDS
;	COMDAT ??_C@_0CH@GFMJMPBD@UDP?5Packet?5received?5dest?5port?5?9@
CONST	SEGMENT
??_C@_0CH@GFMJMPBD@UDP?5Packet?5received?5dest?5port?5?9@ DB 'UDP Packet '
	DB	'received dest port -> %d ', 0dH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05CHOLMPLD@?$CFd?5?$AN?6@
CONST	SEGMENT
??_C@_05CHOLMPLD@?$CFd?5?$AN?6@ DB '%d ', 0dH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@MLEJAGLE@IP?5?9?$DO?5?$CFd?4?$CFd?4?$CFd?4@
CONST	SEGMENT
??_C@_0BA@MLEJAGLE@IP?5?9?$DO?5?$CFd?4?$CFd?4?$CFd?4@ DB 'IP -> %d.%d.%d.'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ip_ntoa@@YAXI@Z DD 035031101H
	DD	0f20c3311H
	DD	05005H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?IPv4CalculateChecksum@@YAGPEAU_ipv4head_@@@Z DD 025031201H
	DD	0f20d2312H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?IPv4HandlePacket@@YAXPEAX@Z DD 025041201H
	DD	010d2312H
	DD	050060012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?CreateIPv4Socket@@YAHHH@Z DD 025031201H
	DD	0d20d2312H
	DD	05009H
xdata	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Net\ipv4.cpp
;	COMDAT ?ip_ntoa@@YAXI@Z
_TEXT	SEGMENT
tv73 = 64
src$ = 96
?ip_ntoa@@YAXI@Z PROC					; ip_ntoa, COMDAT

; 50   : void ip_ntoa(const uint32_t src) {

$LN3:
	mov	DWORD PTR [rsp+8], ecx
	push	rbp
	sub	rsp, 128				; 00000080H
	lea	rbp, QWORD PTR [rsp+48]
	lea	rcx, OFFSET FLAT:__6D71769A_ipv4@cpp
	call	__CheckForDebuggerJustMyCode

; 51   : 	SeTextOut("IP -> %d.%d.%d.", ((src & 0xFF000000) >> 24),

	mov	eax, DWORD PTR src$[rbp]
	and	eax, 255				; 000000ffH
	mov	ecx, DWORD PTR src$[rbp]
	and	ecx, 65280				; 0000ff00H
	shr	ecx, 8
	mov	edx, DWORD PTR src$[rbp]
	and	edx, 16711680				; 00ff0000H
	shr	edx, 16
	mov	r8d, DWORD PTR src$[rbp]
	and	r8d, -16777216				; ff000000H
	shr	r8d, 24
	mov	DWORD PTR tv73[rbp], r8d
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, ecx
	mov	r8d, edx
	mov	eax, DWORD PTR tv73[rbp]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:??_C@_0BA@MLEJAGLE@IP?5?9?$DO?5?$CFd?4?$CFd?4?$CFd?4@
	call	SeTextOut

; 52   : 		((src & 0xFF0000) >> 16),
; 53   : 		((src & 0xFF00) >> 8),
; 54   : 		((src & 0xFF)));
; 55   : 	SeTextOut("%d \r\n", (src & 0xFF));

	mov	eax, DWORD PTR src$[rbp]
	and	eax, 255				; 000000ffH
	mov	edx, eax
	lea	rcx, OFFSET FLAT:??_C@_05CHOLMPLD@?$CFd?5?$AN?6@
	call	SeTextOut

; 56   : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
?ip_ntoa@@YAXI@Z ENDP					; ip_ntoa
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Net\ipv4.cpp
;	COMDAT ?IPv4CalculateChecksum@@YAGPEAU_ipv4head_@@@Z
_TEXT	SEGMENT
sum$ = 0
s$ = 8
i$1 = 16
p$ = 112
?IPv4CalculateChecksum@@YAGPEAU_ipv4head_@@@Z PROC	; IPv4CalculateChecksum, COMDAT

; 38   : uint16_t IPv4CalculateChecksum(IPv4Header * p){

$LN7:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 128				; 00000080H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__6D71769A_ipv4@cpp
	call	__CheckForDebuggerJustMyCode

; 39   : 	uint32_t sum = 0;

	mov	DWORD PTR sum$[rbp], 0

; 40   : 	uint16_t *s = (uint16_t*)p;

	mov	rax, QWORD PTR p$[rbp]
	mov	QWORD PTR s$[rbp], rax

; 41   : 	for (int i = 0; i < 10; ++i) {

	mov	DWORD PTR i$1[rbp], 0
	jmp	SHORT $LN4@IPv4Calcul
$LN2@IPv4Calcul:
	mov	eax, DWORD PTR i$1[rbp]
	inc	eax
	mov	DWORD PTR i$1[rbp], eax
$LN4@IPv4Calcul:
	cmp	DWORD PTR i$1[rbp], 10
	jge	SHORT $LN3@IPv4Calcul

; 42   : 		sum += ntohs(s[i]);

	movsxd	rax, DWORD PTR i$1[rbp]
	mov	rcx, QWORD PTR s$[rbp]
	movzx	eax, WORD PTR [rcx+rax*2]
	and	eax, 255				; 000000ffH
	shl	eax, 8
	movsxd	rcx, DWORD PTR i$1[rbp]
	mov	rdx, QWORD PTR s$[rbp]
	movzx	ecx, WORD PTR [rdx+rcx*2]
	and	ecx, 65280				; 0000ff00H
	sar	ecx, 8
	or	eax, ecx
	mov	ecx, DWORD PTR sum$[rbp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR sum$[rbp], eax

; 43   : 		if (sum > 0xFFFF){

	cmp	DWORD PTR sum$[rbp], 65535		; 0000ffffH
	jbe	SHORT $LN5@IPv4Calcul

; 44   : 			sum = (sum >> 16) + (sum & 0xFFFF);

	mov	eax, DWORD PTR sum$[rbp]
	shr	eax, 16
	mov	ecx, DWORD PTR sum$[rbp]
	and	ecx, 65535				; 0000ffffH
	add	eax, ecx
	mov	DWORD PTR sum$[rbp], eax
$LN5@IPv4Calcul:

; 45   : 		}
; 46   : 	}

	jmp	SHORT $LN2@IPv4Calcul
$LN3@IPv4Calcul:

; 47   : 	return sum;

	movzx	eax, WORD PTR sum$[rbp]

; 48   : }

	lea	rsp, QWORD PTR [rbp+96]
	pop	rbp
	ret	0
?IPv4CalculateChecksum@@YAGPEAU_ipv4head_@@@Z ENDP	; IPv4CalculateChecksum
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Net\ipv4.cpp
;	COMDAT ?IPv4HandlePacket@@YAXPEAX@Z
_TEXT	SEGMENT
pack$ = 32
destport$1 = 40
tv130 = 108
data$ = 128
?IPv4HandlePacket@@YAXPEAX@Z PROC			; IPv4HandlePacket, COMDAT

; 58   : void IPv4HandlePacket(void* data) {

$LN7:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 144				; 00000090H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__6D71769A_ipv4@cpp
	call	__CheckForDebuggerJustMyCode

; 59   : 	char dest[16];
; 60   : 	char src[16];
; 61   : 	IPv4Header* pack = (IPv4Header*)data;

	mov	rax, QWORD PTR data$[rbp]
	mov	QWORD PTR pack$[rbp], rax

; 62   : 	ip_ntoa(ntohl(pack->destAddress));

	mov	rax, QWORD PTR pack$[rbp]
	mov	eax, DWORD PTR [rax+16]
	and	eax, 255				; 000000ffH
	shl	eax, 24
	mov	rcx, QWORD PTR pack$[rbp]
	mov	ecx, DWORD PTR [rcx+16]
	and	ecx, 65280				; 0000ff00H
	shl	ecx, 8
	or	eax, ecx
	mov	rcx, QWORD PTR pack$[rbp]
	mov	ecx, DWORD PTR [rcx+16]
	and	ecx, 16711680				; 00ff0000H
	shr	ecx, 8
	or	eax, ecx
	mov	rcx, QWORD PTR pack$[rbp]
	mov	ecx, DWORD PTR [rcx+16]
	and	ecx, -16777216				; ff000000H
	shr	ecx, 24
	or	eax, ecx
	mov	ecx, eax
	call	?ip_ntoa@@YAXI@Z			; ip_ntoa

; 63   : 	ip_ntoa(ntohl(pack->srcAddress)); 

	mov	rax, QWORD PTR pack$[rbp]
	mov	eax, DWORD PTR [rax+12]
	and	eax, 255				; 000000ffH
	shl	eax, 24
	mov	rcx, QWORD PTR pack$[rbp]
	mov	ecx, DWORD PTR [rcx+12]
	and	ecx, 65280				; 0000ff00H
	shl	ecx, 8
	or	eax, ecx
	mov	rcx, QWORD PTR pack$[rbp]
	mov	ecx, DWORD PTR [rcx+12]
	and	ecx, 16711680				; 00ff0000H
	shr	ecx, 8
	or	eax, ecx
	mov	rcx, QWORD PTR pack$[rbp]
	mov	ecx, DWORD PTR [rcx+12]
	and	ecx, -16777216				; ff000000H
	shr	ecx, 24
	or	eax, ecx
	mov	ecx, eax
	call	?ip_ntoa@@YAXI@Z			; ip_ntoa

; 64   : 	switch (pack->protocol){

	mov	rax, QWORD PTR pack$[rbp]
	movzx	eax, BYTE PTR [rax+9]
	mov	BYTE PTR tv130[rbp], al
	cmp	BYTE PTR tv130[rbp], 17
	je	SHORT $LN5@IPv4Handle
	jmp	SHORT $LN2@IPv4Handle

; 65   : 	case 1:
; 66   : 		break;

	jmp	SHORT $LN2@IPv4Handle
$LN5@IPv4Handle:

; 67   : 	case IPV4_PROTOCOL_UDP:{
; 68   : 							   uint16_t destport = ntohs(((uint16_t*)&pack->payload)[1]);

	mov	eax, 2
	imul	rax, rax, 1
	mov	rcx, QWORD PTR pack$[rbp]
	movzx	eax, WORD PTR [rcx+rax+20]
	and	eax, 255				; 000000ffH
	shl	eax, 8
	mov	ecx, 2
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR pack$[rbp]
	movzx	ecx, WORD PTR [rdx+rcx+20]
	and	ecx, 65280				; 0000ff00H
	sar	ecx, 8
	or	eax, ecx
	mov	WORD PTR destport$1[rbp], ax

; 69   : 							   SeTextOut("UDP Packet received dest port -> %d \r\n", destport);

	movzx	eax, WORD PTR destport$1[rbp]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:??_C@_0CH@GFMJMPBD@UDP?5Packet?5received?5dest?5port?5?9@
	call	SeTextOut
$LN2@IPv4Handle:

; 70   : 							   break;
; 71   : 	}
; 72   : 	}
; 73   : }

	lea	rsp, QWORD PTR [rbp+112]
	pop	rbp
	ret	0
?IPv4HandlePacket@@YAXPEAX@Z ENDP			; IPv4HandlePacket
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Net\ipv4.cpp
;	COMDAT ?CreateIPv4Socket@@YAHHH@Z
_TEXT	SEGMENT
tv64 = 64
type$ = 96
protocol$ = 104
?CreateIPv4Socket@@YAHHH@Z PROC				; CreateIPv4Socket, COMDAT

; 81   : int CreateIPv4Socket(int type, int protocol) {

$LN11:
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__6D71769A_ipv4@cpp
	call	__CheckForDebuggerJustMyCode

; 82   : 	switch (type) {

	mov	eax, DWORD PTR type$[rbp]
	mov	DWORD PTR tv64[rbp], eax
	cmp	DWORD PTR tv64[rbp], 1
	je	SHORT $LN8@CreateIPv4
	cmp	DWORD PTR tv64[rbp], 2
	je	SHORT $LN4@CreateIPv4
	jmp	SHORT $LN9@CreateIPv4
$LN4@CreateIPv4:

; 83   : 	case SOCK_DGRAM:
; 84   : 		if (protocol == 0 || protocol == IPPROTOCOL_UDP)

	cmp	DWORD PTR protocol$[rbp], 0
	je	SHORT $LN6@CreateIPv4
	cmp	DWORD PTR protocol$[rbp], 17
	jne	SHORT $LN5@CreateIPv4
$LN6@CreateIPv4:

; 85   : 			return CreateUDPSocket();

	call	?CreateUDPSocket@@YAHXZ			; CreateUDPSocket
	jmp	SHORT $LN1@CreateIPv4
$LN5@CreateIPv4:

; 86   : 		if (protocol == IPPROTOCOL_ICMP)

	cmp	DWORD PTR protocol$[rbp], 1
	jne	SHORT $LN7@CreateIPv4

; 87   : 			return CreateICMPSocket();

	call	?CreateICMPSocket@@YAHXZ		; CreateICMPSocket
	jmp	SHORT $LN1@CreateIPv4
$LN7@CreateIPv4:

; 88   : 		return -1;

	mov	eax, -1
	jmp	SHORT $LN1@CreateIPv4
$LN8@CreateIPv4:

; 89   : 	case SOCK_STREAM:
; 90   : 		return CreateTCPSocket();

	call	?CreateTCPSocket@@YAHXZ			; CreateTCPSocket
	jmp	SHORT $LN1@CreateIPv4
$LN9@CreateIPv4:

; 91   : 	default:
; 92   : 		return -1;

	mov	eax, -1
$LN1@CreateIPv4:

; 93   : 	}
; 94   : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
?CreateIPv4Socket@@YAHHH@Z ENDP				; CreateIPv4Socket
_TEXT	ENDS
END
