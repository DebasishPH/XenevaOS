; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30154.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?early_spin@@3PAU_spinlock_@@A			; early_spin
_BSS	SEGMENT
?early_spin@@3PAU_spinlock_@@A DQ 08H DUP (?)		; early_spin
_BSS	ENDS
msvcjmc	SEGMENT
__8B123772_spinlock@cpp DB 01H
msvcjmc	ENDS
PUBLIC	AuCreateSpinlock
PUBLIC	AuDeleteSpinlock
PUBLIC	AuAcquireSpinlock
PUBLIC	AuReleaseSpinlock
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_0CM@IGBLDAGO@?$FLaurora?5kernel?$FN?3?5lock?5?9?$DO?5?$CFx?5is?5@ ; `string'
EXTRN	kmalloc:PROC
EXTRN	kfree:PROC
EXTRN	SeTextOut:PROC
EXTRN	x64_pause:PROC
EXTRN	x64_lock_test:PROC
EXTRN	__CheckForDebuggerJustMyCode:PROC
_BSS	SEGMENT
?early_spinlock_cnt@@3EA DB 01H DUP (?)			; early_spinlock_cnt
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AuCreateSpinlock DD imagerel $LN5
	DD	imagerel $LN5+127
	DD	imagerel $unwind$AuCreateSpinlock
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AuDeleteSpinlock DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$AuDeleteSpinlock
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AuAcquireSpinlock DD imagerel $LN10
	DD	imagerel $LN10+134
	DD	imagerel $unwind$AuAcquireSpinlock
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AuReleaseSpinlock DD imagerel $LN4
	DD	imagerel $LN4+71
	DD	imagerel $unwind$AuReleaseSpinlock
pdata	ENDS
;	COMDAT ??_C@_0CM@IGBLDAGO@?$FLaurora?5kernel?$FN?3?5lock?5?9?$DO?5?$CFx?5is?5@
CONST	SEGMENT
??_C@_0CM@IGBLDAGO@?$FLaurora?5kernel?$FN?3?5lock?5?9?$DO?5?$CFx?5is?5@ DB '['
	DB	'aurora kernel]: lock -> %x is corrupted ', 0dH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AuReleaseSpinlock DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	06eH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AuAcquireSpinlock DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AuDeleteSpinlock DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AuCreateSpinlock DD 025030e01H
	DD	0d209230eH
	DD	05005H
xdata	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Sync\spinlock.cpp
;	COMDAT AuReleaseSpinlock
_TEXT	SEGMENT
lock$ = 80
AuReleaseSpinlock PROC					; COMDAT

; 89   : AU_EXTERN AU_EXPORT void AuReleaseSpinlock(Spinlock* lock) {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__8B123772_spinlock@cpp
	call	__CheckForDebuggerJustMyCode

; 90   : 	if (!x64_lock_test(&lock->value, 1, 0))

	mov	rax, QWORD PTR lock$[rbp]
	xor	r8d, r8d
	mov	edx, 1
	mov	rcx, rax
	call	x64_lock_test
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@AuReleaseS

; 91   : 		lock->value = 0;

	mov	rax, QWORD PTR lock$[rbp]
	mov	QWORD PTR [rax], 0
$LN2@AuReleaseS:

; 92   : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
AuReleaseSpinlock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Sync\spinlock.cpp
;	COMDAT AuAcquireSpinlock
_TEXT	SEGMENT
lockd$1 = 0
lock$ = 96
AuAcquireSpinlock PROC					; COMDAT

; 70   : AU_EXTERN AU_EXPORT void AuAcquireSpinlock(Spinlock* lock) {

$LN10:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__8B123772_spinlock@cpp
	call	__CheckForDebuggerJustMyCode

; 71   : 	if (lock->value > 1)  {

	mov	rax, QWORD PTR lock$[rbp]
	cmp	QWORD PTR [rax], 1
	jbe	SHORT $LN7@AuAcquireS

; 72   : 		SeTextOut("[aurora kernel]: lock -> %x is corrupted \r\n", lock);

	mov	rdx, QWORD PTR lock$[rbp]
	lea	rcx, OFFSET FLAT:??_C@_0CM@IGBLDAGO@?$FLaurora?5kernel?$FN?3?5lock?5?9?$DO?5?$CFx?5is?5@
	call	SeTextOut

; 73   : 		lock->value = 0;

	mov	rax, QWORD PTR lock$[rbp]
	mov	QWORD PTR [rax], 0
$LN7@AuAcquireS:
$LN4@AuAcquireS:

; 74   : 	}
; 75   : 	do {	
; 76   : 		if (x64_lock_test(&lock->value, 0, 1)) {

	mov	rax, QWORD PTR lock$[rbp]
	mov	r8d, 1
	xor	edx, edx
	mov	rcx, rax
	call	x64_lock_test
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN8@AuAcquireS

; 77   : 			break;

	jmp	SHORT $LN3@AuAcquireS
$LN8@AuAcquireS:

; 78   : 		}
; 79   : 		x64_pause();

	call	x64_pause

; 80   : 		volatile size_t* lockd = &lock->value;

	mov	rax, QWORD PTR lock$[rbp]
	mov	QWORD PTR lockd$1[rbp], rax
$LN5@AuAcquireS:

; 81   : 		while (*lockd == 1);

	mov	rax, QWORD PTR lockd$1[rbp]
	mov	rax, QWORD PTR [rax]
	cmp	rax, 1
	jne	SHORT $LN6@AuAcquireS
	jmp	SHORT $LN5@AuAcquireS
$LN6@AuAcquireS:

; 82   : 	} while (1);

	xor	eax, eax
	cmp	eax, 1
	jne	SHORT $LN4@AuAcquireS
$LN3@AuAcquireS:

; 83   : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
AuAcquireSpinlock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Sync\spinlock.cpp
;	COMDAT AuDeleteSpinlock
_TEXT	SEGMENT
lock$ = 80
AuDeleteSpinlock PROC					; COMDAT

; 62   : AU_EXTERN AU_EXPORT void AuDeleteSpinlock(Spinlock* lock) {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__8B123772_spinlock@cpp
	call	__CheckForDebuggerJustMyCode

; 63   : 	kfree(lock);

	mov	rcx, QWORD PTR lock$[rbp]
	call	kfree

; 64   : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
AuDeleteSpinlock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Sync\spinlock.cpp
;	COMDAT AuCreateSpinlock
_TEXT	SEGMENT
spinlock$ = 0
early$ = 96
AuCreateSpinlock PROC					; COMDAT

; 44   : AU_EXTERN AU_EXPORT Spinlock* AuCreateSpinlock(bool early) {

$LN5:
	mov	BYTE PTR [rsp+8], cl
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__8B123772_spinlock@cpp
	call	__CheckForDebuggerJustMyCode

; 45   : 	Spinlock* spinlock = NULL;

	mov	QWORD PTR spinlock$[rbp], 0

; 46   : 	if (early) {

	movzx	eax, BYTE PTR early$[rbp]
	test	eax, eax
	je	SHORT $LN2@AuCreateSp

; 47   : 		spinlock = &early_spin[early_spinlock_cnt];

	movzx	eax, BYTE PTR ?early_spinlock_cnt@@3EA
	lea	rcx, OFFSET FLAT:?early_spin@@3PAU_spinlock_@@A ; early_spin
	lea	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR spinlock$[rbp], rax

; 48   : 		spinlock->value = 0;

	mov	rax, QWORD PTR spinlock$[rbp]
	mov	QWORD PTR [rax], 0

; 49   : 		early_spinlock_cnt++;

	movzx	eax, BYTE PTR ?early_spinlock_cnt@@3EA
	inc	al
	mov	BYTE PTR ?early_spinlock_cnt@@3EA, al

; 50   : 	}

	jmp	SHORT $LN3@AuCreateSp
$LN2@AuCreateSp:

; 51   : 	else {
; 52   : 		spinlock = (Spinlock*)kmalloc(sizeof(Spinlock));

	mov	ecx, 8
	call	kmalloc
	mov	QWORD PTR spinlock$[rbp], rax

; 53   : 		spinlock->value = 0;

	mov	rax, QWORD PTR spinlock$[rbp]
	mov	QWORD PTR [rax], 0
$LN3@AuCreateSp:

; 54   : 	}
; 55   : 
; 56   : 	return spinlock;

	mov	rax, QWORD PTR spinlock$[rbp]

; 57   : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
AuCreateSpinlock ENDP
_TEXT	ENDS
END
