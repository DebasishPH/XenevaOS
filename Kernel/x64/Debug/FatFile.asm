; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30154.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

msvcjmc	SEGMENT
__5368F709_FatFile@cpp DB 01H
msvcjmc	ENDS
PUBLIC	?FatFileGetParent@@YAPEAU__VFS_NODE__@@PEAU1@PEBD@Z ; FatFileGetParent
PUBLIC	?FatCreateFile@@YAPEAU__VFS_NODE__@@PEAU1@PEAD@Z ; FatCreateFile
PUBLIC	?FatFileUpdateSize@@YAXPEAU__VFS_NODE__@@0_K@Z	; FatFileUpdateSize
PUBLIC	?FatFileUpdateFilename@@YAHPEAU__VFS_NODE__@@0PEAD@Z ; FatFileUpdateFilename
PUBLIC	?FatFileWriteContent@@YAXPEAU__VFS_NODE__@@0PEA_K@Z ; FatFileWriteContent
PUBLIC	?FatFileWriteDone@@YAXPEAU__VFS_NODE__@@@Z	; FatFileWriteDone
PUBLIC	?FatWrite@@YA_KPEAU__VFS_NODE__@@0PEA_KI@Z	; FatWrite
PUBLIC	?FatFileClearDirEntry@@YAHPEAU__VFS_NODE__@@0@Z	; FatFileClearDirEntry
PUBLIC	?FatFileRemove@@YAHPEAU__VFS_NODE__@@0@Z	; FatFileRemove
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_0CA@JGMINDDG@?$FLFAT?$FN?3?5New?5Cluster?5allocated?5?$AN?6@ ; `string'
PUBLIC	??_C@_0CC@MFLDFGNL@EOC?5mark?5found?5in?5cluster?5?9?$DO?5?$CFx@ ; `string'
EXTRN	AuVDiskRead:PROC
EXTRN	AuVDiskWrite:PROC
EXTRN	?FatClusterToSector32@@YA_KPEAU_FatFS_@@_K@Z:PROC ; FatClusterToSector32
EXTRN	?FatToDOSFilename@@YAXPEBDPEADI@Z:PROC		; FatToDOSFilename
EXTRN	?FatFindFreeCluster@@YAIPEAU__VFS_NODE__@@@Z:PROC ; FatFindFreeCluster
EXTRN	?FatAllocCluster@@YAXPEAU__VFS_NODE__@@HI@Z:PROC ; FatAllocCluster
EXTRN	?FatClearCluster@@YAXPEAU__VFS_NODE__@@I@Z:PROC	; FatClearCluster
EXTRN	?FatReadFAT@@YAIPEAU__VFS_NODE__@@_K@Z:PROC	; FatReadFAT
EXTRN	?FatFormatDate@@YAGXZ:PROC			; FatFormatDate
EXTRN	?FatFormatTime@@YAGXZ:PROC			; FatFormatTime
EXTRN	?FatLocateDir@@YAPEAU__VFS_NODE__@@PEAU1@PEBD@Z:PROC ; FatLocateDir
EXTRN	?FatLocateSubDir@@YAPEAU__VFS_NODE__@@PEAU1@0PEBD@Z:PROC ; FatLocateSubDir
EXTRN	kmalloc:PROC
EXTRN	kfree:PROC
EXTRN	AuPmmngrAlloc:PROC
EXTRN	AuPmmngrFree:PROC
EXTRN	P2V:PROC
EXTRN	V2P:PROC
EXTRN	strcmp:PROC
EXTRN	strcpy:PROC
EXTRN	strchr:PROC
EXTRN	memset:PROC
EXTRN	memcpy:PROC
EXTRN	SeTextOut:PROC
EXTRN	__CheckForDebuggerJustMyCode:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$?FatFileGetParent@@YAPEAU__VFS_NODE__@@PEAU1@PEBD@Z DD imagerel $LN17
	DD	imagerel $LN17+469
	DD	imagerel $unwind$?FatFileGetParent@@YAPEAU__VFS_NODE__@@PEAU1@PEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?FatCreateFile@@YAPEAU__VFS_NODE__@@PEAU1@PEAD@Z DD imagerel $LN26
	DD	imagerel $LN26+1181
	DD	imagerel $unwind$?FatCreateFile@@YAPEAU__VFS_NODE__@@PEAU1@PEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?FatFileUpdateSize@@YAXPEAU__VFS_NODE__@@0_K@Z DD imagerel $LN15
	DD	imagerel $LN15+575
	DD	imagerel $unwind$?FatFileUpdateSize@@YAXPEAU__VFS_NODE__@@0_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?FatFileUpdateFilename@@YAHPEAU__VFS_NODE__@@0PEAD@Z DD imagerel $LN15
	DD	imagerel $LN15+654
	DD	imagerel $unwind$?FatFileUpdateFilename@@YAHPEAU__VFS_NODE__@@0PEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?FatFileWriteContent@@YAXPEAU__VFS_NODE__@@0PEA_K@Z DD imagerel $LN9
	DD	imagerel $LN9+527
	DD	imagerel $unwind$?FatFileWriteContent@@YAXPEAU__VFS_NODE__@@0PEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?FatFileWriteDone@@YAXPEAU__VFS_NODE__@@@Z DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$?FatFileWriteDone@@YAXPEAU__VFS_NODE__@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?FatWrite@@YA_KPEAU__VFS_NODE__@@0PEA_KI@Z DD imagerel $LN9
	DD	imagerel $LN9+297
	DD	imagerel $unwind$?FatWrite@@YA_KPEAU__VFS_NODE__@@0PEA_KI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?FatFileClearDirEntry@@YAHPEAU__VFS_NODE__@@0@Z DD imagerel $LN16
	DD	imagerel $LN16+624
	DD	imagerel $unwind$?FatFileClearDirEntry@@YAHPEAU__VFS_NODE__@@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?FatFileRemove@@YAHPEAU__VFS_NODE__@@0@Z DD imagerel $LN10
	DD	imagerel $LN10+210
	DD	imagerel $unwind$?FatFileRemove@@YAHPEAU__VFS_NODE__@@0@Z
pdata	ENDS
;	COMDAT ??_C@_0CC@MFLDFGNL@EOC?5mark?5found?5in?5cluster?5?9?$DO?5?$CFx@
CONST	SEGMENT
??_C@_0CC@MFLDFGNL@EOC?5mark?5found?5in?5cluster?5?9?$DO?5?$CFx@ DB 'EOC '
	DB	'mark found in cluster -> %x ', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@JGMINDDG@?$FLFAT?$FN?3?5New?5Cluster?5allocated?5?$AN?6@
CONST	SEGMENT
??_C@_0CA@JGMINDDG@?$FLFAT?$FN?3?5New?5Cluster?5allocated?5?$AN?6@ DB '[F'
	DB	'AT]: New Cluster allocated ', 0dH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?FatFileRemove@@YAHPEAU__VFS_NODE__@@0@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?FatFileClearDirEntry@@YAHPEAU__VFS_NODE__@@0@Z DD 025041701H
	DD	01122317H
	DD	0500b0018H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?FatWrite@@YA_KPEAU__VFS_NODE__@@0PEA_KI@Z DD 025032101H
	DD	0f21c2321H
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?FatFileWriteDone@@YAXPEAU__VFS_NODE__@@@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?FatFileWriteContent@@YAXPEAU__VFS_NODE__@@0PEA_K@Z DD 025041c01H
	DD	0117231cH
	DD	050100014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?FatFileUpdateFilename@@YAHPEAU__VFS_NODE__@@0PEAD@Z DD 025041c01H
	DD	0117231cH
	DD	05010001aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?FatFileUpdateSize@@YAXPEAU__VFS_NODE__@@0_K@Z DD 025041c01H
	DD	0117231cH
	DD	050100018H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?FatCreateFile@@YAPEAU__VFS_NODE__@@PEAU1@PEAD@Z DD 025041701H
	DD	01122317H
	DD	0500b001cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?FatFileGetParent@@YAPEAU__VFS_NODE__@@PEAU1@PEBD@Z DD 025041701H
	DD	01122317H
	DD	0500b0016H
xdata	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Fs\Fat\FatFile.cpp
;	COMDAT ?FatFileRemove@@YAHPEAU__VFS_NODE__@@0@Z
_TEXT	SEGMENT
parent_clust$ = 0
cluster$ = 4
next_cluster$1 = 8
fsys$ = 96
file$ = 104
?FatFileRemove@@YAHPEAU__VFS_NODE__@@0@Z PROC		; FatFileRemove, COMDAT

; 463  : int FatFileRemove(AuVFSNode* fsys, AuVFSNode* file) {

$LN10:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__5368F709_FatFile@cpp
	call	__CheckForDebuggerJustMyCode

; 464  : 	if (!fsys)

	cmp	QWORD PTR fsys$[rbp], 0
	jne	SHORT $LN4@FatFileRem

; 465  : 		return -1;

	mov	eax, -1
	jmp	$LN1@FatFileRem
$LN4@FatFileRem:

; 466  : 	if (!file)

	cmp	QWORD PTR file$[rbp], 0
	jne	SHORT $LN5@FatFileRem

; 467  : 		return -1;

	mov	eax, -1
	jmp	$LN1@FatFileRem
$LN5@FatFileRem:

; 468  : 
; 469  : 	uint32_t parent_clust = file->parent_block;

	mov	rax, QWORD PTR file$[rbp]
	mov	eax, DWORD PTR [rax+41]
	mov	DWORD PTR parent_clust$[rbp], eax

; 470  : 	if (!parent_clust)

	cmp	DWORD PTR parent_clust$[rbp], 0
	jne	SHORT $LN6@FatFileRem

; 471  : 		return -1;

	mov	eax, -1
	jmp	SHORT $LN1@FatFileRem
$LN6@FatFileRem:

; 472  : 
; 473  : 	uint32_t cluster = file->current;

	mov	rax, QWORD PTR file$[rbp]
	mov	eax, DWORD PTR [rax+53]
	mov	DWORD PTR cluster$[rbp], eax
$LN2@FatFileRem:

; 474  : 	while (1) {

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN3@FatFileRem

; 475  : 		uint32_t next_cluster = FatReadFAT(fsys, cluster);

	mov	eax, DWORD PTR cluster$[rbp]
	mov	edx, eax
	mov	rcx, QWORD PTR fsys$[rbp]
	call	?FatReadFAT@@YAIPEAU__VFS_NODE__@@_K@Z	; FatReadFAT
	mov	DWORD PTR next_cluster$1[rbp], eax

; 476  : 		if (next_cluster == (FAT_EOC_MARK & 0x0fffffff)) {

	cmp	DWORD PTR next_cluster$1[rbp], 268435448 ; 0ffffff8H
	jne	SHORT $LN7@FatFileRem

; 477  : 			SeTextOut("EOC mark found in cluster -> %x \n", cluster);

	mov	edx, DWORD PTR cluster$[rbp]
	lea	rcx, OFFSET FLAT:??_C@_0CC@MFLDFGNL@EOC?5mark?5found?5in?5cluster?5?9?$DO?5?$CFx@
	call	SeTextOut

; 478  : 			FatAllocCluster(fsys, cluster, 0x00);

	xor	r8d, r8d
	mov	edx, DWORD PTR cluster$[rbp]
	mov	rcx, QWORD PTR fsys$[rbp]
	call	?FatAllocCluster@@YAXPEAU__VFS_NODE__@@HI@Z ; FatAllocCluster

; 479  : 			break;

	jmp	SHORT $LN3@FatFileRem

; 480  : 		}

	jmp	SHORT $LN8@FatFileRem
$LN7@FatFileRem:

; 481  : 		else {
; 482  : 			FatAllocCluster(fsys, cluster, 0x00);

	xor	r8d, r8d
	mov	edx, DWORD PTR cluster$[rbp]
	mov	rcx, QWORD PTR fsys$[rbp]
	call	?FatAllocCluster@@YAXPEAU__VFS_NODE__@@HI@Z ; FatAllocCluster
$LN8@FatFileRem:

; 483  : 		}
; 484  : 		cluster = next_cluster;

	mov	eax, DWORD PTR next_cluster$1[rbp]
	mov	DWORD PTR cluster$[rbp], eax

; 485  : 	}

	jmp	SHORT $LN2@FatFileRem
$LN3@FatFileRem:

; 486  : 
; 487  : 	/* clear the dir entry */
; 488  : 	FatFileClearDirEntry(fsys, file);

	mov	rdx, QWORD PTR file$[rbp]
	mov	rcx, QWORD PTR fsys$[rbp]
	call	?FatFileClearDirEntry@@YAHPEAU__VFS_NODE__@@0@Z ; FatFileClearDirEntry

; 489  : 	return 0;

	xor	eax, eax
$LN1@FatFileRem:

; 490  : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
?FatFileRemove@@YAHPEAU__VFS_NODE__@@0@Z ENDP		; FatFileRemove
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Fs\Fat\FatFile.cpp
;	COMDAT ?FatFileClearDirEntry@@YAHPEAU__VFS_NODE__@@0@Z
_TEXT	SEGMENT
_fs$ = 0
dir_clust$ = 8
fname$ = 16
buff$ = 32
j$1 = 40
dirent$2 = 48
i$3 = 56
name$4 = 64
tv157 = 144
tv94 = 144
fsys$ = 176
file$ = 184
?FatFileClearDirEntry@@YAHPEAU__VFS_NODE__@@0@Z PROC	; FatFileClearDirEntry, COMDAT

; 408  : int FatFileClearDirEntry(AuVFSNode* fsys, AuVFSNode* file) {

$LN16:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 192				; 000000c0H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__5368F709_FatFile@cpp
	call	__CheckForDebuggerJustMyCode

; 409  : 	if (!fsys)

	cmp	QWORD PTR fsys$[rbp], 0
	jne	SHORT $LN10@FatFileCle

; 410  : 		return -1;

	mov	eax, -1
	jmp	$LN1@FatFileCle
$LN10@FatFileCle:

; 411  : 	if (!file)

	cmp	QWORD PTR file$[rbp], 0
	jne	SHORT $LN11@FatFileCle

; 412  : 		return -1;

	mov	eax, -1
	jmp	$LN1@FatFileCle
$LN11@FatFileCle:

; 413  : 	
; 414  : 	FatFS* _fs = (FatFS*)fsys->device;

	mov	rax, QWORD PTR fsys$[rbp]
	mov	rax, QWORD PTR [rax+64]
	mov	QWORD PTR _fs$[rbp], rax

; 415  : 
; 416  : 	uint32_t dir_clust = file->parent_block;

	mov	rax, QWORD PTR file$[rbp]
	mov	eax, DWORD PTR [rax+41]
	mov	DWORD PTR dir_clust$[rbp], eax

; 417  : 	if (!dir_clust)

	cmp	DWORD PTR dir_clust$[rbp], 0
	jne	SHORT $LN12@FatFileCle

; 418  : 		dir_clust = _fs->__RootDirFirstCluster;

	mov	rax, QWORD PTR _fs$[rbp]
	mov	eax, DWORD PTR [rax+40]
	mov	DWORD PTR dir_clust$[rbp], eax
$LN12@FatFileCle:

; 419  : 
; 420  : 	char fname[11];
; 421  : 	memset(fname, 0, 11);

	mov	r8d, 11
	xor	edx, edx
	lea	rcx, QWORD PTR fname$[rbp]
	call	memset

; 422  : 	FatToDOSFilename(file->filename, fname, 11);

	mov	rax, QWORD PTR file$[rbp]
	mov	r8d, 11
	lea	rdx, QWORD PTR fname$[rbp]
	mov	rcx, rax
	call	?FatToDOSFilename@@YAXPEBDPEADI@Z	; FatToDOSFilename

; 423  : 	fname[11] = 0;

	mov	eax, 1
	imul	rax, rax, 11
	mov	BYTE PTR fname$[rbp+rax], 0

; 424  : 
; 425  : 	uint64_t* buff = (uint64_t*)P2V((size_t)AuPmmngrAlloc());

	call	AuPmmngrAlloc
	mov	rcx, rax
	call	P2V
	mov	QWORD PTR buff$[rbp], rax

; 426  : 	memset(buff, 0, PAGE_SIZE);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR buff$[rbp]
	call	memset
$LN2@FatFileCle:

; 427  : 
; 428  : 	while (1) {

	xor	eax, eax
	cmp	eax, 1
	je	$LN3@FatFileCle

; 429  : 		for (int j = 0; j < _fs->__SectorPerCluster; j++) {

	mov	DWORD PTR j$1[rbp], 0
	jmp	SHORT $LN6@FatFileCle
$LN4@FatFileCle:
	mov	eax, DWORD PTR j$1[rbp]
	inc	eax
	mov	DWORD PTR j$1[rbp], eax
$LN6@FatFileCle:
	mov	rax, QWORD PTR _fs$[rbp]
	movzx	eax, BYTE PTR [rax+36]
	cmp	DWORD PTR j$1[rbp], eax
	jge	$LN5@FatFileCle

; 430  : 			memset(buff, 0, PAGE_SIZE);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR buff$[rbp]
	call	memset

; 431  : 			AuVDiskRead(_fs->vdisk, FatClusterToSector32(_fs, dir_clust) + j, 1, (uint64_t*)V2P((size_t)buff));

	mov	rcx, QWORD PTR buff$[rbp]
	call	V2P
	mov	QWORD PTR tv94[rbp], rax
	mov	ecx, DWORD PTR dir_clust$[rbp]
	mov	edx, ecx
	mov	rcx, QWORD PTR _fs$[rbp]
	call	?FatClusterToSector32@@YA_KPEAU_FatFS_@@_K@Z ; FatClusterToSector32
	movsxd	rcx, DWORD PTR j$1[rbp]
	add	rax, rcx
	mov	rcx, QWORD PTR tv94[rbp]
	mov	r9, rcx
	mov	r8d, 1
	mov	rdx, rax
	mov	rax, QWORD PTR _fs$[rbp]
	mov	rcx, QWORD PTR [rax+8]
	call	AuVDiskRead

; 432  : 
; 433  : 			FatDir *dirent = (FatDir*)buff;

	mov	rax, QWORD PTR buff$[rbp]
	mov	QWORD PTR dirent$2[rbp], rax

; 434  : 			for (int i = 0; i < 16; i++) {

	mov	DWORD PTR i$3[rbp], 0
	jmp	SHORT $LN9@FatFileCle
$LN7@FatFileCle:
	mov	eax, DWORD PTR i$3[rbp]
	inc	eax
	mov	DWORD PTR i$3[rbp], eax
$LN9@FatFileCle:
	cmp	DWORD PTR i$3[rbp], 16
	jge	$LN8@FatFileCle

; 435  : 				char name[11];
; 436  : 				memcpy(name, dirent->filename, 11);

	mov	rax, QWORD PTR dirent$2[rbp]
	mov	r8d, 11
	mov	rdx, rax
	lea	rcx, QWORD PTR name$4[rbp]
	call	memcpy

; 437  : 				name[11] = 0;

	mov	eax, 1
	imul	rax, rax, 11
	mov	BYTE PTR name$4[rbp+rax], 0

; 438  : 
; 439  : 				if (strcmp(name, fname) == 0) {

	lea	rdx, QWORD PTR fname$[rbp]
	lea	rcx, QWORD PTR name$4[rbp]
	call	strcmp
	test	eax, eax
	jne	SHORT $LN13@FatFileCle

; 440  : 					memset(dirent, 0, sizeof(FatDir));

	mov	r8d, 32					; 00000020H
	xor	edx, edx
	mov	rcx, QWORD PTR dirent$2[rbp]
	call	memset

; 441  : 					dirent->filename[0] = 0xE5;

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR dirent$2[rbp]
	mov	BYTE PTR [rcx+rax], 229			; 000000e5H

; 442  : 					AuVDiskWrite(_fs->vdisk, FatClusterToSector32(_fs, dir_clust) + j, 1, (uint64_t*)V2P((size_t)buff));

	mov	rcx, QWORD PTR buff$[rbp]
	call	V2P
	mov	QWORD PTR tv157[rbp], rax
	mov	ecx, DWORD PTR dir_clust$[rbp]
	mov	edx, ecx
	mov	rcx, QWORD PTR _fs$[rbp]
	call	?FatClusterToSector32@@YA_KPEAU_FatFS_@@_K@Z ; FatClusterToSector32
	movsxd	rcx, DWORD PTR j$1[rbp]
	add	rax, rcx
	mov	rcx, QWORD PTR tv157[rbp]
	mov	r9, rcx
	mov	r8d, 1
	mov	rdx, rax
	mov	rax, QWORD PTR _fs$[rbp]
	mov	rcx, QWORD PTR [rax+8]
	call	AuVDiskWrite

; 443  : 					AuPmmngrFree((void*)V2P((size_t)buff));

	mov	rcx, QWORD PTR buff$[rbp]
	call	V2P
	mov	rcx, rax
	call	AuPmmngrFree

; 444  : 					return 0;

	xor	eax, eax
	jmp	SHORT $LN1@FatFileCle
$LN13@FatFileCle:

; 445  : 				}
; 446  : 				dirent++;

	mov	rax, QWORD PTR dirent$2[rbp]
	add	rax, 32					; 00000020H
	mov	QWORD PTR dirent$2[rbp], rax

; 447  : 			}

	jmp	$LN7@FatFileCle
$LN8@FatFileCle:

; 448  : 		}

	jmp	$LN4@FatFileCle
$LN5@FatFileCle:

; 449  : 
; 450  : 		dir_clust = FatReadFAT(fsys, dir_clust);

	mov	eax, DWORD PTR dir_clust$[rbp]
	mov	edx, eax
	mov	rcx, QWORD PTR fsys$[rbp]
	call	?FatReadFAT@@YAIPEAU__VFS_NODE__@@_K@Z	; FatReadFAT
	mov	DWORD PTR dir_clust$[rbp], eax

; 451  : 		if (dir_clust == (FAT_EOC_MARK & 0x0FFFFFFF)) 

	cmp	DWORD PTR dir_clust$[rbp], 268435448	; 0ffffff8H
	jne	SHORT $LN14@FatFileCle

; 452  : 			break;

	jmp	SHORT $LN3@FatFileCle
$LN14@FatFileCle:

; 453  : 
; 454  : 	}

	jmp	$LN2@FatFileCle
$LN3@FatFileCle:

; 455  : 	return -1;

	mov	eax, -1
$LN1@FatFileCle:

; 456  : }

	lea	rsp, QWORD PTR [rbp+160]
	pop	rbp
	ret	0
?FatFileClearDirEntry@@YAHPEAU__VFS_NODE__@@0@Z ENDP	; FatFileClearDirEntry
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Fs\Fat\FatFile.cpp
;	COMDAT ?FatWrite@@YA_KPEAU__VFS_NODE__@@0PEA_KI@Z
_TEXT	SEGMENT
_fs$ = 0
num_cluster$ = 8
i$1 = 16
tv76 = 84
tv79 = 88
tv70 = 92
fsys$ = 112
file$ = 120
buffer$ = 128
length$ = 136
?FatWrite@@YA_KPEAU__VFS_NODE__@@0PEA_KI@Z PROC		; FatWrite, COMDAT

; 384  : size_t FatWrite(AuVFSNode* fsys, AuVFSNode* file, uint64_t* buffer, uint32_t length) {

$LN9:
	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 128				; 00000080H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__5368F709_FatFile@cpp
	call	__CheckForDebuggerJustMyCode

; 385  : 	if (!fsys)

	cmp	QWORD PTR fsys$[rbp], 0
	jne	SHORT $LN5@FatWrite

; 386  : 		return 0;

	xor	eax, eax
	jmp	$LN1@FatWrite
$LN5@FatWrite:

; 387  : 	FatFS* _fs = (FatFS*)fsys->device;

	mov	rax, QWORD PTR fsys$[rbp]
	mov	rax, QWORD PTR [rax+64]
	mov	QWORD PTR _fs$[rbp], rax

; 388  : 
; 389  : 	size_t num_cluster = length / (_fs->__BytesPerSector * _fs->__SectorPerCluster) +

	mov	rax, QWORD PTR _fs$[rbp]
	movzx	eax, WORD PTR [rax+64]
	mov	rcx, QWORD PTR _fs$[rbp]
	movzx	ecx, BYTE PTR [rcx+36]
	imul	eax, ecx
	mov	DWORD PTR tv76[rbp], eax
	xor	edx, edx
	mov	eax, DWORD PTR length$[rbp]
	mov	ecx, DWORD PTR tv76[rbp]
	div	ecx
	mov	eax, edx
	test	eax, eax
	je	SHORT $LN7@FatWrite
	mov	DWORD PTR tv79[rbp], 1
	jmp	SHORT $LN8@FatWrite
$LN7@FatWrite:
	mov	DWORD PTR tv79[rbp], 0
$LN8@FatWrite:
	mov	rax, QWORD PTR _fs$[rbp]
	movzx	eax, WORD PTR [rax+64]
	mov	rcx, QWORD PTR _fs$[rbp]
	movzx	ecx, BYTE PTR [rcx+36]
	imul	eax, ecx
	mov	DWORD PTR tv70[rbp], eax
	xor	edx, edx
	mov	eax, DWORD PTR length$[rbp]
	mov	ecx, DWORD PTR tv70[rbp]
	div	ecx
	add	eax, DWORD PTR tv79[rbp]
	mov	eax, eax
	mov	QWORD PTR num_cluster$[rbp], rax

; 390  : 		((length % (_fs->__BytesPerSector * _fs->__SectorPerCluster) ? 1 : 0));
; 391  : 
; 392  : 	for (int i = 0; i < num_cluster; i++) {

	mov	DWORD PTR i$1[rbp], 0
	jmp	SHORT $LN4@FatWrite
$LN2@FatWrite:
	mov	eax, DWORD PTR i$1[rbp]
	inc	eax
	mov	DWORD PTR i$1[rbp], eax
$LN4@FatWrite:
	movsxd	rax, DWORD PTR i$1[rbp]
	cmp	rax, QWORD PTR num_cluster$[rbp]
	jae	SHORT $LN3@FatWrite

; 393  : 		FatFileWriteContent(fsys, file, buffer);

	mov	r8, QWORD PTR buffer$[rbp]
	mov	rdx, QWORD PTR file$[rbp]
	mov	rcx, QWORD PTR fsys$[rbp]
	call	?FatFileWriteContent@@YAXPEAU__VFS_NODE__@@0PEA_K@Z ; FatFileWriteContent

; 394  : 		buffer += (_fs->__BytesPerSector * _fs->__SectorPerCluster);

	mov	rax, QWORD PTR _fs$[rbp]
	movzx	eax, WORD PTR [rax+64]
	mov	rcx, QWORD PTR _fs$[rbp]
	movzx	ecx, BYTE PTR [rcx+36]
	imul	eax, ecx
	cdqe
	mov	rcx, QWORD PTR buffer$[rbp]
	lea	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR buffer$[rbp], rax

; 395  : 	}

	jmp	SHORT $LN2@FatWrite
$LN3@FatWrite:

; 396  : 
; 397  : 
; 398  : 	FatFileUpdateSize(fsys, file, length);

	mov	eax, DWORD PTR length$[rbp]
	mov	r8d, eax
	mov	rdx, QWORD PTR file$[rbp]
	mov	rcx, QWORD PTR fsys$[rbp]
	call	?FatFileUpdateSize@@YAXPEAU__VFS_NODE__@@0_K@Z ; FatFileUpdateSize

; 399  : 	FatFileWriteDone(file);

	mov	rcx, QWORD PTR file$[rbp]
	call	?FatFileWriteDone@@YAXPEAU__VFS_NODE__@@@Z ; FatFileWriteDone
$LN1@FatWrite:

; 400  : 
; 401  : }

	lea	rsp, QWORD PTR [rbp+96]
	pop	rbp
	ret	0
?FatWrite@@YA_KPEAU__VFS_NODE__@@0PEA_KI@Z ENDP		; FatWrite
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Fs\Fat\FatFile.cpp
;	COMDAT ?FatFileWriteDone@@YAXPEAU__VFS_NODE__@@@Z
_TEXT	SEGMENT
file$ = 80
?FatFileWriteDone@@YAXPEAU__VFS_NODE__@@@Z PROC		; FatFileWriteDone, COMDAT

; 371  : void FatFileWriteDone(AuVFSNode* file) {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__5368F709_FatFile@cpp
	call	__CheckForDebuggerJustMyCode

; 372  : 	file->current = file->first_block;

	mov	rax, QWORD PTR file$[rbp]
	mov	rcx, QWORD PTR file$[rbp]
	mov	rcx, QWORD PTR [rcx+45]
	mov	QWORD PTR [rax+53], rcx

; 373  : 	file->eof = 0;

	mov	rax, QWORD PTR file$[rbp]
	mov	BYTE PTR [rax+36], 0

; 374  : 	file->pos = 0;

	mov	rax, QWORD PTR file$[rbp]
	mov	DWORD PTR [rax+37], 0

; 375  : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
?FatFileWriteDone@@YAXPEAU__VFS_NODE__@@@Z ENDP		; FatFileWriteDone
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Fs\Fat\FatFile.cpp
;	COMDAT ?FatFileWriteContent@@YAXPEAU__VFS_NODE__@@0PEA_K@Z
_TEXT	SEGMENT
_fs$ = 0
buff$ = 8
cluster$ = 16
new_cluster$1 = 20
return_cluster$ = 24
sz$ = 32
tv94 = 104
tv130 = 112
fsys$ = 144
file$ = 152
buffer$ = 160
?FatFileWriteContent@@YAXPEAU__VFS_NODE__@@0PEA_K@Z PROC ; FatFileWriteContent, COMDAT

; 323  : void FatFileWriteContent(AuVFSNode* fsys,AuVFSNode* file, uint64_t* buffer) {

$LN9:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 160				; 000000a0H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__5368F709_FatFile@cpp
	call	__CheckForDebuggerJustMyCode

; 324  : 	if (!fsys)

	cmp	QWORD PTR fsys$[rbp], 0
	jne	SHORT $LN2@FatFileWri

; 325  : 		return;

	jmp	$LN1@FatFileWri
$LN2@FatFileWri:

; 326  : 	
; 327  : 
; 328  : 	FatFS* _fs = (FatFS*)fsys->device;

	mov	rax, QWORD PTR fsys$[rbp]
	mov	rax, QWORD PTR [rax+64]
	mov	QWORD PTR _fs$[rbp], rax

; 329  : 
; 330  : 	uint64_t* buff = (uint64_t*)P2V((size_t)AuPmmngrAlloc());

	call	AuPmmngrAlloc
	mov	rcx, rax
	call	P2V
	mov	QWORD PTR buff$[rbp], rax

; 331  : 	memset(buff, 0, PAGE_SIZE);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR buff$[rbp]
	call	memset

; 332  : 
; 333  : 	uint32_t cluster = file->current;

	mov	rax, QWORD PTR file$[rbp]
	mov	eax, DWORD PTR [rax+53]
	mov	DWORD PTR cluster$[rbp], eax

; 334  : 	if (file->eof){

	mov	rax, QWORD PTR file$[rbp]
	movzx	eax, BYTE PTR [rax+36]
	test	eax, eax
	je	SHORT $LN3@FatFileWri

; 335  : 		/* write the new cluster value to
; 336  : 		* old cluster */
; 337  : 		uint32_t new_cluster = FatFindFreeCluster(fsys);

	mov	rcx, QWORD PTR fsys$[rbp]
	call	?FatFindFreeCluster@@YAIPEAU__VFS_NODE__@@@Z ; FatFindFreeCluster
	mov	DWORD PTR new_cluster$1[rbp], eax

; 338  : 		FatAllocCluster(fsys, cluster, new_cluster);

	mov	r8d, DWORD PTR new_cluster$1[rbp]
	mov	edx, DWORD PTR cluster$[rbp]
	mov	rcx, QWORD PTR fsys$[rbp]
	call	?FatAllocCluster@@YAXPEAU__VFS_NODE__@@HI@Z ; FatAllocCluster

; 339  : 		FatAllocCluster(fsys, new_cluster, FAT_EOC_MARK);

	mov	r8d, -8					; fffffff8H
	mov	edx, DWORD PTR new_cluster$1[rbp]
	mov	rcx, QWORD PTR fsys$[rbp]
	call	?FatAllocCluster@@YAXPEAU__VFS_NODE__@@HI@Z ; FatAllocCluster

; 340  : 		FatClearCluster(fsys, new_cluster);

	mov	edx, DWORD PTR new_cluster$1[rbp]
	mov	rcx, QWORD PTR fsys$[rbp]
	call	?FatClearCluster@@YAXPEAU__VFS_NODE__@@I@Z ; FatClearCluster

; 341  : 		cluster = new_cluster;

	mov	eax, DWORD PTR new_cluster$1[rbp]
	mov	DWORD PTR cluster$[rbp], eax

; 342  : 		SeTextOut("[FAT]: New Cluster allocated \r\n");

	lea	rcx, OFFSET FLAT:??_C@_0CA@JGMINDDG@?$FLFAT?$FN?3?5New?5Cluster?5allocated?5?$AN?6@
	call	SeTextOut

; 343  : 		file->eof = 0;

	mov	rax, QWORD PTR file$[rbp]
	mov	BYTE PTR [rax+36], 0
$LN3@FatFileWri:

; 344  : 	}
; 345  : 
; 346  : 	if ((cluster != (FAT_EOC_MARK & 0x0FFFFFFF)) || (cluster != (FAT_BAD_CLUSTER & 0x0fffffff))) {

	cmp	DWORD PTR cluster$[rbp], 268435448	; 0ffffff8H
	jne	SHORT $LN5@FatFileWri
	cmp	DWORD PTR cluster$[rbp], 268435447	; 0ffffff7H
	je	SHORT $LN4@FatFileWri
$LN5@FatFileWri:

; 347  : 		memcpy(buff, buffer, PAGE_SIZE);

	mov	r8d, 4096				; 00001000H
	mov	rdx, QWORD PTR buffer$[rbp]
	mov	rcx, QWORD PTR buff$[rbp]
	call	memcpy

; 348  : 		AuVDiskWrite(_fs->vdisk, FatClusterToSector32(_fs, cluster), _fs->__SectorPerCluster, (uint64_t*)V2P((uint64_t)buff));

	mov	rcx, QWORD PTR buff$[rbp]
	call	V2P
	mov	QWORD PTR tv94[rbp], rax
	mov	rcx, QWORD PTR _fs$[rbp]
	movzx	ecx, BYTE PTR [rcx+36]
	mov	DWORD PTR tv130[rbp], ecx
	mov	edx, DWORD PTR cluster$[rbp]
	mov	rcx, QWORD PTR _fs$[rbp]
	call	?FatClusterToSector32@@YA_KPEAU_FatFS_@@_K@Z ; FatClusterToSector32
	mov	rcx, QWORD PTR tv94[rbp]
	mov	r9, rcx
	mov	ecx, DWORD PTR tv130[rbp]
	mov	r8d, ecx
	mov	rdx, rax
	mov	rax, QWORD PTR _fs$[rbp]
	mov	rcx, QWORD PTR [rax+8]
	call	AuVDiskWrite

; 349  : 		file->pos++;

	mov	rax, QWORD PTR file$[rbp]
	mov	eax, DWORD PTR [rax+37]
	inc	eax
	mov	rcx, QWORD PTR file$[rbp]
	mov	DWORD PTR [rcx+37], eax
$LN4@FatFileWri:

; 350  : 	}
; 351  : 	uint32_t return_cluster = FatReadFAT(fsys, cluster);

	mov	eax, DWORD PTR cluster$[rbp]
	mov	edx, eax
	mov	rcx, QWORD PTR fsys$[rbp]
	call	?FatReadFAT@@YAIPEAU__VFS_NODE__@@_K@Z	; FatReadFAT
	mov	DWORD PTR return_cluster$[rbp], eax

; 352  : 	if (return_cluster == (FAT_EOC_MARK & 0x0FFFFFFF))

	cmp	DWORD PTR return_cluster$[rbp], 268435448 ; 0ffffff8H
	jne	SHORT $LN6@FatFileWri

; 353  : 		file->eof = 1;

	mov	rax, QWORD PTR file$[rbp]
	mov	BYTE PTR [rax+36], 1
	jmp	SHORT $LN7@FatFileWri
$LN6@FatFileWri:

; 354  : 	else
; 355  : 		cluster = return_cluster;

	mov	eax, DWORD PTR return_cluster$[rbp]
	mov	DWORD PTR cluster$[rbp], eax
$LN7@FatFileWri:

; 356  : 
; 357  : 	file->current = cluster;

	mov	eax, DWORD PTR cluster$[rbp]
	mov	rcx, QWORD PTR file$[rbp]
	mov	QWORD PTR [rcx+53], rax

; 358  : 	file->size = file->pos * _fs->__SectorPerCluster * _fs->__BytesPerSector;

	mov	rax, QWORD PTR _fs$[rbp]
	movzx	eax, BYTE PTR [rax+36]
	mov	rcx, QWORD PTR file$[rbp]
	mov	ecx, DWORD PTR [rcx+37]
	imul	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR _fs$[rbp]
	movzx	ecx, WORD PTR [rcx+64]
	imul	eax, ecx
	mov	rcx, QWORD PTR file$[rbp]
	mov	DWORD PTR [rcx+32], eax

; 359  : 	size_t sz = file->size;

	mov	rax, QWORD PTR file$[rbp]
	mov	eax, DWORD PTR [rax+32]
	mov	QWORD PTR sz$[rbp], rax

; 360  : 
; 361  : 	FatFileUpdateSize(fsys, file, sz);

	mov	r8, QWORD PTR sz$[rbp]
	mov	rdx, QWORD PTR file$[rbp]
	mov	rcx, QWORD PTR fsys$[rbp]
	call	?FatFileUpdateSize@@YAXPEAU__VFS_NODE__@@0_K@Z ; FatFileUpdateSize

; 362  : 
; 363  : 	AuPmmngrFree((void*)V2P((size_t)buff));

	mov	rcx, QWORD PTR buff$[rbp]
	call	V2P
	mov	rcx, rax
	call	AuPmmngrFree
$LN1@FatFileWri:

; 364  : }

	lea	rsp, QWORD PTR [rbp+128]
	pop	rbp
	ret	0
?FatFileWriteContent@@YAXPEAU__VFS_NODE__@@0PEA_K@Z ENDP ; FatFileWriteContent
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Fs\Fat\FatFile.cpp
;	COMDAT ?FatFileUpdateFilename@@YAHPEAU__VFS_NODE__@@0PEAD@Z
_TEXT	SEGMENT
_fs$ = 0
dir_cluster$ = 8
fname$ = 16
nname$ = 32
buff$ = 48
j$1 = 56
dirent$2 = 64
i$3 = 72
name$4 = 80
tv161 = 160
tv132 = 160
fsys$ = 192
file$ = 200
newname$ = 208
?FatFileUpdateFilename@@YAHPEAU__VFS_NODE__@@0PEAD@Z PROC ; FatFileUpdateFilename, COMDAT

; 263  : int FatFileUpdateFilename(AuVFSNode* fsys, AuVFSNode* file, char* newname) {

$LN15:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 208				; 000000d0H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__5368F709_FatFile@cpp
	call	__CheckForDebuggerJustMyCode

; 264  : 	if (!fsys)

	cmp	QWORD PTR fsys$[rbp], 0
	jne	SHORT $LN10@FatFileUpd

; 265  : 		return -1;

	mov	eax, -1
	jmp	$LN1@FatFileUpd
$LN10@FatFileUpd:

; 266  : 	if (!file)

	cmp	QWORD PTR file$[rbp], 0
	jne	SHORT $LN11@FatFileUpd

; 267  : 		return -1;

	mov	eax, -1
	jmp	$LN1@FatFileUpd
$LN11@FatFileUpd:

; 268  : 	/*if (!file->parent_block)
; 269  : 	return;*/
; 270  : 	FatFS *_fs = (FatFS*)fsys->device;

	mov	rax, QWORD PTR fsys$[rbp]
	mov	rax, QWORD PTR [rax+64]
	mov	QWORD PTR _fs$[rbp], rax

; 271  : 
; 272  : 	uint32_t dir_cluster = file->parent_block;

	mov	rax, QWORD PTR file$[rbp]
	mov	eax, DWORD PTR [rax+41]
	mov	DWORD PTR dir_cluster$[rbp], eax

; 273  : 
; 274  : 	char fname[11];
; 275  : 	memset(fname, 0, 11);

	mov	r8d, 11
	xor	edx, edx
	lea	rcx, QWORD PTR fname$[rbp]
	call	memset

; 276  : 	FatToDOSFilename(file->filename, fname, 11);

	mov	rax, QWORD PTR file$[rbp]
	mov	r8d, 11
	lea	rdx, QWORD PTR fname$[rbp]
	mov	rcx, rax
	call	?FatToDOSFilename@@YAXPEBDPEADI@Z	; FatToDOSFilename

; 277  : 	fname[11] = 0;

	mov	eax, 1
	imul	rax, rax, 11
	mov	BYTE PTR fname$[rbp+rax], 0

; 278  : 
; 279  : 	char nname[11];
; 280  : 	memset(nname, 0, 11);

	mov	r8d, 11
	xor	edx, edx
	lea	rcx, QWORD PTR nname$[rbp]
	call	memset

; 281  : 	FatToDOSFilename(newname, nname, 11);

	mov	r8d, 11
	lea	rdx, QWORD PTR nname$[rbp]
	mov	rcx, QWORD PTR newname$[rbp]
	call	?FatToDOSFilename@@YAXPEBDPEADI@Z	; FatToDOSFilename

; 282  : 	nname[11] = 0;

	mov	eax, 1
	imul	rax, rax, 11
	mov	BYTE PTR nname$[rbp+rax], 0

; 283  : 
; 284  : 	uint64_t* buff = (uint64_t*)P2V((size_t)AuPmmngrAlloc());

	call	AuPmmngrAlloc
	mov	rcx, rax
	call	P2V
	mov	QWORD PTR buff$[rbp], rax

; 285  : 	memset(buff, 0, PAGE_SIZE);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR buff$[rbp]
	call	memset
$LN2@FatFileUpd:

; 286  : 
; 287  : 	while (1) {

	xor	eax, eax
	cmp	eax, 1
	je	$LN3@FatFileUpd

; 288  : 		for (int j = 0; j < _fs->__SectorPerCluster; j++) {

	mov	DWORD PTR j$1[rbp], 0
	jmp	SHORT $LN6@FatFileUpd
$LN4@FatFileUpd:
	mov	eax, DWORD PTR j$1[rbp]
	inc	eax
	mov	DWORD PTR j$1[rbp], eax
$LN6@FatFileUpd:
	mov	rax, QWORD PTR _fs$[rbp]
	movzx	eax, BYTE PTR [rax+36]
	cmp	DWORD PTR j$1[rbp], eax
	jge	$LN5@FatFileUpd

; 289  : 			memset(buff, 0, PAGE_SIZE);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR buff$[rbp]
	call	memset

; 290  : 			AuVDiskRead(_fs->vdisk, FatClusterToSector32(_fs, dir_cluster) + j, 1, (uint64_t*)V2P((size_t)buff));

	mov	rcx, QWORD PTR buff$[rbp]
	call	V2P
	mov	QWORD PTR tv132[rbp], rax
	mov	ecx, DWORD PTR dir_cluster$[rbp]
	mov	edx, ecx
	mov	rcx, QWORD PTR _fs$[rbp]
	call	?FatClusterToSector32@@YA_KPEAU_FatFS_@@_K@Z ; FatClusterToSector32
	movsxd	rcx, DWORD PTR j$1[rbp]
	add	rax, rcx
	mov	rcx, QWORD PTR tv132[rbp]
	mov	r9, rcx
	mov	r8d, 1
	mov	rdx, rax
	mov	rax, QWORD PTR _fs$[rbp]
	mov	rcx, QWORD PTR [rax+8]
	call	AuVDiskRead

; 291  : 
; 292  : 			FatDir *dirent = (FatDir*)buff;

	mov	rax, QWORD PTR buff$[rbp]
	mov	QWORD PTR dirent$2[rbp], rax

; 293  : 			for (int i = 0; i < 16; i++) {

	mov	DWORD PTR i$3[rbp], 0
	jmp	SHORT $LN9@FatFileUpd
$LN7@FatFileUpd:
	mov	eax, DWORD PTR i$3[rbp]
	inc	eax
	mov	DWORD PTR i$3[rbp], eax
$LN9@FatFileUpd:
	cmp	DWORD PTR i$3[rbp], 16
	jge	$LN8@FatFileUpd

; 294  : 				char name[11];
; 295  : 				memcpy(name, dirent->filename, 11);

	mov	rax, QWORD PTR dirent$2[rbp]
	mov	r8d, 11
	mov	rdx, rax
	lea	rcx, QWORD PTR name$4[rbp]
	call	memcpy

; 296  : 				name[11] = 0;

	mov	eax, 1
	imul	rax, rax, 11
	mov	BYTE PTR name$4[rbp+rax], 0

; 297  : 
; 298  : 				if (strcmp(name, fname) == 0) {

	lea	rdx, QWORD PTR fname$[rbp]
	lea	rcx, QWORD PTR name$4[rbp]
	call	strcmp
	test	eax, eax
	jne	SHORT $LN12@FatFileUpd

; 299  : 					memcpy(dirent->filename, nname, 11);

	mov	rax, QWORD PTR dirent$2[rbp]
	mov	r8d, 11
	lea	rdx, QWORD PTR nname$[rbp]
	mov	rcx, rax
	call	memcpy

; 300  : 					AuVDiskWrite(_fs->vdisk, FatClusterToSector32(_fs, dir_cluster) + j, 1, (uint64_t*)V2P((size_t)buff));

	mov	rcx, QWORD PTR buff$[rbp]
	call	V2P
	mov	QWORD PTR tv161[rbp], rax
	mov	ecx, DWORD PTR dir_cluster$[rbp]
	mov	edx, ecx
	mov	rcx, QWORD PTR _fs$[rbp]
	call	?FatClusterToSector32@@YA_KPEAU_FatFS_@@_K@Z ; FatClusterToSector32
	movsxd	rcx, DWORD PTR j$1[rbp]
	add	rax, rcx
	mov	rcx, QWORD PTR tv161[rbp]
	mov	r9, rcx
	mov	r8d, 1
	mov	rdx, rax
	mov	rax, QWORD PTR _fs$[rbp]
	mov	rcx, QWORD PTR [rax+8]
	call	AuVDiskWrite

; 301  : 					AuPmmngrFree((void*)V2P((size_t)buff));

	mov	rcx, QWORD PTR buff$[rbp]
	call	V2P
	mov	rcx, rax
	call	AuPmmngrFree

; 302  : 					return 0;

	xor	eax, eax
	jmp	SHORT $LN1@FatFileUpd
$LN12@FatFileUpd:

; 303  : 				}
; 304  : 				dirent++;

	mov	rax, QWORD PTR dirent$2[rbp]
	add	rax, 32					; 00000020H
	mov	QWORD PTR dirent$2[rbp], rax

; 305  : 			}

	jmp	$LN7@FatFileUpd
$LN8@FatFileUpd:

; 306  : 		}

	jmp	$LN4@FatFileUpd
$LN5@FatFileUpd:

; 307  : 
; 308  : 		dir_cluster = FatReadFAT(fsys, dir_cluster);

	mov	eax, DWORD PTR dir_cluster$[rbp]
	mov	edx, eax
	mov	rcx, QWORD PTR fsys$[rbp]
	call	?FatReadFAT@@YAIPEAU__VFS_NODE__@@_K@Z	; FatReadFAT
	mov	DWORD PTR dir_cluster$[rbp], eax

; 309  : 		if (dir_cluster == (FAT_EOC_MARK & 0x0FFFFFFF)) 

	cmp	DWORD PTR dir_cluster$[rbp], 268435448	; 0ffffff8H
	jne	SHORT $LN13@FatFileUpd

; 310  : 			break;

	jmp	SHORT $LN3@FatFileUpd
$LN13@FatFileUpd:

; 311  : 	}

	jmp	$LN2@FatFileUpd
$LN3@FatFileUpd:

; 312  : 		
; 313  : 	return -1;

	mov	eax, -1
$LN1@FatFileUpd:

; 314  : }

	lea	rsp, QWORD PTR [rbp+176]
	pop	rbp
	ret	0
?FatFileUpdateFilename@@YAHPEAU__VFS_NODE__@@0PEAD@Z ENDP ; FatFileUpdateFilename
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Fs\Fat\FatFile.cpp
;	COMDAT ?FatFileUpdateSize@@YAXPEAU__VFS_NODE__@@0_K@Z
_TEXT	SEGMENT
_fs$ = 0
dir_cluster$ = 8
fname$ = 16
buff$ = 32
j$1 = 40
dirent$2 = 48
i$3 = 56
name$4 = 64
tv150 = 144
tv92 = 144
fsys$ = 176
file$ = 184
size$ = 192
?FatFileUpdateSize@@YAXPEAU__VFS_NODE__@@0_K@Z PROC	; FatFileUpdateSize, COMDAT

; 209  : void FatFileUpdateSize(AuVFSNode* fsys, AuVFSNode* file, size_t size) {

$LN15:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 192				; 000000c0H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__5368F709_FatFile@cpp
	call	__CheckForDebuggerJustMyCode

; 210  : 	if (!fsys)

	cmp	QWORD PTR fsys$[rbp], 0
	jne	SHORT $LN10@FatFileUpd

; 211  : 		return;

	jmp	$LN1@FatFileUpd
$LN10@FatFileUpd:

; 212  : 	if (!file)

	cmp	QWORD PTR file$[rbp], 0
	jne	SHORT $LN11@FatFileUpd

; 213  : 		return;

	jmp	$LN1@FatFileUpd
$LN11@FatFileUpd:

; 214  : 	/*if (!file->parent_block)
; 215  : 		return;*/
; 216  : 	FatFS *_fs = (FatFS*)fsys->device;

	mov	rax, QWORD PTR fsys$[rbp]
	mov	rax, QWORD PTR [rax+64]
	mov	QWORD PTR _fs$[rbp], rax

; 217  : 
; 218  : 	uint32_t dir_cluster = file->parent_block;

	mov	rax, QWORD PTR file$[rbp]
	mov	eax, DWORD PTR [rax+41]
	mov	DWORD PTR dir_cluster$[rbp], eax

; 219  : 
; 220  : 	char fname[11];
; 221  : 	memset(fname, 0, 11);

	mov	r8d, 11
	xor	edx, edx
	lea	rcx, QWORD PTR fname$[rbp]
	call	memset

; 222  : 	FatToDOSFilename(file->filename, fname, 11);

	mov	rax, QWORD PTR file$[rbp]
	mov	r8d, 11
	lea	rdx, QWORD PTR fname$[rbp]
	mov	rcx, rax
	call	?FatToDOSFilename@@YAXPEBDPEADI@Z	; FatToDOSFilename

; 223  : 	fname[11] = 0;

	mov	eax, 1
	imul	rax, rax, 11
	mov	BYTE PTR fname$[rbp+rax], 0

; 224  : 	uint64_t* buff = (uint64_t*)P2V((size_t)AuPmmngrAlloc());

	call	AuPmmngrAlloc
	mov	rcx, rax
	call	P2V
	mov	QWORD PTR buff$[rbp], rax

; 225  : 	memset(buff, 0, PAGE_SIZE);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR buff$[rbp]
	call	memset
$LN2@FatFileUpd:

; 226  : 
; 227  : 	while (1) {

	xor	eax, eax
	cmp	eax, 1
	je	$LN3@FatFileUpd

; 228  : 		for (int j = 0; j < _fs->__SectorPerCluster; j++) {

	mov	DWORD PTR j$1[rbp], 0
	jmp	SHORT $LN6@FatFileUpd
$LN4@FatFileUpd:
	mov	eax, DWORD PTR j$1[rbp]
	inc	eax
	mov	DWORD PTR j$1[rbp], eax
$LN6@FatFileUpd:
	mov	rax, QWORD PTR _fs$[rbp]
	movzx	eax, BYTE PTR [rax+36]
	cmp	DWORD PTR j$1[rbp], eax
	jge	$LN5@FatFileUpd

; 229  : 			memset(buff, 0, PAGE_SIZE);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR buff$[rbp]
	call	memset

; 230  : 			AuVDiskRead(_fs->vdisk, FatClusterToSector32(_fs, dir_cluster) + j, 1, (uint64_t*)V2P((size_t)buff));

	mov	rcx, QWORD PTR buff$[rbp]
	call	V2P
	mov	QWORD PTR tv92[rbp], rax
	mov	ecx, DWORD PTR dir_cluster$[rbp]
	mov	edx, ecx
	mov	rcx, QWORD PTR _fs$[rbp]
	call	?FatClusterToSector32@@YA_KPEAU_FatFS_@@_K@Z ; FatClusterToSector32
	movsxd	rcx, DWORD PTR j$1[rbp]
	add	rax, rcx
	mov	rcx, QWORD PTR tv92[rbp]
	mov	r9, rcx
	mov	r8d, 1
	mov	rdx, rax
	mov	rax, QWORD PTR _fs$[rbp]
	mov	rcx, QWORD PTR [rax+8]
	call	AuVDiskRead

; 231  : 
; 232  : 			FatDir *dirent = (FatDir*)buff;

	mov	rax, QWORD PTR buff$[rbp]
	mov	QWORD PTR dirent$2[rbp], rax

; 233  : 			for (int i = 0; i < 16; i++) {

	mov	DWORD PTR i$3[rbp], 0
	jmp	SHORT $LN9@FatFileUpd
$LN7@FatFileUpd:
	mov	eax, DWORD PTR i$3[rbp]
	inc	eax
	mov	DWORD PTR i$3[rbp], eax
$LN9@FatFileUpd:
	cmp	DWORD PTR i$3[rbp], 16
	jge	$LN8@FatFileUpd

; 234  : 				char name[11];
; 235  : 				memcpy(name, dirent->filename, 11);

	mov	rax, QWORD PTR dirent$2[rbp]
	mov	r8d, 11
	mov	rdx, rax
	lea	rcx, QWORD PTR name$4[rbp]
	call	memcpy

; 236  : 				name[11] = 0;

	mov	eax, 1
	imul	rax, rax, 11
	mov	BYTE PTR name$4[rbp+rax], 0

; 237  : 
; 238  : 				if (strcmp(name, fname) == 0) {

	lea	rdx, QWORD PTR fname$[rbp]
	lea	rcx, QWORD PTR name$4[rbp]
	call	strcmp
	test	eax, eax
	jne	SHORT $LN12@FatFileUpd

; 239  : 					dirent->file_size = size;

	mov	rax, QWORD PTR dirent$2[rbp]
	mov	ecx, DWORD PTR size$[rbp]
	mov	DWORD PTR [rax+28], ecx

; 240  : 					AuVDiskWrite(_fs->vdisk, FatClusterToSector32(_fs, dir_cluster) + j, 1, (uint64_t*)V2P((size_t)buff));

	mov	rcx, QWORD PTR buff$[rbp]
	call	V2P
	mov	QWORD PTR tv150[rbp], rax
	mov	ecx, DWORD PTR dir_cluster$[rbp]
	mov	edx, ecx
	mov	rcx, QWORD PTR _fs$[rbp]
	call	?FatClusterToSector32@@YA_KPEAU_FatFS_@@_K@Z ; FatClusterToSector32
	movsxd	rcx, DWORD PTR j$1[rbp]
	add	rax, rcx
	mov	rcx, QWORD PTR tv150[rbp]
	mov	r9, rcx
	mov	r8d, 1
	mov	rdx, rax
	mov	rax, QWORD PTR _fs$[rbp]
	mov	rcx, QWORD PTR [rax+8]
	call	AuVDiskWrite

; 241  : 					AuPmmngrFree((void*)V2P((size_t)buff));

	mov	rcx, QWORD PTR buff$[rbp]
	call	V2P
	mov	rcx, rax
	call	AuPmmngrFree

; 242  : 					return;

	jmp	SHORT $LN1@FatFileUpd
$LN12@FatFileUpd:

; 243  : 				}
; 244  : 				dirent++;

	mov	rax, QWORD PTR dirent$2[rbp]
	add	rax, 32					; 00000020H
	mov	QWORD PTR dirent$2[rbp], rax

; 245  : 			}

	jmp	$LN7@FatFileUpd
$LN8@FatFileUpd:

; 246  : 		}

	jmp	$LN4@FatFileUpd
$LN5@FatFileUpd:

; 247  : 
; 248  : 		dir_cluster = FatReadFAT(fsys, dir_cluster);

	mov	eax, DWORD PTR dir_cluster$[rbp]
	mov	edx, eax
	mov	rcx, QWORD PTR fsys$[rbp]
	call	?FatReadFAT@@YAIPEAU__VFS_NODE__@@_K@Z	; FatReadFAT
	mov	DWORD PTR dir_cluster$[rbp], eax

; 249  : 		if (dir_cluster == (FAT_EOC_MARK & 0x0FFFFFFF)) {

	cmp	DWORD PTR dir_cluster$[rbp], 268435448	; 0ffffff8H
	jne	SHORT $LN13@FatFileUpd

; 250  : 			break;

	jmp	SHORT $LN3@FatFileUpd
$LN13@FatFileUpd:

; 251  : 		}
; 252  : 	}

	jmp	$LN2@FatFileUpd
$LN3@FatFileUpd:
$LN1@FatFileUpd:

; 253  : 	return;
; 254  : }

	lea	rsp, QWORD PTR [rbp+160]
	pop	rbp
	ret	0
?FatFileUpdateSize@@YAXPEAU__VFS_NODE__@@0_K@Z ENDP	; FatFileUpdateSize
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Fs\Fat\FatFile.cpp
;	COMDAT ?FatCreateFile@@YAPEAU__VFS_NODE__@@PEAU1@PEAD@Z
_TEXT	SEGMENT
_fs$ = 0
parent$ = 8
parent_cluster$ = 16
file$ = 24
buff$ = 32
path$ = 40
p$ = 48
extract$ = 56
i$1 = 72
fname$ = 80
j$2 = 96
dirent$3 = 104
i$4 = 112
cluster$5 = 116
tv221 = 184
tv166 = 184
fsys$ = 208
filename$ = 216
?FatCreateFile@@YAPEAU__VFS_NODE__@@PEAU1@PEAD@Z PROC	; FatCreateFile, COMDAT

; 103  : AuVFSNode* FatCreateFile(AuVFSNode* fsys, char* filename) {

$LN26:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 224				; 000000e0H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__5368F709_FatFile@cpp
	call	__CheckForDebuggerJustMyCode

; 104  : 	if (!fsys)

	cmp	QWORD PTR fsys$[rbp], 0
	jne	SHORT $LN15@FatCreateF

; 105  : 		return NULL;

	xor	eax, eax
	jmp	$LN1@FatCreateF
$LN15@FatCreateF:

; 106  : 	FatFS* _fs = (FatFS*)fsys->device;

	mov	rax, QWORD PTR fsys$[rbp]
	mov	rax, QWORD PTR [rax+64]
	mov	QWORD PTR _fs$[rbp], rax

; 107  : 
; 108  : 	AuVFSNode* parent = FatFileGetParent(fsys, filename);

	mov	rdx, QWORD PTR filename$[rbp]
	mov	rcx, QWORD PTR fsys$[rbp]
	call	?FatFileGetParent@@YAPEAU__VFS_NODE__@@PEAU1@PEBD@Z ; FatFileGetParent
	mov	QWORD PTR parent$[rbp], rax

; 109  : 	if (!parent)

	cmp	QWORD PTR parent$[rbp], 0
	jne	SHORT $LN16@FatCreateF

; 110  : 		return NULL;

	xor	eax, eax
	jmp	$LN1@FatCreateF
$LN16@FatCreateF:

; 111  : 	
; 112  : 	uint32_t parent_cluster = parent->current;

	mov	rax, QWORD PTR parent$[rbp]
	mov	eax, DWORD PTR [rax+53]
	mov	DWORD PTR parent_cluster$[rbp], eax

; 113  : 	if (!parent_cluster)

	cmp	DWORD PTR parent_cluster$[rbp], 0
	jne	SHORT $LN17@FatCreateF

; 114  : 		parent_cluster = _fs->__RootDirFirstCluster;

	mov	rax, QWORD PTR _fs$[rbp]
	mov	eax, DWORD PTR [rax+40]
	mov	DWORD PTR parent_cluster$[rbp], eax
$LN17@FatCreateF:

; 115  : 
; 116  : 	AuVFSNode* file = (AuVFSNode*)kmalloc(sizeof(AuVFSNode));

	mov	ecx, 178				; 000000b2H
	call	kmalloc
	mov	QWORD PTR file$[rbp], rax

; 117  : 	memset(file, 0, sizeof(AuVFSNode));

	mov	r8d, 178				; 000000b2H
	xor	edx, edx
	mov	rcx, QWORD PTR file$[rbp]
	call	memset

; 118  : 
; 119  : 	uint64_t* buff = (uint64_t*)P2V((size_t)AuPmmngrAlloc());

	call	AuPmmngrAlloc
	mov	rcx, rax
	call	P2V
	mov	QWORD PTR buff$[rbp], rax

; 120  : 	memset(buff, 0, PAGE_SIZE);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR buff$[rbp]
	call	memset

; 121  : 
; 122  : 	char* path = (char*)filename;

	mov	rax, QWORD PTR filename$[rbp]
	mov	QWORD PTR path$[rbp], rax

; 123  : 	char* p = strchr(path, '/');

	mov	edx, 47					; 0000002fH
	mov	rcx, QWORD PTR path$[rbp]
	call	strchr
	mov	QWORD PTR p$[rbp], rax

; 124  : 	if (p)

	cmp	QWORD PTR p$[rbp], 0
	je	SHORT $LN18@FatCreateF

; 125  : 		p++;

	mov	rax, QWORD PTR p$[rbp]
	inc	rax
	mov	QWORD PTR p$[rbp], rax
$LN18@FatCreateF:

; 126  : 
; 127  : 	char extract[16];
; 128  : 	memset(extract, 0, 16);

	mov	r8d, 16
	xor	edx, edx
	lea	rcx, QWORD PTR extract$[rbp]
	call	memset
$LN2@FatCreateF:

; 129  : 	while (p) {

	cmp	QWORD PTR p$[rbp], 0
	je	$LN3@FatCreateF

; 130  : 		int i = 0;

	mov	DWORD PTR i$1[rbp], 0

; 131  : 		for (i = 0; i < 16; i++) {

	mov	DWORD PTR i$1[rbp], 0
	jmp	SHORT $LN6@FatCreateF
$LN4@FatCreateF:
	mov	eax, DWORD PTR i$1[rbp]
	inc	eax
	mov	DWORD PTR i$1[rbp], eax
$LN6@FatCreateF:
	cmp	DWORD PTR i$1[rbp], 16
	jge	SHORT $LN5@FatCreateF

; 132  : 			if (p[i] == '/' || p[i] == '\0')

	movsxd	rax, DWORD PTR i$1[rbp]
	mov	rcx, QWORD PTR p$[rbp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 47					; 0000002fH
	je	SHORT $LN20@FatCreateF
	movsxd	rax, DWORD PTR i$1[rbp]
	mov	rcx, QWORD PTR p$[rbp]
	movsx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	jne	SHORT $LN19@FatCreateF
$LN20@FatCreateF:

; 133  : 				break;

	jmp	SHORT $LN5@FatCreateF
$LN19@FatCreateF:

; 134  : 			extract[i] = p[i];

	movsxd	rax, DWORD PTR i$1[rbp]
	movsxd	rcx, DWORD PTR i$1[rbp]
	mov	rdx, QWORD PTR p$[rbp]
	movzx	eax, BYTE PTR [rdx+rax]
	mov	BYTE PTR extract$[rbp+rcx], al

; 135  : 		}

	jmp	SHORT $LN4@FatCreateF
$LN5@FatCreateF:

; 136  : 		p = strchr(p + 1, '/');

	mov	rax, QWORD PTR p$[rbp]
	inc	rax
	mov	edx, 47					; 0000002fH
	mov	rcx, rax
	call	strchr
	mov	QWORD PTR p$[rbp], rax

; 137  : 		if (p)

	cmp	QWORD PTR p$[rbp], 0
	je	SHORT $LN21@FatCreateF

; 138  : 			p++;

	mov	rax, QWORD PTR p$[rbp]
	inc	rax
	mov	QWORD PTR p$[rbp], rax
$LN21@FatCreateF:

; 139  : 	}

	jmp	$LN2@FatCreateF
$LN3@FatCreateF:

; 140  : 
; 141  : 	char fname[11];
; 142  : 	memset(fname, 0, 11);

	mov	r8d, 11
	xor	edx, edx
	lea	rcx, QWORD PTR fname$[rbp]
	call	memset

; 143  : 	FatToDOSFilename(extract, fname, 11);

	mov	r8d, 11
	lea	rdx, QWORD PTR fname$[rbp]
	lea	rcx, QWORD PTR extract$[rbp]
	call	?FatToDOSFilename@@YAXPEBDPEADI@Z	; FatToDOSFilename

; 144  : 	fname[11] = 0;

	mov	eax, 1
	imul	rax, rax, 11
	mov	BYTE PTR fname$[rbp+rax], 0
$LN7@FatCreateF:

; 145  : 
; 146  : 	while (1) {

	xor	eax, eax
	cmp	eax, 1
	je	$LN8@FatCreateF

; 147  : 		for (int j = 0; j < _fs->__SectorPerCluster; j++) {

	mov	DWORD PTR j$2[rbp], 0
	jmp	SHORT $LN11@FatCreateF
$LN9@FatCreateF:
	mov	eax, DWORD PTR j$2[rbp]
	inc	eax
	mov	DWORD PTR j$2[rbp], eax
$LN11@FatCreateF:
	mov	rax, QWORD PTR _fs$[rbp]
	movzx	eax, BYTE PTR [rax+36]
	cmp	DWORD PTR j$2[rbp], eax
	jge	$LN10@FatCreateF

; 148  : 			memset(buff, 0, PAGE_SIZE);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR buff$[rbp]
	call	memset

; 149  : 			AuVDiskRead(_fs->vdisk, FatClusterToSector32(_fs, parent_cluster) + j, 1, (uint64_t*)V2P((size_t)buff));

	mov	rcx, QWORD PTR buff$[rbp]
	call	V2P
	mov	QWORD PTR tv166[rbp], rax
	mov	ecx, DWORD PTR parent_cluster$[rbp]
	mov	edx, ecx
	mov	rcx, QWORD PTR _fs$[rbp]
	call	?FatClusterToSector32@@YA_KPEAU_FatFS_@@_K@Z ; FatClusterToSector32
	movsxd	rcx, DWORD PTR j$2[rbp]
	add	rax, rcx
	mov	rcx, QWORD PTR tv166[rbp]
	mov	r9, rcx
	mov	r8d, 1
	mov	rdx, rax
	mov	rax, QWORD PTR _fs$[rbp]
	mov	rcx, QWORD PTR [rax+8]
	call	AuVDiskRead

; 150  : 
; 151  : 			FatDir *dirent = (FatDir*)buff;

	mov	rax, QWORD PTR buff$[rbp]
	mov	QWORD PTR dirent$3[rbp], rax

; 152  : 			for (int i = 0; i < 16; i++) {

	mov	DWORD PTR i$4[rbp], 0
	jmp	SHORT $LN14@FatCreateF
$LN12@FatCreateF:
	mov	eax, DWORD PTR i$4[rbp]
	inc	eax
	mov	DWORD PTR i$4[rbp], eax
$LN14@FatCreateF:
	cmp	DWORD PTR i$4[rbp], 16
	jge	$LN13@FatCreateF

; 153  : 				if (dirent->filename[0] == 0x00 || dirent->filename[0] == 0xE5) {

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR dirent$3[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN23@FatCreateF
	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR dirent$3[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 229				; 000000e5H
	jne	$LN22@FatCreateF
$LN23@FatCreateF:

; 154  : 					memcpy(dirent->filename, fname, 11);

	mov	rax, QWORD PTR dirent$3[rbp]
	mov	r8d, 11
	lea	rdx, QWORD PTR fname$[rbp]
	mov	rcx, rax
	call	memcpy

; 155  : 
; 156  : 					uint32_t cluster = FatFindFreeCluster(fsys);

	mov	rcx, QWORD PTR fsys$[rbp]
	call	?FatFindFreeCluster@@YAIPEAU__VFS_NODE__@@@Z ; FatFindFreeCluster
	mov	DWORD PTR cluster$5[rbp], eax

; 157  : 					FatAllocCluster(fsys, cluster, FAT_EOC_MARK);

	mov	r8d, -8					; fffffff8H
	mov	edx, DWORD PTR cluster$5[rbp]
	mov	rcx, QWORD PTR fsys$[rbp]
	call	?FatAllocCluster@@YAXPEAU__VFS_NODE__@@HI@Z ; FatAllocCluster

; 158  : 					FatClearCluster(fsys, cluster);

	mov	edx, DWORD PTR cluster$5[rbp]
	mov	rcx, QWORD PTR fsys$[rbp]
	call	?FatClearCluster@@YAXPEAU__VFS_NODE__@@I@Z ; FatClearCluster

; 159  : 
; 160  : 					dirent->attrib = FAT_ATTRIBUTE_ARCHIVE;

	mov	rax, QWORD PTR dirent$3[rbp]
	mov	BYTE PTR [rax+11], 32			; 00000020H

; 161  : 					dirent->first_cluster = cluster & 0x0000FFFF;

	mov	eax, DWORD PTR cluster$5[rbp]
	and	eax, 65535				; 0000ffffH
	mov	rcx, QWORD PTR dirent$3[rbp]
	mov	WORD PTR [rcx+26], ax

; 162  : 					dirent->first_cluster_hi_bytes = (cluster & 0x0FFF0000) >> 16;

	mov	eax, DWORD PTR cluster$5[rbp]
	and	eax, 268369920				; 0fff0000H
	shr	eax, 16
	mov	rcx, QWORD PTR dirent$3[rbp]
	mov	WORD PTR [rcx+20], ax

; 163  : 					dirent->date_created = FatFormatDate();

	call	?FatFormatDate@@YAGXZ			; FatFormatDate
	mov	rcx, QWORD PTR dirent$3[rbp]
	mov	WORD PTR [rcx+16], ax

; 164  : 					dirent->time_created = FatFormatTime();

	call	?FatFormatTime@@YAGXZ			; FatFormatTime
	mov	rcx, QWORD PTR dirent$3[rbp]
	mov	WORD PTR [rcx+14], ax

; 165  : 					dirent->last_wrt_date = dirent->date_created;

	mov	rax, QWORD PTR dirent$3[rbp]
	mov	rcx, QWORD PTR dirent$3[rbp]
	movzx	ecx, WORD PTR [rcx+16]
	mov	WORD PTR [rax+24], cx

; 166  : 					dirent->last_wrt_time = dirent->time_created;

	mov	rax, QWORD PTR dirent$3[rbp]
	mov	rcx, QWORD PTR dirent$3[rbp]
	movzx	ecx, WORD PTR [rcx+14]
	mov	WORD PTR [rax+22], cx

; 167  : 					dirent->date_last_accessed = dirent->date_created;

	mov	rax, QWORD PTR dirent$3[rbp]
	mov	rcx, QWORD PTR dirent$3[rbp]
	movzx	ecx, WORD PTR [rcx+16]
	mov	WORD PTR [rax+18], cx

; 168  : 					dirent->file_size = 0; //by default, 0 bytes

	mov	rax, QWORD PTR dirent$3[rbp]
	mov	DWORD PTR [rax+28], 0

; 169  : 
; 170  : 					AuVDiskWrite(_fs->vdisk, FatClusterToSector32(_fs, parent_cluster) + j, 1, (uint64_t*)V2P((size_t)buff));

	mov	rcx, QWORD PTR buff$[rbp]
	call	V2P
	mov	QWORD PTR tv221[rbp], rax
	mov	ecx, DWORD PTR parent_cluster$[rbp]
	mov	edx, ecx
	mov	rcx, QWORD PTR _fs$[rbp]
	call	?FatClusterToSector32@@YA_KPEAU_FatFS_@@_K@Z ; FatClusterToSector32
	movsxd	rcx, DWORD PTR j$2[rbp]
	add	rax, rcx
	mov	rcx, QWORD PTR tv221[rbp]
	mov	r9, rcx
	mov	r8d, 1
	mov	rdx, rax
	mov	rax, QWORD PTR _fs$[rbp]
	mov	rcx, QWORD PTR [rax+8]
	call	AuVDiskWrite

; 171  : 					AuPmmngrFree((void*)V2P((size_t)buff));

	mov	rcx, QWORD PTR buff$[rbp]
	call	V2P
	mov	rcx, rax
	call	AuPmmngrFree

; 172  : 
; 173  : 					strcpy(file->filename, extract);

	mov	rax, QWORD PTR file$[rbp]
	lea	rdx, QWORD PTR extract$[rbp]
	mov	rcx, rax
	call	strcpy

; 174  : 					file->size = dirent->file_size;

	mov	rax, QWORD PTR file$[rbp]
	mov	rcx, QWORD PTR dirent$3[rbp]
	mov	ecx, DWORD PTR [rcx+28]
	mov	DWORD PTR [rax+32], ecx

; 175  : 					file->eof = 0;

	mov	rax, QWORD PTR file$[rbp]
	mov	BYTE PTR [rax+36], 0

; 176  : 					file->pos = 0;

	mov	rax, QWORD PTR file$[rbp]
	mov	DWORD PTR [rax+37], 0

; 177  : 					file->current = cluster;

	mov	eax, DWORD PTR cluster$5[rbp]
	mov	rcx, QWORD PTR file$[rbp]
	mov	QWORD PTR [rcx+53], rax

; 178  : 					file->first_block = cluster;

	mov	eax, DWORD PTR cluster$5[rbp]
	mov	rcx, QWORD PTR file$[rbp]
	mov	QWORD PTR [rcx+45], rax

; 179  : 					file->parent_block = parent_cluster;

	mov	rax, QWORD PTR file$[rbp]
	mov	ecx, DWORD PTR parent_cluster$[rbp]
	mov	DWORD PTR [rax+41], ecx

; 180  : 					file->device = fsys;

	mov	rax, QWORD PTR file$[rbp]
	mov	rcx, QWORD PTR fsys$[rbp]
	mov	QWORD PTR [rax+64], rcx

; 181  : 					file->flags |= FS_FLAG_GENERAL;

	mov	rax, QWORD PTR file$[rbp]
	movzx	eax, WORD PTR [rax+61]
	or	eax, 4
	mov	rcx, QWORD PTR file$[rbp]
	mov	WORD PTR [rcx+61], ax

; 182  : 					file->status = FS_STATUS_FOUND;

	mov	rax, QWORD PTR file$[rbp]
	mov	BYTE PTR [rax+63], 1

; 183  : 
; 184  : 					kfree(parent);

	mov	rcx, QWORD PTR parent$[rbp]
	call	kfree

; 185  : 					return file;

	mov	rax, QWORD PTR file$[rbp]
	jmp	SHORT $LN1@FatCreateF
$LN22@FatCreateF:

; 186  : 				}
; 187  : 				dirent++;

	mov	rax, QWORD PTR dirent$3[rbp]
	add	rax, 32					; 00000020H
	mov	QWORD PTR dirent$3[rbp], rax

; 188  : 			}

	jmp	$LN12@FatCreateF
$LN13@FatCreateF:

; 189  : 		}

	jmp	$LN9@FatCreateF
$LN10@FatCreateF:

; 190  : 		parent_cluster = FatReadFAT(fsys, parent_cluster);

	mov	eax, DWORD PTR parent_cluster$[rbp]
	mov	edx, eax
	mov	rcx, QWORD PTR fsys$[rbp]
	call	?FatReadFAT@@YAIPEAU__VFS_NODE__@@_K@Z	; FatReadFAT
	mov	DWORD PTR parent_cluster$[rbp], eax

; 191  : 		if (parent_cluster == (FAT_EOC_MARK & 0x0FFFFFFF))

	cmp	DWORD PTR parent_cluster$[rbp], 268435448 ; 0ffffff8H
	jne	SHORT $LN24@FatCreateF

; 192  : 			break;

	jmp	SHORT $LN8@FatCreateF
$LN24@FatCreateF:

; 193  : 			/* actually, here we need to allocate a new
; 194  : 			 * cluster and write it to root cluster
; 195  : 			 * so that root directory expands
; 196  : 			 */
; 197  : 	}

	jmp	$LN7@FatCreateF
$LN8@FatCreateF:

; 198  : 	kfree(parent);

	mov	rcx, QWORD PTR parent$[rbp]
	call	kfree

; 199  : 	kfree(file);

	mov	rcx, QWORD PTR file$[rbp]
	call	kfree

; 200  : 	return NULL;

	xor	eax, eax
$LN1@FatCreateF:

; 201  : }

	lea	rsp, QWORD PTR [rbp+192]
	pop	rbp
	ret	0
?FatCreateFile@@YAPEAU__VFS_NODE__@@PEAU1@PEAD@Z ENDP	; FatCreateFile
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Fs\Fat\FatFile.cpp
;	COMDAT ?FatFileGetParent@@YAPEAU__VFS_NODE__@@PEAU1@PEBD@Z
_TEXT	SEGMENT
_fs$ = 0
parent$ = 8
retfile$ = 16
path$ = 24
p$ = 32
is_root$ = 40
pathname$1 = 48
i$2 = 64
fsys$ = 160
filename$ = 168
?FatFileGetParent@@YAPEAU__VFS_NODE__@@PEAU1@PEBD@Z PROC ; FatFileGetParent, COMDAT

; 47   : AuVFSNode* FatFileGetParent(AuVFSNode* fsys, const char* filename) {

$LN17:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 176				; 000000b0H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__5368F709_FatFile@cpp
	call	__CheckForDebuggerJustMyCode

; 48   : 	if (!fsys)

	cmp	QWORD PTR fsys$[rbp], 0
	jne	SHORT $LN7@FatFileGet

; 49   : 		return NULL;

	xor	eax, eax
	jmp	$LN1@FatFileGet
$LN7@FatFileGet:

; 50   : 	FatFS* _fs = (FatFS*)fsys->device;

	mov	rax, QWORD PTR fsys$[rbp]
	mov	rax, QWORD PTR [rax+64]
	mov	QWORD PTR _fs$[rbp], rax

; 51   : 	AuVFSNode* parent = NULL;

	mov	QWORD PTR parent$[rbp], 0

; 52   : 	AuVFSNode* retfile = NULL;

	mov	QWORD PTR retfile$[rbp], 0

; 53   : 	char* path = (char*)filename;

	mov	rax, QWORD PTR filename$[rbp]
	mov	QWORD PTR path$[rbp], rax

; 54   : 
; 55   : 	char* p = strchr(path, '/');

	mov	edx, 47					; 0000002fH
	mov	rcx, QWORD PTR path$[rbp]
	call	strchr
	mov	QWORD PTR p$[rbp], rax

; 56   : 	p++;

	mov	rax, QWORD PTR p$[rbp]
	inc	rax
	mov	QWORD PTR p$[rbp], rax

; 57   : 	bool is_root = true;

	mov	BYTE PTR is_root$[rbp], 1
$LN2@FatFileGet:

; 58   : 	
; 59   : 	while (p) {

	cmp	QWORD PTR p$[rbp], 0
	je	$LN3@FatFileGet

; 60   : 		char pathname[16];
; 61   : 		int i = 0;

	mov	DWORD PTR i$2[rbp], 0

; 62   : 		for (i = 0; i < 16; i++) {

	mov	DWORD PTR i$2[rbp], 0
	jmp	SHORT $LN6@FatFileGet
$LN4@FatFileGet:
	mov	eax, DWORD PTR i$2[rbp]
	inc	eax
	mov	DWORD PTR i$2[rbp], eax
$LN6@FatFileGet:
	cmp	DWORD PTR i$2[rbp], 16
	jge	SHORT $LN5@FatFileGet

; 63   : 			if (p[i] == '/' || p[i] == '\0')

	movsxd	rax, DWORD PTR i$2[rbp]
	mov	rcx, QWORD PTR p$[rbp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 47					; 0000002fH
	je	SHORT $LN9@FatFileGet
	movsxd	rax, DWORD PTR i$2[rbp]
	mov	rcx, QWORD PTR p$[rbp]
	movsx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	jne	SHORT $LN8@FatFileGet
$LN9@FatFileGet:

; 64   : 				break;

	jmp	SHORT $LN5@FatFileGet
$LN8@FatFileGet:

; 65   : 			pathname[i] = p[i];

	movsxd	rax, DWORD PTR i$2[rbp]
	movsxd	rcx, DWORD PTR i$2[rbp]
	mov	rdx, QWORD PTR p$[rbp]
	movzx	eax, BYTE PTR [rdx+rax]
	mov	BYTE PTR pathname$1[rbp+rcx], al

; 66   : 		}

	jmp	SHORT $LN4@FatFileGet
$LN5@FatFileGet:

; 67   : 		pathname[i] = 0;

	movsxd	rax, DWORD PTR i$2[rbp]
	mov	BYTE PTR pathname$1[rbp+rax], 0

; 68   : 		if (is_root) {

	movzx	eax, BYTE PTR is_root$[rbp]
	test	eax, eax
	je	SHORT $LN10@FatFileGet

; 69   : 			parent = FatLocateDir(fsys, pathname);

	lea	rdx, QWORD PTR pathname$1[rbp]
	mov	rcx, QWORD PTR fsys$[rbp]
	call	?FatLocateDir@@YAPEAU__VFS_NODE__@@PEAU1@PEBD@Z ; FatLocateDir
	mov	QWORD PTR parent$[rbp], rax

; 70   : 			if (parent) {

	cmp	QWORD PTR parent$[rbp], 0
	je	SHORT $LN12@FatFileGet

; 71   : 				retfile = parent;

	mov	rax, QWORD PTR parent$[rbp]
	mov	QWORD PTR retfile$[rbp], rax
$LN12@FatFileGet:

; 72   : 			}
; 73   : 			is_root = false;

	mov	BYTE PTR is_root$[rbp], 0

; 74   : 		}

	jmp	SHORT $LN11@FatFileGet
$LN10@FatFileGet:

; 75   : 		else {
; 76   : 			parent = FatLocateSubDir(fsys, parent, pathname);

	lea	r8, QWORD PTR pathname$1[rbp]
	mov	rdx, QWORD PTR parent$[rbp]
	mov	rcx, QWORD PTR fsys$[rbp]
	call	?FatLocateSubDir@@YAPEAU__VFS_NODE__@@PEAU1@0PEBD@Z ; FatLocateSubDir
	mov	QWORD PTR parent$[rbp], rax

; 77   : 			if (parent) {

	cmp	QWORD PTR parent$[rbp], 0
	je	SHORT $LN13@FatFileGet

; 78   : 				retfile = parent;

	mov	rax, QWORD PTR parent$[rbp]
	mov	QWORD PTR retfile$[rbp], rax
$LN13@FatFileGet:
$LN11@FatFileGet:

; 79   : 			}
; 80   : 		}
; 81   : 		p = strchr(p + 1, '/');

	mov	rax, QWORD PTR p$[rbp]
	inc	rax
	mov	edx, 47					; 0000002fH
	mov	rcx, rax
	call	strchr
	mov	QWORD PTR p$[rbp], rax

; 82   : 		if (p)

	cmp	QWORD PTR p$[rbp], 0
	je	SHORT $LN14@FatFileGet

; 83   : 			p++;

	mov	rax, QWORD PTR p$[rbp]
	inc	rax
	mov	QWORD PTR p$[rbp], rax
$LN14@FatFileGet:

; 84   : 	}

	jmp	$LN2@FatFileGet
$LN3@FatFileGet:

; 85   : 
; 86   : 	if (!retfile) {

	cmp	QWORD PTR retfile$[rbp], 0
	jne	SHORT $LN15@FatFileGet

; 87   : 		retfile = (AuVFSNode*)kmalloc(sizeof(AuVFSNode));

	mov	ecx, 178				; 000000b2H
	call	kmalloc
	mov	QWORD PTR retfile$[rbp], rax

; 88   : 		memset(retfile, 0, sizeof(AuVFSNode));

	mov	r8d, 178				; 000000b2H
	xor	edx, edx
	mov	rcx, QWORD PTR retfile$[rbp]
	call	memset

; 89   : 		retfile->current = _fs->__RootDirFirstCluster;

	mov	rax, QWORD PTR _fs$[rbp]
	mov	eax, DWORD PTR [rax+40]
	mov	rcx, QWORD PTR retfile$[rbp]
	mov	QWORD PTR [rcx+53], rax

; 90   : 		retfile->first_block = _fs->__RootDirFirstCluster;

	mov	rax, QWORD PTR _fs$[rbp]
	mov	eax, DWORD PTR [rax+40]
	mov	rcx, QWORD PTR retfile$[rbp]
	mov	QWORD PTR [rcx+45], rax

; 91   : 		retfile->flags |= FS_FLAG_DIRECTORY;

	mov	rax, QWORD PTR retfile$[rbp]
	movzx	eax, WORD PTR [rax+61]
	or	eax, 2
	mov	rcx, QWORD PTR retfile$[rbp]
	mov	WORD PTR [rcx+61], ax
$LN15@FatFileGet:

; 92   : 	}
; 93   : 
; 94   : 	return retfile;

	mov	rax, QWORD PTR retfile$[rbp]
$LN1@FatFileGet:

; 95   : }

	lea	rsp, QWORD PTR [rbp+144]
	pop	rbp
	ret	0
?FatFileGetParent@@YAPEAU__VFS_NODE__@@PEAU1@PEBD@Z ENDP ; FatFileGetParent
_TEXT	ENDS
END
