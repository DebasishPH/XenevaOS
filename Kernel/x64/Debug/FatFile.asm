; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.21005.1 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG3514	DB	'[FAT]: New Cluster allocated ', 0dH, 0aH, 00H
$SG3593	DB	'EOC mark found in cluster -> %x ', 0aH, 00H
CONST	ENDS
PUBLIC	?FatFileGetParent@@YAPEAU__VFS_NODE__@@PEAU1@PEBD@Z ; FatFileGetParent
PUBLIC	?FatCreateFile@@YAPEAU__VFS_NODE__@@PEAU1@PEAD@Z ; FatCreateFile
PUBLIC	?FatFileUpdateSize@@YAXPEAU__VFS_NODE__@@0_K@Z	; FatFileUpdateSize
PUBLIC	?FatFileUpdateFilename@@YAHPEAU__VFS_NODE__@@0PEAD@Z ; FatFileUpdateFilename
PUBLIC	?FatFileWriteContent@@YAXPEAU__VFS_NODE__@@0PEA_K@Z ; FatFileWriteContent
PUBLIC	?FatFileWriteDone@@YAXPEAU__VFS_NODE__@@@Z	; FatFileWriteDone
PUBLIC	?FatWrite@@YA_KPEAU__VFS_NODE__@@0PEA_KI@Z	; FatWrite
PUBLIC	?FatFileClearDirEntry@@YAHPEAU__VFS_NODE__@@0@Z	; FatFileClearDirEntry
PUBLIC	?FatFileRemove@@YAHPEAU__VFS_NODE__@@0@Z	; FatFileRemove
EXTRN	AuVDiskRead:PROC
EXTRN	AuVDiskWrite:PROC
EXTRN	AuAcquireMutex:PROC
EXTRN	AuReleaseMutex:PROC
EXTRN	?FatClusterToSector32@@YA_KPEAU_FatFS_@@_K@Z:PROC ; FatClusterToSector32
EXTRN	?FatToDOSFilename@@YAXPEBDPEADI@Z:PROC		; FatToDOSFilename
EXTRN	?FatFindFreeCluster@@YAIPEAU__VFS_NODE__@@@Z:PROC ; FatFindFreeCluster
EXTRN	?FatAllocCluster@@YAXPEAU__VFS_NODE__@@HI@Z:PROC ; FatAllocCluster
EXTRN	?FatClearCluster@@YAXPEAU__VFS_NODE__@@I@Z:PROC	; FatClearCluster
EXTRN	?FatReadFAT@@YAIPEAU__VFS_NODE__@@I@Z:PROC	; FatReadFAT
EXTRN	?FatFormatDate@@YAGXZ:PROC			; FatFormatDate
EXTRN	?FatFormatTime@@YAGXZ:PROC			; FatFormatTime
EXTRN	?FatLocateDir@@YAPEAU__VFS_NODE__@@PEAU1@PEBD@Z:PROC ; FatLocateDir
EXTRN	?FatLocateSubDir@@YAPEAU__VFS_NODE__@@PEAU1@0PEBD@Z:PROC ; FatLocateSubDir
EXTRN	kmalloc:PROC
EXTRN	kfree:PROC
EXTRN	AuPmmngrAlloc:PROC
EXTRN	AuPmmngrFree:PROC
EXTRN	P2V:PROC
EXTRN	V2P:PROC
EXTRN	strcmp:PROC
EXTRN	strcpy:PROC
EXTRN	strchr:PROC
EXTRN	memset:PROC
EXTRN	memcpy:PROC
EXTRN	SeTextOut:PROC
pdata	SEGMENT
$pdata$?FatFileGetParent@@YAPEAU__VFS_NODE__@@PEAU1@PEBD@Z DD imagerel $LN17
	DD	imagerel $LN17+484
	DD	imagerel $unwind$?FatFileGetParent@@YAPEAU__VFS_NODE__@@PEAU1@PEBD@Z
$pdata$?FatCreateFile@@YAPEAU__VFS_NODE__@@PEAU1@PEAD@Z DD imagerel $LN26
	DD	imagerel $LN26+1328
	DD	imagerel $unwind$?FatCreateFile@@YAPEAU__VFS_NODE__@@PEAU1@PEAD@Z
$pdata$?FatFileUpdateSize@@YAXPEAU__VFS_NODE__@@0_K@Z DD imagerel $LN15
	DD	imagerel $LN15+592
	DD	imagerel $unwind$?FatFileUpdateSize@@YAXPEAU__VFS_NODE__@@0_K@Z
$pdata$?FatFileUpdateFilename@@YAHPEAU__VFS_NODE__@@0PEAD@Z DD imagerel $LN15
	DD	imagerel $LN15+680
	DD	imagerel $unwind$?FatFileUpdateFilename@@YAHPEAU__VFS_NODE__@@0PEAD@Z
$pdata$?FatFileWriteContent@@YAXPEAU__VFS_NODE__@@0PEA_K@Z DD imagerel $LN9
	DD	imagerel $LN9+494
	DD	imagerel $unwind$?FatFileWriteContent@@YAXPEAU__VFS_NODE__@@0PEA_K@Z
$pdata$?FatWrite@@YA_KPEAU__VFS_NODE__@@0PEA_KI@Z DD imagerel $LN9
	DD	imagerel $LN9+318
	DD	imagerel $unwind$?FatWrite@@YA_KPEAU__VFS_NODE__@@0PEA_KI@Z
$pdata$?FatFileClearDirEntry@@YAHPEAU__VFS_NODE__@@0@Z DD imagerel $LN16
	DD	imagerel $LN16+648
	DD	imagerel $unwind$?FatFileClearDirEntry@@YAHPEAU__VFS_NODE__@@0@Z
$pdata$?FatFileRemove@@YAHPEAU__VFS_NODE__@@0@Z DD imagerel $LN10
	DD	imagerel $LN10+212
	DD	imagerel $unwind$?FatFileRemove@@YAHPEAU__VFS_NODE__@@0@Z
pdata	ENDS
xdata	SEGMENT
$unwind$?FatFileGetParent@@YAPEAU__VFS_NODE__@@PEAU1@PEBD@Z DD 010e01H
	DD	0c20eH
$unwind$?FatCreateFile@@YAPEAU__VFS_NODE__@@PEAU1@PEAD@Z DD 021101H
	DD	0170111H
$unwind$?FatFileUpdateSize@@YAXPEAU__VFS_NODE__@@0_K@Z DD 021601H
	DD	0110116H
$unwind$?FatFileUpdateFilename@@YAHPEAU__VFS_NODE__@@0PEAD@Z DD 021601H
	DD	0130116H
$unwind$?FatFileWriteContent@@YAXPEAU__VFS_NODE__@@0PEA_K@Z DD 011301H
	DD	0a213H
$unwind$?FatWrite@@YA_KPEAU__VFS_NODE__@@0PEA_KI@Z DD 011801H
	DD	08218H
$unwind$?FatFileClearDirEntry@@YAHPEAU__VFS_NODE__@@0@Z DD 021101H
	DD	0110111H
$unwind$?FatFileRemove@@YAHPEAU__VFS_NODE__@@0@Z DD 010e01H
	DD	0620eH
xdata	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\fs\fat\fatfile.cpp
_TEXT	SEGMENT
cluster$ = 32
next_cluster$1 = 36
parent_clust$ = 40
fsys$ = 64
file$ = 72
?FatFileRemove@@YAHPEAU__VFS_NODE__@@0@Z PROC		; FatFileRemove

; 468  : int FatFileRemove(AuVFSNode* fsys, AuVFSNode* file) {

$LN10:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 469  : 	if (!fsys)

	cmp	QWORD PTR fsys$[rsp], 0
	jne	SHORT $LN7@FatFileRem

; 470  : 		return -1;

	mov	eax, -1
	jmp	$LN8@FatFileRem
$LN7@FatFileRem:

; 471  : 	if (!file)

	cmp	QWORD PTR file$[rsp], 0
	jne	SHORT $LN6@FatFileRem

; 472  : 		return -1;

	mov	eax, -1
	jmp	$LN8@FatFileRem
$LN6@FatFileRem:

; 473  : 
; 474  : 	uint32_t parent_clust = file->parent_block;

	mov	rax, QWORD PTR file$[rsp]
	mov	eax, DWORD PTR [rax+41]
	mov	DWORD PTR parent_clust$[rsp], eax

; 475  : 	if (!parent_clust)

	cmp	DWORD PTR parent_clust$[rsp], 0
	jne	SHORT $LN5@FatFileRem

; 476  : 		return -1;

	mov	eax, -1
	jmp	$LN8@FatFileRem
$LN5@FatFileRem:

; 477  : 
; 478  : 	uint32_t cluster = file->current;

	mov	rax, QWORD PTR file$[rsp]
	mov	eax, DWORD PTR [rax+53]
	mov	DWORD PTR cluster$[rsp], eax
$LN4@FatFileRem:

; 479  : 	while (1) {

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN3@FatFileRem

; 480  : 		uint32_t next_cluster = FatReadFAT(fsys, cluster);

	mov	edx, DWORD PTR cluster$[rsp]
	mov	rcx, QWORD PTR fsys$[rsp]
	call	?FatReadFAT@@YAIPEAU__VFS_NODE__@@I@Z	; FatReadFAT
	mov	DWORD PTR next_cluster$1[rsp], eax

; 481  : 		if (next_cluster == (FAT_EOC_MARK & 0x0fffffff)) {

	cmp	DWORD PTR next_cluster$1[rsp], 268435448 ; 0ffffff8H
	jne	SHORT $LN2@FatFileRem

; 482  : 			SeTextOut("EOC mark found in cluster -> %x \n", cluster);

	mov	edx, DWORD PTR cluster$[rsp]
	lea	rcx, OFFSET FLAT:$SG3593
	call	SeTextOut

; 483  : 			FatAllocCluster(fsys, cluster, 0x00);

	xor	r8d, r8d
	mov	edx, DWORD PTR cluster$[rsp]
	mov	rcx, QWORD PTR fsys$[rsp]
	call	?FatAllocCluster@@YAXPEAU__VFS_NODE__@@HI@Z ; FatAllocCluster

; 484  : 			break;

	jmp	SHORT $LN3@FatFileRem

; 485  : 		}
; 486  : 		else {

	jmp	SHORT $LN1@FatFileRem
$LN2@FatFileRem:

; 487  : 			FatAllocCluster(fsys, cluster, 0x00);

	xor	r8d, r8d
	mov	edx, DWORD PTR cluster$[rsp]
	mov	rcx, QWORD PTR fsys$[rsp]
	call	?FatAllocCluster@@YAXPEAU__VFS_NODE__@@HI@Z ; FatAllocCluster
$LN1@FatFileRem:

; 488  : 		}
; 489  : 		cluster = next_cluster;

	mov	eax, DWORD PTR next_cluster$1[rsp]
	mov	DWORD PTR cluster$[rsp], eax

; 490  : 	}

	jmp	SHORT $LN4@FatFileRem
$LN3@FatFileRem:

; 491  : 
; 492  : 	/* clear the dir entry */
; 493  : 	FatFileClearDirEntry(fsys, file);

	mov	rdx, QWORD PTR file$[rsp]
	mov	rcx, QWORD PTR fsys$[rsp]
	call	?FatFileClearDirEntry@@YAHPEAU__VFS_NODE__@@0@Z ; FatFileClearDirEntry

; 494  : 	return 0;

	xor	eax, eax
$LN8@FatFileRem:

; 495  : }

	add	rsp, 56					; 00000038H
	ret	0
?FatFileRemove@@YAHPEAU__VFS_NODE__@@0@Z ENDP		; FatFileRemove
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\fs\fat\fatfile.cpp
_TEXT	SEGMENT
dir_clust$ = 32
j$1 = 36
i$2 = 40
buff$ = 48
_fs$ = 56
dirent$3 = 64
fname$ = 72
name$4 = 88
tv94 = 104
tv157 = 112
fsys$ = 144
file$ = 152
?FatFileClearDirEntry@@YAHPEAU__VFS_NODE__@@0@Z PROC	; FatFileClearDirEntry

; 413  : int FatFileClearDirEntry(AuVFSNode* fsys, AuVFSNode* file) {

$LN16:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 136				; 00000088H

; 414  : 	if (!fsys)

	cmp	QWORD PTR fsys$[rsp], 0
	jne	SHORT $LN13@FatFileCle

; 415  : 		return -1;

	mov	eax, -1
	jmp	$LN14@FatFileCle
$LN13@FatFileCle:

; 416  : 	if (!file)

	cmp	QWORD PTR file$[rsp], 0
	jne	SHORT $LN12@FatFileCle

; 417  : 		return -1;

	mov	eax, -1
	jmp	$LN14@FatFileCle
$LN12@FatFileCle:

; 418  : 	
; 419  : 	FatFS* _fs = (FatFS*)fsys->device;

	mov	rax, QWORD PTR fsys$[rsp]
	mov	rax, QWORD PTR [rax+63]
	mov	QWORD PTR _fs$[rsp], rax

; 420  : 
; 421  : 	uint32_t dir_clust = file->parent_block;

	mov	rax, QWORD PTR file$[rsp]
	mov	eax, DWORD PTR [rax+41]
	mov	DWORD PTR dir_clust$[rsp], eax

; 422  : 	if (!dir_clust)

	cmp	DWORD PTR dir_clust$[rsp], 0
	jne	SHORT $LN11@FatFileCle

; 423  : 		dir_clust = _fs->__RootDirFirstCluster;

	mov	rax, QWORD PTR _fs$[rsp]
	mov	eax, DWORD PTR [rax+34]
	mov	DWORD PTR dir_clust$[rsp], eax
$LN11@FatFileCle:

; 424  : 
; 425  : 	char fname[11];
; 426  : 	memset(fname, 0, 11);

	mov	r8d, 11
	xor	edx, edx
	lea	rcx, QWORD PTR fname$[rsp]
	call	memset

; 427  : 	FatToDOSFilename(file->filename, fname, 11);

	mov	rax, QWORD PTR file$[rsp]
	mov	r8d, 11
	lea	rdx, QWORD PTR fname$[rsp]
	mov	rcx, rax
	call	?FatToDOSFilename@@YAXPEBDPEADI@Z	; FatToDOSFilename

; 428  : 	fname[11] = 0;

	mov	eax, 1
	imul	rax, rax, 11
	mov	BYTE PTR fname$[rsp+rax], 0

; 429  : 
; 430  : 	uint64_t* buff = (uint64_t*)P2V((size_t)AuPmmngrAlloc());

	call	AuPmmngrAlloc
	mov	rcx, rax
	call	P2V
	mov	QWORD PTR buff$[rsp], rax

; 431  : 	memset(buff, 0, PAGE_SIZE);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR buff$[rsp]
	call	memset
$LN10@FatFileCle:

; 432  : 
; 433  : 	while (1) {

	xor	eax, eax
	cmp	eax, 1
	je	$LN9@FatFileCle

; 434  : 		for (int j = 0; j < _fs->__SectorPerCluster; j++) {

	mov	DWORD PTR j$1[rsp], 0
	jmp	SHORT $LN8@FatFileCle
$LN7@FatFileCle:
	mov	eax, DWORD PTR j$1[rsp]
	inc	eax
	mov	DWORD PTR j$1[rsp], eax
$LN8@FatFileCle:
	mov	rax, QWORD PTR _fs$[rsp]
	movzx	eax, BYTE PTR [rax+33]
	cmp	DWORD PTR j$1[rsp], eax
	jge	$LN6@FatFileCle

; 435  : 			memset(buff, 0, PAGE_SIZE);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR buff$[rsp]
	call	memset

; 436  : 			AuVDiskRead(_fs->vdisk, FatClusterToSector32(_fs, dir_clust) + j, 1, (uint64_t*)V2P((size_t)buff));

	mov	rcx, QWORD PTR buff$[rsp]
	call	V2P
	mov	QWORD PTR tv94[rsp], rax
	mov	ecx, DWORD PTR dir_clust$[rsp]
	mov	edx, ecx
	mov	rcx, QWORD PTR _fs$[rsp]
	call	?FatClusterToSector32@@YA_KPEAU_FatFS_@@_K@Z ; FatClusterToSector32
	movsxd	rcx, DWORD PTR j$1[rsp]
	add	rax, rcx
	mov	rcx, QWORD PTR tv94[rsp]
	mov	r9, rcx
	mov	r8d, 1
	mov	rdx, rax
	mov	rax, QWORD PTR _fs$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	AuVDiskRead

; 437  : 
; 438  : 			FatDir *dirent = (FatDir*)buff;

	mov	rax, QWORD PTR buff$[rsp]
	mov	QWORD PTR dirent$3[rsp], rax

; 439  : 			for (int i = 0; i < 16; i++) {

	mov	DWORD PTR i$2[rsp], 0
	jmp	SHORT $LN5@FatFileCle
$LN4@FatFileCle:
	mov	eax, DWORD PTR i$2[rsp]
	inc	eax
	mov	DWORD PTR i$2[rsp], eax
$LN5@FatFileCle:
	cmp	DWORD PTR i$2[rsp], 16
	jge	$LN3@FatFileCle

; 440  : 				char name[11];
; 441  : 				memcpy(name, dirent->filename, 11);

	mov	rax, QWORD PTR dirent$3[rsp]
	mov	r8d, 11
	mov	rdx, rax
	lea	rcx, QWORD PTR name$4[rsp]
	call	memcpy

; 442  : 				name[11] = 0;

	mov	eax, 1
	imul	rax, rax, 11
	mov	BYTE PTR name$4[rsp+rax], 0

; 443  : 
; 444  : 				if (strcmp(name, fname) == 0) {

	lea	rdx, QWORD PTR fname$[rsp]
	lea	rcx, QWORD PTR name$4[rsp]
	call	strcmp
	test	eax, eax
	jne	$LN2@FatFileCle

; 445  : 					memset(dirent, 0, sizeof(FatDir));

	mov	r8d, 32					; 00000020H
	xor	edx, edx
	mov	rcx, QWORD PTR dirent$3[rsp]
	call	memset

; 446  : 					dirent->filename[0] = 0xE5;

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR dirent$3[rsp]
	mov	BYTE PTR [rcx+rax], 229			; 000000e5H

; 447  : 					AuVDiskWrite(_fs->vdisk, FatClusterToSector32(_fs, dir_clust) + j, 1, (uint64_t*)V2P((size_t)buff));

	mov	rcx, QWORD PTR buff$[rsp]
	call	V2P
	mov	QWORD PTR tv157[rsp], rax
	mov	ecx, DWORD PTR dir_clust$[rsp]
	mov	edx, ecx
	mov	rcx, QWORD PTR _fs$[rsp]
	call	?FatClusterToSector32@@YA_KPEAU_FatFS_@@_K@Z ; FatClusterToSector32
	movsxd	rcx, DWORD PTR j$1[rsp]
	add	rax, rcx
	mov	rcx, QWORD PTR tv157[rsp]
	mov	r9, rcx
	mov	r8d, 1
	mov	rdx, rax
	mov	rax, QWORD PTR _fs$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	AuVDiskWrite

; 448  : 					AuPmmngrFree((void*)V2P((size_t)buff));

	mov	rcx, QWORD PTR buff$[rsp]
	call	V2P
	mov	rcx, rax
	call	AuPmmngrFree

; 449  : 					return 0;

	xor	eax, eax
	jmp	SHORT $LN14@FatFileCle
$LN2@FatFileCle:

; 450  : 				}
; 451  : 				dirent++;

	mov	rax, QWORD PTR dirent$3[rsp]
	add	rax, 32					; 00000020H
	mov	QWORD PTR dirent$3[rsp], rax

; 452  : 			}

	jmp	$LN4@FatFileCle
$LN3@FatFileCle:

; 453  : 		}

	jmp	$LN7@FatFileCle
$LN6@FatFileCle:

; 454  : 
; 455  : 		dir_clust = FatReadFAT(fsys, dir_clust);

	mov	edx, DWORD PTR dir_clust$[rsp]
	mov	rcx, QWORD PTR fsys$[rsp]
	call	?FatReadFAT@@YAIPEAU__VFS_NODE__@@I@Z	; FatReadFAT
	mov	DWORD PTR dir_clust$[rsp], eax

; 456  : 		if (dir_clust == (FAT_EOC_MARK & 0x0FFFFFFF)) 

	cmp	DWORD PTR dir_clust$[rsp], 268435448	; 0ffffff8H
	jne	SHORT $LN1@FatFileCle

; 457  : 			break;

	jmp	SHORT $LN9@FatFileCle
$LN1@FatFileCle:

; 458  : 
; 459  : 	}

	jmp	$LN10@FatFileCle
$LN9@FatFileCle:

; 460  : 	return -1;

	mov	eax, -1
$LN14@FatFileCle:

; 461  : }

	add	rsp, 136				; 00000088H
	ret	0
?FatFileClearDirEntry@@YAHPEAU__VFS_NODE__@@0@Z ENDP	; FatFileClearDirEntry
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\fs\fat\fatfile.cpp
_TEXT	SEGMENT
i$1 = 32
tv81 = 36
tv78 = 40
tv72 = 44
_fs$ = 48
num_cluster$ = 56
fsys$ = 80
file$ = 88
buffer$ = 96
length$ = 104
?FatWrite@@YA_KPEAU__VFS_NODE__@@0PEA_KI@Z PROC		; FatWrite

; 387  : size_t FatWrite(AuVFSNode* fsys, AuVFSNode* file, uint64_t* buffer, uint32_t length) {

$LN9:
	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 388  : 	if (!fsys)

	cmp	QWORD PTR fsys$[rsp], 0
	jne	SHORT $LN4@FatWrite

; 389  : 		return 0;

	xor	eax, eax
	jmp	$LN5@FatWrite
$LN4@FatWrite:

; 390  : 	FatFS* _fs = (FatFS*)fsys->device;

	mov	rax, QWORD PTR fsys$[rsp]
	mov	rax, QWORD PTR [rax+63]
	mov	QWORD PTR _fs$[rsp], rax

; 391  : 
; 392  : 	AuAcquireMutex(_fs->fat_mutex);

	mov	rax, QWORD PTR _fs$[rsp]
	mov	rcx, QWORD PTR [rax+68]
	call	AuAcquireMutex

; 393  : 
; 394  : 	size_t num_cluster = length / (_fs->__BytesPerSector * _fs->__SectorPerCluster) +
; 395  : 		((length % (_fs->__BytesPerSector * _fs->__SectorPerCluster) ? 1 : 0));

	mov	rax, QWORD PTR _fs$[rsp]
	movzx	eax, WORD PTR [rax+58]
	mov	rcx, QWORD PTR _fs$[rsp]
	movzx	ecx, BYTE PTR [rcx+33]
	imul	eax, ecx
	mov	DWORD PTR tv78[rsp], eax
	xor	edx, edx
	mov	eax, DWORD PTR length$[rsp]
	mov	ecx, DWORD PTR tv78[rsp]
	div	ecx
	mov	eax, edx
	test	eax, eax
	je	SHORT $LN7@FatWrite
	mov	DWORD PTR tv81[rsp], 1
	jmp	SHORT $LN8@FatWrite
$LN7@FatWrite:
	mov	DWORD PTR tv81[rsp], 0
$LN8@FatWrite:
	mov	rax, QWORD PTR _fs$[rsp]
	movzx	eax, WORD PTR [rax+58]
	mov	rcx, QWORD PTR _fs$[rsp]
	movzx	ecx, BYTE PTR [rcx+33]
	imul	eax, ecx
	mov	DWORD PTR tv72[rsp], eax
	xor	edx, edx
	mov	eax, DWORD PTR length$[rsp]
	mov	ecx, DWORD PTR tv72[rsp]
	div	ecx
	add	eax, DWORD PTR tv81[rsp]
	mov	eax, eax
	mov	QWORD PTR num_cluster$[rsp], rax

; 396  : 
; 397  : 	for (int i = 0; i < num_cluster; i++) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN3@FatWrite
$LN2@FatWrite:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN3@FatWrite:
	movsxd	rax, DWORD PTR i$1[rsp]
	cmp	rax, QWORD PTR num_cluster$[rsp]
	jae	SHORT $LN1@FatWrite

; 398  : 		FatFileWriteContent(fsys, file, buffer);

	mov	r8, QWORD PTR buffer$[rsp]
	mov	rdx, QWORD PTR file$[rsp]
	mov	rcx, QWORD PTR fsys$[rsp]
	call	?FatFileWriteContent@@YAXPEAU__VFS_NODE__@@0PEA_K@Z ; FatFileWriteContent

; 399  : 		buffer += (_fs->__BytesPerSector * _fs->__SectorPerCluster);

	mov	rax, QWORD PTR _fs$[rsp]
	movzx	eax, WORD PTR [rax+58]
	mov	rcx, QWORD PTR _fs$[rsp]
	movzx	ecx, BYTE PTR [rcx+33]
	imul	eax, ecx
	cdqe
	mov	rcx, QWORD PTR buffer$[rsp]
	lea	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR buffer$[rsp], rax

; 400  : 	}

	jmp	SHORT $LN2@FatWrite
$LN1@FatWrite:

; 401  : 
; 402  : 	FatFileUpdateSize(fsys, file, length);

	mov	eax, DWORD PTR length$[rsp]
	mov	r8d, eax
	mov	rdx, QWORD PTR file$[rsp]
	mov	rcx, QWORD PTR fsys$[rsp]
	call	?FatFileUpdateSize@@YAXPEAU__VFS_NODE__@@0_K@Z ; FatFileUpdateSize

; 403  : 	FatFileWriteDone(file);

	mov	rcx, QWORD PTR file$[rsp]
	call	?FatFileWriteDone@@YAXPEAU__VFS_NODE__@@@Z ; FatFileWriteDone

; 404  : 
; 405  : 	AuReleaseMutex(_fs->fat_mutex);

	mov	rax, QWORD PTR _fs$[rsp]
	mov	rcx, QWORD PTR [rax+68]
	call	AuReleaseMutex
$LN5@FatWrite:

; 406  : }

	add	rsp, 72					; 00000048H
	ret	0
?FatWrite@@YA_KPEAU__VFS_NODE__@@0PEA_KI@Z ENDP		; FatWrite
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\fs\fat\fatfile.cpp
_TEXT	SEGMENT
file$ = 8
?FatFileWriteDone@@YAXPEAU__VFS_NODE__@@@Z PROC		; FatFileWriteDone

; 374  : void FatFileWriteDone(AuVFSNode* file) {

	mov	QWORD PTR [rsp+8], rcx

; 375  : 	file->current = file->first_block;

	mov	rax, QWORD PTR file$[rsp]
	mov	rcx, QWORD PTR file$[rsp]
	mov	rcx, QWORD PTR [rcx+45]
	mov	QWORD PTR [rax+53], rcx

; 376  : 	file->eof = 0;

	mov	rax, QWORD PTR file$[rsp]
	mov	BYTE PTR [rax+36], 0

; 377  : 	file->pos = 0;

	mov	rax, QWORD PTR file$[rsp]
	mov	DWORD PTR [rax+37], 0

; 378  : }

	ret	0
?FatFileWriteDone@@YAXPEAU__VFS_NODE__@@@Z ENDP		; FatFileWriteDone
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\fs\fat\fatfile.cpp
_TEXT	SEGMENT
cluster$ = 32
new_cluster$1 = 36
return_cluster$ = 40
tv130 = 44
_fs$ = 48
buff$ = 56
tv94 = 64
sz$ = 72
fsys$ = 96
file$ = 104
buffer$ = 112
?FatFileWriteContent@@YAXPEAU__VFS_NODE__@@0PEA_K@Z PROC ; FatFileWriteContent

; 326  : void FatFileWriteContent(AuVFSNode* fsys,AuVFSNode* file, uint64_t* buffer) {

$LN9:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 327  : 	if (!fsys)

	cmp	QWORD PTR fsys$[rsp], 0
	jne	SHORT $LN6@FatFileWri

; 328  : 		return;

	jmp	$LN7@FatFileWri
$LN6@FatFileWri:

; 329  : 	
; 330  : 
; 331  : 	FatFS* _fs = (FatFS*)fsys->device;

	mov	rax, QWORD PTR fsys$[rsp]
	mov	rax, QWORD PTR [rax+63]
	mov	QWORD PTR _fs$[rsp], rax

; 332  : 
; 333  : 	uint64_t* buff = (uint64_t*)P2V((size_t)AuPmmngrAlloc());

	call	AuPmmngrAlloc
	mov	rcx, rax
	call	P2V
	mov	QWORD PTR buff$[rsp], rax

; 334  : 	memset(buff, 0, PAGE_SIZE);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR buff$[rsp]
	call	memset

; 335  : 
; 336  : 	uint32_t cluster = file->current;

	mov	rax, QWORD PTR file$[rsp]
	mov	eax, DWORD PTR [rax+53]
	mov	DWORD PTR cluster$[rsp], eax

; 337  : 	if (file->eof){

	mov	rax, QWORD PTR file$[rsp]
	movzx	eax, BYTE PTR [rax+36]
	test	eax, eax
	je	SHORT $LN5@FatFileWri

; 338  : 		/* write the new cluster value to
; 339  : 		* old cluster */
; 340  : 		uint32_t new_cluster = FatFindFreeCluster(fsys);

	mov	rcx, QWORD PTR fsys$[rsp]
	call	?FatFindFreeCluster@@YAIPEAU__VFS_NODE__@@@Z ; FatFindFreeCluster
	mov	DWORD PTR new_cluster$1[rsp], eax

; 341  : 		FatAllocCluster(fsys, cluster, new_cluster);

	mov	r8d, DWORD PTR new_cluster$1[rsp]
	mov	edx, DWORD PTR cluster$[rsp]
	mov	rcx, QWORD PTR fsys$[rsp]
	call	?FatAllocCluster@@YAXPEAU__VFS_NODE__@@HI@Z ; FatAllocCluster

; 342  : 		FatAllocCluster(fsys, new_cluster, FAT_EOC_MARK);

	mov	r8d, -8					; fffffff8H
	mov	edx, DWORD PTR new_cluster$1[rsp]
	mov	rcx, QWORD PTR fsys$[rsp]
	call	?FatAllocCluster@@YAXPEAU__VFS_NODE__@@HI@Z ; FatAllocCluster

; 343  : 		FatClearCluster(fsys, new_cluster);

	mov	edx, DWORD PTR new_cluster$1[rsp]
	mov	rcx, QWORD PTR fsys$[rsp]
	call	?FatClearCluster@@YAXPEAU__VFS_NODE__@@I@Z ; FatClearCluster

; 344  : 		cluster = new_cluster;

	mov	eax, DWORD PTR new_cluster$1[rsp]
	mov	DWORD PTR cluster$[rsp], eax

; 345  : 		SeTextOut("[FAT]: New Cluster allocated \r\n");

	lea	rcx, OFFSET FLAT:$SG3514
	call	SeTextOut

; 346  : 		file->eof = 0;

	mov	rax, QWORD PTR file$[rsp]
	mov	BYTE PTR [rax+36], 0
$LN5@FatFileWri:

; 347  : 	}
; 348  : 
; 349  : 	if ((cluster != (FAT_EOC_MARK & 0x0FFFFFFF)) || (cluster != (FAT_BAD_CLUSTER & 0x0fffffff))) {

	cmp	DWORD PTR cluster$[rsp], 268435448	; 0ffffff8H
	jne	SHORT $LN3@FatFileWri
	cmp	DWORD PTR cluster$[rsp], 268435447	; 0ffffff7H
	je	SHORT $LN4@FatFileWri
$LN3@FatFileWri:

; 350  : 		memcpy(buff, buffer, PAGE_SIZE);

	mov	r8d, 4096				; 00001000H
	mov	rdx, QWORD PTR buffer$[rsp]
	mov	rcx, QWORD PTR buff$[rsp]
	call	memcpy

; 351  : 		AuVDiskWrite(_fs->vdisk, FatClusterToSector32(_fs, cluster), _fs->__SectorPerCluster, (uint64_t*)V2P((uint64_t)buff));

	mov	rcx, QWORD PTR buff$[rsp]
	call	V2P
	mov	QWORD PTR tv94[rsp], rax
	mov	rcx, QWORD PTR _fs$[rsp]
	movzx	ecx, BYTE PTR [rcx+33]
	mov	DWORD PTR tv130[rsp], ecx
	mov	edx, DWORD PTR cluster$[rsp]
	mov	rcx, QWORD PTR _fs$[rsp]
	call	?FatClusterToSector32@@YA_KPEAU_FatFS_@@_K@Z ; FatClusterToSector32
	mov	rcx, QWORD PTR tv94[rsp]
	mov	r9, rcx
	mov	ecx, DWORD PTR tv130[rsp]
	mov	r8d, ecx
	mov	rdx, rax
	mov	rax, QWORD PTR _fs$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	AuVDiskWrite

; 352  : 		file->pos++;

	mov	rax, QWORD PTR file$[rsp]
	mov	eax, DWORD PTR [rax+37]
	inc	eax
	mov	rcx, QWORD PTR file$[rsp]
	mov	DWORD PTR [rcx+37], eax
$LN4@FatFileWri:

; 353  : 	}
; 354  : 	uint32_t return_cluster = FatReadFAT(fsys, cluster);

	mov	edx, DWORD PTR cluster$[rsp]
	mov	rcx, QWORD PTR fsys$[rsp]
	call	?FatReadFAT@@YAIPEAU__VFS_NODE__@@I@Z	; FatReadFAT
	mov	DWORD PTR return_cluster$[rsp], eax

; 355  : 	if (return_cluster == (FAT_EOC_MARK & 0x0FFFFFFF))

	cmp	DWORD PTR return_cluster$[rsp], 268435448 ; 0ffffff8H
	jne	SHORT $LN2@FatFileWri

; 356  : 		file->eof = 1;

	mov	rax, QWORD PTR file$[rsp]
	mov	BYTE PTR [rax+36], 1

; 357  : 	else

	jmp	SHORT $LN1@FatFileWri
$LN2@FatFileWri:

; 358  : 		cluster = return_cluster;

	mov	eax, DWORD PTR return_cluster$[rsp]
	mov	DWORD PTR cluster$[rsp], eax
$LN1@FatFileWri:

; 359  : 
; 360  : 	file->current = cluster;

	mov	eax, DWORD PTR cluster$[rsp]
	mov	rcx, QWORD PTR file$[rsp]
	mov	QWORD PTR [rcx+53], rax

; 361  : 	file->size = file->pos * _fs->__SectorPerCluster * _fs->__BytesPerSector;

	mov	rax, QWORD PTR _fs$[rsp]
	movzx	eax, BYTE PTR [rax+33]
	mov	rcx, QWORD PTR file$[rsp]
	mov	ecx, DWORD PTR [rcx+37]
	imul	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR _fs$[rsp]
	movzx	ecx, WORD PTR [rcx+58]
	imul	eax, ecx
	mov	rcx, QWORD PTR file$[rsp]
	mov	DWORD PTR [rcx+32], eax

; 362  : 	size_t sz = file->size;

	mov	rax, QWORD PTR file$[rsp]
	mov	eax, DWORD PTR [rax+32]
	mov	QWORD PTR sz$[rsp], rax

; 363  : 
; 364  : 	FatFileUpdateSize(fsys, file, sz);

	mov	r8, QWORD PTR sz$[rsp]
	mov	rdx, QWORD PTR file$[rsp]
	mov	rcx, QWORD PTR fsys$[rsp]
	call	?FatFileUpdateSize@@YAXPEAU__VFS_NODE__@@0_K@Z ; FatFileUpdateSize

; 365  : 
; 366  : 	AuPmmngrFree((void*)V2P((size_t)buff));

	mov	rcx, QWORD PTR buff$[rsp]
	call	V2P
	mov	rcx, rax
	call	AuPmmngrFree
$LN7@FatFileWri:

; 367  : }

	add	rsp, 88					; 00000058H
	ret	0
?FatFileWriteContent@@YAXPEAU__VFS_NODE__@@0PEA_K@Z ENDP ; FatFileWriteContent
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\fs\fat\fatfile.cpp
_TEXT	SEGMENT
j$1 = 32
dir_cluster$ = 36
i$2 = 40
buff$ = 48
_fs$ = 56
dirent$3 = 64
fname$ = 72
nname$ = 88
name$4 = 104
tv132 = 120
tv161 = 128
fsys$ = 160
file$ = 168
newname$ = 176
?FatFileUpdateFilename@@YAHPEAU__VFS_NODE__@@0PEAD@Z PROC ; FatFileUpdateFilename

; 266  : int FatFileUpdateFilename(AuVFSNode* fsys, AuVFSNode* file, char* newname) {

$LN15:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 152				; 00000098H

; 267  : 	if (!fsys)

	cmp	QWORD PTR fsys$[rsp], 0
	jne	SHORT $LN12@FatFileUpd

; 268  : 		return -1;

	mov	eax, -1
	jmp	$LN13@FatFileUpd
$LN12@FatFileUpd:

; 269  : 	if (!file)

	cmp	QWORD PTR file$[rsp], 0
	jne	SHORT $LN11@FatFileUpd

; 270  : 		return -1;

	mov	eax, -1
	jmp	$LN13@FatFileUpd
$LN11@FatFileUpd:

; 271  : 	/*if (!file->parent_block)
; 272  : 	return;*/
; 273  : 	FatFS *_fs = (FatFS*)fsys->device;

	mov	rax, QWORD PTR fsys$[rsp]
	mov	rax, QWORD PTR [rax+63]
	mov	QWORD PTR _fs$[rsp], rax

; 274  : 
; 275  : 	uint32_t dir_cluster = file->parent_block;

	mov	rax, QWORD PTR file$[rsp]
	mov	eax, DWORD PTR [rax+41]
	mov	DWORD PTR dir_cluster$[rsp], eax

; 276  : 
; 277  : 	char fname[11];
; 278  : 	memset(fname, 0, 11);

	mov	r8d, 11
	xor	edx, edx
	lea	rcx, QWORD PTR fname$[rsp]
	call	memset

; 279  : 	FatToDOSFilename(file->filename, fname, 11);

	mov	rax, QWORD PTR file$[rsp]
	mov	r8d, 11
	lea	rdx, QWORD PTR fname$[rsp]
	mov	rcx, rax
	call	?FatToDOSFilename@@YAXPEBDPEADI@Z	; FatToDOSFilename

; 280  : 	fname[11] = 0;

	mov	eax, 1
	imul	rax, rax, 11
	mov	BYTE PTR fname$[rsp+rax], 0

; 281  : 
; 282  : 	char nname[11];
; 283  : 	memset(nname, 0, 11);

	mov	r8d, 11
	xor	edx, edx
	lea	rcx, QWORD PTR nname$[rsp]
	call	memset

; 284  : 	FatToDOSFilename(newname, nname, 11);

	mov	r8d, 11
	lea	rdx, QWORD PTR nname$[rsp]
	mov	rcx, QWORD PTR newname$[rsp]
	call	?FatToDOSFilename@@YAXPEBDPEADI@Z	; FatToDOSFilename

; 285  : 	nname[11] = 0;

	mov	eax, 1
	imul	rax, rax, 11
	mov	BYTE PTR nname$[rsp+rax], 0

; 286  : 
; 287  : 	uint64_t* buff = (uint64_t*)P2V((size_t)AuPmmngrAlloc());

	call	AuPmmngrAlloc
	mov	rcx, rax
	call	P2V
	mov	QWORD PTR buff$[rsp], rax

; 288  : 	memset(buff, 0, PAGE_SIZE);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR buff$[rsp]
	call	memset
$LN10@FatFileUpd:

; 289  : 
; 290  : 	while (1) {

	xor	eax, eax
	cmp	eax, 1
	je	$LN9@FatFileUpd

; 291  : 		for (int j = 0; j < _fs->__SectorPerCluster; j++) {

	mov	DWORD PTR j$1[rsp], 0
	jmp	SHORT $LN8@FatFileUpd
$LN7@FatFileUpd:
	mov	eax, DWORD PTR j$1[rsp]
	inc	eax
	mov	DWORD PTR j$1[rsp], eax
$LN8@FatFileUpd:
	mov	rax, QWORD PTR _fs$[rsp]
	movzx	eax, BYTE PTR [rax+33]
	cmp	DWORD PTR j$1[rsp], eax
	jge	$LN6@FatFileUpd

; 292  : 			memset(buff, 0, PAGE_SIZE);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR buff$[rsp]
	call	memset

; 293  : 			AuVDiskRead(_fs->vdisk, FatClusterToSector32(_fs, dir_cluster) + j, 1, (uint64_t*)V2P((size_t)buff));

	mov	rcx, QWORD PTR buff$[rsp]
	call	V2P
	mov	QWORD PTR tv132[rsp], rax
	mov	ecx, DWORD PTR dir_cluster$[rsp]
	mov	edx, ecx
	mov	rcx, QWORD PTR _fs$[rsp]
	call	?FatClusterToSector32@@YA_KPEAU_FatFS_@@_K@Z ; FatClusterToSector32
	movsxd	rcx, DWORD PTR j$1[rsp]
	add	rax, rcx
	mov	rcx, QWORD PTR tv132[rsp]
	mov	r9, rcx
	mov	r8d, 1
	mov	rdx, rax
	mov	rax, QWORD PTR _fs$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	AuVDiskRead

; 294  : 
; 295  : 			FatDir *dirent = (FatDir*)buff;

	mov	rax, QWORD PTR buff$[rsp]
	mov	QWORD PTR dirent$3[rsp], rax

; 296  : 			for (int i = 0; i < 16; i++) {

	mov	DWORD PTR i$2[rsp], 0
	jmp	SHORT $LN5@FatFileUpd
$LN4@FatFileUpd:
	mov	eax, DWORD PTR i$2[rsp]
	inc	eax
	mov	DWORD PTR i$2[rsp], eax
$LN5@FatFileUpd:
	cmp	DWORD PTR i$2[rsp], 16
	jge	$LN3@FatFileUpd

; 297  : 				char name[11];
; 298  : 				memcpy(name, dirent->filename, 11);

	mov	rax, QWORD PTR dirent$3[rsp]
	mov	r8d, 11
	mov	rdx, rax
	lea	rcx, QWORD PTR name$4[rsp]
	call	memcpy

; 299  : 				name[11] = 0;

	mov	eax, 1
	imul	rax, rax, 11
	mov	BYTE PTR name$4[rsp+rax], 0

; 300  : 
; 301  : 				if (strcmp(name, fname) == 0) {

	lea	rdx, QWORD PTR fname$[rsp]
	lea	rcx, QWORD PTR name$4[rsp]
	call	strcmp
	test	eax, eax
	jne	SHORT $LN2@FatFileUpd

; 302  : 					memcpy(dirent->filename, nname, 11);

	mov	rax, QWORD PTR dirent$3[rsp]
	mov	r8d, 11
	lea	rdx, QWORD PTR nname$[rsp]
	mov	rcx, rax
	call	memcpy

; 303  : 					AuVDiskWrite(_fs->vdisk, FatClusterToSector32(_fs, dir_cluster) + j, 1, (uint64_t*)V2P((size_t)buff));

	mov	rcx, QWORD PTR buff$[rsp]
	call	V2P
	mov	QWORD PTR tv161[rsp], rax
	mov	ecx, DWORD PTR dir_cluster$[rsp]
	mov	edx, ecx
	mov	rcx, QWORD PTR _fs$[rsp]
	call	?FatClusterToSector32@@YA_KPEAU_FatFS_@@_K@Z ; FatClusterToSector32
	movsxd	rcx, DWORD PTR j$1[rsp]
	add	rax, rcx
	mov	rcx, QWORD PTR tv161[rsp]
	mov	r9, rcx
	mov	r8d, 1
	mov	rdx, rax
	mov	rax, QWORD PTR _fs$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	AuVDiskWrite

; 304  : 					AuPmmngrFree((void*)V2P((size_t)buff));

	mov	rcx, QWORD PTR buff$[rsp]
	call	V2P
	mov	rcx, rax
	call	AuPmmngrFree

; 305  : 					return 0;

	xor	eax, eax
	jmp	SHORT $LN13@FatFileUpd
$LN2@FatFileUpd:

; 306  : 				}
; 307  : 				dirent++;

	mov	rax, QWORD PTR dirent$3[rsp]
	add	rax, 32					; 00000020H
	mov	QWORD PTR dirent$3[rsp], rax

; 308  : 			}

	jmp	$LN4@FatFileUpd
$LN3@FatFileUpd:

; 309  : 		}

	jmp	$LN7@FatFileUpd
$LN6@FatFileUpd:

; 310  : 
; 311  : 		dir_cluster = FatReadFAT(fsys, dir_cluster);

	mov	edx, DWORD PTR dir_cluster$[rsp]
	mov	rcx, QWORD PTR fsys$[rsp]
	call	?FatReadFAT@@YAIPEAU__VFS_NODE__@@I@Z	; FatReadFAT
	mov	DWORD PTR dir_cluster$[rsp], eax

; 312  : 		if (dir_cluster == (FAT_EOC_MARK & 0x0FFFFFFF)) 

	cmp	DWORD PTR dir_cluster$[rsp], 268435448	; 0ffffff8H
	jne	SHORT $LN1@FatFileUpd

; 313  : 			break;

	jmp	SHORT $LN9@FatFileUpd
$LN1@FatFileUpd:

; 314  : 	}

	jmp	$LN10@FatFileUpd
$LN9@FatFileUpd:

; 315  : 		
; 316  : 	return -1;

	mov	eax, -1
$LN13@FatFileUpd:

; 317  : }

	add	rsp, 152				; 00000098H
	ret	0
?FatFileUpdateFilename@@YAHPEAU__VFS_NODE__@@0PEAD@Z ENDP ; FatFileUpdateFilename
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\fs\fat\fatfile.cpp
_TEXT	SEGMENT
dir_cluster$ = 32
j$1 = 36
i$2 = 40
buff$ = 48
_fs$ = 56
dirent$3 = 64
fname$ = 72
name$4 = 88
tv150 = 104
tv92 = 112
fsys$ = 144
file$ = 152
size$ = 160
?FatFileUpdateSize@@YAXPEAU__VFS_NODE__@@0_K@Z PROC	; FatFileUpdateSize

; 212  : void FatFileUpdateSize(AuVFSNode* fsys, AuVFSNode* file, size_t size) {

$LN15:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 136				; 00000088H

; 213  : 	if (!fsys)

	cmp	QWORD PTR fsys$[rsp], 0
	jne	SHORT $LN12@FatFileUpd

; 214  : 		return;

	jmp	$LN13@FatFileUpd
$LN12@FatFileUpd:

; 215  : 	if (!file)

	cmp	QWORD PTR file$[rsp], 0
	jne	SHORT $LN11@FatFileUpd

; 216  : 		return;

	jmp	$LN13@FatFileUpd
$LN11@FatFileUpd:

; 217  : 	/*if (!file->parent_block)
; 218  : 		return;*/
; 219  : 	FatFS *_fs = (FatFS*)fsys->device;

	mov	rax, QWORD PTR fsys$[rsp]
	mov	rax, QWORD PTR [rax+63]
	mov	QWORD PTR _fs$[rsp], rax

; 220  : 
; 221  : 	uint32_t dir_cluster = file->parent_block;

	mov	rax, QWORD PTR file$[rsp]
	mov	eax, DWORD PTR [rax+41]
	mov	DWORD PTR dir_cluster$[rsp], eax

; 222  : 
; 223  : 	char fname[11];
; 224  : 	memset(fname, 0, 11);

	mov	r8d, 11
	xor	edx, edx
	lea	rcx, QWORD PTR fname$[rsp]
	call	memset

; 225  : 	FatToDOSFilename(file->filename, fname, 11);

	mov	rax, QWORD PTR file$[rsp]
	mov	r8d, 11
	lea	rdx, QWORD PTR fname$[rsp]
	mov	rcx, rax
	call	?FatToDOSFilename@@YAXPEBDPEADI@Z	; FatToDOSFilename

; 226  : 	fname[11] = 0;

	mov	eax, 1
	imul	rax, rax, 11
	mov	BYTE PTR fname$[rsp+rax], 0

; 227  : 	uint64_t* buff = (uint64_t*)P2V((size_t)AuPmmngrAlloc());

	call	AuPmmngrAlloc
	mov	rcx, rax
	call	P2V
	mov	QWORD PTR buff$[rsp], rax

; 228  : 	memset(buff, 0, PAGE_SIZE);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR buff$[rsp]
	call	memset
$LN10@FatFileUpd:

; 229  : 
; 230  : 	while (1) {

	xor	eax, eax
	cmp	eax, 1
	je	$LN9@FatFileUpd

; 231  : 		for (int j = 0; j < _fs->__SectorPerCluster; j++) {

	mov	DWORD PTR j$1[rsp], 0
	jmp	SHORT $LN8@FatFileUpd
$LN7@FatFileUpd:
	mov	eax, DWORD PTR j$1[rsp]
	inc	eax
	mov	DWORD PTR j$1[rsp], eax
$LN8@FatFileUpd:
	mov	rax, QWORD PTR _fs$[rsp]
	movzx	eax, BYTE PTR [rax+33]
	cmp	DWORD PTR j$1[rsp], eax
	jge	$LN6@FatFileUpd

; 232  : 			memset(buff, 0, PAGE_SIZE);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR buff$[rsp]
	call	memset

; 233  : 			AuVDiskRead(_fs->vdisk, FatClusterToSector32(_fs, dir_cluster) + j, 1, (uint64_t*)V2P((size_t)buff));

	mov	rcx, QWORD PTR buff$[rsp]
	call	V2P
	mov	QWORD PTR tv92[rsp], rax
	mov	ecx, DWORD PTR dir_cluster$[rsp]
	mov	edx, ecx
	mov	rcx, QWORD PTR _fs$[rsp]
	call	?FatClusterToSector32@@YA_KPEAU_FatFS_@@_K@Z ; FatClusterToSector32
	movsxd	rcx, DWORD PTR j$1[rsp]
	add	rax, rcx
	mov	rcx, QWORD PTR tv92[rsp]
	mov	r9, rcx
	mov	r8d, 1
	mov	rdx, rax
	mov	rax, QWORD PTR _fs$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	AuVDiskRead

; 234  : 
; 235  : 			FatDir *dirent = (FatDir*)buff;

	mov	rax, QWORD PTR buff$[rsp]
	mov	QWORD PTR dirent$3[rsp], rax

; 236  : 			for (int i = 0; i < 16; i++) {

	mov	DWORD PTR i$2[rsp], 0
	jmp	SHORT $LN5@FatFileUpd
$LN4@FatFileUpd:
	mov	eax, DWORD PTR i$2[rsp]
	inc	eax
	mov	DWORD PTR i$2[rsp], eax
$LN5@FatFileUpd:
	cmp	DWORD PTR i$2[rsp], 16
	jge	$LN3@FatFileUpd

; 237  : 				char name[11];
; 238  : 				memcpy(name, dirent->filename, 11);

	mov	rax, QWORD PTR dirent$3[rsp]
	mov	r8d, 11
	mov	rdx, rax
	lea	rcx, QWORD PTR name$4[rsp]
	call	memcpy

; 239  : 				name[11] = 0;

	mov	eax, 1
	imul	rax, rax, 11
	mov	BYTE PTR name$4[rsp+rax], 0

; 240  : 
; 241  : 				if (strcmp(name, fname) == 0) {

	lea	rdx, QWORD PTR fname$[rsp]
	lea	rcx, QWORD PTR name$4[rsp]
	call	strcmp
	test	eax, eax
	jne	SHORT $LN2@FatFileUpd

; 242  : 					dirent->file_size = size;

	mov	rax, QWORD PTR dirent$3[rsp]
	mov	ecx, DWORD PTR size$[rsp]
	mov	DWORD PTR [rax+28], ecx

; 243  : 					AuVDiskWrite(_fs->vdisk, FatClusterToSector32(_fs, dir_cluster) + j, 1, (uint64_t*)V2P((size_t)buff));

	mov	rcx, QWORD PTR buff$[rsp]
	call	V2P
	mov	QWORD PTR tv150[rsp], rax
	mov	ecx, DWORD PTR dir_cluster$[rsp]
	mov	edx, ecx
	mov	rcx, QWORD PTR _fs$[rsp]
	call	?FatClusterToSector32@@YA_KPEAU_FatFS_@@_K@Z ; FatClusterToSector32
	movsxd	rcx, DWORD PTR j$1[rsp]
	add	rax, rcx
	mov	rcx, QWORD PTR tv150[rsp]
	mov	r9, rcx
	mov	r8d, 1
	mov	rdx, rax
	mov	rax, QWORD PTR _fs$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	AuVDiskWrite

; 244  : 					AuPmmngrFree((void*)V2P((size_t)buff));

	mov	rcx, QWORD PTR buff$[rsp]
	call	V2P
	mov	rcx, rax
	call	AuPmmngrFree

; 245  : 					return;

	jmp	SHORT $LN13@FatFileUpd
$LN2@FatFileUpd:

; 246  : 				}
; 247  : 				dirent++;

	mov	rax, QWORD PTR dirent$3[rsp]
	add	rax, 32					; 00000020H
	mov	QWORD PTR dirent$3[rsp], rax

; 248  : 			}

	jmp	$LN4@FatFileUpd
$LN3@FatFileUpd:

; 249  : 		}

	jmp	$LN7@FatFileUpd
$LN6@FatFileUpd:

; 250  : 
; 251  : 		dir_cluster = FatReadFAT(fsys, dir_cluster);

	mov	edx, DWORD PTR dir_cluster$[rsp]
	mov	rcx, QWORD PTR fsys$[rsp]
	call	?FatReadFAT@@YAIPEAU__VFS_NODE__@@I@Z	; FatReadFAT
	mov	DWORD PTR dir_cluster$[rsp], eax

; 252  : 		if (dir_cluster == (FAT_EOC_MARK & 0x0FFFFFFF)) {

	cmp	DWORD PTR dir_cluster$[rsp], 268435448	; 0ffffff8H
	jne	SHORT $LN1@FatFileUpd

; 253  : 			break;

	jmp	SHORT $LN9@FatFileUpd
$LN1@FatFileUpd:

; 254  : 		}
; 255  : 	}

	jmp	$LN10@FatFileUpd
$LN9@FatFileUpd:
$LN13@FatFileUpd:

; 256  : 	return;
; 257  : }

	add	rsp, 136				; 00000088H
	ret	0
?FatFileUpdateSize@@YAXPEAU__VFS_NODE__@@0_K@Z ENDP	; FatFileUpdateSize
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\fs\fat\fatfile.cpp
_TEXT	SEGMENT
dirent$1 = 32
parent_cluster$ = 40
i$2 = 44
file$ = 48
cluster$3 = 56
p$ = 64
j$4 = 72
_fs$ = 80
i$5 = 88
buff$ = 96
parent$ = 104
fname$ = 112
tv223 = 128
tv168 = 136
path$ = 144
extract$ = 152
fsys$ = 192
filename$ = 200
?FatCreateFile@@YAPEAU__VFS_NODE__@@PEAU1@PEAD@Z PROC	; FatCreateFile

; 103  : AuVFSNode* FatCreateFile(AuVFSNode* fsys, char* filename) {

$LN26:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 184				; 000000b8H

; 104  : 	if (!fsys)

	cmp	QWORD PTR fsys$[rsp], 0
	jne	SHORT $LN23@FatCreateF

; 105  : 		return NULL;

	xor	eax, eax
	jmp	$LN24@FatCreateF
$LN23@FatCreateF:

; 106  : 	FatFS* _fs = (FatFS*)fsys->device;

	mov	rax, QWORD PTR fsys$[rsp]
	mov	rax, QWORD PTR [rax+63]
	mov	QWORD PTR _fs$[rsp], rax

; 107  : 	
; 108  : 	AuAcquireMutex(_fs->fat_mutex);

	mov	rax, QWORD PTR _fs$[rsp]
	mov	rcx, QWORD PTR [rax+68]
	call	AuAcquireMutex

; 109  : 
; 110  : 	AuVFSNode* parent = FatFileGetParent(fsys, filename);

	mov	rdx, QWORD PTR filename$[rsp]
	mov	rcx, QWORD PTR fsys$[rsp]
	call	?FatFileGetParent@@YAPEAU__VFS_NODE__@@PEAU1@PEBD@Z ; FatFileGetParent
	mov	QWORD PTR parent$[rsp], rax

; 111  : 	if (!parent)

	cmp	QWORD PTR parent$[rsp], 0
	jne	SHORT $LN22@FatCreateF

; 112  : 		return NULL;

	xor	eax, eax
	jmp	$LN24@FatCreateF
$LN22@FatCreateF:

; 113  : 	
; 114  : 	uint32_t parent_cluster = parent->current;

	mov	rax, QWORD PTR parent$[rsp]
	mov	eax, DWORD PTR [rax+53]
	mov	DWORD PTR parent_cluster$[rsp], eax

; 115  : 	if (!parent_cluster)

	cmp	DWORD PTR parent_cluster$[rsp], 0
	jne	SHORT $LN21@FatCreateF

; 116  : 		parent_cluster = _fs->__RootDirFirstCluster;

	mov	rax, QWORD PTR _fs$[rsp]
	mov	eax, DWORD PTR [rax+34]
	mov	DWORD PTR parent_cluster$[rsp], eax
$LN21@FatCreateF:

; 117  : 
; 118  : 	AuVFSNode* file = (AuVFSNode*)kmalloc(sizeof(AuVFSNode));

	mov	ecx, 159				; 0000009fH
	call	kmalloc
	mov	QWORD PTR file$[rsp], rax

; 119  : 	memset(file, 0, sizeof(AuVFSNode));

	mov	r8d, 159				; 0000009fH
	xor	edx, edx
	mov	rcx, QWORD PTR file$[rsp]
	call	memset

; 120  : 
; 121  : 	uint64_t* buff = (uint64_t*)P2V((size_t)AuPmmngrAlloc());

	call	AuPmmngrAlloc
	mov	rcx, rax
	call	P2V
	mov	QWORD PTR buff$[rsp], rax

; 122  : 	memset(buff, 0, PAGE_SIZE);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR buff$[rsp]
	call	memset

; 123  : 
; 124  : 	char* path = (char*)filename;

	mov	rax, QWORD PTR filename$[rsp]
	mov	QWORD PTR path$[rsp], rax

; 125  : 	char* p = strchr(path, '/');

	mov	edx, 47					; 0000002fH
	mov	rcx, QWORD PTR path$[rsp]
	call	strchr
	mov	QWORD PTR p$[rsp], rax

; 126  : 	if (p)

	cmp	QWORD PTR p$[rsp], 0
	je	SHORT $LN20@FatCreateF

; 127  : 		p++;

	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax
$LN20@FatCreateF:

; 128  : 
; 129  : 	char extract[16];
; 130  : 	memset(extract, 0, 16);

	mov	r8d, 16
	xor	edx, edx
	lea	rcx, QWORD PTR extract$[rsp]
	call	memset
$LN19@FatCreateF:

; 131  : 	while (p) {

	cmp	QWORD PTR p$[rsp], 0
	je	$LN18@FatCreateF

; 132  : 		int i = 0;

	mov	DWORD PTR i$2[rsp], 0

; 133  : 		for (i = 0; i < 16; i++) {

	mov	DWORD PTR i$2[rsp], 0
	jmp	SHORT $LN17@FatCreateF
$LN16@FatCreateF:
	mov	eax, DWORD PTR i$2[rsp]
	inc	eax
	mov	DWORD PTR i$2[rsp], eax
$LN17@FatCreateF:
	cmp	DWORD PTR i$2[rsp], 16
	jge	SHORT $LN15@FatCreateF

; 134  : 			if (p[i] == '/' || p[i] == '\0')

	movsxd	rax, DWORD PTR i$2[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 47					; 0000002fH
	je	SHORT $LN13@FatCreateF
	movsxd	rax, DWORD PTR i$2[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	jne	SHORT $LN14@FatCreateF
$LN13@FatCreateF:

; 135  : 				break;

	jmp	SHORT $LN15@FatCreateF
$LN14@FatCreateF:

; 136  : 			extract[i] = p[i];

	movsxd	rax, DWORD PTR i$2[rsp]
	movsxd	rcx, DWORD PTR i$2[rsp]
	mov	rdx, QWORD PTR p$[rsp]
	movzx	eax, BYTE PTR [rdx+rax]
	mov	BYTE PTR extract$[rsp+rcx], al

; 137  : 		}

	jmp	SHORT $LN16@FatCreateF
$LN15@FatCreateF:

; 138  : 		p = strchr(p + 1, '/');

	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	edx, 47					; 0000002fH
	mov	rcx, rax
	call	strchr
	mov	QWORD PTR p$[rsp], rax

; 139  : 		if (p)

	cmp	QWORD PTR p$[rsp], 0
	je	SHORT $LN12@FatCreateF

; 140  : 			p++;

	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax
$LN12@FatCreateF:

; 141  : 	}

	jmp	$LN19@FatCreateF
$LN18@FatCreateF:

; 142  : 
; 143  : 	char fname[11];
; 144  : 	memset(fname, 0, 11);

	mov	r8d, 11
	xor	edx, edx
	lea	rcx, QWORD PTR fname$[rsp]
	call	memset

; 145  : 	FatToDOSFilename(extract, fname, 11);

	mov	r8d, 11
	lea	rdx, QWORD PTR fname$[rsp]
	lea	rcx, QWORD PTR extract$[rsp]
	call	?FatToDOSFilename@@YAXPEBDPEADI@Z	; FatToDOSFilename

; 146  : 	fname[11] = 0;

	mov	eax, 1
	imul	rax, rax, 11
	mov	BYTE PTR fname$[rsp+rax], 0
$LN11@FatCreateF:

; 147  : 
; 148  : 	while (1) {

	xor	eax, eax
	cmp	eax, 1
	je	$LN10@FatCreateF

; 149  : 		for (int j = 0; j < _fs->__SectorPerCluster; j++) {

	mov	DWORD PTR j$4[rsp], 0
	jmp	SHORT $LN9@FatCreateF
$LN8@FatCreateF:
	mov	eax, DWORD PTR j$4[rsp]
	inc	eax
	mov	DWORD PTR j$4[rsp], eax
$LN9@FatCreateF:
	mov	rax, QWORD PTR _fs$[rsp]
	movzx	eax, BYTE PTR [rax+33]
	cmp	DWORD PTR j$4[rsp], eax
	jge	$LN7@FatCreateF

; 150  : 			memset(buff, 0, PAGE_SIZE);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR buff$[rsp]
	call	memset

; 151  : 			AuVDiskRead(_fs->vdisk, FatClusterToSector32(_fs, parent_cluster) + j, 1, (uint64_t*)V2P((size_t)buff));

	mov	rcx, QWORD PTR buff$[rsp]
	call	V2P
	mov	QWORD PTR tv168[rsp], rax
	mov	ecx, DWORD PTR parent_cluster$[rsp]
	mov	edx, ecx
	mov	rcx, QWORD PTR _fs$[rsp]
	call	?FatClusterToSector32@@YA_KPEAU_FatFS_@@_K@Z ; FatClusterToSector32
	movsxd	rcx, DWORD PTR j$4[rsp]
	add	rax, rcx
	mov	rcx, QWORD PTR tv168[rsp]
	mov	r9, rcx
	mov	r8d, 1
	mov	rdx, rax
	mov	rax, QWORD PTR _fs$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	AuVDiskRead

; 152  : 
; 153  : 			FatDir *dirent = (FatDir*)buff;

	mov	rax, QWORD PTR buff$[rsp]
	mov	QWORD PTR dirent$1[rsp], rax

; 154  : 			for (int i = 0; i < 16; i++) {

	mov	DWORD PTR i$5[rsp], 0
	jmp	SHORT $LN6@FatCreateF
$LN5@FatCreateF:
	mov	eax, DWORD PTR i$5[rsp]
	inc	eax
	mov	DWORD PTR i$5[rsp], eax
$LN6@FatCreateF:
	cmp	DWORD PTR i$5[rsp], 16
	jge	$LN4@FatCreateF

; 155  : 				if (dirent->filename[0] == 0x00 || dirent->filename[0] == 0xE5) {

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR dirent$1[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN2@FatCreateF
	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR dirent$1[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 229				; 000000e5H
	jne	$LN3@FatCreateF
$LN2@FatCreateF:

; 156  : 					memcpy(dirent->filename, fname, 11);

	mov	rax, QWORD PTR dirent$1[rsp]
	mov	r8d, 11
	lea	rdx, QWORD PTR fname$[rsp]
	mov	rcx, rax
	call	memcpy

; 157  : 
; 158  : 					uint32_t cluster = FatFindFreeCluster(fsys);

	mov	rcx, QWORD PTR fsys$[rsp]
	call	?FatFindFreeCluster@@YAIPEAU__VFS_NODE__@@@Z ; FatFindFreeCluster
	mov	DWORD PTR cluster$3[rsp], eax

; 159  : 					FatAllocCluster(fsys, cluster, FAT_EOC_MARK);

	mov	r8d, -8					; fffffff8H
	mov	edx, DWORD PTR cluster$3[rsp]
	mov	rcx, QWORD PTR fsys$[rsp]
	call	?FatAllocCluster@@YAXPEAU__VFS_NODE__@@HI@Z ; FatAllocCluster

; 160  : 					FatClearCluster(fsys, cluster);

	mov	edx, DWORD PTR cluster$3[rsp]
	mov	rcx, QWORD PTR fsys$[rsp]
	call	?FatClearCluster@@YAXPEAU__VFS_NODE__@@I@Z ; FatClearCluster

; 161  : 
; 162  : 					dirent->attrib = FAT_ATTRIBUTE_ARCHIVE;

	mov	rax, QWORD PTR dirent$1[rsp]
	mov	BYTE PTR [rax+11], 32			; 00000020H

; 163  : 					dirent->first_cluster = cluster & 0x0000FFFF;

	mov	eax, DWORD PTR cluster$3[rsp]
	and	eax, 65535				; 0000ffffH
	mov	rcx, QWORD PTR dirent$1[rsp]
	mov	WORD PTR [rcx+26], ax

; 164  : 					dirent->first_cluster_hi_bytes = (cluster & 0x0FFF0000) >> 16;

	mov	eax, DWORD PTR cluster$3[rsp]
	and	eax, 268369920				; 0fff0000H
	shr	eax, 16
	mov	rcx, QWORD PTR dirent$1[rsp]
	mov	WORD PTR [rcx+20], ax

; 165  : 					dirent->date_created = FatFormatDate();

	call	?FatFormatDate@@YAGXZ			; FatFormatDate
	mov	rcx, QWORD PTR dirent$1[rsp]
	mov	WORD PTR [rcx+16], ax

; 166  : 					dirent->time_created = FatFormatTime();

	call	?FatFormatTime@@YAGXZ			; FatFormatTime
	mov	rcx, QWORD PTR dirent$1[rsp]
	mov	WORD PTR [rcx+14], ax

; 167  : 					dirent->last_wrt_date = dirent->date_created;

	mov	rax, QWORD PTR dirent$1[rsp]
	mov	rcx, QWORD PTR dirent$1[rsp]
	movzx	ecx, WORD PTR [rcx+16]
	mov	WORD PTR [rax+24], cx

; 168  : 					dirent->last_wrt_time = dirent->time_created;

	mov	rax, QWORD PTR dirent$1[rsp]
	mov	rcx, QWORD PTR dirent$1[rsp]
	movzx	ecx, WORD PTR [rcx+14]
	mov	WORD PTR [rax+22], cx

; 169  : 					dirent->date_last_accessed = dirent->date_created;

	mov	rax, QWORD PTR dirent$1[rsp]
	mov	rcx, QWORD PTR dirent$1[rsp]
	movzx	ecx, WORD PTR [rcx+16]
	mov	WORD PTR [rax+18], cx

; 170  : 					dirent->file_size = 0; //by default, 0 bytes

	mov	rax, QWORD PTR dirent$1[rsp]
	mov	DWORD PTR [rax+28], 0

; 171  : 
; 172  : 					AuVDiskWrite(_fs->vdisk, FatClusterToSector32(_fs, parent_cluster) + j, 1, (uint64_t*)V2P((size_t)buff));

	mov	rcx, QWORD PTR buff$[rsp]
	call	V2P
	mov	QWORD PTR tv223[rsp], rax
	mov	ecx, DWORD PTR parent_cluster$[rsp]
	mov	edx, ecx
	mov	rcx, QWORD PTR _fs$[rsp]
	call	?FatClusterToSector32@@YA_KPEAU_FatFS_@@_K@Z ; FatClusterToSector32
	movsxd	rcx, DWORD PTR j$4[rsp]
	add	rax, rcx
	mov	rcx, QWORD PTR tv223[rsp]
	mov	r9, rcx
	mov	r8d, 1
	mov	rdx, rax
	mov	rax, QWORD PTR _fs$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	AuVDiskWrite

; 173  : 					AuPmmngrFree((void*)V2P((size_t)buff));

	mov	rcx, QWORD PTR buff$[rsp]
	call	V2P
	mov	rcx, rax
	call	AuPmmngrFree

; 174  : 
; 175  : 					strcpy(file->filename, extract);

	mov	rax, QWORD PTR file$[rsp]
	lea	rdx, QWORD PTR extract$[rsp]
	mov	rcx, rax
	call	strcpy

; 176  : 					file->size = dirent->file_size;

	mov	rax, QWORD PTR file$[rsp]
	mov	rcx, QWORD PTR dirent$1[rsp]
	mov	ecx, DWORD PTR [rcx+28]
	mov	DWORD PTR [rax+32], ecx

; 177  : 					file->eof = 0;

	mov	rax, QWORD PTR file$[rsp]
	mov	BYTE PTR [rax+36], 0

; 178  : 					file->pos = 0;

	mov	rax, QWORD PTR file$[rsp]
	mov	DWORD PTR [rax+37], 0

; 179  : 					file->current = cluster;

	mov	eax, DWORD PTR cluster$3[rsp]
	mov	rcx, QWORD PTR file$[rsp]
	mov	QWORD PTR [rcx+53], rax

; 180  : 					file->first_block = cluster;

	mov	eax, DWORD PTR cluster$3[rsp]
	mov	rcx, QWORD PTR file$[rsp]
	mov	QWORD PTR [rcx+45], rax

; 181  : 					file->parent_block = parent_cluster;

	mov	rax, QWORD PTR file$[rsp]
	mov	ecx, DWORD PTR parent_cluster$[rsp]
	mov	DWORD PTR [rax+41], ecx

; 182  : 					file->device = fsys;

	mov	rax, QWORD PTR file$[rsp]
	mov	rcx, QWORD PTR fsys$[rsp]
	mov	QWORD PTR [rax+63], rcx

; 183  : 					file->flags |= FS_FLAG_GENERAL;

	mov	rax, QWORD PTR file$[rsp]
	movzx	eax, BYTE PTR [rax+61]
	or	eax, 4
	mov	rcx, QWORD PTR file$[rsp]
	mov	BYTE PTR [rcx+61], al

; 184  : 					file->status = FS_STATUS_FOUND;

	mov	rax, QWORD PTR file$[rsp]
	mov	BYTE PTR [rax+62], 1

; 185  : 
; 186  : 					kfree(parent);

	mov	rcx, QWORD PTR parent$[rsp]
	call	kfree

; 187  : 					return file;

	mov	rax, QWORD PTR file$[rsp]
	jmp	SHORT $LN24@FatCreateF
$LN3@FatCreateF:

; 188  : 				}
; 189  : 				dirent++;

	mov	rax, QWORD PTR dirent$1[rsp]
	add	rax, 32					; 00000020H
	mov	QWORD PTR dirent$1[rsp], rax

; 190  : 			}

	jmp	$LN5@FatCreateF
$LN4@FatCreateF:

; 191  : 		}

	jmp	$LN8@FatCreateF
$LN7@FatCreateF:

; 192  : 		parent_cluster = FatReadFAT(fsys, parent_cluster);

	mov	edx, DWORD PTR parent_cluster$[rsp]
	mov	rcx, QWORD PTR fsys$[rsp]
	call	?FatReadFAT@@YAIPEAU__VFS_NODE__@@I@Z	; FatReadFAT
	mov	DWORD PTR parent_cluster$[rsp], eax

; 193  : 		if (parent_cluster == (FAT_EOC_MARK & 0x0FFFFFFF))

	cmp	DWORD PTR parent_cluster$[rsp], 268435448 ; 0ffffff8H
	jne	SHORT $LN1@FatCreateF

; 194  : 			break;

	jmp	SHORT $LN10@FatCreateF
$LN1@FatCreateF:

; 195  : 			/* actually, here we need to allocate a new
; 196  : 			 * cluster and write it to root cluster
; 197  : 			 * so that root directory expands
; 198  : 			 */
; 199  : 	}

	jmp	$LN11@FatCreateF
$LN10@FatCreateF:

; 200  : 	kfree(parent);

	mov	rcx, QWORD PTR parent$[rsp]
	call	kfree

; 201  : 	kfree(file);

	mov	rcx, QWORD PTR file$[rsp]
	call	kfree

; 202  : 	AuReleaseMutex(_fs->fat_mutex);

	mov	rax, QWORD PTR _fs$[rsp]
	mov	rcx, QWORD PTR [rax+68]
	call	AuReleaseMutex

; 203  : 	return NULL;

	xor	eax, eax
$LN24@FatCreateF:

; 204  : }

	add	rsp, 184				; 000000b8H
	ret	0
?FatCreateFile@@YAPEAU__VFS_NODE__@@PEAU1@PEAD@Z ENDP	; FatCreateFile
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\fs\fat\fatfile.cpp
_TEXT	SEGMENT
is_root$ = 32
i$1 = 36
p$ = 40
retfile$ = 48
parent$ = 56
_fs$ = 64
path$ = 72
pathname$2 = 80
fsys$ = 112
filename$ = 120
?FatFileGetParent@@YAPEAU__VFS_NODE__@@PEAU1@PEBD@Z PROC ; FatFileGetParent

; 47   : AuVFSNode* FatFileGetParent(AuVFSNode* fsys, const char* filename) {

$LN17:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 48   : 	if (!fsys)

	cmp	QWORD PTR fsys$[rsp], 0
	jne	SHORT $LN14@FatFileGet

; 49   : 		return NULL;

	xor	eax, eax
	jmp	$LN15@FatFileGet
$LN14@FatFileGet:

; 50   : 	FatFS* _fs = (FatFS*)fsys->device;

	mov	rax, QWORD PTR fsys$[rsp]
	mov	rax, QWORD PTR [rax+63]
	mov	QWORD PTR _fs$[rsp], rax

; 51   : 	AuVFSNode* parent = NULL;

	mov	QWORD PTR parent$[rsp], 0

; 52   : 	AuVFSNode* retfile = NULL;

	mov	QWORD PTR retfile$[rsp], 0

; 53   : 	char* path = (char*)filename;

	mov	rax, QWORD PTR filename$[rsp]
	mov	QWORD PTR path$[rsp], rax

; 54   : 
; 55   : 	char* p = strchr(path, '/');

	mov	edx, 47					; 0000002fH
	mov	rcx, QWORD PTR path$[rsp]
	call	strchr
	mov	QWORD PTR p$[rsp], rax

; 56   : 	p++;

	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax

; 57   : 	bool is_root = true;

	mov	BYTE PTR is_root$[rsp], 1
$LN13@FatFileGet:

; 58   : 	
; 59   : 	while (p) {

	cmp	QWORD PTR p$[rsp], 0
	je	$LN12@FatFileGet

; 60   : 		char pathname[16];
; 61   : 		int i = 0;

	mov	DWORD PTR i$1[rsp], 0

; 62   : 		for (i = 0; i < 16; i++) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN11@FatFileGet
$LN10@FatFileGet:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN11@FatFileGet:
	cmp	DWORD PTR i$1[rsp], 16
	jge	SHORT $LN9@FatFileGet

; 63   : 			if (p[i] == '/' || p[i] == '\0')

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 47					; 0000002fH
	je	SHORT $LN7@FatFileGet
	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	jne	SHORT $LN8@FatFileGet
$LN7@FatFileGet:

; 64   : 				break;

	jmp	SHORT $LN9@FatFileGet
$LN8@FatFileGet:

; 65   : 			pathname[i] = p[i];

	movsxd	rax, DWORD PTR i$1[rsp]
	movsxd	rcx, DWORD PTR i$1[rsp]
	mov	rdx, QWORD PTR p$[rsp]
	movzx	eax, BYTE PTR [rdx+rax]
	mov	BYTE PTR pathname$2[rsp+rcx], al

; 66   : 		}

	jmp	SHORT $LN10@FatFileGet
$LN9@FatFileGet:

; 67   : 		pathname[i] = 0;

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	BYTE PTR pathname$2[rsp+rax], 0

; 68   : 		if (is_root) {

	movzx	eax, BYTE PTR is_root$[rsp]
	test	eax, eax
	je	SHORT $LN6@FatFileGet

; 69   : 			parent = FatLocateDir(fsys, pathname);

	lea	rdx, QWORD PTR pathname$2[rsp]
	mov	rcx, QWORD PTR fsys$[rsp]
	call	?FatLocateDir@@YAPEAU__VFS_NODE__@@PEAU1@PEBD@Z ; FatLocateDir
	mov	QWORD PTR parent$[rsp], rax

; 70   : 			if (parent) {

	cmp	QWORD PTR parent$[rsp], 0
	je	SHORT $LN5@FatFileGet

; 71   : 				retfile = parent;

	mov	rax, QWORD PTR parent$[rsp]
	mov	QWORD PTR retfile$[rsp], rax
$LN5@FatFileGet:

; 72   : 			}
; 73   : 			is_root = false;

	mov	BYTE PTR is_root$[rsp], 0

; 74   : 		}
; 75   : 		else {

	jmp	SHORT $LN4@FatFileGet
$LN6@FatFileGet:

; 76   : 			parent = FatLocateSubDir(fsys, parent, pathname);

	lea	r8, QWORD PTR pathname$2[rsp]
	mov	rdx, QWORD PTR parent$[rsp]
	mov	rcx, QWORD PTR fsys$[rsp]
	call	?FatLocateSubDir@@YAPEAU__VFS_NODE__@@PEAU1@0PEBD@Z ; FatLocateSubDir
	mov	QWORD PTR parent$[rsp], rax

; 77   : 			if (parent) {

	cmp	QWORD PTR parent$[rsp], 0
	je	SHORT $LN3@FatFileGet

; 78   : 				retfile = parent;

	mov	rax, QWORD PTR parent$[rsp]
	mov	QWORD PTR retfile$[rsp], rax
$LN3@FatFileGet:
$LN4@FatFileGet:

; 79   : 			}
; 80   : 		}
; 81   : 		p = strchr(p + 1, '/');

	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	edx, 47					; 0000002fH
	mov	rcx, rax
	call	strchr
	mov	QWORD PTR p$[rsp], rax

; 82   : 		if (p)

	cmp	QWORD PTR p$[rsp], 0
	je	SHORT $LN2@FatFileGet

; 83   : 			p++;

	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax
$LN2@FatFileGet:

; 84   : 	}

	jmp	$LN13@FatFileGet
$LN12@FatFileGet:

; 85   : 
; 86   : 	if (!retfile) {

	cmp	QWORD PTR retfile$[rsp], 0
	jne	SHORT $LN1@FatFileGet

; 87   : 		retfile = (AuVFSNode*)kmalloc(sizeof(AuVFSNode));

	mov	ecx, 159				; 0000009fH
	call	kmalloc
	mov	QWORD PTR retfile$[rsp], rax

; 88   : 		memset(retfile, 0, sizeof(AuVFSNode));

	mov	r8d, 159				; 0000009fH
	xor	edx, edx
	mov	rcx, QWORD PTR retfile$[rsp]
	call	memset

; 89   : 		retfile->current = _fs->__RootDirFirstCluster;

	mov	rax, QWORD PTR _fs$[rsp]
	mov	eax, DWORD PTR [rax+34]
	mov	rcx, QWORD PTR retfile$[rsp]
	mov	QWORD PTR [rcx+53], rax

; 90   : 		retfile->first_block = _fs->__RootDirFirstCluster;

	mov	rax, QWORD PTR _fs$[rsp]
	mov	eax, DWORD PTR [rax+34]
	mov	rcx, QWORD PTR retfile$[rsp]
	mov	QWORD PTR [rcx+45], rax

; 91   : 		retfile->flags |= FS_FLAG_DIRECTORY;

	mov	rax, QWORD PTR retfile$[rsp]
	movzx	eax, BYTE PTR [rax+61]
	or	eax, 2
	mov	rcx, QWORD PTR retfile$[rsp]
	mov	BYTE PTR [rcx+61], al
$LN1@FatFileGet:

; 92   : 	}
; 93   : 
; 94   : 	return retfile;

	mov	rax, QWORD PTR retfile$[rsp]
$LN15@FatFileGet:

; 95   : }

	add	rsp, 104				; 00000068H
	ret	0
?FatFileGetParent@@YAPEAU__VFS_NODE__@@PEAU1@PEBD@Z ENDP ; FatFileGetParent
_TEXT	ENDS
END
