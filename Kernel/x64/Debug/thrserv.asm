; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30154.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

msvcjmc	SEGMENT
__ABA981AA_thrserv@cpp DB 01H
msvcjmc	ENDS
PUBLIC	?PauseThread@@YAHXZ				; PauseThread
PUBLIC	?GetThreadID@@YAGXZ				; GetThreadID
PUBLIC	?GetProcessID@@YAHXZ				; GetProcessID
PUBLIC	?ProcessExit@@YAHXZ				; ProcessExit
PUBLIC	?ProcessWaitForTermination@@YAHH@Z		; ProcessWaitForTermination
PUBLIC	?CreateProcess@@YAHHPEAD@Z			; CreateProcess
PUBLIC	?ProcessLoadExec@@YAHHPEADHPEAPEAD@Z		; ProcessLoadExec
PUBLIC	?ProcessSleep@@YAH_K@Z				; ProcessSleep
PUBLIC	?SignalReturn@@YAXH@Z				; SignalReturn
PUBLIC	?SetSignal@@YAHHP6AXH@Z@Z			; SetSignal
PUBLIC	?GetSystemTimerTick@@YA_KXZ			; GetSystemTimerTick
PUBLIC	?CreateUserThread@@YAHP6AXPEAX@ZPEAD@Z		; CreateUserThread
PUBLIC	?CloseUserThread@@YAHH@Z			; CloseUserThread
PUBLIC	?SetFileToProcess@@YAHHHH@Z			; SetFileToProcess
PUBLIC	?SendSignal@@YAHHH@Z				; SendSignal
PUBLIC	?GetCurrentTime@@YAHPEAX@Z			; GetCurrentTime
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_0BD@PDJGFKAF@No?5process?5found?5?6@	; `string'
PUBLIC	??_C@_0CC@CMEAMPJG@THRSERV?3?5allocatedarg?$FL1?$FN?5?9?$DO?5?$CFs?5@ ; `string'
PUBLIC	??_C@_0BN@JKCEMIBF@Process?5launched?5failed?5?$CFs?$AN?6@ ; `string'
PUBLIC	??_C@_0N@DJMEAOIO@Returning?5?$AN?6@		; `string'
PUBLIC	??_C@_0BB@CCMNFELK@Signal?5Return?5?$AN?6@	; `string'
EXTRN	AuGetCurrentThread:PROC
EXTRN	AuBlockThread:PROC
EXTRN	AuSleepThread:PROC
EXTRN	AuForceScheduler:PROC
EXTRN	AuGetSystemTimerTick:PROC
EXTRN	?AuProcessFindPID@@YAPEAU_au_proc_@@H@Z:PROC	; AuProcessFindPID
EXTRN	?AuProcessFindThread@@YAPEAU_au_proc_@@PEAU_au_thread_@@@Z:PROC ; AuProcessFindThread
EXTRN	?AuProcessFindSubThread@@YAPEAU_au_proc_@@PEAU_au_thread_@@@Z:PROC ; AuProcessFindSubThread
EXTRN	?AuCreateProcessSlot@@YAPEAU_au_proc_@@PEAU1@PEAD@Z:PROC ; AuCreateProcessSlot
EXTRN	?AuProcessExit@@YAXPEAU_au_proc_@@_N@Z:PROC	; AuProcessExit
EXTRN	?AuProcessWaitForTermination@@YAXPEAU_au_proc_@@H@Z:PROC ; AuProcessWaitForTermination
EXTRN	?AuCreateUserthread@@YAHPEAU_au_proc_@@P6AXPEAX@ZPEAD@Z:PROC ; AuCreateUserthread
EXTRN	AuGetCurrentTime:PROC
EXTRN	?AuSendSignal@@YAXGH@Z:PROC			; AuSendSignal
EXTRN	x64_cli:PROC
EXTRN	x64_force_sched:PROC
EXTRN	strlen:PROC
EXTRN	memset:PROC
EXTRN	SeTextOut:PROC
EXTRN	?AuLoadExecToProcess@@YAHPEAU_au_proc_@@PEADHPEAPEAD@Z:PROC ; AuLoadExecToProcess
EXTRN	kmalloc:PROC
EXTRN	kfree:PROC
EXTRN	AuTextOut:PROC
EXTRN	__CheckForDebuggerJustMyCode:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$?PauseThread@@YAHXZ DD imagerel $LN3
	DD	imagerel $LN3+62
	DD	imagerel $unwind$?PauseThread@@YAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetThreadID@@YAGXZ DD imagerel $LN4
	DD	imagerel $LN4+63
	DD	imagerel $unwind$?GetThreadID@@YAGXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetProcessID@@YAHXZ DD imagerel $LN6
	DD	imagerel $LN6+105
	DD	imagerel $unwind$?GetProcessID@@YAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ProcessExit@@YAHXZ DD imagerel $LN4
	DD	imagerel $LN4+83
	DD	imagerel $unwind$?ProcessExit@@YAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ProcessWaitForTermination@@YAHH@Z DD imagerel $LN3
	DD	imagerel $LN3+73
	DD	imagerel $unwind$?ProcessWaitForTermination@@YAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?CreateProcess@@YAHHPEAD@Z DD imagerel $LN4
	DD	imagerel $LN4+77
	DD	imagerel $unwind$?CreateProcess@@YAHHPEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ProcessLoadExec@@YAHHPEADHPEAPEAD@Z DD imagerel $LN14
	DD	imagerel $LN14+426
	DD	imagerel $unwind$?ProcessLoadExec@@YAHHPEADHPEAPEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ProcessSleep@@YAH_K@Z DD imagerel $LN5
	DD	imagerel $LN5+107
	DD	imagerel $unwind$?ProcessSleep@@YAH_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?SignalReturn@@YAXH@Z DD imagerel $LN3
	DD	imagerel $LN3+49
	DD	imagerel $unwind$?SignalReturn@@YAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?SetSignal@@YAHHP6AXH@Z@Z DD imagerel $LN4
	DD	imagerel $LN4+77
	DD	imagerel $unwind$?SetSignal@@YAHHP6AXH@Z@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetSystemTimerTick@@YA_KXZ DD imagerel $LN3
	DD	imagerel $LN3+34
	DD	imagerel $unwind$?GetSystemTimerTick@@YA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?CreateUserThread@@YAHP6AXPEAX@ZPEAD@Z DD imagerel $LN6
	DD	imagerel $LN6+133
	DD	imagerel $unwind$?CreateUserThread@@YAHP6AXPEAX@ZPEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?CloseUserThread@@YAHH@Z DD imagerel $LN4
	DD	imagerel $LN4+72
	DD	imagerel $unwind$?CloseUserThread@@YAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?SetFileToProcess@@YAHHHH@Z DD imagerel $LN10
	DD	imagerel $LN10+268
	DD	imagerel $unwind$?SetFileToProcess@@YAHHHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?SendSignal@@YAHHH@Z DD imagerel $LN5
	DD	imagerel $LN5+114
	DD	imagerel $unwind$?SendSignal@@YAHHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetCurrentTime@@YAHPEAX@Z DD imagerel $LN3
	DD	imagerel $LN3+52
	DD	imagerel $unwind$?GetCurrentTime@@YAHPEAX@Z
pdata	ENDS
;	COMDAT ??_C@_0BB@CCMNFELK@Signal?5Return?5?$AN?6@
CONST	SEGMENT
??_C@_0BB@CCMNFELK@Signal?5Return?5?$AN?6@ DB 'Signal Return ', 0dH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DJMEAOIO@Returning?5?$AN?6@
CONST	SEGMENT
??_C@_0N@DJMEAOIO@Returning?5?$AN?6@ DB 'Returning ', 0dH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@JKCEMIBF@Process?5launched?5failed?5?$CFs?$AN?6@
CONST	SEGMENT
??_C@_0BN@JKCEMIBF@Process?5launched?5failed?5?$CFs?$AN?6@ DB 'Process la'
	DB	'unched failed %s', 0dH, 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@CMEAMPJG@THRSERV?3?5allocatedarg?$FL1?$FN?5?9?$DO?5?$CFs?5@
CONST	SEGMENT
??_C@_0CC@CMEAMPJG@THRSERV?3?5allocatedarg?$FL1?$FN?5?9?$DO?5?$CFs?5@ DB 'T'
	DB	'HRSERV: allocatedarg[1] -> %s ', 0dH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@PDJGFKAF@No?5process?5found?5?6@
CONST	SEGMENT
??_C@_0BD@PDJGFKAF@No?5process?5found?5?6@ DB 'No process found ', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetCurrentTime@@YAHPEAX@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?SendSignal@@YAHHH@Z DD 025031201H
	DD	0d20d2312H
	DD	05009H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?SetFileToProcess@@YAHHHH@Z DD 025041a01H
	DD	0115231aH
	DD	0500e0012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?CloseUserThread@@YAHH@Z DD 025030e01H
	DD	0d209230eH
	DD	05005H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?CreateUserThread@@YAHP6AXPEAX@ZPEAD@Z DD 025031701H
	DD	0f2122317H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetSystemTimerTick@@YA_KXZ DD 025030b01H
	DD	0b206230bH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?SetSignal@@YAHHP6AXH@Z@Z DD 025031301H
	DD	0d20e2313H
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?SignalReturn@@YAXH@Z DD 025030e01H
	DD	0b209230eH
	DD	05005H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ProcessSleep@@YAH_K@Z DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ProcessLoadExec@@YAHHPEADHPEAPEAD@Z DD 025042001H
	DD	011b2320H
	DD	050140012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?CreateProcess@@YAHHPEAD@Z DD 025031301H
	DD	0d20e2313H
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ProcessWaitForTermination@@YAHH@Z DD 025030e01H
	DD	0d209230eH
	DD	05005H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ProcessExit@@YAHXZ DD 025030b01H
	DD	0d206230bH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetProcessID@@YAHXZ DD 025030b01H
	DD	0d206230bH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetThreadID@@YAGXZ DD 025030b01H
	DD	0d206230bH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?PauseThread@@YAHXZ DD 025030b01H
	DD	0d206230bH
	DD	05002H
xdata	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Serv\thrserv.cpp
;	COMDAT ?GetCurrentTime@@YAHPEAX@Z
_TEXT	SEGMENT
ptr$ = 80
?GetCurrentTime@@YAHPEAX@Z PROC				; GetCurrentTime, COMDAT

; 335  : int GetCurrentTime(void* ptr) {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__ABA981AA_thrserv@cpp
	call	__CheckForDebuggerJustMyCode

; 336  : 	x64_cli();

	call	x64_cli

; 337  : 	AuGetCurrentTime((AuTime*)ptr);

	mov	rcx, QWORD PTR ptr$[rbp]
	call	AuGetCurrentTime

; 338  : 	return 1;

	mov	eax, 1

; 339  : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
?GetCurrentTime@@YAHPEAX@Z ENDP				; GetCurrentTime
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Serv\thrserv.cpp
;	COMDAT ?SendSignal@@YAHHH@Z
_TEXT	SEGMENT
proc$ = 0
mainthr$ = 8
pid$ = 96
signo$ = 104
?SendSignal@@YAHHH@Z PROC				; SendSignal, COMDAT

; 318  : int SendSignal(int pid,int signo) {

$LN5:
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__ABA981AA_thrserv@cpp
	call	__CheckForDebuggerJustMyCode

; 319  : 	x64_cli();

	call	x64_cli

; 320  : 	AuProcess* proc = AuProcessFindPID(pid);

	mov	ecx, DWORD PTR pid$[rbp]
	call	?AuProcessFindPID@@YAPEAU_au_proc_@@H@Z	; AuProcessFindPID
	mov	QWORD PTR proc$[rbp], rax

; 321  : 	if (!proc)

	cmp	QWORD PTR proc$[rbp], 0
	jne	SHORT $LN2@SendSignal

; 322  : 		return -1;

	mov	eax, -1
	jmp	SHORT $LN1@SendSignal
$LN2@SendSignal:

; 323  : 
; 324  : 	AuThread* mainthr = proc->main_thread;

	mov	rax, QWORD PTR proc$[rbp]
	mov	rax, QWORD PTR [rax+70]
	mov	QWORD PTR mainthr$[rbp], rax

; 325  : 	if (!mainthr)

	cmp	QWORD PTR mainthr$[rbp], 0
	jne	SHORT $LN3@SendSignal

; 326  : 		return -1;

	mov	eax, -1
	jmp	SHORT $LN1@SendSignal
$LN3@SendSignal:

; 327  : 	AuSendSignal(mainthr->id, signo);

	mov	edx, DWORD PTR signo$[rbp]
	mov	rax, QWORD PTR mainthr$[rbp]
	movzx	ecx, WORD PTR [rax+301]
	call	?AuSendSignal@@YAXGH@Z			; AuSendSignal

; 328  : 	return 0;

	xor	eax, eax
$LN1@SendSignal:

; 329  : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
?SendSignal@@YAHHH@Z ENDP				; SendSignal
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Serv\thrserv.cpp
;	COMDAT ?SetFileToProcess@@YAHHHH@Z
_TEXT	SEGMENT
thr$ = 0
proc$ = 8
destproc$ = 16
file$ = 24
destfile$ = 32
fileno$ = 128
dest_fdidx$ = 136
proc_id$ = 144
?SetFileToProcess@@YAHHHH@Z PROC			; SetFileToProcess, COMDAT

; 266  : int SetFileToProcess(int fileno, int dest_fdidx, int proc_id) {

$LN10:
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	push	rbp
	sub	rsp, 144				; 00000090H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__ABA981AA_thrserv@cpp
	call	__CheckForDebuggerJustMyCode

; 267  : 	x64_cli();

	call	x64_cli

; 268  : 	AuThread* thr = AuGetCurrentThread();

	call	AuGetCurrentThread
	mov	QWORD PTR thr$[rbp], rax

; 269  : 	if (!thr)

	cmp	QWORD PTR thr$[rbp], 0
	jne	SHORT $LN2@SetFileToP

; 270  : 		return 0;

	xor	eax, eax
	jmp	$LN1@SetFileToP
$LN2@SetFileToP:

; 271  : 	/* file check if current thread's process is
; 272  : 	 * found by checking twice, first by
; 273  : 	 * main thread checkup second by sub thread
; 274  : 	 * checkup
; 275  : 	 */
; 276  : 	AuProcess* proc = AuProcessFindThread(thr);

	mov	rcx, QWORD PTR thr$[rbp]
	call	?AuProcessFindThread@@YAPEAU_au_proc_@@PEAU_au_thread_@@@Z ; AuProcessFindThread
	mov	QWORD PTR proc$[rbp], rax

; 277  : 	if (!proc) {

	cmp	QWORD PTR proc$[rbp], 0
	jne	SHORT $LN3@SetFileToP

; 278  : 		proc = AuProcessFindSubThread(thr);

	mov	rcx, QWORD PTR thr$[rbp]
	call	?AuProcessFindSubThread@@YAPEAU_au_proc_@@PEAU_au_thread_@@@Z ; AuProcessFindSubThread
	mov	QWORD PTR proc$[rbp], rax

; 279  : 		if (!proc)

	cmp	QWORD PTR proc$[rbp], 0
	jne	SHORT $LN4@SetFileToP

; 280  : 			return -1;

	mov	eax, -1
	jmp	$LN1@SetFileToP
$LN4@SetFileToP:
$LN3@SetFileToP:

; 281  : 	}
; 282  : 
; 283  : 	/* now try getting the destination process by its
; 284  : 	* process id
; 285  : 	*/
; 286  : 	AuProcess* destproc = AuProcessFindPID(proc_id);

	mov	ecx, DWORD PTR proc_id$[rbp]
	call	?AuProcessFindPID@@YAPEAU_au_proc_@@H@Z	; AuProcessFindPID
	mov	QWORD PTR destproc$[rbp], rax

; 287  : 	if (!destproc)

	cmp	QWORD PTR destproc$[rbp], 0
	jne	SHORT $LN5@SetFileToP

; 288  : 		return -1;

	mov	eax, -1
	jmp	SHORT $LN1@SetFileToP
$LN5@SetFileToP:

; 289  : 
; 290  : 	/* now try getting the file from current process
; 291  : 	 * file entry
; 292  : 	 */
; 293  : 	AuVFSNode* file = proc->fds[fileno];

	movsxd	rax, DWORD PTR fileno$[rbp]
	mov	rcx, QWORD PTR proc$[rbp]
	mov	rax, QWORD PTR [rcx+rax*8+567]
	mov	QWORD PTR file$[rbp], rax

; 294  : 	if (!file)

	cmp	QWORD PTR file$[rbp], 0
	jne	SHORT $LN6@SetFileToP

; 295  : 		return -1;

	mov	eax, -1
	jmp	SHORT $LN1@SetFileToP
$LN6@SetFileToP:

; 296  : 
; 297  : 	AuVFSNode *destfile = destproc->fds[dest_fdidx];

	movsxd	rax, DWORD PTR dest_fdidx$[rbp]
	mov	rcx, QWORD PTR destproc$[rbp]
	mov	rax, QWORD PTR [rcx+rax*8+567]
	mov	QWORD PTR destfile$[rbp], rax

; 298  : 	if (destfile)

	cmp	QWORD PTR destfile$[rbp], 0
	je	SHORT $LN7@SetFileToP

; 299  : 		return -1;

	mov	eax, -1
	jmp	SHORT $LN1@SetFileToP
	jmp	SHORT $LN8@SetFileToP
$LN7@SetFileToP:

; 300  : 	else {
; 301  : 		/* now we have no file entry in destination
; 302  : 		 * process's file index, so make entry
; 303  : 		 * of current process's file targeted by
; 304  : 		 * fileno to destination processes file
; 305  : 		 * entry 
; 306  : 		 */
; 307  : 		destproc->fds[dest_fdidx] = file;

	movsxd	rax, DWORD PTR dest_fdidx$[rbp]
	mov	rcx, QWORD PTR destproc$[rbp]
	mov	rdx, QWORD PTR file$[rbp]
	mov	QWORD PTR [rcx+rax*8+567], rdx

; 308  : 		file->fileCopyCount += 1;

	mov	rax, QWORD PTR file$[rbp]
	movzx	eax, WORD PTR [rax+72]
	inc	eax
	mov	rcx, QWORD PTR file$[rbp]
	mov	WORD PTR [rcx+72], ax
$LN8@SetFileToP:
$LN1@SetFileToP:

; 309  : 	}
; 310  : }

	lea	rsp, QWORD PTR [rbp+112]
	pop	rbp
	ret	0
?SetFileToProcess@@YAHHHH@Z ENDP			; SetFileToProcess
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Serv\thrserv.cpp
;	COMDAT ?CloseUserThread@@YAHH@Z
_TEXT	SEGMENT
thr$ = 0
proc$ = 8
thread_idx$ = 96
?CloseUserThread@@YAHH@Z PROC				; CloseUserThread, COMDAT

; 248  : int CloseUserThread(int thread_idx) {

$LN4:
	mov	DWORD PTR [rsp+8], ecx
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__ABA981AA_thrserv@cpp
	call	__CheckForDebuggerJustMyCode

; 249  : 	x64_cli();

	call	x64_cli

; 250  : 	AuThread* thr = AuGetCurrentThread();

	call	AuGetCurrentThread
	mov	QWORD PTR thr$[rbp], rax

; 251  : 	if (!thr)

	cmp	QWORD PTR thr$[rbp], 0
	jne	SHORT $LN2@CloseUserT

; 252  : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@CloseUserT
$LN2@CloseUserT:

; 253  : 	AuProcess* proc = AuProcessFindThread(thr);

	mov	rcx, QWORD PTR thr$[rbp]
	call	?AuProcessFindThread@@YAPEAU_au_proc_@@PEAU_au_thread_@@@Z ; AuProcessFindThread
	mov	QWORD PTR proc$[rbp], rax

; 254  : 
; 255  : 	/* under development*/
; 256  : 	return 0; //NOT IMPLEMENTED

	xor	eax, eax
$LN1@CloseUserT:

; 257  : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
?CloseUserThread@@YAHH@Z ENDP				; CloseUserThread
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Serv\thrserv.cpp
;	COMDAT ?CreateUserThread@@YAHP6AXPEAX@ZPEAD@Z
_TEXT	SEGMENT
thr$ = 0
proc$ = 8
idx$ = 16
entry$ = 112
name$ = 120
?CreateUserThread@@YAHP6AXPEAX@ZPEAD@Z PROC		; CreateUserThread, COMDAT

; 225  : int CreateUserThread(void(*entry) (void*), char *name){

$LN6:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 128				; 00000080H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__ABA981AA_thrserv@cpp
	call	__CheckForDebuggerJustMyCode

; 226  : 	x64_cli();

	call	x64_cli

; 227  : 	AuThread* thr = AuGetCurrentThread();

	call	AuGetCurrentThread
	mov	QWORD PTR thr$[rbp], rax

; 228  : 	if (!thr)

	cmp	QWORD PTR thr$[rbp], 0
	jne	SHORT $LN2@CreateUser

; 229  : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@CreateUser
$LN2@CreateUser:

; 230  : 	AuProcess* proc = AuProcessFindThread(thr);

	mov	rcx, QWORD PTR thr$[rbp]
	call	?AuProcessFindThread@@YAPEAU_au_proc_@@PEAU_au_thread_@@@Z ; AuProcessFindThread
	mov	QWORD PTR proc$[rbp], rax

; 231  : 	if (!proc) {

	cmp	QWORD PTR proc$[rbp], 0
	jne	SHORT $LN3@CreateUser

; 232  : 		proc = AuProcessFindSubThread(thr);

	mov	rcx, QWORD PTR thr$[rbp]
	call	?AuProcessFindSubThread@@YAPEAU_au_proc_@@PEAU_au_thread_@@@Z ; AuProcessFindSubThread
	mov	QWORD PTR proc$[rbp], rax

; 233  : 		if (!proc)

	cmp	QWORD PTR proc$[rbp], 0
	jne	SHORT $LN4@CreateUser

; 234  : 			return 0;

	xor	eax, eax
	jmp	SHORT $LN1@CreateUser
$LN4@CreateUser:
$LN3@CreateUser:

; 235  : 	}
; 236  : 	int idx = AuCreateUserthread(proc, entry, name);

	mov	r8, QWORD PTR name$[rbp]
	mov	rdx, QWORD PTR entry$[rbp]
	mov	rcx, QWORD PTR proc$[rbp]
	call	?AuCreateUserthread@@YAHPEAU_au_proc_@@P6AXPEAX@ZPEAD@Z ; AuCreateUserthread
	mov	DWORD PTR idx$[rbp], eax

; 237  : 	return idx;

	mov	eax, DWORD PTR idx$[rbp]
$LN1@CreateUser:

; 238  : }

	lea	rsp, QWORD PTR [rbp+96]
	pop	rbp
	ret	0
?CreateUserThread@@YAHP6AXPEAX@ZPEAD@Z ENDP		; CreateUserThread
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Serv\thrserv.cpp
;	COMDAT ?GetSystemTimerTick@@YA_KXZ
_TEXT	SEGMENT
?GetSystemTimerTick@@YA_KXZ PROC			; GetSystemTimerTick, COMDAT

; 216  : size_t GetSystemTimerTick() {

$LN3:
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__ABA981AA_thrserv@cpp
	call	__CheckForDebuggerJustMyCode

; 217  : 	return AuGetSystemTimerTick();

	call	AuGetSystemTimerTick

; 218  : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
?GetSystemTimerTick@@YA_KXZ ENDP			; GetSystemTimerTick
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Serv\thrserv.cpp
;	COMDAT ?SetSignal@@YAHHP6AXH@Z@Z
_TEXT	SEGMENT
thr$ = 0
signo$ = 96
handler$ = 104
?SetSignal@@YAHHP6AXH@Z@Z PROC				; SetSignal, COMDAT

; 205  : int SetSignal(int signo, AuSigHandler handler){

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__ABA981AA_thrserv@cpp
	call	__CheckForDebuggerJustMyCode

; 206  : 	AuThread* thr = AuGetCurrentThread();

	call	AuGetCurrentThread
	mov	QWORD PTR thr$[rbp], rax

; 207  : 	if (!thr)

	cmp	QWORD PTR thr$[rbp], 0
	jne	SHORT $LN2@SetSignal

; 208  : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@SetSignal
$LN2@SetSignal:

; 209  : 	thr->singals[signo] = handler;

	movsxd	rax, DWORD PTR signo$[rbp]
	mov	rcx, QWORD PTR thr$[rbp]
	mov	rdx, QWORD PTR handler$[rbp]
	mov	QWORD PTR [rcx+rax*8+312], rdx
$LN1@SetSignal:

; 210  : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
?SetSignal@@YAHHP6AXH@Z@Z ENDP				; SetSignal
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Serv\thrserv.cpp
;	COMDAT ?SignalReturn@@YAXH@Z
_TEXT	SEGMENT
num$ = 80
?SignalReturn@@YAXH@Z PROC				; SignalReturn, COMDAT

; 194  : void SignalReturn(int num) {

$LN3:
	mov	DWORD PTR [rsp+8], ecx
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__ABA981AA_thrserv@cpp
	call	__CheckForDebuggerJustMyCode

; 195  : 	x64_cli();

	call	x64_cli

; 196  : 	SeTextOut("Signal Return \r\n");

	lea	rcx, OFFSET FLAT:??_C@_0BB@CCMNFELK@Signal?5Return?5?$AN?6@
	call	SeTextOut

; 197  : 	/* just make a page fault */
; 198  : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
?SignalReturn@@YAXH@Z ENDP				; SignalReturn
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Serv\thrserv.cpp
;	COMDAT ?ProcessSleep@@YAH_K@Z
_TEXT	SEGMENT
sleep_time$ = 0
current_thr$ = 8
ms$ = 96
?ProcessSleep@@YAH_K@Z PROC				; ProcessSleep, COMDAT

; 179  : int ProcessSleep(uint64_t ms) {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__ABA981AA_thrserv@cpp
	call	__CheckForDebuggerJustMyCode

; 180  : 	x64_cli();

	call	x64_cli

; 181  : 	uint64_t sleep_time = ms * 1000;

	imul	rax, QWORD PTR ms$[rbp], 1000		; 000003e8H
	mov	QWORD PTR sleep_time$[rbp], rax

; 182  : 	AuThread* current_thr = AuGetCurrentThread();

	call	AuGetCurrentThread
	mov	QWORD PTR current_thr$[rbp], rax

; 183  : 	if (!current_thr)

	cmp	QWORD PTR current_thr$[rbp], 0
	jne	SHORT $LN2@ProcessSle

; 184  : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@ProcessSle
$LN2@ProcessSle:

; 185  : 	if (current_thr->pendingSigCount > 0)

	mov	rax, QWORD PTR current_thr$[rbp]
	movzx	eax, BYTE PTR [rax+632]
	test	eax, eax
	jle	SHORT $LN3@ProcessSle

; 186  : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@ProcessSle
$LN3@ProcessSle:

; 187  : 	AuSleepThread(current_thr, sleep_time);

	mov	rdx, QWORD PTR sleep_time$[rbp]
	mov	rcx, QWORD PTR current_thr$[rbp]
	call	AuSleepThread

; 188  : 	AuForceScheduler();

	call	AuForceScheduler
$LN1@ProcessSle:

; 189  : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
?ProcessSleep@@YAH_K@Z ENDP				; ProcessSleep
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Serv\thrserv.cpp
;	COMDAT ?ProcessLoadExec@@YAHHPEADHPEAPEAD@Z
_TEXT	SEGMENT
proc$ = 0
char_cnt$ = 8
i$1 = 12
l$2 = 16
allocated_argv$ = 24
i$3 = 32
status$ = 36
proc_id$ = 128
filename$ = 136
argc$ = 144
argv$ = 152
?ProcessLoadExec@@YAHHPEADHPEAPEAD@Z PROC		; ProcessLoadExec, COMDAT

; 126  : int ProcessLoadExec(int proc_id, char* filename,int argc, char** argv) {

$LN14:
	mov	QWORD PTR [rsp+32], r9
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	push	rbp
	sub	rsp, 144				; 00000090H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__ABA981AA_thrserv@cpp
	call	__CheckForDebuggerJustMyCode

; 127  : 	x64_cli();

	call	x64_cli

; 128  : 	AuProcess* proc = AuProcessFindPID(proc_id);

	mov	ecx, DWORD PTR proc_id$[rbp]
	call	?AuProcessFindPID@@YAPEAU_au_proc_@@H@Z	; AuProcessFindPID
	mov	QWORD PTR proc$[rbp], rax

; 129  : 	//SeTextOut("Loading process -> %s \r\n", filename);
; 130  : 	if (!proc) {

	cmp	QWORD PTR proc$[rbp], 0
	jne	SHORT $LN8@ProcessLoa

; 131  : 		AuTextOut("No process found \n");

	lea	rcx, OFFSET FLAT:??_C@_0BD@PDJGFKAF@No?5process?5found?5?6@
	call	AuTextOut

; 132  : 		return -1;

	mov	eax, -1
	jmp	$LN1@ProcessLoa
$LN8@ProcessLoa:

; 133  : 	}
; 134  : 	
; 135  : 	/* prepare stuffs for passing arguments */
; 136  : 	int char_cnt = 0;

	mov	DWORD PTR char_cnt$[rbp], 0

; 137  : 	for (int i = 0; i < argc; i++) {

	mov	DWORD PTR i$1[rbp], 0
	jmp	SHORT $LN4@ProcessLoa
$LN2@ProcessLoa:
	mov	eax, DWORD PTR i$1[rbp]
	inc	eax
	mov	DWORD PTR i$1[rbp], eax
$LN4@ProcessLoa:
	mov	eax, DWORD PTR argc$[rbp]
	cmp	DWORD PTR i$1[rbp], eax
	jge	SHORT $LN3@ProcessLoa

; 138  : 		size_t l = strlen(argv[i]);

	movsxd	rax, DWORD PTR i$1[rbp]
	mov	rcx, QWORD PTR argv$[rbp]
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	strlen
	mov	QWORD PTR l$2[rbp], rax

; 139  : 		char_cnt += l; 

	movsxd	rax, DWORD PTR char_cnt$[rbp]
	add	rax, QWORD PTR l$2[rbp]
	mov	DWORD PTR char_cnt$[rbp], eax

; 140  : 	}

	jmp	SHORT $LN2@ProcessLoa
$LN3@ProcessLoa:

; 141  : 	
; 142  : 	char** allocated_argv = 0;

	mov	QWORD PTR allocated_argv$[rbp], 0

; 143  : 	if (char_cnt > 0) {

	cmp	DWORD PTR char_cnt$[rbp], 0
	jle	SHORT $LN9@ProcessLoa

; 144  : 		/*
; 145  : 		 BUGG:kmalloc: mentioned in loader.cpp inside AuLoadExecToProcess 
; 146  : 		 */
; 147  : 		allocated_argv = (char**)kmalloc(argc * sizeof(char*));

	movsxd	rax, DWORD PTR argc$[rbp]
	shl	rax, 3
	mov	ecx, eax
	call	kmalloc
	mov	QWORD PTR allocated_argv$[rbp], rax

; 148  : 		memset(allocated_argv, 0, argc * sizeof(char*));

	movsxd	rax, DWORD PTR argc$[rbp]
	shl	rax, 3
	mov	r8d, eax
	xor	edx, edx
	mov	rcx, QWORD PTR allocated_argv$[rbp]
	call	memset

; 149  : 		for (int i = 0; i < argc; i++){

	mov	DWORD PTR i$3[rbp], 0
	jmp	SHORT $LN7@ProcessLoa
$LN5@ProcessLoa:
	mov	eax, DWORD PTR i$3[rbp]
	inc	eax
	mov	DWORD PTR i$3[rbp], eax
$LN7@ProcessLoa:
	mov	eax, DWORD PTR argc$[rbp]
	cmp	DWORD PTR i$3[rbp], eax
	jge	SHORT $LN6@ProcessLoa

; 150  : 			/*
; 151  : 			 * TRICKY: char pointers from argv[i] is already allocated
; 152  : 			 * in XEShell while spawning the process in order to pass
; 153  : 			 * argument, so we use those allocated user memory areas
; 154  : 			 * directly inside the argument array and only this argument
; 155  : 			 * array will get freed while loading the process, pointer
; 156  : 			 * memory will get freed in XEShell itself
; 157  : 			 */
; 158  : 			allocated_argv[i] = argv[i];

	movsxd	rax, DWORD PTR i$3[rbp]
	movsxd	rcx, DWORD PTR i$3[rbp]
	mov	rdx, QWORD PTR allocated_argv$[rbp]
	mov	r8, QWORD PTR argv$[rbp]
	mov	rax, QWORD PTR [r8+rax*8]
	mov	QWORD PTR [rdx+rcx*8], rax

; 159  : 		}

	jmp	SHORT $LN5@ProcessLoa
$LN6@ProcessLoa:
$LN9@ProcessLoa:

; 160  : 	}
; 161  : 	if (argc > 1)

	cmp	DWORD PTR argc$[rbp], 1
	jle	SHORT $LN10@ProcessLoa

; 162  : 		SeTextOut("THRSERV: allocatedarg[1] -> %s \r\n", allocated_argv[1]);

	mov	eax, 8
	imul	rax, rax, 1
	mov	rcx, QWORD PTR allocated_argv$[rbp]
	mov	rdx, QWORD PTR [rcx+rax]
	lea	rcx, OFFSET FLAT:??_C@_0CC@CMEAMPJG@THRSERV?3?5allocatedarg?$FL1?$FN?5?9?$DO?5?$CFs?5@
	call	SeTextOut
$LN10@ProcessLoa:

; 163  : 	int status = AuLoadExecToProcess(proc, filename, argc,allocated_argv);

	mov	r9, QWORD PTR allocated_argv$[rbp]
	mov	r8d, DWORD PTR argc$[rbp]
	mov	rdx, QWORD PTR filename$[rbp]
	mov	rcx, QWORD PTR proc$[rbp]
	call	?AuLoadExecToProcess@@YAHPEAU_au_proc_@@PEADHPEAPEAD@Z ; AuLoadExecToProcess
	mov	DWORD PTR status$[rbp], eax

; 164  : 	if (status == -1) {

	cmp	DWORD PTR status$[rbp], -1
	jne	SHORT $LN11@ProcessLoa

; 165  : 		if (allocated_argv)

	cmp	QWORD PTR allocated_argv$[rbp], 0
	je	SHORT $LN12@ProcessLoa

; 166  : 			kfree(allocated_argv);

	mov	rcx, QWORD PTR allocated_argv$[rbp]
	call	kfree
$LN12@ProcessLoa:

; 167  : 		SeTextOut("Process launched failed %s\r\n", filename);

	mov	rdx, QWORD PTR filename$[rbp]
	lea	rcx, OFFSET FLAT:??_C@_0BN@JKCEMIBF@Process?5launched?5failed?5?$CFs?$AN?6@
	call	SeTextOut

; 168  : 		AuProcessExit(proc, true);

	mov	dl, 1
	mov	rcx, QWORD PTR proc$[rbp]
	call	?AuProcessExit@@YAXPEAU_au_proc_@@_N@Z	; AuProcessExit

; 169  : 		SeTextOut("Returning \r\n");

	lea	rcx, OFFSET FLAT:??_C@_0N@DJMEAOIO@Returning?5?$AN?6@
	call	SeTextOut

; 170  : 		return -1;

	mov	eax, -1
$LN11@ProcessLoa:
$LN1@ProcessLoa:

; 171  : 	}
; 172  : }

	lea	rsp, QWORD PTR [rbp+112]
	pop	rbp
	ret	0
?ProcessLoadExec@@YAHHPEADHPEAPEAD@Z ENDP		; ProcessLoadExec
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Serv\thrserv.cpp
;	COMDAT ?CreateProcess@@YAHHPEAD@Z
_TEXT	SEGMENT
slot$ = 0
parent_id$ = 96
name$ = 104
?CreateProcess@@YAHHPEAD@Z PROC				; CreateProcess, COMDAT

; 114  : int CreateProcess(int parent_id, char *name) {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__ABA981AA_thrserv@cpp
	call	__CheckForDebuggerJustMyCode

; 115  : 	x64_cli();

	call	x64_cli

; 116  : 	AuProcess* slot = AuCreateProcessSlot(0, name);

	mov	rdx, QWORD PTR name$[rbp]
	xor	ecx, ecx
	call	?AuCreateProcessSlot@@YAPEAU_au_proc_@@PEAU1@PEAD@Z ; AuCreateProcessSlot
	mov	QWORD PTR slot$[rbp], rax

; 117  : 	if (!slot)

	cmp	QWORD PTR slot$[rbp], 0
	jne	SHORT $LN2@CreateProc

; 118  : 		return -1;

	mov	eax, -1
	jmp	SHORT $LN1@CreateProc
$LN2@CreateProc:

; 119  : 	return slot->proc_id;

	mov	rax, QWORD PTR slot$[rbp]
	mov	eax, DWORD PTR [rax]
$LN1@CreateProc:

; 120  : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
?CreateProcess@@YAHHPEAD@Z ENDP				; CreateProcess
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Serv\thrserv.cpp
;	COMDAT ?ProcessWaitForTermination@@YAHH@Z
_TEXT	SEGMENT
current_thr$ = 0
proc$ = 8
pid$ = 96
?ProcessWaitForTermination@@YAHH@Z PROC			; ProcessWaitForTermination, COMDAT

; 101  : int ProcessWaitForTermination(int pid) {

$LN3:
	mov	DWORD PTR [rsp+8], ecx
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__ABA981AA_thrserv@cpp
	call	__CheckForDebuggerJustMyCode

; 102  : 	x64_cli();

	call	x64_cli

; 103  : 	AuThread* current_thr = AuGetCurrentThread();

	call	AuGetCurrentThread
	mov	QWORD PTR current_thr$[rbp], rax

; 104  : 	AuProcess* proc = AuProcessFindThread(current_thr);

	mov	rcx, QWORD PTR current_thr$[rbp]
	call	?AuProcessFindThread@@YAPEAU_au_proc_@@PEAU_au_thread_@@@Z ; AuProcessFindThread
	mov	QWORD PTR proc$[rbp], rax

; 105  : 	AuProcessWaitForTermination(proc, pid);

	mov	edx, DWORD PTR pid$[rbp]
	mov	rcx, QWORD PTR proc$[rbp]
	call	?AuProcessWaitForTermination@@YAXPEAU_au_proc_@@H@Z ; AuProcessWaitForTermination

; 106  : 	return 0;

	xor	eax, eax

; 107  : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
?ProcessWaitForTermination@@YAHH@Z ENDP			; ProcessWaitForTermination
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Serv\thrserv.cpp
;	COMDAT ?ProcessExit@@YAHXZ
_TEXT	SEGMENT
current_thr$ = 0
proc$ = 8
?ProcessExit@@YAHXZ PROC				; ProcessExit, COMDAT

; 86   : int ProcessExit() {

$LN4:
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__ABA981AA_thrserv@cpp
	call	__CheckForDebuggerJustMyCode

; 87   : 	x64_cli();

	call	x64_cli

; 88   : 	AuThread* current_thr = AuGetCurrentThread();

	call	AuGetCurrentThread
	mov	QWORD PTR current_thr$[rbp], rax

; 89   : 	AuProcess* proc = AuProcessFindThread(current_thr);

	mov	rcx, QWORD PTR current_thr$[rbp]
	call	?AuProcessFindThread@@YAPEAU_au_proc_@@PEAU_au_thread_@@@Z ; AuProcessFindThread
	mov	QWORD PTR proc$[rbp], rax

; 90   : 	if (!proc)

	cmp	QWORD PTR proc$[rbp], 0
	jne	SHORT $LN2@ProcessExi

; 91   : 		return 1;

	mov	eax, 1
	jmp	SHORT $LN1@ProcessExi
$LN2@ProcessExi:

; 92   : 	AuProcessExit(proc, true);

	mov	dl, 1
	mov	rcx, QWORD PTR proc$[rbp]
	call	?AuProcessExit@@YAXPEAU_au_proc_@@_N@Z	; AuProcessExit

; 93   : 	return 0;

	xor	eax, eax
$LN1@ProcessExi:

; 94   : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
?ProcessExit@@YAHXZ ENDP				; ProcessExit
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Serv\thrserv.cpp
;	COMDAT ?GetProcessID@@YAHXZ
_TEXT	SEGMENT
current_thr$ = 0
proc$ = 8
?GetProcessID@@YAHXZ PROC				; GetProcessID, COMDAT

; 68   : int GetProcessID() {

$LN6:
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__ABA981AA_thrserv@cpp
	call	__CheckForDebuggerJustMyCode

; 69   : 	AuThread * current_thr = AuGetCurrentThread();

	call	AuGetCurrentThread
	mov	QWORD PTR current_thr$[rbp], rax

; 70   : 	if (!current_thr)

	cmp	QWORD PTR current_thr$[rbp], 0
	jne	SHORT $LN2@GetProcess

; 71   : 		return -1;

	mov	eax, -1
	jmp	SHORT $LN1@GetProcess
$LN2@GetProcess:

; 72   : 	AuProcess* proc = AuProcessFindThread(current_thr);

	mov	rcx, QWORD PTR current_thr$[rbp]
	call	?AuProcessFindThread@@YAPEAU_au_proc_@@PEAU_au_thread_@@@Z ; AuProcessFindThread
	mov	QWORD PTR proc$[rbp], rax

; 73   : 	if (!proc){

	cmp	QWORD PTR proc$[rbp], 0
	jne	SHORT $LN3@GetProcess

; 74   : 		proc = AuProcessFindSubThread(current_thr);

	mov	rcx, QWORD PTR current_thr$[rbp]
	call	?AuProcessFindSubThread@@YAPEAU_au_proc_@@PEAU_au_thread_@@@Z ; AuProcessFindSubThread
	mov	QWORD PTR proc$[rbp], rax

; 75   : 		if (!proc){

	cmp	QWORD PTR proc$[rbp], 0
	jne	SHORT $LN4@GetProcess

; 76   : 			return -1;

	mov	eax, -1
	jmp	SHORT $LN1@GetProcess
$LN4@GetProcess:
$LN3@GetProcess:

; 77   : 		}
; 78   : 	}
; 79   : 	return proc->proc_id;

	mov	rax, QWORD PTR proc$[rbp]
	mov	eax, DWORD PTR [rax]
$LN1@GetProcess:

; 80   : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
?GetProcessID@@YAHXZ ENDP				; GetProcessID
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Serv\thrserv.cpp
;	COMDAT ?GetThreadID@@YAGXZ
_TEXT	SEGMENT
current_thr$ = 0
?GetThreadID@@YAGXZ PROC				; GetThreadID, COMDAT

; 57   : uint16_t GetThreadID() {

$LN4:
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__ABA981AA_thrserv@cpp
	call	__CheckForDebuggerJustMyCode

; 58   : 	AuThread* current_thr = AuGetCurrentThread();

	call	AuGetCurrentThread
	mov	QWORD PTR current_thr$[rbp], rax

; 59   : 	if (!current_thr)

	cmp	QWORD PTR current_thr$[rbp], 0
	jne	SHORT $LN2@GetThreadI

; 60   : 		return -1;

	mov	eax, 65535				; 0000ffffH
	jmp	SHORT $LN1@GetThreadI
$LN2@GetThreadI:

; 61   : 	return current_thr->id;

	mov	rax, QWORD PTR current_thr$[rbp]
	movzx	eax, WORD PTR [rax+301]
$LN1@GetThreadI:

; 62   : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
?GetThreadID@@YAGXZ ENDP				; GetThreadID
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Serv\thrserv.cpp
;	COMDAT ?PauseThread@@YAHXZ
_TEXT	SEGMENT
current_thr$ = 0
?PauseThread@@YAHXZ PROC				; PauseThread, COMDAT

; 46   : int PauseThread() {

$LN3:
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__ABA981AA_thrserv@cpp
	call	__CheckForDebuggerJustMyCode

; 47   : 	x64_cli();

	call	x64_cli

; 48   : 	AuThread * current_thr = AuGetCurrentThread();

	call	AuGetCurrentThread
	mov	QWORD PTR current_thr$[rbp], rax

; 49   : 	AuBlockThread(current_thr);

	mov	rcx, QWORD PTR current_thr$[rbp]
	call	AuBlockThread

; 50   : 	x64_force_sched();

	call	x64_force_sched

; 51   : 	return 1;

	mov	eax, 1

; 52   : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
?PauseThread@@YAHXZ ENDP				; PauseThread
_TEXT	ENDS
END
