; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30154.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?shmmaplist@@3PEAU_list_@@EA			; shmmaplist
_BSS	SEGMENT
?shmmaplist@@3PEAU_list_@@EA DQ 01H DUP (?)		; shmmaplist
_BSS	ENDS
msvcjmc	SEGMENT
__C365CCBF_mmap@cpp DB 01H
msvcjmc	ENDS
PUBLIC	?SharedMemMapListInitialise@@YAXXZ		; SharedMemMapListInitialise
PUBLIC	?CreateMemMapping@@YAPEAXPEAX_KHHH1@Z		; CreateMemMapping
PUBLIC	?MemMapDirty@@YAXPEAX_KHH@Z			; MemMapDirty
PUBLIC	?UnmapMemMapping@@YAXPEAX_K@Z			; UnmapMemMapping
PUBLIC	?AuCreateSharedMmapObject@@YAPEAU_sh_memap_object_@@PEAD@Z ; AuCreateSharedMmapObject
PUBLIC	?AuAddSharedMmapObject@@YAXPEAU_sh_memap_object_@@@Z ; AuAddSharedMmapObject
PUBLIC	?AuRemoveSharedMmapObject@@YAXPEAU_sh_memap_object_@@@Z ; AuRemoveSharedMmapObject
PUBLIC	?AuSharedMmapObjectFindByName@@YAPEAU_sh_memap_object_@@PEAD@Z ; AuSharedMmapObjectFindByName
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_01KMDKNFGN@?1@				; `string'
PUBLIC	??_C@_0BF@DDMMBABB@mmap?5reading?5file?5?$AN?6@	; `string'
PUBLIC	??_C@_0BN@BEEDHOIO@SHOBJ?5newly?5created?5?9?$DO?5?$CFs?5?$AN?6@ ; `string'
PUBLIC	??_C@_0BG@JHLECFAA@MemUnmap?5len?5?9?$DO?5?$CFd?5?$AN?6@ ; `string'
PUBLIC	??_C@_0BP@HEHILAKC@Mem?5Unmap?5len?5aligned?5?9?$DO?5?$CFd?5?$AN?6@ ; `string'
EXTRN	strcmp:PROC
EXTRN	strcpy:PROC
EXTRN	strlen:PROC
EXTRN	memset:PROC
EXTRN	AuVmmngrGetPage:PROC
EXTRN	AuMapPage:PROC
EXTRN	AuGetFreePage:PROC
EXTRN	AuPmmngrAlloc:PROC
EXTRN	AuPmmngrFree:PROC
EXTRN	kmalloc:PROC
EXTRN	kfree:PROC
EXTRN	initialize_list:PROC
EXTRN	list_add:PROC
EXTRN	list_remove:PROC
EXTRN	list_get_at:PROC
EXTRN	AuVFSFind:PROC
EXTRN	AuVFSNodeReadBlock:PROC
EXTRN	AuVFSGetBlockFor:PROC
EXTRN	AuGetCurrentThread:PROC
EXTRN	?AuProcessFindThread@@YAPEAU_au_proc_@@PEAU_au_thread_@@@Z:PROC ; AuProcessFindThread
EXTRN	SeTextOut:PROC
EXTRN	x64_cli:PROC
EXTRN	__CheckForDebuggerJustMyCode:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$?SharedMemMapListInitialise@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+41
	DD	imagerel $unwind$?SharedMemMapListInitialise@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?CreateMemMapping@@YAPEAXPEAX_KHHH1@Z DD imagerel $LN32
	DD	imagerel $LN32+1157
	DD	imagerel $unwind$?CreateMemMapping@@YAPEAXPEAX_KHHH1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?MemMapDirty@@YAXPEAX_KHH@Z DD imagerel $LN13
	DD	imagerel $LN13+390
	DD	imagerel $unwind$?MemMapDirty@@YAXPEAX_KHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?UnmapMemMapping@@YAXPEAX_K@Z DD imagerel $LN11
	DD	imagerel $LN11+366
	DD	imagerel $unwind$?UnmapMemMapping@@YAXPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuCreateSharedMmapObject@@YAPEAU_sh_memap_object_@@PEAD@Z DD imagerel $LN3
	DD	imagerel $LN3+125
	DD	imagerel $unwind$?AuCreateSharedMmapObject@@YAPEAU_sh_memap_object_@@PEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuAddSharedMmapObject@@YAXPEAU_sh_memap_object_@@@Z DD imagerel $LN3
	DD	imagerel $LN3+49
	DD	imagerel $unwind$?AuAddSharedMmapObject@@YAXPEAU_sh_memap_object_@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuRemoveSharedMmapObject@@YAXPEAU_sh_memap_object_@@@Z DD imagerel $LN7
	DD	imagerel $LN7+131
	DD	imagerel $unwind$?AuRemoveSharedMmapObject@@YAXPEAU_sh_memap_object_@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuSharedMmapObjectFindByName@@YAPEAU_sh_memap_object_@@PEAD@Z DD imagerel $LN7
	DD	imagerel $LN7+113
	DD	imagerel $unwind$?AuSharedMmapObjectFindByName@@YAPEAU_sh_memap_object_@@PEAD@Z
pdata	ENDS
;	COMDAT ??_C@_0BP@HEHILAKC@Mem?5Unmap?5len?5aligned?5?9?$DO?5?$CFd?5?$AN?6@
CONST	SEGMENT
??_C@_0BP@HEHILAKC@Mem?5Unmap?5len?5aligned?5?9?$DO?5?$CFd?5?$AN?6@ DB 'M'
	DB	'em Unmap len aligned -> %d ', 0dH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@JHLECFAA@MemUnmap?5len?5?9?$DO?5?$CFd?5?$AN?6@
CONST	SEGMENT
??_C@_0BG@JHLECFAA@MemUnmap?5len?5?9?$DO?5?$CFd?5?$AN?6@ DB 'MemUnmap len'
	DB	' -> %d ', 0dH, 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@BEEDHOIO@SHOBJ?5newly?5created?5?9?$DO?5?$CFs?5?$AN?6@
CONST	SEGMENT
??_C@_0BN@BEEDHOIO@SHOBJ?5newly?5created?5?9?$DO?5?$CFs?5?$AN?6@ DB 'SHOB'
	DB	'J newly created -> %s ', 0dH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@DDMMBABB@mmap?5reading?5file?5?$AN?6@
CONST	SEGMENT
??_C@_0BF@DDMMBABB@mmap?5reading?5file?5?$AN?6@ DB 'mmap reading file ', 0dH
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_01KMDKNFGN@?1@
CONST	SEGMENT
??_C@_01KMDKNFGN@?1@ DB '/', 00H			; `string'
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuSharedMmapObjectFindByName@@YAPEAU_sh_memap_object_@@PEAD@Z DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuRemoveSharedMmapObject@@YAXPEAU_sh_memap_object_@@@Z DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuAddSharedMmapObject@@YAXPEAU_sh_memap_object_@@@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuCreateSharedMmapObject@@YAPEAU_sh_memap_object_@@PEAD@Z DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?UnmapMemMapping@@YAXPEAX_K@Z DD 025041701H
	DD	01122317H
	DD	0500b0012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?MemMapDirty@@YAXPEAX_KHH@Z DD 025032101H
	DD	0f21c2321H
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?CreateMemMapping@@YAPEAXPEAX_KHHH1@Z DD 025042101H
	DD	011c2321H
	DD	05015001aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?SharedMemMapListInitialise@@YAXXZ DD 025030b01H
	DD	0b206230bH
	DD	05002H
xdata	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Mm\mmap.cpp
;	COMDAT ?AuSharedMmapObjectFindByName@@YAPEAU_sh_memap_object_@@PEAD@Z
_TEXT	SEGMENT
i$1 = 0
obj_$2 = 8
name$ = 96
?AuSharedMmapObjectFindByName@@YAPEAU_sh_memap_object_@@PEAD@Z PROC ; AuSharedMmapObjectFindByName, COMDAT

; 98   : AuSharedMmapObject* AuSharedMmapObjectFindByName(char* name) {

$LN7:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__C365CCBF_mmap@cpp
	call	__CheckForDebuggerJustMyCode

; 99   : 	for (int i = 0; i < shmmaplist->pointer; i++){

	mov	DWORD PTR i$1[rbp], 0
	jmp	SHORT $LN4@AuSharedMm
$LN2@AuSharedMm:
	mov	eax, DWORD PTR i$1[rbp]
	inc	eax
	mov	DWORD PTR i$1[rbp], eax
$LN4@AuSharedMm:
	mov	rax, QWORD PTR ?shmmaplist@@3PEAU_list_@@EA ; shmmaplist
	mov	eax, DWORD PTR [rax]
	cmp	DWORD PTR i$1[rbp], eax
	jae	SHORT $LN3@AuSharedMm

; 100  : 		AuSharedMmapObject* obj_ = (AuSharedMmapObject*)list_get_at(shmmaplist, i);

	mov	edx, DWORD PTR i$1[rbp]
	mov	rcx, QWORD PTR ?shmmaplist@@3PEAU_list_@@EA ; shmmaplist
	call	list_get_at
	mov	QWORD PTR obj_$2[rbp], rax

; 101  : 		if (strcmp(obj_->objectName, name) == 0)

	mov	rdx, QWORD PTR name$[rbp]
	mov	rax, QWORD PTR obj_$2[rbp]
	mov	rcx, QWORD PTR [rax]
	call	strcmp
	test	eax, eax
	jne	SHORT $LN5@AuSharedMm

; 102  : 			return obj_;

	mov	rax, QWORD PTR obj_$2[rbp]
	jmp	SHORT $LN1@AuSharedMm
$LN5@AuSharedMm:

; 103  : 	}

	jmp	SHORT $LN2@AuSharedMm
$LN3@AuSharedMm:

; 104  : 	return NULL;

	xor	eax, eax
$LN1@AuSharedMm:

; 105  : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
?AuSharedMmapObjectFindByName@@YAPEAU_sh_memap_object_@@PEAD@Z ENDP ; AuSharedMmapObjectFindByName
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Mm\mmap.cpp
;	COMDAT ?AuRemoveSharedMmapObject@@YAXPEAU_sh_memap_object_@@@Z
_TEXT	SEGMENT
i$1 = 0
obj_$2 = 8
obj$ = 96
?AuRemoveSharedMmapObject@@YAXPEAU_sh_memap_object_@@@Z PROC ; AuRemoveSharedMmapObject, COMDAT

; 88   : void AuRemoveSharedMmapObject(AuSharedMmapObject* obj) {

$LN7:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__C365CCBF_mmap@cpp
	call	__CheckForDebuggerJustMyCode

; 89   : 	for (int i = 0; i < shmmaplist->pointer; i++){

	mov	DWORD PTR i$1[rbp], 0
	jmp	SHORT $LN4@AuRemoveSh
$LN2@AuRemoveSh:
	mov	eax, DWORD PTR i$1[rbp]
	inc	eax
	mov	DWORD PTR i$1[rbp], eax
$LN4@AuRemoveSh:
	mov	rax, QWORD PTR ?shmmaplist@@3PEAU_list_@@EA ; shmmaplist
	mov	eax, DWORD PTR [rax]
	cmp	DWORD PTR i$1[rbp], eax
	jae	SHORT $LN3@AuRemoveSh

; 90   : 		AuSharedMmapObject* obj_ = (AuSharedMmapObject*)list_get_at(shmmaplist, i);

	mov	edx, DWORD PTR i$1[rbp]
	mov	rcx, QWORD PTR ?shmmaplist@@3PEAU_list_@@EA ; shmmaplist
	call	list_get_at
	mov	QWORD PTR obj_$2[rbp], rax

; 91   : 		if (obj_ == obj)

	mov	rax, QWORD PTR obj$[rbp]
	cmp	QWORD PTR obj_$2[rbp], rax
	jne	SHORT $LN5@AuRemoveSh

; 92   : 			list_remove(shmmaplist, i);

	mov	edx, DWORD PTR i$1[rbp]
	mov	rcx, QWORD PTR ?shmmaplist@@3PEAU_list_@@EA ; shmmaplist
	call	list_remove
$LN5@AuRemoveSh:

; 93   : 	}

	jmp	SHORT $LN2@AuRemoveSh
$LN3@AuRemoveSh:

; 94   : 	kfree(obj->objectName);

	mov	rax, QWORD PTR obj$[rbp]
	mov	rcx, QWORD PTR [rax]
	call	kfree

; 95   : 	kfree(obj);

	mov	rcx, QWORD PTR obj$[rbp]
	call	kfree

; 96   : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
?AuRemoveSharedMmapObject@@YAXPEAU_sh_memap_object_@@@Z ENDP ; AuRemoveSharedMmapObject
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Mm\mmap.cpp
;	COMDAT ?AuAddSharedMmapObject@@YAXPEAU_sh_memap_object_@@@Z
_TEXT	SEGMENT
obj$ = 80
?AuAddSharedMmapObject@@YAXPEAU_sh_memap_object_@@@Z PROC ; AuAddSharedMmapObject, COMDAT

; 84   : void AuAddSharedMmapObject(AuSharedMmapObject* obj) {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__C365CCBF_mmap@cpp
	call	__CheckForDebuggerJustMyCode

; 85   : 	list_add(shmmaplist, obj);

	mov	rdx, QWORD PTR obj$[rbp]
	mov	rcx, QWORD PTR ?shmmaplist@@3PEAU_list_@@EA ; shmmaplist
	call	list_add

; 86   : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
?AuAddSharedMmapObject@@YAXPEAU_sh_memap_object_@@@Z ENDP ; AuAddSharedMmapObject
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Mm\mmap.cpp
;	COMDAT ?AuCreateSharedMmapObject@@YAPEAU_sh_memap_object_@@PEAD@Z
_TEXT	SEGMENT
obj$ = 0
name$ = 96
?AuCreateSharedMmapObject@@YAPEAU_sh_memap_object_@@PEAD@Z PROC ; AuCreateSharedMmapObject, COMDAT

; 75   : AuSharedMmapObject* AuCreateSharedMmapObject(char* name) {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__C365CCBF_mmap@cpp
	call	__CheckForDebuggerJustMyCode

; 76   : 	AuSharedMmapObject* obj = (AuSharedMmapObject*)kmalloc(sizeof(AuSharedMmapObject));

	mov	ecx, 30
	call	kmalloc
	mov	QWORD PTR obj$[rbp], rax

; 77   : 	memset(obj, 0, sizeof(AuSharedMmapObject));

	mov	r8d, 30
	xor	edx, edx
	mov	rcx, QWORD PTR obj$[rbp]
	call	memset

; 78   : 	obj->objectName = (char*)kmalloc(strlen(name));

	mov	rcx, QWORD PTR name$[rbp]
	call	strlen
	mov	ecx, eax
	call	kmalloc
	mov	rcx, QWORD PTR obj$[rbp]
	mov	QWORD PTR [rcx], rax

; 79   : 	strcpy(obj->objectName, name);

	mov	rdx, QWORD PTR name$[rbp]
	mov	rax, QWORD PTR obj$[rbp]
	mov	rcx, QWORD PTR [rax]
	call	strcpy

; 80   : 	obj->linkCount += 1;

	mov	rax, QWORD PTR obj$[rbp]
	movzx	eax, WORD PTR [rax+26]
	inc	eax
	mov	rcx, QWORD PTR obj$[rbp]
	mov	WORD PTR [rcx+26], ax

; 81   : 	return obj;

	mov	rax, QWORD PTR obj$[rbp]

; 82   : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
?AuCreateSharedMmapObject@@YAPEAU_sh_memap_object_@@PEAD@Z ENDP ; AuCreateSharedMmapObject
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Mm\mmap.cpp
;	COMDAT ?UnmapMemMapping@@YAXPEAX_K@Z
_TEXT	SEGMENT
addr$ = 0
i$1 = 8
page$2 = 16
phys$3 = 24
tv75 = 96
tv71 = 96
address$ = 128
len$ = 136
?UnmapMemMapping@@YAXPEAX_K@Z PROC			; UnmapMemMapping, COMDAT

; 272  : void UnmapMemMapping(void* address, size_t len) {

$LN11:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 144				; 00000090H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__C365CCBF_mmap@cpp
	call	__CheckForDebuggerJustMyCode

; 273  : 	x64_cli();

	call	x64_cli

; 274  : 	if (!len)

	cmp	QWORD PTR len$[rbp], 0
	jne	SHORT $LN5@UnmapMemMa

; 275  : 		return;

	jmp	$LN1@UnmapMemMa
$LN5@UnmapMemMa:

; 276  : 
; 277  : 	SeTextOut("MemUnmap len -> %d \r\n", len);

	mov	rdx, QWORD PTR len$[rbp]
	lea	rcx, OFFSET FLAT:??_C@_0BG@JHLECFAA@MemUnmap?5len?5?9?$DO?5?$CFd?5?$AN?6@
	call	SeTextOut

; 278  : 	len = PAGE_ALIGN(len); //simply align the length

	mov	rax, QWORD PTR len$[rbp]
	and	rax, 4095				; 00000fffH
	test	rax, rax
	je	SHORT $LN9@UnmapMemMa
	mov	rax, QWORD PTR len$[rbp]
	add	rax, 4096				; 00001000H
	and	rax, -4096				; fffffffffffff000H
	mov	QWORD PTR tv71[rbp], rax
	jmp	SHORT $LN10@UnmapMemMa
$LN9@UnmapMemMa:
	mov	rax, QWORD PTR len$[rbp]
	mov	QWORD PTR tv71[rbp], rax
$LN10@UnmapMemMa:
	mov	rax, QWORD PTR tv71[rbp]
	mov	QWORD PTR len$[rbp], rax

; 279  : 	SeTextOut("Mem Unmap len aligned -> %d \r\n", len);

	mov	rdx, QWORD PTR len$[rbp]
	lea	rcx, OFFSET FLAT:??_C@_0BP@HEHILAKC@Mem?5Unmap?5len?5aligned?5?9?$DO?5?$CFd?5?$AN?6@
	call	SeTextOut

; 280  : 	uint64_t addr = (uint64_t)address;

	mov	rax, QWORD PTR address$[rbp]
	mov	QWORD PTR addr$[rbp], rax

; 281  : 	for (int i = 0; i < len / PAGE_SIZE; i++) {

	mov	DWORD PTR i$1[rbp], 0
	jmp	SHORT $LN4@UnmapMemMa
$LN2@UnmapMemMa:
	mov	eax, DWORD PTR i$1[rbp]
	inc	eax
	mov	DWORD PTR i$1[rbp], eax
$LN4@UnmapMemMa:
	movsxd	rax, DWORD PTR i$1[rbp]
	mov	QWORD PTR tv75[rbp], rax
	xor	edx, edx
	mov	rax, QWORD PTR len$[rbp]
	mov	ecx, 4096				; 00001000H
	div	rcx
	mov	rcx, QWORD PTR tv75[rbp]
	cmp	rcx, rax
	jae	$LN3@UnmapMemMa

; 282  : 		AuVPage* page = AuVmmngrGetPage(addr + static_cast<int64_t>(i) * PAGE_SIZE, VIRT_GETPAGE_ONLY_RET, VIRT_GETPAGE_ONLY_RET);

	movsxd	rax, DWORD PTR i$1[rbp]
	imul	rax, rax, 4096				; 00001000H
	mov	rcx, QWORD PTR addr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	r8b, 2
	mov	dl, 2
	mov	rcx, rax
	call	AuVmmngrGetPage
	mov	QWORD PTR page$2[rbp], rax

; 283  : 		if (page) {

	cmp	QWORD PTR page$2[rbp], 0
	je	SHORT $LN6@UnmapMemMa

; 284  : 			uint64_t phys = page->bits.page << PAGE_SHIFT;

	mov	rax, QWORD PTR page$2[rbp]
	mov	rax, QWORD PTR [rax]
	shr	rax, 12
	and	rax, 268435455				; 0fffffffH
	shl	rax, 12
	mov	QWORD PTR phys$3[rbp], rax

; 285  : 			if (phys){

	cmp	QWORD PTR phys$3[rbp], 0
	je	SHORT $LN7@UnmapMemMa

; 286  : 				AuPmmngrFree((void*)phys);

	mov	rcx, QWORD PTR phys$3[rbp]
	call	AuPmmngrFree
$LN7@UnmapMemMa:

; 287  : 			}
; 288  : 			page->bits.page = 0;

	mov	rax, QWORD PTR page$2[rbp]
	mov	rcx, -1099511623681			; ffffff0000000fffH
	mov	rax, QWORD PTR [rax]
	and	rax, rcx
	mov	rcx, QWORD PTR page$2[rbp]
	mov	QWORD PTR [rcx], rax

; 289  : 			page->bits.present = 0;

	mov	rax, QWORD PTR page$2[rbp]
	mov	rax, QWORD PTR [rax]
	and	rax, -2
	mov	rcx, QWORD PTR page$2[rbp]
	mov	QWORD PTR [rcx], rax
$LN6@UnmapMemMa:

; 290  : 		}
; 291  : 	}

	jmp	$LN2@UnmapMemMa
$LN3@UnmapMemMa:
$LN1@UnmapMemMa:

; 292  : 
; 293  : }

	lea	rsp, QWORD PTR [rbp+112]
	pop	rbp
	ret	0
?UnmapMemMapping@@YAXPEAX_K@Z ENDP			; UnmapMemMapping
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Mm\mmap.cpp
;	COMDAT ?MemMapDirty@@YAXPEAX_KHH@Z
_TEXT	SEGMENT
startAddr$ = 0
i$1 = 8
page$2 = 16
tv70 = 88
tv68 = 88
startingVaddr$ = 112
len$ = 120
flags$ = 128
prot$ = 136
?MemMapDirty@@YAXPEAX_KHH@Z PROC			; MemMapDirty, COMDAT

; 244  : void MemMapDirty(void* startingVaddr, size_t len, int flags, int prot) {

$LN13:
	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 128				; 00000080H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__C365CCBF_mmap@cpp
	call	__CheckForDebuggerJustMyCode

; 245  : 	x64_cli();

	call	x64_cli

; 246  : 	len = PAGE_ALIGN(len); //simply align the length

	mov	rax, QWORD PTR len$[rbp]
	and	rax, 4095				; 00000fffH
	test	rax, rax
	je	SHORT $LN11@MemMapDirt
	mov	rax, QWORD PTR len$[rbp]
	add	rax, 4096				; 00001000H
	and	rax, -4096				; fffffffffffff000H
	mov	QWORD PTR tv68[rbp], rax
	jmp	SHORT $LN12@MemMapDirt
$LN11@MemMapDirt:
	mov	rax, QWORD PTR len$[rbp]
	mov	QWORD PTR tv68[rbp], rax
$LN12@MemMapDirt:
	mov	rax, QWORD PTR tv68[rbp]
	mov	QWORD PTR len$[rbp], rax

; 247  : 	uint64_t startAddr = (uint64_t)startingVaddr;

	mov	rax, QWORD PTR startingVaddr$[rbp]
	mov	QWORD PTR startAddr$[rbp], rax

; 248  : 	for (int i = 0; i < len / PAGE_SIZE; i++) {

	mov	DWORD PTR i$1[rbp], 0
	jmp	SHORT $LN4@MemMapDirt
$LN2@MemMapDirt:
	mov	eax, DWORD PTR i$1[rbp]
	inc	eax
	mov	DWORD PTR i$1[rbp], eax
$LN4@MemMapDirt:
	movsxd	rax, DWORD PTR i$1[rbp]
	mov	QWORD PTR tv70[rbp], rax
	xor	edx, edx
	mov	rax, QWORD PTR len$[rbp]
	mov	ecx, 4096				; 00001000H
	div	rcx
	mov	rcx, QWORD PTR tv70[rbp]
	cmp	rcx, rax
	jae	$LN3@MemMapDirt

; 249  : 		AuVPage *page = AuVmmngrGetPage(startAddr + static_cast<int64_t>(i) * PAGE_SIZE, NULL, VIRT_GETPAGE_ONLY_RET);

	movsxd	rax, DWORD PTR i$1[rbp]
	imul	rax, rax, 4096				; 00001000H
	mov	rcx, QWORD PTR startAddr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	r8b, 2
	xor	edx, edx
	mov	rcx, rax
	call	AuVmmngrGetPage
	mov	QWORD PTR page$2[rbp], rax

; 250  : 
; 251  : 		/* check for  protection flag */
; 252  : 		if (prot & PROTECTION_FLAG_READONLY)

	mov	eax, DWORD PTR prot$[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN5@MemMapDirt

; 253  : 			page->bits.writable = 0;

	mov	rax, QWORD PTR page$2[rbp]
	mov	rax, QWORD PTR [rax]
	and	rax, -3
	mov	rcx, QWORD PTR page$2[rbp]
	mov	QWORD PTR [rcx], rax
$LN5@MemMapDirt:

; 254  : 		if (prot & PROTECTION_FLAG_NO_EXEC)

	mov	eax, DWORD PTR prot$[rbp]
	and	eax, 4
	test	eax, eax
	je	SHORT $LN6@MemMapDirt

; 255  : 			page->bits.nx = 1;

	mov	rax, QWORD PTR page$2[rbp]
	mov	rcx, 4503599627370496			; 0010000000000000H
	mov	rax, QWORD PTR [rax]
	or	rax, rcx
	mov	rcx, QWORD PTR page$2[rbp]
	mov	QWORD PTR [rcx], rax
$LN6@MemMapDirt:

; 256  : 		if (prot & PROTECTION_FLAG_NO_CACHE)

	mov	eax, DWORD PTR prot$[rbp]
	and	eax, 8
	test	eax, eax
	je	SHORT $LN7@MemMapDirt

; 257  : 			page->bits.cache_disable = 1;

	mov	rax, QWORD PTR page$2[rbp]
	mov	rax, QWORD PTR [rax]
	or	rax, 16
	mov	rcx, QWORD PTR page$2[rbp]
	mov	QWORD PTR [rcx], rax
$LN7@MemMapDirt:

; 258  : 		if (prot & PROTECTION_FLAG_READONLY && prot & PROTECTION_FLAG_WRITE)

	mov	eax, DWORD PTR prot$[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN8@MemMapDirt
	mov	eax, DWORD PTR prot$[rbp]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN8@MemMapDirt

; 259  : 			page->bits.writable = 0;

	mov	rax, QWORD PTR page$2[rbp]
	mov	rax, QWORD PTR [rax]
	and	rax, -3
	mov	rcx, QWORD PTR page$2[rbp]
	mov	QWORD PTR [rcx], rax
$LN8@MemMapDirt:

; 260  : 
; 261  : 		if (flags & MEMMAP_FLAG_COW)

	mov	eax, DWORD PTR flags$[rbp]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN9@MemMapDirt

; 262  : 			page->bits.cow = 1;

	mov	rax, QWORD PTR page$2[rbp]
	mov	rax, QWORD PTR [rax]
	bts	rax, 9
	mov	rcx, QWORD PTR page$2[rbp]
	mov	QWORD PTR [rcx], rax
$LN9@MemMapDirt:

; 263  : 	}

	jmp	$LN2@MemMapDirt
$LN3@MemMapDirt:

; 264  : }

	lea	rsp, QWORD PTR [rbp+96]
	pop	rbp
	ret	0
?MemMapDirty@@YAXPEAX_KHH@Z ENDP			; MemMapDirty
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Mm\mmap.cpp
;	COMDAT ?CreateMemMapping@@YAPEAXPEAX_KHHH1@Z
_TEXT	SEGMENT
curr_thr$ = 0
proc$ = 8
file$ = 16
fsys$ = 24
startingPhysAddr$ = 32
shobj_len_increase$ = 40
shobj_new_create$ = 41
shobj$ = 48
lookup_addr$ = 56
file_block_start$1 = 64
i$2 = 72
phys$3 = 80
page$4 = 88
tv150 = 160
tv81 = 160
address$ = 192
len$ = 200
prot$ = 208
flags$ = 216
fd$ = 224
offset$ = 232
?CreateMemMapping@@YAPEAXPEAX_KHHH1@Z PROC		; CreateMemMapping, COMDAT

; 118  : 	uint64_t offset) {

$LN32:
	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 208				; 000000d0H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__C365CCBF_mmap@cpp
	call	__CheckForDebuggerJustMyCode

; 119  : 	x64_cli();

	call	x64_cli

; 120  : 
; 121  : 	if (!len)

	cmp	QWORD PTR len$[rbp], 0
	jne	SHORT $LN5@CreateMemM

; 122  : 		return 0;

	xor	eax, eax
	jmp	$LN1@CreateMemM
$LN5@CreateMemM:

; 123  : 
; 124  : 	/* for now, memory mapping doesn't support lazy loading 
; 125  : 	 * so everything works at pre-paging */
; 126  : 
; 127  : 	AuThread* curr_thr = AuGetCurrentThread();

	call	AuGetCurrentThread
	mov	QWORD PTR curr_thr$[rbp], rax

; 128  : 	AuProcess* proc = AuProcessFindThread(curr_thr);

	mov	rcx, QWORD PTR curr_thr$[rbp]
	call	?AuProcessFindThread@@YAPEAU_au_proc_@@PEAU_au_thread_@@@Z ; AuProcessFindThread
	mov	QWORD PTR proc$[rbp], rax

; 129  : 	AuVFSNode *file = NULL;

	mov	QWORD PTR file$[rbp], 0

; 130  : 	AuVFSNode* fsys = NULL;

	mov	QWORD PTR fsys$[rbp], 0

; 131  : 	uint64_t startingPhysAddr = NULL;

	mov	QWORD PTR startingPhysAddr$[rbp], 0

; 132  : 	bool shobj_len_increase = false;

	mov	BYTE PTR shobj_len_increase$[rbp], 0

; 133  : 	bool shobj_new_create = false;

	mov	BYTE PTR shobj_new_create$[rbp], 0

; 134  : 
; 135  : 	AuSharedMmapObject* shobj = NULL;

	mov	QWORD PTR shobj$[rbp], 0

; 136  : 	if (fd != -1) 

	cmp	DWORD PTR fd$[rbp], -1
	je	SHORT $LN6@CreateMemM

; 137  : 		file = proc->fds[fd];

	movsxd	rax, DWORD PTR fd$[rbp]
	mov	rcx, QWORD PTR proc$[rbp]
	mov	rax, QWORD PTR [rcx+rax*8+567]
	mov	QWORD PTR file$[rbp], rax
$LN6@CreateMemM:

; 138  : 	
; 139  : 	size_t lookup_addr = NULL;

	mov	QWORD PTR lookup_addr$[rbp], 0

; 140  : 	if (!address)

	cmp	QWORD PTR address$[rbp], 0
	jne	SHORT $LN7@CreateMemM

; 141  : 		lookup_addr = (size_t)AuGetFreePage(true, (void*)PROCESS_MMAP_ADDRESS);

	mov	edx, -1073741824			; ffffffffc0000000H
	mov	cl, 1
	call	AuGetFreePage
	mov	QWORD PTR lookup_addr$[rbp], rax
	jmp	SHORT $LN8@CreateMemM
$LN7@CreateMemM:

; 142  : 	else
; 143  : 		lookup_addr = (size_t)address;

	mov	rax, QWORD PTR address$[rbp]
	mov	QWORD PTR lookup_addr$[rbp], rax
$LN8@CreateMemM:

; 144  : 
; 145  : 	len = PAGE_ALIGN(len); //simply align the length

	mov	rax, QWORD PTR len$[rbp]
	and	rax, 4095				; 00000fffH
	test	rax, rax
	je	SHORT $LN30@CreateMemM
	mov	rax, QWORD PTR len$[rbp]
	add	rax, 4096				; 00001000H
	and	rax, -4096				; fffffffffffff000H
	mov	QWORD PTR tv81[rbp], rax
	jmp	SHORT $LN31@CreateMemM
$LN30@CreateMemM:
	mov	rax, QWORD PTR len$[rbp]
	mov	QWORD PTR tv81[rbp], rax
$LN31@CreateMemM:
	mov	rax, QWORD PTR tv81[rbp]
	mov	QWORD PTR len$[rbp], rax

; 146  : 
; 147  : 
; 148  : 	if (file) {

	cmp	QWORD PTR file$[rbp], 0
	je	$LN9@CreateMemM

; 149  : 		uint64_t file_block_start = 0;

	mov	QWORD PTR file_block_start$1[rbp], 0

; 150  : 		fsys = AuVFSFind("/");

	lea	rcx, OFFSET FLAT:??_C@_01KMDKNFGN@?1@
	call	AuVFSFind
	mov	QWORD PTR fsys$[rbp], rax

; 151  : 		if (!fsys && fd != -1)

	cmp	QWORD PTR fsys$[rbp], 0
	jne	SHORT $LN10@CreateMemM
	cmp	DWORD PTR fd$[rbp], -1
	je	SHORT $LN10@CreateMemM

; 152  : 			return 0;

	xor	eax, eax
	jmp	$LN1@CreateMemM
$LN10@CreateMemM:

; 153  : 		if (!(file->flags & FS_FLAG_DEVICE)) {

	mov	rax, QWORD PTR file$[rbp]
	movzx	eax, WORD PTR [rax+61]
	and	eax, 8
	test	eax, eax
	jne	SHORT $LN11@CreateMemM

; 154  : 			file_block_start = AuVFSGetBlockFor(fsys, file, offset);

	mov	r8, QWORD PTR offset$[rbp]
	mov	rdx, QWORD PTR file$[rbp]
	mov	rcx, QWORD PTR fsys$[rbp]
	call	AuVFSGetBlockFor
	mov	QWORD PTR file_block_start$1[rbp], rax

; 155  : 			file->current = file_block_start;

	mov	rax, QWORD PTR file$[rbp]
	mov	rcx, QWORD PTR file_block_start$1[rbp]
	mov	QWORD PTR [rax+53], rcx
$LN11@CreateMemM:

; 156  : 		}
; 157  : 
; 158  : 		if (flags & MEMMAP_FLAG_SHARED) {

	mov	eax, DWORD PTR flags$[rbp]
	and	eax, 1
	test	eax, eax
	je	$LN12@CreateMemM

; 159  : 			shobj = AuSharedMmapObjectFindByName(file->filename);

	mov	rax, QWORD PTR file$[rbp]
	mov	rcx, rax
	call	?AuSharedMmapObjectFindByName@@YAPEAU_sh_memap_object_@@PEAD@Z ; AuSharedMmapObjectFindByName
	mov	QWORD PTR shobj$[rbp], rax

; 160  : 			/* no shobject found with specified name, so we create
; 161  : 			 * new one */
; 162  : 			if (!shobj) {

	cmp	QWORD PTR shobj$[rbp], 0
	jne	SHORT $LN13@CreateMemM

; 163  : 				shobj = AuCreateSharedMmapObject(file->filename);

	mov	rax, QWORD PTR file$[rbp]
	mov	rcx, rax
	call	?AuCreateSharedMmapObject@@YAPEAU_sh_memap_object_@@PEAD@Z ; AuCreateSharedMmapObject
	mov	QWORD PTR shobj$[rbp], rax

; 164  : 				shobj->flags = flags;

	mov	rax, QWORD PTR shobj$[rbp]
	movzx	ecx, BYTE PTR flags$[rbp]
	mov	BYTE PTR [rax+8], cl

; 165  : 				shobj->len = 0;

	mov	rax, QWORD PTR shobj$[rbp]
	mov	QWORD PTR [rax+18], 0

; 166  : 				shobj->prot_flags = prot;

	mov	rax, QWORD PTR shobj$[rbp]
	movzx	ecx, BYTE PTR prot$[rbp]
	mov	BYTE PTR [rax+9], cl

; 167  : 				shobj->ownerProc = proc->proc_id;

	mov	rax, QWORD PTR shobj$[rbp]
	mov	rcx, QWORD PTR proc$[rbp]
	movzx	ecx, WORD PTR [rcx]
	mov	WORD PTR [rax+28], cx

; 168  : 				AuAddSharedMmapObject(shobj);

	mov	rcx, QWORD PTR shobj$[rbp]
	call	?AuAddSharedMmapObject@@YAXPEAU_sh_memap_object_@@@Z ; AuAddSharedMmapObject

; 169  : 				shobj_new_create = true;

	mov	BYTE PTR shobj_new_create$[rbp], 1
$LN13@CreateMemM:

; 170  : 			}
; 171  : 			/* okay, already there is an shared object with this
; 172  : 			 * particular name, so check further
; 173  : 			 */
; 174  : 			if (shobj) {

	cmp	QWORD PTR shobj$[rbp], 0
	je	SHORT $LN14@CreateMemM

; 175  : 				/* firstly, check if the owner process is accessing,
; 176  : 				 * then simply we work on the shared object
; 177  : 				 */
; 178  : 				if (shobj->ownerProc == proc->proc_id) {

	mov	rax, QWORD PTR shobj$[rbp]
	movzx	eax, WORD PTR [rax+28]
	mov	rcx, QWORD PTR proc$[rbp]
	cmp	eax, DWORD PTR [rcx]
	jne	SHORT $LN15@CreateMemM

; 179  : 					shobj_len_increase = true;

	mov	BYTE PTR shobj_len_increase$[rbp], 1

; 180  : 				}

	jmp	SHORT $LN16@CreateMemM
$LN15@CreateMemM:

; 181  : 				else {
; 182  : 					/* we need to map that object here*/
; 183  : 					startingPhysAddr = shobj->beginPhysicalAddr;

	mov	rax, QWORD PTR shobj$[rbp]
	mov	rax, QWORD PTR [rax+10]
	mov	QWORD PTR startingPhysAddr$[rbp], rax
$LN16@CreateMemM:
$LN14@CreateMemM:
$LN12@CreateMemM:
$LN9@CreateMemM:

; 184  : 				}
; 185  : 			}
; 186  : 		}
; 187  : 	}
; 188  : 
; 189  : 	
; 190  : 
; 191  : 	for (int i = 0; i < len / PAGE_SIZE; i++) {

	mov	DWORD PTR i$2[rbp], 0
	jmp	SHORT $LN4@CreateMemM
$LN2@CreateMemM:
	mov	eax, DWORD PTR i$2[rbp]
	inc	eax
	mov	DWORD PTR i$2[rbp], eax
$LN4@CreateMemM:
	movsxd	rax, DWORD PTR i$2[rbp]
	mov	QWORD PTR tv150[rbp], rax
	xor	edx, edx
	mov	rax, QWORD PTR len$[rbp]
	mov	ecx, 4096				; 00001000H
	div	rcx
	mov	rcx, QWORD PTR tv150[rbp]
	cmp	rcx, rax
	jae	$LN3@CreateMemM

; 192  : 		uint64_t phys = 0;

	mov	QWORD PTR phys$3[rbp], 0

; 193  : 		if (startingPhysAddr && (flags & MEMMAP_FLAG_SHARED))

	cmp	QWORD PTR startingPhysAddr$[rbp], 0
	je	SHORT $LN17@CreateMemM
	mov	eax, DWORD PTR flags$[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN17@CreateMemM

; 194  : 			phys = startingPhysAddr + static_cast<int64_t>(i) * PAGE_SIZE;

	movsxd	rax, DWORD PTR i$2[rbp]
	imul	rax, rax, 4096				; 00001000H
	mov	rcx, QWORD PTR startingPhysAddr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR phys$3[rbp], rax
	jmp	SHORT $LN18@CreateMemM
$LN17@CreateMemM:

; 195  : 		else
; 196  : 			phys = (uint64_t)AuPmmngrAlloc();

	call	AuPmmngrAlloc
	mov	QWORD PTR phys$3[rbp], rax
$LN18@CreateMemM:

; 197  : 
; 198  : 		if (startingPhysAddr == 0 && shobj_new_create)

	cmp	QWORD PTR startingPhysAddr$[rbp], 0
	jne	SHORT $LN19@CreateMemM
	movzx	eax, BYTE PTR shobj_new_create$[rbp]
	test	eax, eax
	je	SHORT $LN19@CreateMemM

; 199  : 			startingPhysAddr = phys;

	mov	rax, QWORD PTR phys$3[rbp]
	mov	QWORD PTR startingPhysAddr$[rbp], rax
$LN19@CreateMemM:

; 200  : 
; 201  : 		if (file && !(flags & MEMMAP_FLAG_DISCARD_FILE_READ)){

	cmp	QWORD PTR file$[rbp], 0
	je	SHORT $LN20@CreateMemM
	mov	eax, DWORD PTR flags$[rbp]
	and	eax, 8
	test	eax, eax
	jne	SHORT $LN20@CreateMemM

; 202  : 			SeTextOut("mmap reading file \r\n");

	lea	rcx, OFFSET FLAT:??_C@_0BF@DDMMBABB@mmap?5reading?5file?5?$AN?6@
	call	SeTextOut

; 203  : 			AuVFSNodeReadBlock(fsys, file, (uint64_t*)phys);

	mov	r8, QWORD PTR phys$3[rbp]
	mov	rdx, QWORD PTR file$[rbp]
	mov	rcx, QWORD PTR fsys$[rbp]
	call	AuVFSNodeReadBlock
$LN20@CreateMemM:

; 204  : 		}
; 205  : 		AuMapPage(phys, lookup_addr + static_cast<int64_t>(i) * PAGE_SIZE, X86_64_PAGING_USER);

	movsxd	rax, DWORD PTR i$2[rbp]
	imul	rax, rax, 4096				; 00001000H
	mov	rcx, QWORD PTR lookup_addr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	r8b, 4
	mov	rdx, rax
	mov	rcx, QWORD PTR phys$3[rbp]
	call	AuMapPage

; 206  : 		AuVPage *page = AuVmmngrGetPage(lookup_addr + static_cast<int64_t>(i) * PAGE_SIZE, NULL, VIRT_GETPAGE_ONLY_RET);

	movsxd	rax, DWORD PTR i$2[rbp]
	imul	rax, rax, 4096				; 00001000H
	mov	rcx, QWORD PTR lookup_addr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	r8b, 2
	xor	edx, edx
	mov	rcx, rax
	call	AuVmmngrGetPage
	mov	QWORD PTR page$4[rbp], rax

; 207  : 
; 208  : 		/* check for  protection flag */
; 209  : 		if (prot & PROTECTION_FLAG_READONLY)

	mov	eax, DWORD PTR prot$[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN21@CreateMemM

; 210  : 			page->bits.writable = 0;

	mov	rax, QWORD PTR page$4[rbp]
	mov	rax, QWORD PTR [rax]
	and	rax, -3
	mov	rcx, QWORD PTR page$4[rbp]
	mov	QWORD PTR [rcx], rax
$LN21@CreateMemM:

; 211  : 		if (prot & PROTECTION_FLAG_NO_EXEC)

	mov	eax, DWORD PTR prot$[rbp]
	and	eax, 4
	test	eax, eax
	je	SHORT $LN22@CreateMemM

; 212  : 			page->bits.nx = 1;

	mov	rax, QWORD PTR page$4[rbp]
	mov	rcx, 4503599627370496			; 0010000000000000H
	mov	rax, QWORD PTR [rax]
	or	rax, rcx
	mov	rcx, QWORD PTR page$4[rbp]
	mov	QWORD PTR [rcx], rax
$LN22@CreateMemM:

; 213  : 		if (prot & PROTECTION_FLAG_NO_CACHE)

	mov	eax, DWORD PTR prot$[rbp]
	and	eax, 8
	test	eax, eax
	je	SHORT $LN23@CreateMemM

; 214  : 			page->bits.cache_disable = 1;

	mov	rax, QWORD PTR page$4[rbp]
	mov	rax, QWORD PTR [rax]
	or	rax, 16
	mov	rcx, QWORD PTR page$4[rbp]
	mov	QWORD PTR [rcx], rax
$LN23@CreateMemM:

; 215  : 		if (prot & PROTECTION_FLAG_READONLY && prot & PROTECTION_FLAG_WRITE)

	mov	eax, DWORD PTR prot$[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN24@CreateMemM
	mov	eax, DWORD PTR prot$[rbp]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN24@CreateMemM

; 216  : 			page->bits.writable = 0;

	mov	rax, QWORD PTR page$4[rbp]
	mov	rax, QWORD PTR [rax]
	and	rax, -3
	mov	rcx, QWORD PTR page$4[rbp]
	mov	QWORD PTR [rcx], rax
$LN24@CreateMemM:

; 217  : 
; 218  : 		if (flags & MEMMAP_FLAG_COW)

	mov	eax, DWORD PTR flags$[rbp]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN25@CreateMemM

; 219  : 			page->bits.cow = 1;

	mov	rax, QWORD PTR page$4[rbp]
	mov	rax, QWORD PTR [rax]
	bts	rax, 9
	mov	rcx, QWORD PTR page$4[rbp]
	mov	QWORD PTR [rcx], rax
$LN25@CreateMemM:

; 220  : 	}

	jmp	$LN2@CreateMemM
$LN3@CreateMemM:

; 221  : 
; 222  : 	/* shared bit should be handled differently */
; 223  : 	if (flags & MEMMAP_FLAG_SHARED && shobj) {

	mov	eax, DWORD PTR flags$[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN26@CreateMemM
	cmp	QWORD PTR shobj$[rbp], 0
	je	SHORT $LN26@CreateMemM

; 224  : 		if (shobj_new_create){

	movzx	eax, BYTE PTR shobj_new_create$[rbp]
	test	eax, eax
	je	SHORT $LN27@CreateMemM

; 225  : 			shobj->beginPhysicalAddr = startingPhysAddr;

	mov	rax, QWORD PTR shobj$[rbp]
	mov	rcx, QWORD PTR startingPhysAddr$[rbp]
	mov	QWORD PTR [rax+10], rcx

; 226  : 			shobj->len = len;

	mov	rax, QWORD PTR shobj$[rbp]
	mov	rcx, QWORD PTR len$[rbp]
	mov	QWORD PTR [rax+18], rcx

; 227  : 			SeTextOut("SHOBJ newly created -> %s \r\n", shobj->objectName);

	mov	rax, QWORD PTR shobj$[rbp]
	mov	rdx, QWORD PTR [rax]
	lea	rcx, OFFSET FLAT:??_C@_0BN@BEEDHOIO@SHOBJ?5newly?5created?5?9?$DO?5?$CFs?5?$AN?6@
	call	SeTextOut
$LN27@CreateMemM:

; 228  : 		}
; 229  : 		if (shobj_len_increase)

	movzx	eax, BYTE PTR shobj_len_increase$[rbp]
	test	eax, eax
	je	SHORT $LN28@CreateMemM

; 230  : 			shobj->len += len;

	mov	rax, QWORD PTR shobj$[rbp]
	mov	rax, QWORD PTR [rax+18]
	add	rax, QWORD PTR len$[rbp]
	mov	rcx, QWORD PTR shobj$[rbp]
	mov	QWORD PTR [rcx+18], rax
$LN28@CreateMemM:
$LN26@CreateMemM:

; 231  : 	}
; 232  : 
; 233  : 	proc->proc_mmap_len += len;

	mov	rax, QWORD PTR proc$[rbp]
	mov	rax, QWORD PTR [rax+1111]
	add	rax, QWORD PTR len$[rbp]
	mov	rcx, QWORD PTR proc$[rbp]
	mov	QWORD PTR [rcx+1111], rax

; 234  : 	return (void*)lookup_addr;

	mov	rax, QWORD PTR lookup_addr$[rbp]
$LN1@CreateMemM:

; 235  : }

	lea	rsp, QWORD PTR [rbp+176]
	pop	rbp
	ret	0
?CreateMemMapping@@YAPEAXPEAX_KHHH1@Z ENDP		; CreateMemMapping
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Mm\mmap.cpp
;	COMDAT ?SharedMemMapListInitialise@@YAXXZ
_TEXT	SEGMENT
?SharedMemMapListInitialise@@YAXXZ PROC			; SharedMemMapListInitialise, COMDAT

; 68   : void SharedMemMapListInitialise() {

$LN3:
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__C365CCBF_mmap@cpp
	call	__CheckForDebuggerJustMyCode

; 69   : 	shmmaplist = initialize_list();

	call	initialize_list
	mov	QWORD PTR ?shmmaplist@@3PEAU_list_@@EA, rax ; shmmaplist

; 70   : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
?SharedMemMapListInitialise@@YAXXZ ENDP			; SharedMemMapListInitialise
_TEXT	ENDS
END
