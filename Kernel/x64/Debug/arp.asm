; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30154.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

msvcjmc	SEGMENT
__7BFC8353_arp@cpp DB 01H
msvcjmc	ENDS
PUBLIC	AuARPRequestMAC
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_0BA@BOFDAJAA@ARP?5Setuped?5?$CFx?6@	; `string'
EXTRN	?AuEthernetSend@@YAXPEAU__VFS_NODE__@@PEAX_KGPEAE@Z:PROC ; AuEthernetSend
EXTRN	memset:PROC
EXTRN	memcpy:PROC
EXTRN	AuTextOut:PROC
EXTRN	kmalloc:PROC
EXTRN	kfree:PROC
EXTRN	__CheckForDebuggerJustMyCode:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$AuARPRequestMAC DD imagerel $LN5
	DD	imagerel $LN5+286
	DD	imagerel $unwind$AuARPRequestMAC
pdata	ENDS
;	COMDAT ??_C@_0BA@BOFDAJAA@ARP?5Setuped?5?$CFx?6@
CONST	SEGMENT
??_C@_0BA@BOFDAJAA@ARP?5Setuped?5?$CFx?6@ DB 'ARP Setuped %x', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AuARPRequestMAC DD 035041201H
	DD	010d3312H
	DD	050060012H
xdata	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Net\arp.cpp
;	COMDAT AuARPRequestMAC
_TEXT	SEGMENT
ndev$ = 0
arp$ = 8
mac$ = 16
nic$ = 112
AuARPRequestMAC PROC					; COMDAT

; 42   : void AuARPRequestMAC(AuVFSNode* nic) {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 144				; 00000090H
	lea	rbp, QWORD PTR [rsp+48]
	lea	rcx, OFFSET FLAT:__7BFC8353_arp@cpp
	call	__CheckForDebuggerJustMyCode

; 43   : 	AuNetworkDevice *ndev = (AuNetworkDevice*)nic->device;

	mov	rax, QWORD PTR nic$[rbp]
	mov	rax, QWORD PTR [rax+64]
	mov	QWORD PTR ndev$[rbp], rax

; 44   : 	if (!ndev)

	cmp	QWORD PTR ndev$[rbp], 0
	jne	SHORT $LN2@AuARPReque

; 45   : 		return;

	jmp	$LN1@AuARPReque
$LN2@AuARPReque:

; 46   : 	NetARP *arp = (NetARP*)kmalloc(sizeof(NetARP));

	mov	ecx, 28
	call	kmalloc
	mov	QWORD PTR arp$[rbp], rax

; 47   : 	arp->hwAddressType = htons(1); //0x0100;

	mov	eax, 256				; 00000100H
	mov	rcx, QWORD PTR arp$[rbp]
	mov	WORD PTR [rcx], ax

; 48   : 	arp->hwProtocolType = htons(ETHERNET_TYPE_IPV4);

	mov	eax, 8
	mov	rcx, QWORD PTR arp$[rbp]
	mov	WORD PTR [rcx+2], ax

; 49   : 	arp->hwAddressSize = 6;

	mov	rax, QWORD PTR arp$[rbp]
	mov	BYTE PTR [rax+4], 6

; 50   : 	arp->protocolSize = 4;

	mov	rax, QWORD PTR arp$[rbp]
	mov	BYTE PTR [rax+5], 4

; 51   : 	arp->operation = htons(1);

	mov	eax, 256				; 00000100H
	mov	rcx, QWORD PTR arp$[rbp]
	mov	WORD PTR [rcx+6], ax

; 52   : 
; 53   : 	uint8_t* mac = ndev->mac;

	mov	rax, QWORD PTR ndev$[rbp]
	mov	QWORD PTR mac$[rbp], rax

; 54   : 	memcpy(arp->srcMac, mac, 6); //192.168.0.1

	mov	rax, QWORD PTR arp$[rbp]
	add	rax, 8
	mov	r8d, 6
	mov	rdx, QWORD PTR mac$[rbp]
	mov	rcx, rax
	call	memcpy

; 55   : 	arp->srcIP = 0xC0A80001;

	mov	rax, QWORD PTR arp$[rbp]
	mov	DWORD PTR [rax+14], -1062731775		; c0a80001H

; 56   : 
; 57   : 	memset(arp->destMac, 0xff, 6);//192.168.43.02

	mov	rax, QWORD PTR arp$[rbp]
	add	rax, 18
	mov	r8d, 6
	mov	dl, 255					; 000000ffH
	mov	rcx, rax
	call	memset

; 58   : 	arp->destIP = 0xC0A82B02;

	mov	rax, QWORD PTR arp$[rbp]
	mov	DWORD PTR [rax+24], -1062720766		; c0a82b02H

; 59   : 	AuTextOut("ARP Setuped %x\n",arp->destIP);

	mov	rax, QWORD PTR arp$[rbp]
	mov	edx, DWORD PTR [rax+24]
	lea	rcx, OFFSET FLAT:??_C@_0BA@BOFDAJAA@ARP?5Setuped?5?$CFx?6@
	call	AuTextOut

; 60   : 	
; 61   : 	if (ndev->type == NETDEV_TYPE_ETHERNET)

	mov	rax, QWORD PTR ndev$[rbp]
	movzx	eax, BYTE PTR [rax+10]
	cmp	eax, 1
	jne	SHORT $LN3@AuARPReque

; 62   : 		AuEthernetSend(nic,&arp, sizeof(NetARP), ETHERNET_TYPE_ARP, arp->destMac);

	mov	rax, QWORD PTR arp$[rbp]
	add	rax, 18
	mov	QWORD PTR [rsp+32], rax
	mov	r9w, 2054				; 00000806H
	mov	r8d, 28
	lea	rdx, QWORD PTR arp$[rbp]
	mov	rcx, QWORD PTR nic$[rbp]
	call	?AuEthernetSend@@YAXPEAU__VFS_NODE__@@PEAX_KGPEAE@Z ; AuEthernetSend
$LN3@AuARPReque:

; 63   : 	/* here we need to call different interfaces depending
; 64   : 	 * on the nic node passed, ARP can be sent through different
; 65   : 	 * link layer other than Ethernet
; 66   : 	 */
; 67   : 	kfree(arp);

	mov	rcx, QWORD PTR arp$[rbp]
	call	kfree
$LN1@AuARPReque:

; 68   : }

	lea	rsp, QWORD PTR [rbp+96]
	pop	rbp
	ret	0
AuARPRequestMAC ENDP
_TEXT	ENDS
END
