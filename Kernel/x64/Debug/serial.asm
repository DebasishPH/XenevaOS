; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30154.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

msvcjmc	SEGMENT
__26E2B342_serial@cpp DB 01H
msvcjmc	ENDS
PUBLIC	?AuInitialiseSerial@@YAXXZ			; AuInitialiseSerial
PUBLIC	SeTextOut
PUBLIC	?SerialInterruptHandler@@YAX_KPEAX@Z		; SerialInterruptHandler
PUBLIC	?is_transmit_empty@@YAHXZ			; is_transmit_empty
PUBLIC	?WriteSerial@@YAXD@Z				; WriteSerial
PUBLIC	?DebugSerial@@YAXPEAD@Z				; DebugSerial
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_01JOAMLHOP@?9@				; `string'
PUBLIC	??_C@_01LFCBOECM@?4@				; `string'
EXTRN	strlen:PROC
EXTRN	AuInterruptEnd:PROC
EXTRN	x64_inportb:PROC
EXTRN	x64_outportb:PROC
EXTRN	?sztoa@@YAPEAD_KPEADH@Z:PROC			; sztoa
EXTRN	?ftoa@@YAPEADME@Z:PROC				; ftoa
EXTRN	__CheckForDebuggerJustMyCode:PROC
EXTRN	_fltused:DWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuInitialiseSerial@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+106
	DD	imagerel $unwind$?AuInitialiseSerial@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$SeTextOut DD imagerel $LN25
	DD	imagerel $LN25+855
	DD	imagerel $unwind$SeTextOut
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?SerialInterruptHandler@@YAX_KPEAX@Z DD imagerel $LN3
	DD	imagerel $LN3+45
	DD	imagerel $unwind$?SerialInterruptHandler@@YAX_KPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?is_transmit_empty@@YAHXZ DD imagerel $LN3
	DD	imagerel $LN3+44
	DD	imagerel $unwind$?is_transmit_empty@@YAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?WriteSerial@@YAXD@Z DD imagerel $LN5
	DD	imagerel $LN5+56
	DD	imagerel $unwind$?WriteSerial@@YAXD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?DebugSerial@@YAXPEAD@Z DD imagerel $LN6
	DD	imagerel $LN6+95
	DD	imagerel $unwind$?DebugSerial@@YAXPEAD@Z
pdata	ENDS
;	COMDAT ??_C@_01LFCBOECM@?4@
CONST	SEGMENT
??_C@_01LFCBOECM@?4@ DB '.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01JOAMLHOP@?9@
CONST	SEGMENT
??_C@_01JOAMLHOP@?9@ DB '-', 00H			; `string'
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?DebugSerial@@YAXPEAD@Z DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?WriteSerial@@YAXD@Z DD 025030e01H
	DD	0b209230eH
	DD	05005H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?is_transmit_empty@@YAHXZ DD 025030b01H
	DD	0b206230bH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?SerialInterruptHandler@@YAX_KPEAX@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$SeTextOut DD 025042101H
	DD	011c2321H
	DD	05015002cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuInitialiseSerial@@YAXXZ DD 025030b01H
	DD	0b206230bH
	DD	05002H
xdata	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\serial.cpp
;	COMDAT ?DebugSerial@@YAXPEAD@Z
_TEXT	SEGMENT
i$1 = 0
tv65 = 72
string$ = 96
?DebugSerial@@YAXPEAD@Z PROC				; DebugSerial, COMDAT

; 72   : void DebugSerial(char* string) {

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__26E2B342_serial@cpp
	call	__CheckForDebuggerJustMyCode

; 73   : 	for (int i = 0; i < strlen(string); i++)

	mov	DWORD PTR i$1[rbp], 0
	jmp	SHORT $LN4@DebugSeria
$LN2@DebugSeria:
	mov	eax, DWORD PTR i$1[rbp]
	inc	eax
	mov	DWORD PTR i$1[rbp], eax
$LN4@DebugSeria:
	movsxd	rax, DWORD PTR i$1[rbp]
	mov	QWORD PTR tv65[rbp], rax
	mov	rcx, QWORD PTR string$[rbp]
	call	strlen
	mov	rcx, QWORD PTR tv65[rbp]
	cmp	rcx, rax
	jae	SHORT $LN3@DebugSeria

; 74   : 		WriteSerial(string[i]);

	movsxd	rax, DWORD PTR i$1[rbp]
	mov	rcx, QWORD PTR string$[rbp]
	movzx	ecx, BYTE PTR [rcx+rax]
	call	?WriteSerial@@YAXD@Z			; WriteSerial
	jmp	SHORT $LN2@DebugSeria
$LN3@DebugSeria:

; 75   : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
?DebugSerial@@YAXPEAD@Z ENDP				; DebugSerial
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\serial.cpp
;	COMDAT ?WriteSerial@@YAXD@Z
_TEXT	SEGMENT
a$ = 80
?WriteSerial@@YAXD@Z PROC				; WriteSerial, COMDAT

; 67   : void WriteSerial(char a) {

$LN5:
	mov	BYTE PTR [rsp+8], cl
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__26E2B342_serial@cpp
	call	__CheckForDebuggerJustMyCode
$LN2@WriteSeria:

; 68   : 	while (is_transmit_empty() == 0);

	call	?is_transmit_empty@@YAHXZ		; is_transmit_empty
	test	eax, eax
	jne	SHORT $LN3@WriteSeria
	jmp	SHORT $LN2@WriteSeria
$LN3@WriteSeria:

; 69   : 	x64_outportb(SERIAL_PORT, a);

	movzx	edx, BYTE PTR a$[rbp]
	mov	cx, 1016				; 000003f8H
	call	x64_outportb

; 70   : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
?WriteSerial@@YAXD@Z ENDP				; WriteSerial
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\serial.cpp
;	COMDAT ?is_transmit_empty@@YAHXZ
_TEXT	SEGMENT
?is_transmit_empty@@YAHXZ PROC				; is_transmit_empty, COMDAT

; 63   : int is_transmit_empty() {

$LN3:
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__26E2B342_serial@cpp
	call	__CheckForDebuggerJustMyCode

; 64   : 	return x64_inportb(SERIAL_PORT + 5) & 0x20;

	mov	cx, 1021				; 000003fdH
	call	x64_inportb
	movzx	eax, al
	and	eax, 32					; 00000020H

; 65   : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
?is_transmit_empty@@YAHXZ ENDP				; is_transmit_empty
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\serial.cpp
;	COMDAT ?SerialInterruptHandler@@YAX_KPEAX@Z
_TEXT	SEGMENT
v$ = 80
p$ = 88
?SerialInterruptHandler@@YAX_KPEAX@Z PROC		; SerialInterruptHandler, COMDAT

; 42   : void SerialInterruptHandler(size_t v, void* p) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__26E2B342_serial@cpp
	call	__CheckForDebuggerJustMyCode

; 43   : 	AuInterruptEnd(4);

	mov	cl, 4
	call	AuInterruptEnd

; 44   : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
?SerialInterruptHandler@@YAX_KPEAX@Z ENDP		; SerialInterruptHandler
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\serial.cpp
;	COMDAT SeTextOut
_TEXT	SEGMENT
args$ = 0
width$1 = 8
i$2 = 16
i$3 = 24
buffer$4 = 32
len$5 = 112
c$6 = 120
val$7 = 128
buffer$8 = 144
x$9 = 224
x$10 = 232
buf$11 = 240
buf$12 = 244
format$ = 336
SeTextOut PROC						; COMDAT

; 81   : AU_EXTERN AU_EXPORT void SeTextOut(char* format, ...) {

$LN25:
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	push	rbp
	sub	rsp, 352				; 00000160H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__26E2B342_serial@cpp
	call	__CheckForDebuggerJustMyCode

; 82   : 
; 83   : 	_va_list_ args;
; 84   : 	va_start(args, format);

	lea	rax, QWORD PTR format$[rbp+8]
	mov	QWORD PTR args$[rbp], rax
$LN2@SeTextOut:

; 85   : 
; 86   : 	while (*format)

	mov	rax, QWORD PTR format$[rbp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	$LN3@SeTextOut

; 87   : 	{
; 88   : 		if (*format == '%')

	mov	rax, QWORD PTR format$[rbp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 37					; 00000025H
	jne	$LN7@SeTextOut

; 89   : 		{
; 90   : 			++format;

	mov	rax, QWORD PTR format$[rbp]
	inc	rax
	mov	QWORD PTR format$[rbp], rax

; 91   : 			if (*format == 'd')

	mov	rax, QWORD PTR format$[rbp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 100				; 00000064H
	jne	$LN9@SeTextOut

; 92   : 			{
; 93   : 				size_t width = 0;

	mov	QWORD PTR width$1[rbp], 0

; 94   : 				if (format[1] == '.')

	mov	eax, 1
	imul	rax, rax, 1
	mov	rcx, QWORD PTR format$[rbp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 46					; 0000002eH
	jne	SHORT $LN11@SeTextOut

; 95   : 				{
; 96   : 					for (size_t i = 2; format[i] >= '0' && format[i] <= '9'; ++i)

	mov	QWORD PTR i$2[rbp], 2
	jmp	SHORT $LN6@SeTextOut
$LN4@SeTextOut:
	mov	rax, QWORD PTR i$2[rbp]
	inc	rax
	mov	QWORD PTR i$2[rbp], rax
$LN6@SeTextOut:
	mov	rax, QWORD PTR i$2[rbp]
	mov	rcx, QWORD PTR format$[rbp]
	add	rcx, rax
	mov	rax, rcx
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 48					; 00000030H
	jl	SHORT $LN5@SeTextOut
	mov	rax, QWORD PTR i$2[rbp]
	mov	rcx, QWORD PTR format$[rbp]
	add	rcx, rax
	mov	rax, rcx
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 57					; 00000039H
	jg	SHORT $LN5@SeTextOut

; 97   : 					{
; 98   : 						width *= 10;

	imul	rax, QWORD PTR width$1[rbp], 10
	mov	QWORD PTR width$1[rbp], rax

; 99   : 						width += format[i] - '0';

	mov	rax, QWORD PTR i$2[rbp]
	mov	rcx, QWORD PTR format$[rbp]
	add	rcx, rax
	mov	rax, rcx
	movsx	eax, BYTE PTR [rax]
	sub	eax, 48					; 00000030H
	cdqe
	mov	rcx, QWORD PTR width$1[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR width$1[rbp], rax

; 100  : 					}

	jmp	SHORT $LN4@SeTextOut
$LN5@SeTextOut:
$LN11@SeTextOut:

; 101  : 				}
; 102  : 				size_t i = va_arg(args, size_t);

	mov	rax, QWORD PTR args$[rbp]
	add	rax, 8
	mov	QWORD PTR args$[rbp], rax
	mov	rax, QWORD PTR args$[rbp]
	mov	rax, QWORD PTR [rax-8]
	mov	QWORD PTR i$3[rbp], rax

; 103  : 				char buffer[sizeof(size_t)* 8 + 1];
; 104  : 				//	size_t len
; 105  : 				if ((int)i < 0) {

	cmp	DWORD PTR i$3[rbp], 0
	jge	SHORT $LN12@SeTextOut

; 106  : 					DebugSerial("-");

	lea	rcx, OFFSET FLAT:??_C@_01JOAMLHOP@?9@
	call	?DebugSerial@@YAXPEAD@Z			; DebugSerial

; 107  : 					i = ((int)i * -1);

	imul	eax, DWORD PTR i$3[rbp], -1
	cdqe
	mov	QWORD PTR i$3[rbp], rax

; 108  : 					sztoa(i, buffer, 10);

	mov	r8d, 10
	lea	rdx, QWORD PTR buffer$4[rbp]
	mov	rcx, QWORD PTR i$3[rbp]
	call	?sztoa@@YAPEAD_KPEADH@Z			; sztoa

; 109  : 				}

	jmp	SHORT $LN13@SeTextOut
$LN12@SeTextOut:

; 110  : 				else {
; 111  : 					sztoa(i, buffer, 10);

	mov	r8d, 10
	lea	rdx, QWORD PTR buffer$4[rbp]
	mov	rcx, QWORD PTR i$3[rbp]
	call	?sztoa@@YAPEAD_KPEADH@Z			; sztoa

; 112  : 					size_t len = strlen(buffer);

	lea	rcx, QWORD PTR buffer$4[rbp]
	call	strlen
	mov	QWORD PTR len$5[rbp], rax
$LN13@SeTextOut:

; 113  : 				}
; 114  : 				/*	while (len++ < width)
; 115  : 				puts("0");*/
; 116  : 				DebugSerial(buffer);

	lea	rcx, QWORD PTR buffer$4[rbp]
	call	?DebugSerial@@YAXPEAD@Z			; DebugSerial

; 117  : 			}

	jmp	$LN10@SeTextOut
$LN9@SeTextOut:

; 118  : 			else if (*format == 'c')

	mov	rax, QWORD PTR format$[rbp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 99					; 00000063H
	jne	SHORT $LN14@SeTextOut

; 119  : 			{
; 120  : 				char c = va_arg(args, char);

	mov	rax, QWORD PTR args$[rbp]
	add	rax, 8
	mov	QWORD PTR args$[rbp], rax
	mov	rax, QWORD PTR args$[rbp]
	movzx	eax, BYTE PTR [rax-8]
	mov	BYTE PTR c$6[rbp], al

; 121  : 				//char buffer[sizeof(size_t) * 8 + 1];
; 122  : 				//sztoa(c, buffer, 10);
; 123  : 				//puts(buffer);
; 124  : 				WriteSerial(c);

	movzx	ecx, BYTE PTR c$6[rbp]
	call	?WriteSerial@@YAXD@Z			; WriteSerial

; 125  : 			}

	jmp	$LN15@SeTextOut
$LN14@SeTextOut:

; 126  : 			else if (*format == 'x')

	mov	rax, QWORD PTR format$[rbp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 120				; 00000078H
	jne	SHORT $LN16@SeTextOut

; 127  : 			{
; 128  : 				size_t val = va_arg(args,size_t);

	mov	rax, QWORD PTR args$[rbp]
	add	rax, 8
	mov	QWORD PTR args$[rbp], rax
	mov	rax, QWORD PTR args$[rbp]
	mov	rax, QWORD PTR [rax-8]
	mov	QWORD PTR val$7[rbp], rax

; 129  : 				char buffer[sizeof(size_t)* 8 + 1];
; 130  : 				sztoa(val, buffer, 16);

	mov	r8d, 16
	lea	rdx, QWORD PTR buffer$8[rbp]
	mov	rcx, QWORD PTR val$7[rbp]
	call	?sztoa@@YAPEAD_KPEADH@Z			; sztoa

; 131  : 				//puts("0x");
; 132  : 				DebugSerial(buffer);

	lea	rcx, QWORD PTR buffer$8[rbp]
	call	?DebugSerial@@YAXPEAD@Z			; DebugSerial

; 133  : 			}

	jmp	$LN17@SeTextOut
$LN16@SeTextOut:

; 134  : 			else if (*format == 's')

	mov	rax, QWORD PTR format$[rbp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 115				; 00000073H
	jne	SHORT $LN18@SeTextOut

; 135  : 			{
; 136  : 				char* x = va_arg(args, char*);

	mov	rax, QWORD PTR args$[rbp]
	add	rax, 8
	mov	QWORD PTR args$[rbp], rax
	mov	rax, QWORD PTR args$[rbp]
	mov	rax, QWORD PTR [rax-8]
	mov	QWORD PTR x$9[rbp], rax

; 137  : 				DebugSerial(x);

	mov	rcx, QWORD PTR x$9[rbp]
	call	?DebugSerial@@YAXPEAD@Z			; DebugSerial

; 138  : 			}

	jmp	$LN19@SeTextOut
$LN18@SeTextOut:

; 139  : 			else if (*format == 'f')

	mov	rax, QWORD PTR format$[rbp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 102				; 00000066H
	jne	SHORT $LN20@SeTextOut

; 140  : 			{
; 141  : 				double x = va_arg(args, double);

	mov	rax, QWORD PTR args$[rbp]
	add	rax, 8
	mov	QWORD PTR args$[rbp], rax
	mov	rax, QWORD PTR args$[rbp]
	movsd	xmm0, QWORD PTR [rax-8]
	movsd	QWORD PTR x$10[rbp], xmm0

; 142  : 				DebugSerial(ftoa(x, 2));

	cvtsd2ss xmm0, QWORD PTR x$10[rbp]
	mov	dl, 2
	call	?ftoa@@YAPEADME@Z			; ftoa
	mov	rcx, rax
	call	?DebugSerial@@YAXPEAD@Z			; DebugSerial

; 143  : 			}

	jmp	SHORT $LN21@SeTextOut
$LN20@SeTextOut:

; 144  : 			else if (*format == '%')

	mov	rax, QWORD PTR format$[rbp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 37					; 00000025H
	jne	SHORT $LN22@SeTextOut

; 145  : 			{
; 146  : 				DebugSerial(".");

	lea	rcx, OFFSET FLAT:??_C@_01LFCBOECM@?4@
	call	?DebugSerial@@YAXPEAD@Z			; DebugSerial

; 147  : 			}

	jmp	SHORT $LN23@SeTextOut
$LN22@SeTextOut:

; 148  : 			else
; 149  : 			{
; 150  : 				char buf[3];
; 151  : 				buf[0] = '%'; buf[1] = *format; buf[2] = '\0';

	mov	eax, 1
	imul	rax, rax, 0
	mov	BYTE PTR buf$11[rbp+rax], 37		; 00000025H
	mov	eax, 1
	imul	rax, rax, 1
	mov	rcx, QWORD PTR format$[rbp]
	movzx	ecx, BYTE PTR [rcx]
	mov	BYTE PTR buf$11[rbp+rax], cl
	mov	eax, 1
	imul	rax, rax, 2
	mov	BYTE PTR buf$11[rbp+rax], 0

; 152  : 				DebugSerial(buf);

	lea	rcx, QWORD PTR buf$11[rbp]
	call	?DebugSerial@@YAXPEAD@Z			; DebugSerial
$LN23@SeTextOut:
$LN21@SeTextOut:
$LN19@SeTextOut:
$LN17@SeTextOut:
$LN15@SeTextOut:
$LN10@SeTextOut:

; 153  : 			}
; 154  : 		}

	jmp	SHORT $LN8@SeTextOut
$LN7@SeTextOut:

; 155  : 		else
; 156  : 		{
; 157  : 			char buf[2];
; 158  : 			buf[0] = *format; buf[1] = '\0';

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR format$[rbp]
	movzx	ecx, BYTE PTR [rcx]
	mov	BYTE PTR buf$12[rbp+rax], cl
	mov	eax, 1
	imul	rax, rax, 1
	mov	BYTE PTR buf$12[rbp+rax], 0

; 159  : 			DebugSerial(buf);

	lea	rcx, QWORD PTR buf$12[rbp]
	call	?DebugSerial@@YAXPEAD@Z			; DebugSerial
$LN8@SeTextOut:

; 160  : 		}
; 161  : 		++format;

	mov	rax, QWORD PTR format$[rbp]
	inc	rax
	mov	QWORD PTR format$[rbp], rax

; 162  : 	}

	jmp	$LN2@SeTextOut
$LN3@SeTextOut:

; 163  : 	va_end(args);
; 164  : 
; 165  : }

	lea	rsp, QWORD PTR [rbp+320]
	pop	rbp
	ret	0
SeTextOut ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\serial.cpp
;	COMDAT ?AuInitialiseSerial@@YAXXZ
_TEXT	SEGMENT
?AuInitialiseSerial@@YAXXZ PROC				; AuInitialiseSerial, COMDAT

; 50   : void AuInitialiseSerial() {

$LN3:
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__26E2B342_serial@cpp
	call	__CheckForDebuggerJustMyCode

; 51   : 	x64_outportb(SERIAL_PORT + 1, 0x00);

	xor	edx, edx
	mov	cx, 1017				; 000003f9H
	call	x64_outportb

; 52   : 	x64_outportb((SERIAL_PORT + 3), 0x80);

	mov	dl, 128					; 00000080H
	mov	cx, 1019				; 000003fbH
	call	x64_outportb

; 53   : 	x64_outportb((SERIAL_PORT + 0), 0x03);

	mov	dl, 3
	mov	cx, 1016				; 000003f8H
	call	x64_outportb

; 54   : 	x64_outportb((SERIAL_PORT + 1), 0x00);

	xor	edx, edx
	mov	cx, 1017				; 000003f9H
	call	x64_outportb

; 55   : 	x64_outportb((SERIAL_PORT + 3), 0x03);

	mov	dl, 3
	mov	cx, 1019				; 000003fbH
	call	x64_outportb

; 56   : 	x64_outportb((SERIAL_PORT + 2), 0xC7);

	mov	dl, 199					; 000000c7H
	mov	cx, 1018				; 000003faH
	call	x64_outportb

; 57   : 	x64_outportb((SERIAL_PORT + 4), 0x0B);

	mov	dl, 11
	mov	cx, 1020				; 000003fcH
	call	x64_outportb

; 58   : 
; 59   : 	//x64_outportb (PORT + 4, 0x0F);
; 60   : 	//interrupt_set (4,serial_handler, 4);
; 61   : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
?AuInitialiseSerial@@YAXXZ ENDP				; AuInitialiseSerial
_TEXT	ENDS
END
