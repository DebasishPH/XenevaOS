; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30154.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?_RootPaging@@3PEA_KEA				; _RootPaging
PUBLIC	?_MmioBase@@3PEA_KEA				; _MmioBase
_BSS	SEGMENT
?_RootPaging@@3PEA_KEA DQ 01H DUP (?)			; _RootPaging
?_MmioBase@@3PEA_KEA DQ 01H DUP (?)			; _MmioBase
_BSS	ENDS
msvcjmc	SEGMENT
__71D0FFAE_vmmngr@cpp DB 01H
msvcjmc	ENDS
PUBLIC	?AuVmmngrInitialize@@YAXXZ			; AuVmmngrInitialize
PUBLIC	AuVmmngrGetPage
PUBLIC	AuMapPage
PUBLIC	AuMapPageEx
PUBLIC	AuMapMMIO
PUBLIC	AuGetFreePage
PUBLIC	AuFreePages
PUBLIC	AuGetPhysicalAddress
PUBLIC	AuGetPhysicalAddressEx
PUBLIC	AuCreateVirtualAddressSpace
PUBLIC	AuGetRootPageTable
PUBLIC	?AuVmmngrBootFree@@YAXXZ			; AuVmmngrBootFree
PUBLIC	?AuVmmngrCloneAddressSpace@@YAXPEA_K0@Z		; AuVmmngrCloneAddressSpace
PUBLIC	?x86_64_pml4_index@@YA_K_K@Z			; x86_64_pml4_index
PUBLIC	?x86_64_pdp_index@@YA_K_K@Z			; x86_64_pdp_index
PUBLIC	?x86_64_pd_index@@YA_K_K@Z			; x86_64_pd_index
PUBLIC	?x86_64_pt_index@@YA_K_K@Z			; x86_64_pt_index
PUBLIC	?x86_64_p_index@@YA_K_K@Z			; x86_64_p_index
PUBLIC	?Au_x86_64_Paging_Init@@YAXXZ			; Au_x86_64_Paging_Init
PUBLIC	__JustMyCode_Default
EXTRN	AuPmmngrAlloc:PROC
EXTRN	AuPmmngrFree:PROC
EXTRN	P2V:PROC
EXTRN	V2P:PROC
EXTRN	?AuPmmngrMoveHigher@@YAXXZ:PROC			; AuPmmngrMoveHigher
EXTRN	x64_mfence:PROC
EXTRN	x64_read_cr3:PROC
EXTRN	x64_write_cr3:PROC
EXTRN	flush_tlb:PROC
EXTRN	memset:PROC
EXTRN	memcpy:PROC
EXTRN	__CheckForDebuggerJustMyCode:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuVmmngrInitialize@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+34
	DD	imagerel $unwind$?AuVmmngrInitialize@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AuVmmngrGetPage DD imagerel $LN10
	DD	imagerel $LN10+718
	DD	imagerel $unwind$AuVmmngrGetPage
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AuMapPage DD imagerel $LN7
	DD	imagerel $LN7+607
	DD	imagerel $unwind$AuMapPage
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AuMapPageEx DD imagerel $LN7
	DD	imagerel $LN7+607
	DD	imagerel $unwind$AuMapPageEx
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AuMapMMIO DD imagerel $LN6
	DD	imagerel $LN6+169
	DD	imagerel $unwind$AuMapMMIO
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AuGetFreePage DD imagerel $LN16
	DD	imagerel $LN16+416
	DD	imagerel $unwind$AuGetFreePage
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AuFreePages DD imagerel $LN8
	DD	imagerel $LN8+400
	DD	imagerel $unwind$AuFreePages
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AuGetPhysicalAddress DD imagerel $LN5
	DD	imagerel $LN5+225
	DD	imagerel $unwind$AuGetPhysicalAddress
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AuGetPhysicalAddressEx DD imagerel $LN5
	DD	imagerel $LN5+224
	DD	imagerel $unwind$AuGetPhysicalAddressEx
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AuCreateVirtualAddressSpace DD imagerel $LN9
	DD	imagerel $LN9+188
	DD	imagerel $unwind$AuCreateVirtualAddressSpace
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AuGetRootPageTable DD imagerel $LN3
	DD	imagerel $LN3+36
	DD	imagerel $unwind$AuGetRootPageTable
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuVmmngrBootFree@@YAXXZ DD imagerel $LN6
	DD	imagerel $LN6+91
	DD	imagerel $unwind$?AuVmmngrBootFree@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuVmmngrCloneAddressSpace@@YAXPEA_K0@Z DD imagerel $LN19
	DD	imagerel $LN19+695
	DD	imagerel $unwind$?AuVmmngrCloneAddressSpace@@YAXPEA_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?x86_64_pml4_index@@YA_K_K@Z DD imagerel $LN3
	DD	imagerel $LN3+47
	DD	imagerel $unwind$?x86_64_pml4_index@@YA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?x86_64_pdp_index@@YA_K_K@Z DD imagerel $LN3
	DD	imagerel $LN3+47
	DD	imagerel $unwind$?x86_64_pdp_index@@YA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?x86_64_pd_index@@YA_K_K@Z DD imagerel $LN3
	DD	imagerel $LN3+47
	DD	imagerel $unwind$?x86_64_pd_index@@YA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?x86_64_pt_index@@YA_K_K@Z DD imagerel $LN3
	DD	imagerel $LN3+47
	DD	imagerel $unwind$?x86_64_pt_index@@YA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?x86_64_p_index@@YA_K_K@Z DD imagerel $LN3
	DD	imagerel $LN3+43
	DD	imagerel $unwind$?x86_64_p_index@@YA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Au_x86_64_Paging_Init@@YAXXZ DD imagerel $LN12
	DD	imagerel $LN12+383
	DD	imagerel $unwind$?Au_x86_64_Paging_Init@@YAXXZ
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Au_x86_64_Paging_Init@@YAXXZ DD 025040e01H
	DD	0109230eH
	DD	050020012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?x86_64_p_index@@YA_K_K@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?x86_64_pt_index@@YA_K_K@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?x86_64_pd_index@@YA_K_K@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?x86_64_pdp_index@@YA_K_K@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?x86_64_pml4_index@@YA_K_K@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuVmmngrCloneAddressSpace@@YAXPEA_K0@Z DD 025041701H
	DD	01122317H
	DD	0500b001aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuVmmngrBootFree@@YAXXZ DD 025030b01H
	DD	0d206230bH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AuGetRootPageTable DD 025030b01H
	DD	0b206230bH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AuCreateVirtualAddressSpace DD 025030e01H
	DD	0f209230eH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AuGetPhysicalAddressEx DD 025041701H
	DD	01122317H
	DD	0500b0012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AuGetPhysicalAddress DD 025041201H
	DD	010d2312H
	DD	050060012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AuFreePages DD 025041b01H
	DD	0116231bH
	DD	0500f0014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AuGetFreePage DD 025041601H
	DD	01112316H
	DD	0500a0014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AuMapMMIO DD 025031701H
	DD	0f2122317H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AuMapPageEx DD 025042101H
	DD	011c2321H
	DD	050150016H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AuMapPage DD 025041c01H
	DD	0117231cH
	DD	050100016H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AuVmmngrGetPage DD 025041b01H
	DD	0116231bH
	DD	0500f001aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuVmmngrInitialize@@YAXXZ DD 025030b01H
	DD	0b206230bH
	DD	05002H
xdata	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Mm\vmmngr.cpp
;	COMDAT ?Au_x86_64_Paging_Init@@YAXXZ
_TEXT	SEGMENT
OldCR3$ = 0
NewCR3$ = 8
i$1 = 16
PDPT$ = 24
i$2 = 32
tv140 = 104
tv95 = 104
?Au_x86_64_Paging_Init@@YAXXZ PROC			; Au_x86_64_Paging_Init, COMDAT

; 80   : void Au_x86_64_Paging_Init() {

$LN12:
	push	rbp
	sub	rsp, 144				; 00000090H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__71D0FFAE_vmmngr@cpp
	call	__CheckForDebuggerJustMyCode

; 81   : 	uint64_t *OldCR3 = (uint64_t*)x64_read_cr3();

	call	x64_read_cr3
	mov	QWORD PTR OldCR3$[rbp], rax

; 82   : 	uint64_t *NewCR3 = (uint64_t*)AuPmmngrAlloc();

	call	AuPmmngrAlloc
	mov	QWORD PTR NewCR3$[rbp], rax

; 83   : 	memset(NewCR3, 0, 4096);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR NewCR3$[rbp]
	call	memset

; 84   : 	
; 85   : 	for (int i = 0; i < 512; ++i) {

	mov	DWORD PTR i$1[rbp], 0
	jmp	SHORT $LN4@Au_x86_64_
$LN2@Au_x86_64_:
	mov	eax, DWORD PTR i$1[rbp]
	inc	eax
	mov	DWORD PTR i$1[rbp], eax
$LN4@Au_x86_64_:
	cmp	DWORD PTR i$1[rbp], 512			; 00000200H
	jge	SHORT $LN3@Au_x86_64_

; 86   : 		if (i == 511)

	cmp	DWORD PTR i$1[rbp], 511			; 000001ffH
	jne	SHORT $LN8@Au_x86_64_

; 87   : 			continue;

	jmp	SHORT $LN2@Au_x86_64_
$LN8@Au_x86_64_:

; 88   : 
; 89   : 		if ((OldCR3[i] & X86_64_PAGING_PRESENT))

	movsxd	rax, DWORD PTR i$1[rbp]
	mov	rcx, QWORD PTR OldCR3$[rbp]
	mov	rax, QWORD PTR [rcx+rax*8]
	and	rax, 1
	test	rax, rax
	je	SHORT $LN9@Au_x86_64_

; 90   : 			NewCR3[i] = OldCR3[i];

	movsxd	rax, DWORD PTR i$1[rbp]
	movsxd	rcx, DWORD PTR i$1[rbp]
	mov	rdx, QWORD PTR NewCR3$[rbp]
	mov	r8, QWORD PTR OldCR3$[rbp]
	mov	rax, QWORD PTR [r8+rax*8]
	mov	QWORD PTR [rdx+rcx*8], rax
	jmp	SHORT $LN10@Au_x86_64_
$LN9@Au_x86_64_:

; 91   : 		else
; 92   : 			NewCR3[i] = 0;

	movsxd	rax, DWORD PTR i$1[rbp]
	mov	rcx, QWORD PTR NewCR3$[rbp]
	mov	QWORD PTR [rcx+rax*8], 0
$LN10@Au_x86_64_:

; 93   : 
; 94   : 	}

	jmp	SHORT $LN2@Au_x86_64_
$LN3@Au_x86_64_:

; 95   : 
; 96   : 	uint64_t* PDPT = (uint64_t*)AuPmmngrAlloc();

	call	AuPmmngrAlloc
	mov	QWORD PTR PDPT$[rbp], rax

; 97   : 	memset(PDPT, 0, 4096);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR PDPT$[rbp]
	call	memset

; 98   : 
; 99   : 	NewCR3[x86_64_pml4_index(PHYSICAL_MEM_BASE)] = (uint64_t)PDPT | X86_64_PAGING_PRESENT | X86_64_PAGING_WRITABLE;

	mov	rax, QWORD PTR PDPT$[rbp]
	or	rax, 1
	or	rax, 2
	mov	QWORD PTR tv95[rbp], rax
	mov	rcx, -140737488355328			; ffff800000000000H
	call	?x86_64_pml4_index@@YA_K_K@Z		; x86_64_pml4_index
	mov	rcx, QWORD PTR NewCR3$[rbp]
	mov	rdx, QWORD PTR tv95[rbp]
	mov	QWORD PTR [rcx+rax*8], rdx

; 100  : 
; 101  : 	for (size_t i = 0; i < 512; i++)

	mov	QWORD PTR i$2[rbp], 0
	jmp	SHORT $LN7@Au_x86_64_
$LN5@Au_x86_64_:
	mov	rax, QWORD PTR i$2[rbp]
	inc	rax
	mov	QWORD PTR i$2[rbp], rax
$LN7@Au_x86_64_:
	cmp	QWORD PTR i$2[rbp], 512			; 00000200H
	jae	SHORT $LN6@Au_x86_64_

; 102  : 		PDPT[x86_64_pdp_index(PHYSICAL_MEM_BASE) + i] = i * 512 * 512 * 4096 | 0x80 | X86_64_PAGING_PRESENT | X86_64_PAGING_WRITABLE;

	imul	rax, QWORD PTR i$2[rbp], 512		; 00000200H
	imul	rax, rax, 512				; 00000200H
	imul	rax, rax, 4096				; 00001000H
	bts	rax, 7
	or	rax, 1
	or	rax, 2
	mov	QWORD PTR tv140[rbp], rax
	mov	rcx, -140737488355328			; ffff800000000000H
	call	?x86_64_pdp_index@@YA_K_K@Z		; x86_64_pdp_index
	add	rax, QWORD PTR i$2[rbp]
	mov	rcx, QWORD PTR PDPT$[rbp]
	mov	rdx, QWORD PTR tv140[rbp]
	mov	QWORD PTR [rcx+rax*8], rdx
	jmp	SHORT $LN5@Au_x86_64_
$LN6@Au_x86_64_:

; 103  : 
; 104  : 
; 105  : 	x64_write_cr3((size_t)NewCR3);

	mov	rcx, QWORD PTR NewCR3$[rbp]
	call	x64_write_cr3

; 106  : 
; 107  : 	_RootPaging = NewCR3;

	mov	rax, QWORD PTR NewCR3$[rbp]
	mov	QWORD PTR ?_RootPaging@@3PEA_KEA, rax	; _RootPaging

; 108  : 
; 109  : 	AuPmmngrMoveHigher();

	call	?AuPmmngrMoveHigher@@YAXXZ		; AuPmmngrMoveHigher

; 110  : 
; 111  : 	_MmioBase = (uint64_t*)MMIO_BASE;

	mov	rax, -1030792151040			; ffffff1000000000H
	mov	QWORD PTR ?_MmioBase@@3PEA_KEA, rax	; _MmioBase

; 112  : }

	lea	rsp, QWORD PTR [rbp+112]
	pop	rbp
	ret	0
?Au_x86_64_Paging_Init@@YAXXZ ENDP			; Au_x86_64_Paging_Init
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Mm\vmmngr.cpp
;	COMDAT ?x86_64_p_index@@YA_K_K@Z
_TEXT	SEGMENT
addr$ = 80
?x86_64_p_index@@YA_K_K@Z PROC				; x86_64_p_index, COMDAT

; 71   : size_t x86_64_p_index(uint64_t addr){

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__71D0FFAE_vmmngr@cpp
	call	__CheckForDebuggerJustMyCode

; 72   : 	return (addr & 0x7ff);

	mov	rax, QWORD PTR addr$[rbp]
	and	rax, 2047				; 000007ffH

; 73   : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
?x86_64_p_index@@YA_K_K@Z ENDP				; x86_64_p_index
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Mm\vmmngr.cpp
;	COMDAT ?x86_64_pt_index@@YA_K_K@Z
_TEXT	SEGMENT
addr$ = 80
?x86_64_pt_index@@YA_K_K@Z PROC				; x86_64_pt_index, COMDAT

; 67   : size_t x86_64_pt_index(uint64_t addr){

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__71D0FFAE_vmmngr@cpp
	call	__CheckForDebuggerJustMyCode

; 68   : 	return (addr >> 12) & 0x1ff;

	mov	rax, QWORD PTR addr$[rbp]
	shr	rax, 12
	and	rax, 511				; 000001ffH

; 69   : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
?x86_64_pt_index@@YA_K_K@Z ENDP				; x86_64_pt_index
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Mm\vmmngr.cpp
;	COMDAT ?x86_64_pd_index@@YA_K_K@Z
_TEXT	SEGMENT
addr$ = 80
?x86_64_pd_index@@YA_K_K@Z PROC				; x86_64_pd_index, COMDAT

; 63   : size_t x86_64_pd_index(uint64_t addr){

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__71D0FFAE_vmmngr@cpp
	call	__CheckForDebuggerJustMyCode

; 64   : 	return (addr >> 21) & 0x1ff;

	mov	rax, QWORD PTR addr$[rbp]
	shr	rax, 21
	and	rax, 511				; 000001ffH

; 65   : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
?x86_64_pd_index@@YA_K_K@Z ENDP				; x86_64_pd_index
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Mm\vmmngr.cpp
;	COMDAT ?x86_64_pdp_index@@YA_K_K@Z
_TEXT	SEGMENT
addr$ = 80
?x86_64_pdp_index@@YA_K_K@Z PROC			; x86_64_pdp_index, COMDAT

; 59   : size_t x86_64_pdp_index(uint64_t addr){

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__71D0FFAE_vmmngr@cpp
	call	__CheckForDebuggerJustMyCode

; 60   : 	return (addr >> 30) & 0x1ff;

	mov	rax, QWORD PTR addr$[rbp]
	shr	rax, 30
	and	rax, 511				; 000001ffH

; 61   : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
?x86_64_pdp_index@@YA_K_K@Z ENDP			; x86_64_pdp_index
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Mm\vmmngr.cpp
;	COMDAT ?x86_64_pml4_index@@YA_K_K@Z
_TEXT	SEGMENT
addr$ = 80
?x86_64_pml4_index@@YA_K_K@Z PROC			; x86_64_pml4_index, COMDAT

; 55   : size_t  x86_64_pml4_index(uint64_t addr){

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__71D0FFAE_vmmngr@cpp
	call	__CheckForDebuggerJustMyCode

; 56   : 	return (addr >> 39) & 0x1ff;

	mov	rax, QWORD PTR addr$[rbp]
	shr	rax, 39					; 00000027H
	and	rax, 511				; 000001ffH

; 57   : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
?x86_64_pml4_index@@YA_K_K@Z ENDP			; x86_64_pml4_index
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Mm\vmmngr.cpp
;	COMDAT ?AuVmmngrCloneAddressSpace@@YAXPEA_K0@Z
_TEXT	SEGMENT
i$1 = 0
pdp_new$2 = 8
pdp_in$3 = 16
j$4 = 24
pd_new$5 = 32
pd_in$6 = 40
k$7 = 48
pt_new$8 = 56
pt_in$9 = 64
m$10 = 72
addr$11 = 80
page$12 = 88
new_page$13 = 96
destcr3$ = 192
srccr3$ = 200
?AuVmmngrCloneAddressSpace@@YAXPEA_K0@Z PROC		; AuVmmngrCloneAddressSpace, COMDAT

; 516  : void AuVmmngrCloneAddressSpace(uint64_t *destcr3, uint64_t* srccr3){

$LN19:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 208				; 000000d0H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__71D0FFAE_vmmngr@cpp
	call	__CheckForDebuggerJustMyCode

; 517  : 	for (int i = 0; i < 256; ++i) {

	mov	DWORD PTR i$1[rbp], 0
	jmp	SHORT $LN4@AuVmmngrCl
$LN2@AuVmmngrCl:
	mov	eax, DWORD PTR i$1[rbp]
	inc	eax
	mov	DWORD PTR i$1[rbp], eax
$LN4@AuVmmngrCl:
	cmp	DWORD PTR i$1[rbp], 256			; 00000100H
	jge	$LN3@AuVmmngrCl

; 518  : 		if ((srccr3[i] & X86_64_PAGING_PRESENT)) {

	movsxd	rax, DWORD PTR i$1[rbp]
	mov	rcx, QWORD PTR srccr3$[rbp]
	mov	rax, QWORD PTR [rcx+rax*8]
	and	rax, 1
	test	rax, rax
	je	$LN14@AuVmmngrCl

; 519  : 			/* allocate a new pdp */
; 520  : 			uint64_t* pdp_new = (uint64_t*)P2V((size_t)AuPmmngrAlloc());

	call	AuPmmngrAlloc
	mov	rcx, rax
	call	P2V
	mov	QWORD PTR pdp_new$2[rbp], rax

; 521  : 			memset(pdp_new, 0, PAGE_SIZE);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR pdp_new$2[rbp]
	call	memset

; 522  : 			destcr3[i] = V2P((size_t)pdp_new) | X86_64_PAGING_PRESENT | X86_64_PAGING_USER;

	mov	rcx, QWORD PTR pdp_new$2[rbp]
	call	V2P
	or	rax, 1
	or	rax, 4
	movsxd	rcx, DWORD PTR i$1[rbp]
	mov	rdx, QWORD PTR destcr3$[rbp]
	mov	QWORD PTR [rdx+rcx*8], rax

; 523  : 			uint64_t *pdp_in = (uint64_t*)(P2V(srccr3[i]) & ~(4096 - 1));

	movsxd	rax, DWORD PTR i$1[rbp]
	mov	rcx, QWORD PTR srccr3$[rbp]
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	P2V
	and	rax, -4096				; fffffffffffff000H
	mov	QWORD PTR pdp_in$3[rbp], rax

; 524  : 			/* inside page directory pointer */
; 525  : 			for (int j = 0; j < 512; ++j) {

	mov	DWORD PTR j$4[rbp], 0
	jmp	SHORT $LN7@AuVmmngrCl
$LN5@AuVmmngrCl:
	mov	eax, DWORD PTR j$4[rbp]
	inc	eax
	mov	DWORD PTR j$4[rbp], eax
$LN7@AuVmmngrCl:
	cmp	DWORD PTR j$4[rbp], 512			; 00000200H
	jge	$LN6@AuVmmngrCl

; 526  : 				if ((pdp_in[j] & X86_64_PAGING_PRESENT)) {

	movsxd	rax, DWORD PTR j$4[rbp]
	mov	rcx, QWORD PTR pdp_in$3[rbp]
	mov	rax, QWORD PTR [rcx+rax*8]
	and	rax, 1
	test	rax, rax
	je	$LN15@AuVmmngrCl

; 527  : 					uint64_t* pd_new = (uint64_t*)P2V((size_t)AuPmmngrAlloc());

	call	AuPmmngrAlloc
	mov	rcx, rax
	call	P2V
	mov	QWORD PTR pd_new$5[rbp], rax

; 528  : 					memset(pd_new, 0, PAGE_SIZE);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR pd_new$5[rbp]
	call	memset

; 529  : 					pdp_new[j] = V2P((size_t)pd_new) | X86_64_PAGING_PRESENT | X86_64_PAGING_USER;

	mov	rcx, QWORD PTR pd_new$5[rbp]
	call	V2P
	or	rax, 1
	or	rax, 4
	movsxd	rcx, DWORD PTR j$4[rbp]
	mov	rdx, QWORD PTR pdp_new$2[rbp]
	mov	QWORD PTR [rdx+rcx*8], rax

; 530  : 					uint64_t* pd_in = (uint64_t*)(P2V(pdp_in[j]) & ~(4096 - 1));

	movsxd	rax, DWORD PTR j$4[rbp]
	mov	rcx, QWORD PTR pdp_in$3[rbp]
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	P2V
	and	rax, -4096				; fffffffffffff000H
	mov	QWORD PTR pd_in$6[rbp], rax

; 531  : 
; 532  : 					/* inside page directory*/
; 533  : 					for (int k = 0; k < 512; ++k) {

	mov	DWORD PTR k$7[rbp], 0
	jmp	SHORT $LN10@AuVmmngrCl
$LN8@AuVmmngrCl:
	mov	eax, DWORD PTR k$7[rbp]
	inc	eax
	mov	DWORD PTR k$7[rbp], eax
$LN10@AuVmmngrCl:
	cmp	DWORD PTR k$7[rbp], 512			; 00000200H
	jge	$LN9@AuVmmngrCl

; 534  : 						if ((pd_in[k] & X86_64_PAGING_PRESENT)) {

	movsxd	rax, DWORD PTR k$7[rbp]
	mov	rcx, QWORD PTR pd_in$6[rbp]
	mov	rax, QWORD PTR [rcx+rax*8]
	and	rax, 1
	test	rax, rax
	je	$LN16@AuVmmngrCl

; 535  : 							uint64_t* pt_new = (uint64_t*)P2V((size_t)AuPmmngrAlloc());

	call	AuPmmngrAlloc
	mov	rcx, rax
	call	P2V
	mov	QWORD PTR pt_new$8[rbp], rax

; 536  : 							memset(pt_new, 0, PAGE_SIZE);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR pt_new$8[rbp]
	call	memset

; 537  : 							pd_new[k] = V2P((size_t)pt_new) | X86_64_PAGING_PRESENT | X86_64_PAGING_USER;

	mov	rcx, QWORD PTR pt_new$8[rbp]
	call	V2P
	or	rax, 1
	or	rax, 4
	movsxd	rcx, DWORD PTR k$7[rbp]
	mov	rdx, QWORD PTR pd_new$5[rbp]
	mov	QWORD PTR [rdx+rcx*8], rax

; 538  : 							uint64_t* pt_in = (uint64_t*)(P2V(pd_in[k]) & ~(4096 - 1));

	movsxd	rax, DWORD PTR k$7[rbp]
	mov	rcx, QWORD PTR pd_in$6[rbp]
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	P2V
	and	rax, -4096				; fffffffffffff000H
	mov	QWORD PTR pt_in$9[rbp], rax

; 539  : 
; 540  : 							for (int m = 0; m < 512; ++m) {

	mov	DWORD PTR m$10[rbp], 0
	jmp	SHORT $LN13@AuVmmngrCl
$LN11@AuVmmngrCl:
	mov	eax, DWORD PTR m$10[rbp]
	inc	eax
	mov	DWORD PTR m$10[rbp], eax
$LN13@AuVmmngrCl:
	cmp	DWORD PTR m$10[rbp], 512		; 00000200H
	jge	$LN12@AuVmmngrCl

; 541  : 								if ((pt_in[m] & X86_64_PAGING_PRESENT)) {

	movsxd	rax, DWORD PTR m$10[rbp]
	mov	rcx, QWORD PTR pt_in$9[rbp]
	mov	rax, QWORD PTR [rcx+rax*8]
	and	rax, 1
	test	rax, rax
	je	$LN17@AuVmmngrCl

; 542  : 									size_t addr = ((i << (9 * 3 + 12)) | (j << (9 * 2 + 12)) | (k << (9 + 12)) |

	mov	eax, DWORD PTR i$1[rbp]
	shl	eax, 39					; 00000027H
	mov	ecx, DWORD PTR j$4[rbp]
	shl	ecx, 30
	or	eax, ecx
	mov	ecx, DWORD PTR k$7[rbp]
	shl	ecx, 21
	or	eax, ecx
	mov	ecx, DWORD PTR m$10[rbp]
	shl	ecx, 12
	or	eax, ecx
	cdqe
	mov	QWORD PTR addr$11[rbp], rax

; 543  : 										(m << PAGE_SHIFT));
; 544  : 									uint64_t *page = (uint64_t*)(P2V(pt_in[m]) & ~(4096 - 1));

	movsxd	rax, DWORD PTR m$10[rbp]
	mov	rcx, QWORD PTR pt_in$9[rbp]
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	P2V
	and	rax, -4096				; fffffffffffff000H
	mov	QWORD PTR page$12[rbp], rax

; 545  : 									/* here clone the pages to new pages */
; 546  : 									uint64_t* new_page = (uint64_t*)P2V((size_t)AuPmmngrAlloc());

	call	AuPmmngrAlloc
	mov	rcx, rax
	call	P2V
	mov	QWORD PTR new_page$13[rbp], rax

; 547  : 									memcpy(new_page, page, PAGE_SIZE);

	mov	r8d, 4096				; 00001000H
	mov	rdx, QWORD PTR page$12[rbp]
	mov	rcx, QWORD PTR new_page$13[rbp]
	call	memcpy

; 548  : 									pt_new[m] = V2P((size_t)new_page) | X86_64_PAGING_PRESENT | X86_64_PAGING_WRITABLE | X86_64_PAGING_USER;

	mov	rcx, QWORD PTR new_page$13[rbp]
	call	V2P
	or	rax, 1
	or	rax, 2
	or	rax, 4
	movsxd	rcx, DWORD PTR m$10[rbp]
	mov	rdx, QWORD PTR pt_new$8[rbp]
	mov	QWORD PTR [rdx+rcx*8], rax
$LN17@AuVmmngrCl:

; 549  : 									
; 550  : 								}
; 551  : 							}

	jmp	$LN11@AuVmmngrCl
$LN12@AuVmmngrCl:
$LN16@AuVmmngrCl:

; 552  : 						}
; 553  : 					}

	jmp	$LN8@AuVmmngrCl
$LN9@AuVmmngrCl:
$LN15@AuVmmngrCl:

; 554  : 				}
; 555  : 			}

	jmp	$LN5@AuVmmngrCl
$LN6@AuVmmngrCl:
$LN14@AuVmmngrCl:

; 556  : 		}
; 557  : 	}

	jmp	$LN2@AuVmmngrCl
$LN3@AuVmmngrCl:

; 558  : }

	lea	rsp, QWORD PTR [rbp+176]
	pop	rbp
	ret	0
?AuVmmngrCloneAddressSpace@@YAXPEA_K0@Z ENDP		; AuVmmngrCloneAddressSpace
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Mm\vmmngr.cpp
;	COMDAT ?AuVmmngrBootFree@@YAXXZ
_TEXT	SEGMENT
cr3$ = 0
i$1 = 8
?AuVmmngrBootFree@@YAXXZ PROC				; AuVmmngrBootFree, COMDAT

; 502  : void AuVmmngrBootFree() {

$LN6:
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__71D0FFAE_vmmngr@cpp
	call	__CheckForDebuggerJustMyCode

; 503  : #ifdef ARCH_X64
; 504  : 	uint64_t* cr3 = (uint64_t*)x64_read_cr3();

	call	x64_read_cr3
	mov	QWORD PTR cr3$[rbp], rax

; 505  : 	for (int i = 0; i < 256; i++)

	mov	DWORD PTR i$1[rbp], 0
	jmp	SHORT $LN4@AuVmmngrBo
$LN2@AuVmmngrBo:
	mov	eax, DWORD PTR i$1[rbp]
	inc	eax
	mov	DWORD PTR i$1[rbp], eax
$LN4@AuVmmngrBo:
	cmp	DWORD PTR i$1[rbp], 256			; 00000100H
	jge	SHORT $LN3@AuVmmngrBo

; 506  : 		cr3[i] = 0;

	movsxd	rax, DWORD PTR i$1[rbp]
	mov	rcx, QWORD PTR cr3$[rbp]
	mov	QWORD PTR [rcx+rax*8], 0
	jmp	SHORT $LN2@AuVmmngrBo
$LN3@AuVmmngrBo:

; 507  : 	x64_write_cr3((uint64_t)cr3);

	mov	rcx, QWORD PTR cr3$[rbp]
	call	x64_write_cr3

; 508  : #endif
; 509  : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
?AuVmmngrBootFree@@YAXXZ ENDP				; AuVmmngrBootFree
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Mm\vmmngr.cpp
;	COMDAT AuGetRootPageTable
_TEXT	SEGMENT
AuGetRootPageTable PROC					; COMDAT

; 482  : uint64_t* AuGetRootPageTable() {

$LN3:
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__71D0FFAE_vmmngr@cpp
	call	__CheckForDebuggerJustMyCode

; 483  : #ifdef ARCH_X64
; 484  : 	return _RootPaging;

	mov	rax, QWORD PTR ?_RootPaging@@3PEA_KEA	; _RootPaging

; 485  : #endif
; 486  : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
AuGetRootPageTable ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Mm\vmmngr.cpp
;	COMDAT AuCreateVirtualAddressSpace
_TEXT	SEGMENT
root_cr3$ = 0
new_cr3$ = 8
i$1 = 16
AuCreateVirtualAddressSpace PROC			; COMDAT

; 461  : uint64_t* AuCreateVirtualAddressSpace() {

$LN9:
	push	rbp
	sub	rsp, 128				; 00000080H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__71D0FFAE_vmmngr@cpp
	call	__CheckForDebuggerJustMyCode

; 462  : 	uint64_t* root_cr3 = (uint64_t*)P2V((size_t)_RootPaging);

	mov	rcx, QWORD PTR ?_RootPaging@@3PEA_KEA	; _RootPaging
	call	P2V
	mov	QWORD PTR root_cr3$[rbp], rax

; 463  : 	uint64_t* new_cr3 = (uint64_t*)P2V((size_t)AuPmmngrAlloc());

	call	AuPmmngrAlloc
	mov	rcx, rax
	call	P2V
	mov	QWORD PTR new_cr3$[rbp], rax

; 464  : 	memset(new_cr3, 0, PAGE_SIZE);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR new_cr3$[rbp]
	call	memset

; 465  : 
; 466  : 	for (int i = 0; i < 512; i++) {

	mov	DWORD PTR i$1[rbp], 0
	jmp	SHORT $LN4@AuCreateVi
$LN2@AuCreateVi:
	mov	eax, DWORD PTR i$1[rbp]
	inc	eax
	mov	DWORD PTR i$1[rbp], eax
$LN4@AuCreateVi:
	cmp	DWORD PTR i$1[rbp], 512			; 00000200H
	jge	SHORT $LN3@AuCreateVi

; 467  : 		if (i < 256)

	cmp	DWORD PTR i$1[rbp], 256			; 00000100H
	jge	SHORT $LN5@AuCreateVi

; 468  : 			continue;

	jmp	SHORT $LN2@AuCreateVi
$LN5@AuCreateVi:

; 469  : 		if (root_cr3[i] & X86_64_PAGING_PRESENT)

	movsxd	rax, DWORD PTR i$1[rbp]
	mov	rcx, QWORD PTR root_cr3$[rbp]
	mov	rax, QWORD PTR [rcx+rax*8]
	and	rax, 1
	test	rax, rax
	je	SHORT $LN6@AuCreateVi

; 470  : 			new_cr3[i] = root_cr3[i];

	movsxd	rax, DWORD PTR i$1[rbp]
	movsxd	rcx, DWORD PTR i$1[rbp]
	mov	rdx, QWORD PTR new_cr3$[rbp]
	mov	r8, QWORD PTR root_cr3$[rbp]
	mov	rax, QWORD PTR [r8+rax*8]
	mov	QWORD PTR [rdx+rcx*8], rax
	jmp	SHORT $LN7@AuCreateVi
$LN6@AuCreateVi:

; 471  : 		else
; 472  : 			new_cr3[i] = 0;

	movsxd	rax, DWORD PTR i$1[rbp]
	mov	rcx, QWORD PTR new_cr3$[rbp]
	mov	QWORD PTR [rcx+rax*8], 0
$LN7@AuCreateVi:

; 473  : 	}

	jmp	SHORT $LN2@AuCreateVi
$LN3@AuCreateVi:

; 474  : 
; 475  : 	return new_cr3;

	mov	rax, QWORD PTR new_cr3$[rbp]

; 476  : }

	lea	rsp, QWORD PTR [rbp+96]
	pop	rbp
	ret	0
AuCreateVirtualAddressSpace ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Mm\vmmngr.cpp
;	COMDAT AuGetPhysicalAddressEx
_TEXT	SEGMENT
i1$ = 0
pml4_$ = 8
pdpt$ = 16
pd$ = 24
pt$ = 32
page$ = 40
cr3$ = 128
virt_addr$ = 136
AuGetPhysicalAddressEx PROC				; COMDAT

; 439  : void* AuGetPhysicalAddressEx(uint64_t* cr3, uint64_t virt_addr){

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 144				; 00000090H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__71D0FFAE_vmmngr@cpp
	call	__CheckForDebuggerJustMyCode

; 440  : 
; 441  : 	const long i1 = x86_64_pml4_index(virt_addr);

	mov	rcx, QWORD PTR virt_addr$[rbp]
	call	?x86_64_pml4_index@@YA_K_K@Z		; x86_64_pml4_index
	mov	DWORD PTR i1$[rbp], eax

; 442  : 
; 443  : 	uint64_t *pml4_ = cr3;

	mov	rax, QWORD PTR cr3$[rbp]
	mov	QWORD PTR pml4_$[rbp], rax

; 444  : 	uint64_t *pdpt = (uint64_t*)(P2V(pml4_[x86_64_pml4_index(virt_addr)]) & ~(4096 - 1));

	mov	rcx, QWORD PTR virt_addr$[rbp]
	call	?x86_64_pml4_index@@YA_K_K@Z		; x86_64_pml4_index
	mov	rcx, QWORD PTR pml4_$[rbp]
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	P2V
	and	rax, -4096				; fffffffffffff000H
	mov	QWORD PTR pdpt$[rbp], rax

; 445  : 	uint64_t *pd = (uint64_t*)(P2V(pdpt[x86_64_pdp_index(virt_addr)]) & ~(4096 - 1));

	mov	rcx, QWORD PTR virt_addr$[rbp]
	call	?x86_64_pdp_index@@YA_K_K@Z		; x86_64_pdp_index
	mov	rcx, QWORD PTR pdpt$[rbp]
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	P2V
	and	rax, -4096				; fffffffffffff000H
	mov	QWORD PTR pd$[rbp], rax

; 446  : 	uint64_t *pt = (uint64_t*)(P2V(pd[x86_64_pd_index(virt_addr)]) & ~(4096 - 1));

	mov	rcx, QWORD PTR virt_addr$[rbp]
	call	?x86_64_pd_index@@YA_K_K@Z		; x86_64_pd_index
	mov	rcx, QWORD PTR pd$[rbp]
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	P2V
	and	rax, -4096				; fffffffffffff000H
	mov	QWORD PTR pt$[rbp], rax

; 447  : 	uint64_t *page = (uint64_t*)(P2V(pt[x86_64_pt_index(virt_addr)]) & ~(4096 - 1));

	mov	rcx, QWORD PTR virt_addr$[rbp]
	call	?x86_64_pt_index@@YA_K_K@Z		; x86_64_pt_index
	mov	rcx, QWORD PTR pt$[rbp]
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	P2V
	and	rax, -4096				; fffffffffffff000H
	mov	QWORD PTR page$[rbp], rax

; 448  : 
; 449  : 	if (page)

	cmp	QWORD PTR page$[rbp], 0
	je	SHORT $LN2@AuGetPhysi

; 450  : 		return page;

	mov	rax, QWORD PTR page$[rbp]
	jmp	SHORT $LN1@AuGetPhysi
	jmp	SHORT $LN3@AuGetPhysi
$LN2@AuGetPhysi:

; 451  : 	else
; 452  : 		return NULL;

	xor	eax, eax
$LN3@AuGetPhysi:
$LN1@AuGetPhysi:

; 453  : 
; 454  : }

	lea	rsp, QWORD PTR [rbp+112]
	pop	rbp
	ret	0
AuGetPhysicalAddressEx ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Mm\vmmngr.cpp
;	COMDAT AuGetPhysicalAddress
_TEXT	SEGMENT
i1$ = 0
pml4_$ = 8
pdpt$ = 16
pd$ = 24
pt$ = 32
page$ = 40
virt_addr$ = 128
AuGetPhysicalAddress PROC				; COMDAT

; 416  : void* AuGetPhysicalAddress(uint64_t virt_addr){

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 144				; 00000090H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__71D0FFAE_vmmngr@cpp
	call	__CheckForDebuggerJustMyCode

; 417  : 
; 418  : 	const long i1 = x86_64_pml4_index(virt_addr);

	mov	rcx, QWORD PTR virt_addr$[rbp]
	call	?x86_64_pml4_index@@YA_K_K@Z		; x86_64_pml4_index
	mov	DWORD PTR i1$[rbp], eax

; 419  : 
; 420  : 	uint64_t *pml4_ = (uint64_t*)P2V(x64_read_cr3());

	call	x64_read_cr3
	mov	rcx, rax
	call	P2V
	mov	QWORD PTR pml4_$[rbp], rax

; 421  : 	uint64_t *pdpt = (uint64_t*)(P2V(pml4_[x86_64_pml4_index(virt_addr)]) & ~(4096 - 1));

	mov	rcx, QWORD PTR virt_addr$[rbp]
	call	?x86_64_pml4_index@@YA_K_K@Z		; x86_64_pml4_index
	mov	rcx, QWORD PTR pml4_$[rbp]
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	P2V
	and	rax, -4096				; fffffffffffff000H
	mov	QWORD PTR pdpt$[rbp], rax

; 422  : 	uint64_t *pd = (uint64_t*)(P2V(pdpt[x86_64_pdp_index(virt_addr)]) & ~(4096 - 1));

	mov	rcx, QWORD PTR virt_addr$[rbp]
	call	?x86_64_pdp_index@@YA_K_K@Z		; x86_64_pdp_index
	mov	rcx, QWORD PTR pdpt$[rbp]
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	P2V
	and	rax, -4096				; fffffffffffff000H
	mov	QWORD PTR pd$[rbp], rax

; 423  : 	uint64_t *pt = (uint64_t*)(P2V(pd[x86_64_pd_index(virt_addr)]) & ~(4096 - 1));

	mov	rcx, QWORD PTR virt_addr$[rbp]
	call	?x86_64_pd_index@@YA_K_K@Z		; x86_64_pd_index
	mov	rcx, QWORD PTR pd$[rbp]
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	P2V
	and	rax, -4096				; fffffffffffff000H
	mov	QWORD PTR pt$[rbp], rax

; 424  : 	uint64_t *page = (uint64_t*)(P2V(pt[x86_64_pt_index(virt_addr)]) & ~(4096 - 1));

	mov	rcx, QWORD PTR virt_addr$[rbp]
	call	?x86_64_pt_index@@YA_K_K@Z		; x86_64_pt_index
	mov	rcx, QWORD PTR pt$[rbp]
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	P2V
	and	rax, -4096				; fffffffffffff000H
	mov	QWORD PTR page$[rbp], rax

; 425  : 
; 426  : 	if (page)

	cmp	QWORD PTR page$[rbp], 0
	je	SHORT $LN2@AuGetPhysi

; 427  : 		return page;

	mov	rax, QWORD PTR page$[rbp]
	jmp	SHORT $LN1@AuGetPhysi
	jmp	SHORT $LN3@AuGetPhysi
$LN2@AuGetPhysi:

; 428  : 	else
; 429  : 		return NULL;

	xor	eax, eax
$LN3@AuGetPhysi:
$LN1@AuGetPhysi:

; 430  : 
; 431  : }

	lea	rsp, QWORD PTR [rbp+112]
	pop	rbp
	ret	0
AuGetPhysicalAddress ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Mm\vmmngr.cpp
;	COMDAT AuFreePages
_TEXT	SEGMENT
i1$ = 0
i$1 = 4
pml4_$2 = 8
pdpt$3 = 16
pd$4 = 24
pt$5 = 32
page$6 = 40
tv68 = 112
virt_addr$ = 144
free_physical$ = 152
s$ = 160
AuFreePages PROC					; COMDAT

; 387  : void AuFreePages(uint64_t virt_addr, bool free_physical, size_t s){

$LN8:
	mov	QWORD PTR [rsp+24], r8
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 160				; 000000a0H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__71D0FFAE_vmmngr@cpp
	call	__CheckForDebuggerJustMyCode

; 388  : 
; 389  : 	const long i1 = x86_64_pml4_index(virt_addr);

	mov	rcx, QWORD PTR virt_addr$[rbp]
	call	?x86_64_pml4_index@@YA_K_K@Z		; x86_64_pml4_index
	mov	DWORD PTR i1$[rbp], eax

; 390  : 
; 391  : 	for (int i = 0; i < (s / 4096) + 1; i++) {

	mov	DWORD PTR i$1[rbp], 0
	jmp	SHORT $LN4@AuFreePage
$LN2@AuFreePage:
	mov	eax, DWORD PTR i$1[rbp]
	inc	eax
	mov	DWORD PTR i$1[rbp], eax
$LN4@AuFreePage:
	movsxd	rax, DWORD PTR i$1[rbp]
	mov	QWORD PTR tv68[rbp], rax
	xor	edx, edx
	mov	rax, QWORD PTR s$[rbp]
	mov	ecx, 4096				; 00001000H
	div	rcx
	inc	rax
	mov	rcx, QWORD PTR tv68[rbp]
	cmp	rcx, rax
	jae	$LN3@AuFreePage

; 392  : 		uint64_t *pml4_ = (uint64_t*)P2V(x64_read_cr3());

	call	x64_read_cr3
	mov	rcx, rax
	call	P2V
	mov	QWORD PTR pml4_$2[rbp], rax

; 393  : 		uint64_t *pdpt = (uint64_t*)(P2V(pml4_[x86_64_pml4_index(virt_addr)]) & ~(4096 - 1));

	mov	rcx, QWORD PTR virt_addr$[rbp]
	call	?x86_64_pml4_index@@YA_K_K@Z		; x86_64_pml4_index
	mov	rcx, QWORD PTR pml4_$2[rbp]
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	P2V
	and	rax, -4096				; fffffffffffff000H
	mov	QWORD PTR pdpt$3[rbp], rax

; 394  : 		uint64_t *pd = (uint64_t*)(P2V(pdpt[x86_64_pdp_index(virt_addr)]) & ~(4096 - 1));

	mov	rcx, QWORD PTR virt_addr$[rbp]
	call	?x86_64_pdp_index@@YA_K_K@Z		; x86_64_pdp_index
	mov	rcx, QWORD PTR pdpt$3[rbp]
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	P2V
	and	rax, -4096				; fffffffffffff000H
	mov	QWORD PTR pd$4[rbp], rax

; 395  : 		uint64_t *pt = (uint64_t*)(P2V(pd[x86_64_pd_index(virt_addr)]) & ~(4096 - 1));

	mov	rcx, QWORD PTR virt_addr$[rbp]
	call	?x86_64_pd_index@@YA_K_K@Z		; x86_64_pd_index
	mov	rcx, QWORD PTR pd$4[rbp]
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	P2V
	and	rax, -4096				; fffffffffffff000H
	mov	QWORD PTR pt$5[rbp], rax

; 396  : 		uint64_t *page = (uint64_t*)(P2V(pt[x86_64_pt_index(virt_addr)]) & ~(4096 - 1));

	mov	rcx, QWORD PTR virt_addr$[rbp]
	call	?x86_64_pt_index@@YA_K_K@Z		; x86_64_pt_index
	mov	rcx, QWORD PTR pt$5[rbp]
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	P2V
	and	rax, -4096				; fffffffffffff000H
	mov	QWORD PTR page$6[rbp], rax

; 397  : 
; 398  : 		if ((pt[x86_64_pt_index(virt_addr)] & X86_64_PAGING_PRESENT) != 0) {

	mov	rcx, QWORD PTR virt_addr$[rbp]
	call	?x86_64_pt_index@@YA_K_K@Z		; x86_64_pt_index
	mov	rcx, QWORD PTR pt$5[rbp]
	mov	rax, QWORD PTR [rcx+rax*8]
	and	rax, 1
	test	rax, rax
	je	SHORT $LN5@AuFreePage

; 399  : 			pt[x86_64_pt_index(virt_addr)] = 0;

	mov	rcx, QWORD PTR virt_addr$[rbp]
	call	?x86_64_pt_index@@YA_K_K@Z		; x86_64_pt_index
	mov	rcx, QWORD PTR pt$5[rbp]
	mov	QWORD PTR [rcx+rax*8], 0
$LN5@AuFreePage:

; 400  : 		}
; 401  : 
; 402  : 		if (free_physical && page != 0)

	movzx	eax, BYTE PTR free_physical$[rbp]
	test	eax, eax
	je	SHORT $LN6@AuFreePage
	cmp	QWORD PTR page$6[rbp], 0
	je	SHORT $LN6@AuFreePage

; 403  : 			AuPmmngrFree((void*)V2P((size_t)page));

	mov	rcx, QWORD PTR page$6[rbp]
	call	V2P
	mov	rcx, rax
	call	AuPmmngrFree
$LN6@AuFreePage:

; 404  : 		
; 405  : 		virt_addr = virt_addr + i * 4096;

	imul	eax, DWORD PTR i$1[rbp], 4096		; 00001000H
	cdqe
	mov	rcx, QWORD PTR virt_addr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR virt_addr$[rbp], rax

; 406  : 	}

	jmp	$LN2@AuFreePage
$LN3@AuFreePage:

; 407  : 
; 408  : }

	lea	rsp, QWORD PTR [rbp+128]
	pop	rbp
	ret	0
AuFreePages ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Mm\vmmngr.cpp
;	COMDAT AuGetFreePage
_TEXT	SEGMENT
page$ = 0
start$ = 8
end$ = 16
pml4$ = 24
pdpt$1 = 32
pd$2 = 40
pt$3 = 48
user$ = 144
ptr$ = 152
AuGetFreePage PROC					; COMDAT

; 339  : uint64_t* AuGetFreePage(bool user, void* ptr) {

$LN16:
	mov	QWORD PTR [rsp+16], rdx
	mov	BYTE PTR [rsp+8], cl
	push	rbp
	sub	rsp, 160				; 000000a0H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__71D0FFAE_vmmngr@cpp
	call	__CheckForDebuggerJustMyCode

; 340  : 	uint64_t* page = 0;

	mov	QWORD PTR page$[rbp], 0

; 341  : 	uint64_t start = 0;

	mov	QWORD PTR start$[rbp], 0

; 342  : 	if (user) {

	movzx	eax, BYTE PTR user$[rbp]
	test	eax, eax
	je	SHORT $LN5@AuGetFreeP

; 343  : 		if (ptr)

	cmp	QWORD PTR ptr$[rbp], 0
	je	SHORT $LN7@AuGetFreeP

; 344  : 			start = (uint64_t)ptr;

	mov	rax, QWORD PTR ptr$[rbp]
	mov	QWORD PTR start$[rbp], rax
	jmp	SHORT $LN8@AuGetFreeP
$LN7@AuGetFreeP:

; 345  : 		else
; 346  : 			start = USER_BASE_ADDRESS;

	mov	QWORD PTR start$[rbp], 1610612736	; 60000000H
$LN8@AuGetFreeP:

; 347  : 	}

	jmp	SHORT $LN6@AuGetFreeP
$LN5@AuGetFreeP:

; 348  : 	else {
; 349  : 		if (ptr)

	cmp	QWORD PTR ptr$[rbp], 0
	je	SHORT $LN9@AuGetFreeP

; 350  : 			start = (uint64_t)ptr;

	mov	rax, QWORD PTR ptr$[rbp]
	mov	QWORD PTR start$[rbp], rax
	jmp	SHORT $LN10@AuGetFreeP
$LN9@AuGetFreeP:

; 351  : 		else
; 352  : 			start = KERNEL_BASE_ADDRESS;

	mov	rax, -35184372088832			; ffffe00000000000H
	mov	QWORD PTR start$[rbp], rax
$LN10@AuGetFreeP:
$LN6@AuGetFreeP:

; 353  : 	}
; 354  : 
; 355  : 	uint64_t* end = 0;

	mov	QWORD PTR end$[rbp], 0

; 356  : 	uint64_t *pml4 = (uint64_t*)P2V(x64_read_cr3());

	call	x64_read_cr3
	mov	rcx, rax
	call	P2V
	mov	QWORD PTR pml4$[rbp], rax
$LN2@AuGetFreeP:

; 357  : 
; 358  : 	/* Walk through every page tables */
; 359  : 	for (;;) {
; 360  : 		if (!(pml4[x86_64_pml4_index(start)] & X86_64_PAGING_PRESENT))

	mov	rcx, QWORD PTR start$[rbp]
	call	?x86_64_pml4_index@@YA_K_K@Z		; x86_64_pml4_index
	mov	rcx, QWORD PTR pml4$[rbp]
	mov	rax, QWORD PTR [rcx+rax*8]
	and	rax, 1
	test	rax, rax
	jne	SHORT $LN11@AuGetFreeP

; 361  : 			return (uint64_t*)start;

	mov	rax, QWORD PTR start$[rbp]
	jmp	$LN1@AuGetFreeP
$LN11@AuGetFreeP:

; 362  : 
; 363  : 		uint64_t *pdpt = (uint64_t*)(P2V(pml4[x86_64_pml4_index(start)]) & ~(4096 - 1));

	mov	rcx, QWORD PTR start$[rbp]
	call	?x86_64_pml4_index@@YA_K_K@Z		; x86_64_pml4_index
	mov	rcx, QWORD PTR pml4$[rbp]
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	P2V
	and	rax, -4096				; fffffffffffff000H
	mov	QWORD PTR pdpt$1[rbp], rax

; 364  : 		if (!(pdpt[x86_64_pdp_index(start)] & X86_64_PAGING_PRESENT))

	mov	rcx, QWORD PTR start$[rbp]
	call	?x86_64_pdp_index@@YA_K_K@Z		; x86_64_pdp_index
	mov	rcx, QWORD PTR pdpt$1[rbp]
	mov	rax, QWORD PTR [rcx+rax*8]
	and	rax, 1
	test	rax, rax
	jne	SHORT $LN12@AuGetFreeP

; 365  : 			return (uint64_t*)start;

	mov	rax, QWORD PTR start$[rbp]
	jmp	$LN1@AuGetFreeP
$LN12@AuGetFreeP:

; 366  : 
; 367  : 		uint64_t *pd = (uint64_t*)(P2V(pdpt[x86_64_pdp_index(start)]) & ~(4096 - 1));

	mov	rcx, QWORD PTR start$[rbp]
	call	?x86_64_pdp_index@@YA_K_K@Z		; x86_64_pdp_index
	mov	rcx, QWORD PTR pdpt$1[rbp]
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	P2V
	and	rax, -4096				; fffffffffffff000H
	mov	QWORD PTR pd$2[rbp], rax

; 368  : 		if (!(pd[x86_64_pd_index(start)] & X86_64_PAGING_PRESENT))

	mov	rcx, QWORD PTR start$[rbp]
	call	?x86_64_pd_index@@YA_K_K@Z		; x86_64_pd_index
	mov	rcx, QWORD PTR pd$2[rbp]
	mov	rax, QWORD PTR [rcx+rax*8]
	and	rax, 1
	test	rax, rax
	jne	SHORT $LN13@AuGetFreeP

; 369  : 			return (uint64_t*)start;

	mov	rax, QWORD PTR start$[rbp]
	jmp	SHORT $LN1@AuGetFreeP
$LN13@AuGetFreeP:

; 370  : 
; 371  : 		uint64_t *pt = (uint64_t*)(P2V(pd[x86_64_pd_index(start)]) & ~(4096 - 1));

	mov	rcx, QWORD PTR start$[rbp]
	call	?x86_64_pd_index@@YA_K_K@Z		; x86_64_pd_index
	mov	rcx, QWORD PTR pd$2[rbp]
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	P2V
	and	rax, -4096				; fffffffffffff000H
	mov	QWORD PTR pt$3[rbp], rax

; 372  : 
; 373  : 		if (!(pt[x86_64_pt_index(start)] & X86_64_PAGING_PRESENT))

	mov	rcx, QWORD PTR start$[rbp]
	call	?x86_64_pt_index@@YA_K_K@Z		; x86_64_pt_index
	mov	rcx, QWORD PTR pt$3[rbp]
	mov	rax, QWORD PTR [rcx+rax*8]
	and	rax, 1
	test	rax, rax
	jne	SHORT $LN14@AuGetFreeP

; 374  : 			return (uint64_t*)start;

	mov	rax, QWORD PTR start$[rbp]
	jmp	SHORT $LN1@AuGetFreeP
$LN14@AuGetFreeP:

; 375  : 
; 376  : 		start += 4096;

	mov	rax, QWORD PTR start$[rbp]
	add	rax, 4096				; 00001000H
	mov	QWORD PTR start$[rbp], rax

; 377  : 	}

	jmp	$LN2@AuGetFreeP

; 378  : 	return 0;

	xor	eax, eax
$LN1@AuGetFreeP:

; 379  : }

	lea	rsp, QWORD PTR [rbp+128]
	pop	rbp
	ret	0
AuGetFreePage ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Mm\vmmngr.cpp
;	COMDAT AuMapMMIO
_TEXT	SEGMENT
out$ = 0
i$1 = 8
address$ = 16
phys_addr$ = 112
page_count$ = 120
AuMapMMIO PROC						; COMDAT

; 321  : void* AuMapMMIO(uint64_t phys_addr, size_t page_count) {

$LN6:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 128				; 00000080H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__71D0FFAE_vmmngr@cpp
	call	__CheckForDebuggerJustMyCode

; 322  : 	uint64_t out = (uint64_t)_MmioBase;

	mov	rax, QWORD PTR ?_MmioBase@@3PEA_KEA	; _MmioBase
	mov	QWORD PTR out$[rbp], rax

; 323  : 	for (size_t i = 0; i < page_count; i++)

	mov	QWORD PTR i$1[rbp], 0
	jmp	SHORT $LN4@AuMapMMIO
$LN2@AuMapMMIO:
	mov	rax, QWORD PTR i$1[rbp]
	inc	rax
	mov	QWORD PTR i$1[rbp], rax
$LN4@AuMapMMIO:
	mov	rax, QWORD PTR page_count$[rbp]
	cmp	QWORD PTR i$1[rbp], rax
	jae	SHORT $LN3@AuMapMMIO

; 324  : 		AuMapPage(phys_addr + i * 4096, out + i * 4096, 0x04 | 0x80000 | 0x200000);

	imul	rax, QWORD PTR i$1[rbp], 4096		; 00001000H
	mov	rcx, QWORD PTR out$[rbp]
	add	rcx, rax
	mov	rax, rcx
	imul	rcx, QWORD PTR i$1[rbp], 4096		; 00001000H
	mov	rdx, QWORD PTR phys_addr$[rbp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r8b, 4
	mov	rdx, rax
	call	AuMapPage
	jmp	SHORT $LN2@AuMapMMIO
$LN3@AuMapMMIO:

; 325  : 
; 326  : 	uint64_t address = out;

	mov	rax, QWORD PTR out$[rbp]
	mov	QWORD PTR address$[rbp], rax

; 327  : 	_MmioBase = (uint64_t*)(address + (page_count * 4096));

	imul	rax, QWORD PTR page_count$[rbp], 4096	; 00001000H
	mov	rcx, QWORD PTR address$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR ?_MmioBase@@3PEA_KEA, rax	; _MmioBase

; 328  : 	return (void*)out;

	mov	rax, QWORD PTR out$[rbp]

; 329  : }

	lea	rsp, QWORD PTR [rbp+96]
	pop	rbp
	ret	0
AuMapMMIO ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Mm\vmmngr.cpp
;	COMDAT AuMapPageEx
_TEXT	SEGMENT
flags$ = 0
i4$ = 4
i3$ = 8
i2$ = 12
i1$ = 16
page$1 = 24
pml3$ = 32
page$2 = 40
pml2$ = 48
page$3 = 56
pml1$ = 64
pml4i$ = 160
phys_addr$ = 168
virt_addr$ = 176
attrib$ = 184
AuMapPageEx PROC					; COMDAT

; 261  : bool AuMapPageEx(uint64_t *pml4i, uint64_t phys_addr, uint64_t virt_addr, uint8_t attrib) {

$LN7:
	mov	BYTE PTR [rsp+32], r9b
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 176				; 000000b0H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__71D0FFAE_vmmngr@cpp
	call	__CheckForDebuggerJustMyCode

; 262  : 	uint8_t flags = X86_64_PAGING_PRESENT | X86_64_PAGING_WRITABLE | attrib;

	movzx	eax, BYTE PTR attrib$[rbp]
	or	eax, 3
	mov	BYTE PTR flags$[rbp], al

; 263  : 
; 264  : 	const long i4 = (virt_addr >> 39) & 0x1FF;

	mov	rax, QWORD PTR virt_addr$[rbp]
	shr	rax, 39					; 00000027H
	and	rax, 511				; 000001ffH
	mov	DWORD PTR i4$[rbp], eax

; 265  : 	const long i3 = (virt_addr >> 30) & 0x1FF;

	mov	rax, QWORD PTR virt_addr$[rbp]
	shr	rax, 30
	and	rax, 511				; 000001ffH
	mov	DWORD PTR i3$[rbp], eax

; 266  : 	const long i2 = (virt_addr >> 21) & 0x1FF;

	mov	rax, QWORD PTR virt_addr$[rbp]
	shr	rax, 21
	and	rax, 511				; 000001ffH
	mov	DWORD PTR i2$[rbp], eax

; 267  : 	const long i1 = (virt_addr >> 12) & 0x1FF;

	mov	rax, QWORD PTR virt_addr$[rbp]
	shr	rax, 12
	and	rax, 511				; 000001ffH
	mov	DWORD PTR i1$[rbp], eax

; 268  : 
; 269  : 
; 270  : 	if (!(pml4i[i4] & X86_64_PAGING_PRESENT))

	movsxd	rax, DWORD PTR i4$[rbp]
	mov	rcx, QWORD PTR pml4i$[rbp]
	mov	rax, QWORD PTR [rcx+rax*8]
	and	rax, 1
	test	rax, rax
	jne	SHORT $LN2@AuMapPageE

; 271  : 	{
; 272  : 		const uint64_t page = (uint64_t)AuPmmngrAlloc();

	call	AuPmmngrAlloc
	mov	QWORD PTR page$1[rbp], rax

; 273  : 		pml4i[i4] = page | flags;

	movzx	eax, BYTE PTR flags$[rbp]
	mov	rcx, QWORD PTR page$1[rbp]
	or	rcx, rax
	mov	rax, rcx
	movsxd	rcx, DWORD PTR i4$[rbp]
	mov	rdx, QWORD PTR pml4i$[rbp]
	mov	QWORD PTR [rdx+rcx*8], rax

; 274  : 		memset((void*)P2V(page), 0, 4096);

	mov	rcx, QWORD PTR page$1[rbp]
	call	P2V
	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, rax
	call	memset

; 275  : 		flush_tlb((void*)pml4i);

	mov	rcx, QWORD PTR pml4i$[rbp]
	call	flush_tlb

; 276  : 		x64_mfence();

	call	x64_mfence
$LN2@AuMapPageE:

; 277  : 	}
; 278  : 	uint64_t* pml3 = (uint64_t*)(P2V(pml4i[i4]) & ~(4096 - 1));

	movsxd	rax, DWORD PTR i4$[rbp]
	mov	rcx, QWORD PTR pml4i$[rbp]
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	P2V
	and	rax, -4096				; fffffffffffff000H
	mov	QWORD PTR pml3$[rbp], rax

; 279  : 
; 280  : 	if (!(pml3[i3] & X86_64_PAGING_PRESENT))

	movsxd	rax, DWORD PTR i3$[rbp]
	mov	rcx, QWORD PTR pml3$[rbp]
	mov	rax, QWORD PTR [rcx+rax*8]
	and	rax, 1
	test	rax, rax
	jne	SHORT $LN3@AuMapPageE

; 281  : 	{
; 282  : 		const uint64_t page = (uint64_t)AuPmmngrAlloc();

	call	AuPmmngrAlloc
	mov	QWORD PTR page$2[rbp], rax

; 283  : 		pml3[i3] = page | flags;

	movzx	eax, BYTE PTR flags$[rbp]
	mov	rcx, QWORD PTR page$2[rbp]
	or	rcx, rax
	mov	rax, rcx
	movsxd	rcx, DWORD PTR i3$[rbp]
	mov	rdx, QWORD PTR pml3$[rbp]
	mov	QWORD PTR [rdx+rcx*8], rax

; 284  : 		memset((void*)P2V(page), 0, 4096);

	mov	rcx, QWORD PTR page$2[rbp]
	call	P2V
	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, rax
	call	memset

; 285  : 		flush_tlb((void*)pml3);

	mov	rcx, QWORD PTR pml3$[rbp]
	call	flush_tlb

; 286  : 		x64_mfence();

	call	x64_mfence
$LN3@AuMapPageE:

; 287  : 
; 288  : 	}
; 289  : 
; 290  : 
; 291  : 	uint64_t* pml2 = (uint64_t*)(P2V(pml3[i3]) & ~(4096 - 1));

	movsxd	rax, DWORD PTR i3$[rbp]
	mov	rcx, QWORD PTR pml3$[rbp]
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	P2V
	and	rax, -4096				; fffffffffffff000H
	mov	QWORD PTR pml2$[rbp], rax

; 292  : 
; 293  : 	if (!(pml2[i2] & X86_64_PAGING_PRESENT))

	movsxd	rax, DWORD PTR i2$[rbp]
	mov	rcx, QWORD PTR pml2$[rbp]
	mov	rax, QWORD PTR [rcx+rax*8]
	and	rax, 1
	test	rax, rax
	jne	SHORT $LN4@AuMapPageE

; 294  : 	{
; 295  : 		const uint64_t page = (uint64_t)AuPmmngrAlloc();

	call	AuPmmngrAlloc
	mov	QWORD PTR page$3[rbp], rax

; 296  : 		pml2[i2] = page | flags;

	movzx	eax, BYTE PTR flags$[rbp]
	mov	rcx, QWORD PTR page$3[rbp]
	or	rcx, rax
	mov	rax, rcx
	movsxd	rcx, DWORD PTR i2$[rbp]
	mov	rdx, QWORD PTR pml2$[rbp]
	mov	QWORD PTR [rdx+rcx*8], rax

; 297  : 		memset((void*)P2V(page), 0, 4096);

	mov	rcx, QWORD PTR page$3[rbp]
	call	P2V
	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, rax
	call	memset

; 298  : 		flush_tlb((void*)pml2);

	mov	rcx, QWORD PTR pml2$[rbp]
	call	flush_tlb

; 299  : 		x64_mfence();

	call	x64_mfence
$LN4@AuMapPageE:

; 300  : 
; 301  : 	}
; 302  : 
; 303  : 	uint64_t* pml1 = (uint64_t*)(P2V(pml2[i2]) & ~(4096 - 1));

	movsxd	rax, DWORD PTR i2$[rbp]
	mov	rcx, QWORD PTR pml2$[rbp]
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	P2V
	and	rax, -4096				; fffffffffffff000H
	mov	QWORD PTR pml1$[rbp], rax

; 304  : 	if (pml1[i1] & X86_64_PAGING_PRESENT)

	movsxd	rax, DWORD PTR i1$[rbp]
	mov	rcx, QWORD PTR pml1$[rbp]
	mov	rax, QWORD PTR [rcx+rax*8]
	and	rax, 1
	test	rax, rax
	je	SHORT $LN5@AuMapPageE

; 305  : 	{
; 306  : 		AuPmmngrFree((void*)phys_addr);

	mov	rcx, QWORD PTR phys_addr$[rbp]
	call	AuPmmngrFree

; 307  : 		return false;

	xor	al, al
	jmp	SHORT $LN1@AuMapPageE
$LN5@AuMapPageE:

; 308  : 	}
; 309  : 
; 310  : 	pml1[i1] = phys_addr | flags;

	movzx	eax, BYTE PTR flags$[rbp]
	mov	rcx, QWORD PTR phys_addr$[rbp]
	or	rcx, rax
	mov	rax, rcx
	movsxd	rcx, DWORD PTR i1$[rbp]
	mov	rdx, QWORD PTR pml1$[rbp]
	mov	QWORD PTR [rdx+rcx*8], rax

; 311  : 	flush_tlb((void*)pml1);

	mov	rcx, QWORD PTR pml1$[rbp]
	call	flush_tlb

; 312  : 	x64_mfence();

	call	x64_mfence

; 313  : 	return true;

	mov	al, 1
$LN1@AuMapPageE:

; 314  : }

	lea	rsp, QWORD PTR [rbp+144]
	pop	rbp
	ret	0
AuMapPageEx ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Mm\vmmngr.cpp
;	COMDAT AuMapPage
_TEXT	SEGMENT
flags$ = 0
i4$ = 4
i3$ = 8
i2$ = 12
i1$ = 16
pml4i$ = 24
page$1 = 32
pml3$ = 40
page$2 = 48
pml2$ = 56
page$3 = 64
pml1$ = 72
phys_addr$ = 160
virt_addr$ = 168
attrib$ = 176
AuMapPage PROC						; COMDAT

; 196  : bool AuMapPage(uint64_t phys_addr, uint64_t virt_addr, uint8_t attrib) {

$LN7:
	mov	BYTE PTR [rsp+24], r8b
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 176				; 000000b0H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__71D0FFAE_vmmngr@cpp
	call	__CheckForDebuggerJustMyCode

; 197  : 	uint8_t flags = X86_64_PAGING_PRESENT | X86_64_PAGING_WRITABLE | attrib;

	movzx	eax, BYTE PTR attrib$[rbp]
	or	eax, 3
	mov	BYTE PTR flags$[rbp], al

; 198  : 
; 199  : 	const long i4 = (virt_addr >> 39) & 0x1FF;

	mov	rax, QWORD PTR virt_addr$[rbp]
	shr	rax, 39					; 00000027H
	and	rax, 511				; 000001ffH
	mov	DWORD PTR i4$[rbp], eax

; 200  : 	const long i3 = (virt_addr >> 30) & 0x1FF;

	mov	rax, QWORD PTR virt_addr$[rbp]
	shr	rax, 30
	and	rax, 511				; 000001ffH
	mov	DWORD PTR i3$[rbp], eax

; 201  : 	const long i2 = (virt_addr >> 21) & 0x1FF;

	mov	rax, QWORD PTR virt_addr$[rbp]
	shr	rax, 21
	and	rax, 511				; 000001ffH
	mov	DWORD PTR i2$[rbp], eax

; 202  : 	const long i1 = (virt_addr >> 12) & 0x1FF;

	mov	rax, QWORD PTR virt_addr$[rbp]
	shr	rax, 12
	and	rax, 511				; 000001ffH
	mov	DWORD PTR i1$[rbp], eax

; 203  : 
; 204  : 	uint64_t *pml4i = (uint64_t*)P2V(x64_read_cr3());

	call	x64_read_cr3
	mov	rcx, rax
	call	P2V
	mov	QWORD PTR pml4i$[rbp], rax

; 205  : 
; 206  : 	if (!(pml4i[i4] & X86_64_PAGING_PRESENT))

	movsxd	rax, DWORD PTR i4$[rbp]
	mov	rcx, QWORD PTR pml4i$[rbp]
	mov	rax, QWORD PTR [rcx+rax*8]
	and	rax, 1
	test	rax, rax
	jne	SHORT $LN2@AuMapPage

; 207  : 	{
; 208  : 		const uint64_t page = (uint64_t)AuPmmngrAlloc();

	call	AuPmmngrAlloc
	mov	QWORD PTR page$1[rbp], rax

; 209  : 		pml4i[i4] = page | flags;

	movzx	eax, BYTE PTR flags$[rbp]
	mov	rcx, QWORD PTR page$1[rbp]
	or	rcx, rax
	mov	rax, rcx
	movsxd	rcx, DWORD PTR i4$[rbp]
	mov	rdx, QWORD PTR pml4i$[rbp]
	mov	QWORD PTR [rdx+rcx*8], rax

; 210  : 		memset((void*)P2V(page), 0, 4096);

	mov	rcx, QWORD PTR page$1[rbp]
	call	P2V
	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, rax
	call	memset

; 211  : 		flush_tlb((void*)pml4i);

	mov	rcx, QWORD PTR pml4i$[rbp]
	call	flush_tlb

; 212  : 		x64_mfence();

	call	x64_mfence
$LN2@AuMapPage:

; 213  : 	}
; 214  : 	uint64_t* pml3 = (uint64_t*)(P2V(pml4i[i4]) & ~(4096 - 1));

	movsxd	rax, DWORD PTR i4$[rbp]
	mov	rcx, QWORD PTR pml4i$[rbp]
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	P2V
	and	rax, -4096				; fffffffffffff000H
	mov	QWORD PTR pml3$[rbp], rax

; 215  : 
; 216  : 	if (!(pml3[i3] & X86_64_PAGING_PRESENT))

	movsxd	rax, DWORD PTR i3$[rbp]
	mov	rcx, QWORD PTR pml3$[rbp]
	mov	rax, QWORD PTR [rcx+rax*8]
	and	rax, 1
	test	rax, rax
	jne	SHORT $LN3@AuMapPage

; 217  : 	{
; 218  : 		const uint64_t page = (uint64_t)AuPmmngrAlloc();

	call	AuPmmngrAlloc
	mov	QWORD PTR page$2[rbp], rax

; 219  : 		pml3[i3] = page | flags;

	movzx	eax, BYTE PTR flags$[rbp]
	mov	rcx, QWORD PTR page$2[rbp]
	or	rcx, rax
	mov	rax, rcx
	movsxd	rcx, DWORD PTR i3$[rbp]
	mov	rdx, QWORD PTR pml3$[rbp]
	mov	QWORD PTR [rdx+rcx*8], rax

; 220  : 		memset((void*)P2V(page), 0, 4096);

	mov	rcx, QWORD PTR page$2[rbp]
	call	P2V
	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, rax
	call	memset

; 221  : 		flush_tlb((void*)pml3);

	mov	rcx, QWORD PTR pml3$[rbp]
	call	flush_tlb

; 222  : 		x64_mfence();

	call	x64_mfence
$LN3@AuMapPage:

; 223  : 
; 224  : 	}
; 225  : 
; 226  : 
; 227  : 	uint64_t* pml2 = (uint64_t*)(P2V(pml3[i3]) & ~(4096 - 1));

	movsxd	rax, DWORD PTR i3$[rbp]
	mov	rcx, QWORD PTR pml3$[rbp]
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	P2V
	and	rax, -4096				; fffffffffffff000H
	mov	QWORD PTR pml2$[rbp], rax

; 228  : 
; 229  : 	if (!(pml2[i2] & X86_64_PAGING_PRESENT))

	movsxd	rax, DWORD PTR i2$[rbp]
	mov	rcx, QWORD PTR pml2$[rbp]
	mov	rax, QWORD PTR [rcx+rax*8]
	and	rax, 1
	test	rax, rax
	jne	SHORT $LN4@AuMapPage

; 230  : 	{
; 231  : 		const uint64_t page = (uint64_t)AuPmmngrAlloc();

	call	AuPmmngrAlloc
	mov	QWORD PTR page$3[rbp], rax

; 232  : 		pml2[i2] = page | flags;

	movzx	eax, BYTE PTR flags$[rbp]
	mov	rcx, QWORD PTR page$3[rbp]
	or	rcx, rax
	mov	rax, rcx
	movsxd	rcx, DWORD PTR i2$[rbp]
	mov	rdx, QWORD PTR pml2$[rbp]
	mov	QWORD PTR [rdx+rcx*8], rax

; 233  : 		memset((void*)P2V(page), 0, 4096);

	mov	rcx, QWORD PTR page$3[rbp]
	call	P2V
	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, rax
	call	memset

; 234  : 		flush_tlb((void*)pml2);

	mov	rcx, QWORD PTR pml2$[rbp]
	call	flush_tlb

; 235  : 		x64_mfence();

	call	x64_mfence
$LN4@AuMapPage:

; 236  : 
; 237  : 	}
; 238  : 
; 239  : 	uint64_t* pml1 = (uint64_t*)(P2V(pml2[i2]) & ~(4096 - 1));

	movsxd	rax, DWORD PTR i2$[rbp]
	mov	rcx, QWORD PTR pml2$[rbp]
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	P2V
	and	rax, -4096				; fffffffffffff000H
	mov	QWORD PTR pml1$[rbp], rax

; 240  : 	if (pml1[i1] & X86_64_PAGING_PRESENT)

	movsxd	rax, DWORD PTR i1$[rbp]
	mov	rcx, QWORD PTR pml1$[rbp]
	mov	rax, QWORD PTR [rcx+rax*8]
	and	rax, 1
	test	rax, rax
	je	SHORT $LN5@AuMapPage

; 241  : 	{
; 242  : 		AuPmmngrFree((void*)phys_addr);

	mov	rcx, QWORD PTR phys_addr$[rbp]
	call	AuPmmngrFree

; 243  : 		return false;

	xor	al, al
	jmp	SHORT $LN1@AuMapPage
$LN5@AuMapPage:

; 244  : 	}
; 245  : 
; 246  : 	pml1[i1] = phys_addr | flags;

	movzx	eax, BYTE PTR flags$[rbp]
	mov	rcx, QWORD PTR phys_addr$[rbp]
	or	rcx, rax
	mov	rax, rcx
	movsxd	rcx, DWORD PTR i1$[rbp]
	mov	rdx, QWORD PTR pml1$[rbp]
	mov	QWORD PTR [rdx+rcx*8], rax

; 247  : 	flush_tlb((void*)pml1);

	mov	rcx, QWORD PTR pml1$[rbp]
	call	flush_tlb

; 248  : 	x64_mfence();

	call	x64_mfence

; 249  : 	return true;

	mov	al, 1
$LN1@AuMapPage:

; 250  : }

	lea	rsp, QWORD PTR [rbp+144]
	pop	rbp
	ret	0
AuMapPage ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Mm\vmmngr.cpp
;	COMDAT AuVmmngrGetPage
_TEXT	SEGMENT
flags$ = 0
i4$ = 4
i3$ = 8
i2$ = 12
i1$ = 16
pml4i$ = 24
page$1 = 32
pml3$ = 40
page$2 = 48
pml2$ = 56
page$3 = 64
pml1$ = 72
page$4 = 80
phys_addr$5 = 88
vpage$6 = 96
virt_addr$ = 192
_flags$ = 200
mode$ = 208
AuVmmngrGetPage PROC					; COMDAT

; 123  : AuVPage * AuVmmngrGetPage(uint64_t virt_addr, uint8_t _flags, uint8_t mode) {

$LN10:
	mov	BYTE PTR [rsp+24], r8b
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 208				; 000000d0H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__71D0FFAE_vmmngr@cpp
	call	__CheckForDebuggerJustMyCode

; 124  : 	uint8_t flags = X86_64_PAGING_PRESENT | X86_64_PAGING_WRITABLE | _flags;

	movzx	eax, BYTE PTR _flags$[rbp]
	or	eax, 3
	mov	BYTE PTR flags$[rbp], al

; 125  : 
; 126  : 
; 127  : 	const long i4 = (virt_addr >> 39) & 0x1FF;

	mov	rax, QWORD PTR virt_addr$[rbp]
	shr	rax, 39					; 00000027H
	and	rax, 511				; 000001ffH
	mov	DWORD PTR i4$[rbp], eax

; 128  : 	const long i3 = (virt_addr >> 30) & 0x1FF;

	mov	rax, QWORD PTR virt_addr$[rbp]
	shr	rax, 30
	and	rax, 511				; 000001ffH
	mov	DWORD PTR i3$[rbp], eax

; 129  : 	const long i2 = (virt_addr >> 21) & 0x1FF;

	mov	rax, QWORD PTR virt_addr$[rbp]
	shr	rax, 21
	and	rax, 511				; 000001ffH
	mov	DWORD PTR i2$[rbp], eax

; 130  : 	const long i1 = (virt_addr >> 12) & 0x1FF;

	mov	rax, QWORD PTR virt_addr$[rbp]
	shr	rax, 12
	and	rax, 511				; 000001ffH
	mov	DWORD PTR i1$[rbp], eax

; 131  : 
; 132  : 	uint64_t *pml4i = (uint64_t*)P2V(x64_read_cr3());

	call	x64_read_cr3
	mov	rcx, rax
	call	P2V
	mov	QWORD PTR pml4i$[rbp], rax

; 133  : 
; 134  : 	if (!(pml4i[i4] & X86_64_PAGING_PRESENT))

	movsxd	rax, DWORD PTR i4$[rbp]
	mov	rcx, QWORD PTR pml4i$[rbp]
	mov	rax, QWORD PTR [rcx+rax*8]
	and	rax, 1
	test	rax, rax
	jne	SHORT $LN2@AuVmmngrGe

; 135  : 	{
; 136  : 		const uint64_t page = (uint64_t)AuPmmngrAlloc();

	call	AuPmmngrAlloc
	mov	QWORD PTR page$1[rbp], rax

; 137  : 		pml4i[i4] = page | flags;

	movzx	eax, BYTE PTR flags$[rbp]
	mov	rcx, QWORD PTR page$1[rbp]
	or	rcx, rax
	mov	rax, rcx
	movsxd	rcx, DWORD PTR i4$[rbp]
	mov	rdx, QWORD PTR pml4i$[rbp]
	mov	QWORD PTR [rdx+rcx*8], rax

; 138  : 		memset((void*)P2V(page), 0, 4096);

	mov	rcx, QWORD PTR page$1[rbp]
	call	P2V
	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, rax
	call	memset

; 139  : 		flush_tlb((void*)page);

	mov	rcx, QWORD PTR page$1[rbp]
	call	flush_tlb

; 140  : 		x64_mfence();

	call	x64_mfence
$LN2@AuVmmngrGe:

; 141  : 	}
; 142  : 	uint64_t* pml3 = (uint64_t*)(P2V(pml4i[i4]) & ~(4096 - 1));

	movsxd	rax, DWORD PTR i4$[rbp]
	mov	rcx, QWORD PTR pml4i$[rbp]
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	P2V
	and	rax, -4096				; fffffffffffff000H
	mov	QWORD PTR pml3$[rbp], rax

; 143  : 
; 144  : 	if (!(pml3[i3] & X86_64_PAGING_PRESENT))

	movsxd	rax, DWORD PTR i3$[rbp]
	mov	rcx, QWORD PTR pml3$[rbp]
	mov	rax, QWORD PTR [rcx+rax*8]
	and	rax, 1
	test	rax, rax
	jne	SHORT $LN3@AuVmmngrGe

; 145  : 	{
; 146  : 		const uint64_t page = (uint64_t)AuPmmngrAlloc();

	call	AuPmmngrAlloc
	mov	QWORD PTR page$2[rbp], rax

; 147  : 		pml3[i3] = page | flags;

	movzx	eax, BYTE PTR flags$[rbp]
	mov	rcx, QWORD PTR page$2[rbp]
	or	rcx, rax
	mov	rax, rcx
	movsxd	rcx, DWORD PTR i3$[rbp]
	mov	rdx, QWORD PTR pml3$[rbp]
	mov	QWORD PTR [rdx+rcx*8], rax

; 148  : 		memset((void*)P2V(page), 0, 4096);

	mov	rcx, QWORD PTR page$2[rbp]
	call	P2V
	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, rax
	call	memset

; 149  : 		flush_tlb((void*)page);

	mov	rcx, QWORD PTR page$2[rbp]
	call	flush_tlb

; 150  : 		x64_mfence();

	call	x64_mfence
$LN3@AuVmmngrGe:

; 151  : 
; 152  : 	}
; 153  : 
; 154  : 
; 155  : 	uint64_t* pml2 = (uint64_t*)(P2V(pml3[i3]) & ~(4096 - 1));

	movsxd	rax, DWORD PTR i3$[rbp]
	mov	rcx, QWORD PTR pml3$[rbp]
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	P2V
	and	rax, -4096				; fffffffffffff000H
	mov	QWORD PTR pml2$[rbp], rax

; 156  : 
; 157  : 	if (!(pml2[i2] & X86_64_PAGING_PRESENT))

	movsxd	rax, DWORD PTR i2$[rbp]
	mov	rcx, QWORD PTR pml2$[rbp]
	mov	rax, QWORD PTR [rcx+rax*8]
	and	rax, 1
	test	rax, rax
	jne	SHORT $LN4@AuVmmngrGe

; 158  : 	{
; 159  : 		const uint64_t page = (uint64_t)AuPmmngrAlloc();

	call	AuPmmngrAlloc
	mov	QWORD PTR page$3[rbp], rax

; 160  : 		pml2[i2] = page | flags;

	movzx	eax, BYTE PTR flags$[rbp]
	mov	rcx, QWORD PTR page$3[rbp]
	or	rcx, rax
	mov	rax, rcx
	movsxd	rcx, DWORD PTR i2$[rbp]
	mov	rdx, QWORD PTR pml2$[rbp]
	mov	QWORD PTR [rdx+rcx*8], rax

; 161  : 		memset((void*)P2V(page), 0, 4096);

	mov	rcx, QWORD PTR page$3[rbp]
	call	P2V
	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, rax
	call	memset

; 162  : 		flush_tlb((void*)page);

	mov	rcx, QWORD PTR page$3[rbp]
	call	flush_tlb

; 163  : 		x64_mfence();

	call	x64_mfence
$LN4@AuVmmngrGe:

; 164  : 
; 165  : 	}
; 166  : 
; 167  : 	uint64_t* pml1 = (uint64_t*)(P2V(pml2[i2]) & ~(4096 - 1));

	movsxd	rax, DWORD PTR i2$[rbp]
	mov	rcx, QWORD PTR pml2$[rbp]
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	P2V
	and	rax, -4096				; fffffffffffff000H
	mov	QWORD PTR pml1$[rbp], rax

; 168  : 	if (pml1[i1] & X86_64_PAGING_PRESENT)

	movsxd	rax, DWORD PTR i1$[rbp]
	mov	rcx, QWORD PTR pml1$[rbp]
	mov	rax, QWORD PTR [rcx+rax*8]
	and	rax, 1
	test	rax, rax
	je	SHORT $LN5@AuVmmngrGe

; 169  : 	{
; 170  : 
; 171  : 		AuVPage *page = (AuVPage*)&pml1[i1];

	movsxd	rax, DWORD PTR i1$[rbp]
	mov	rcx, QWORD PTR pml1$[rbp]
	lea	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR page$4[rbp], rax

; 172  : 		return page;

	mov	rax, QWORD PTR page$4[rbp]
	jmp	$LN1@AuVmmngrGe

; 173  : 	}

	jmp	$LN6@AuVmmngrGe
$LN5@AuVmmngrGe:

; 174  : 	else {
; 175  : 		if (mode & VIRT_GETPAGE_CREATE && !(mode & VIRT_GETPAGE_ONLY_RET)) {

	movzx	eax, BYTE PTR mode$[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN7@AuVmmngrGe
	movzx	eax, BYTE PTR mode$[rbp]
	and	eax, 2
	test	eax, eax
	jne	SHORT $LN7@AuVmmngrGe

; 176  : 			uint64_t phys_addr = (uint64_t)AuPmmngrAlloc();

	call	AuPmmngrAlloc
	mov	QWORD PTR phys_addr$5[rbp], rax

; 177  : 			memset((void*)P2V(phys_addr), 0, 4096);

	mov	rcx, QWORD PTR phys_addr$5[rbp]
	call	P2V
	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, rax
	call	memset

; 178  : 			pml1[i1] = phys_addr | flags;

	movzx	eax, BYTE PTR flags$[rbp]
	mov	rcx, QWORD PTR phys_addr$5[rbp]
	or	rcx, rax
	mov	rax, rcx
	movsxd	rcx, DWORD PTR i1$[rbp]
	mov	rdx, QWORD PTR pml1$[rbp]
	mov	QWORD PTR [rdx+rcx*8], rax

; 179  : 			flush_tlb((void*)virt_addr);

	mov	rcx, QWORD PTR virt_addr$[rbp]
	call	flush_tlb

; 180  : 			x64_mfence();

	call	x64_mfence

; 181  : 			AuVPage *vpage = (AuVPage*)&pml1[i1];

	movsxd	rax, DWORD PTR i1$[rbp]
	mov	rcx, QWORD PTR pml1$[rbp]
	lea	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR vpage$6[rbp], rax

; 182  : 			return vpage;

	mov	rax, QWORD PTR vpage$6[rbp]
	jmp	SHORT $LN1@AuVmmngrGe
$LN7@AuVmmngrGe:

; 183  : 		}
; 184  : 		if (mode & VIRT_GETPAGE_ONLY_RET)

	movzx	eax, BYTE PTR mode$[rbp]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN8@AuVmmngrGe

; 185  : 			return NULL;

	xor	eax, eax
$LN8@AuVmmngrGe:
$LN6@AuVmmngrGe:
$LN1@AuVmmngrGe:

; 186  : 	}
; 187  : }

	lea	rsp, QWORD PTR [rbp+176]
	pop	rbp
	ret	0
AuVmmngrGetPage ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Mm\vmmngr.cpp
;	COMDAT ?AuVmmngrInitialize@@YAXXZ
_TEXT	SEGMENT
?AuVmmngrInitialize@@YAXXZ PROC				; AuVmmngrInitialize, COMDAT

; 492  : void AuVmmngrInitialize() {

$LN3:
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__71D0FFAE_vmmngr@cpp
	call	__CheckForDebuggerJustMyCode

; 493  : #ifdef ARCH_X64
; 494  : 	Au_x86_64_Paging_Init();

	call	?Au_x86_64_Paging_Init@@YAXXZ		; Au_x86_64_Paging_Init

; 495  : #endif
; 496  : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
?AuVmmngrInitialize@@YAXXZ ENDP				; AuVmmngrInitialize
_TEXT	ENDS
END
