; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.21005.1 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?_RootPaging@@3PEA_KEA				; _RootPaging
PUBLIC	?_MmioBase@@3PEA_KEA				; _MmioBase
_BSS	SEGMENT
?_RootPaging@@3PEA_KEA DQ 01H DUP (?)			; _RootPaging
?_MmioBase@@3PEA_KEA DQ 01H DUP (?)			; _MmioBase
_BSS	ENDS
PUBLIC	?AuVmmngrInitialize@@YAXXZ			; AuVmmngrInitialize
PUBLIC	AuVmmngrGetPage
PUBLIC	AuMapPage
PUBLIC	AuMapPageEx
PUBLIC	AuMapMMIO
PUBLIC	AuGetFreePage
PUBLIC	AuFreePages
PUBLIC	AuGetPhysicalAddress
PUBLIC	AuGetPhysicalAddressEx
PUBLIC	AuCreateVirtualAddressSpace
PUBLIC	AuGetRootPageTable
PUBLIC	?AuVmmngrBootFree@@YAXXZ			; AuVmmngrBootFree
PUBLIC	?AuVmmngrCloneAddressSpace@@YAXPEA_K0@Z		; AuVmmngrCloneAddressSpace
PUBLIC	?x86_64_pml4_index@@YA_K_K@Z			; x86_64_pml4_index
PUBLIC	?x86_64_pdp_index@@YA_K_K@Z			; x86_64_pdp_index
PUBLIC	?x86_64_pd_index@@YA_K_K@Z			; x86_64_pd_index
PUBLIC	?x86_64_pt_index@@YA_K_K@Z			; x86_64_pt_index
PUBLIC	?x86_64_p_index@@YA_K_K@Z			; x86_64_p_index
PUBLIC	?Au_x86_64_Paging_Init@@YAXXZ			; Au_x86_64_Paging_Init
EXTRN	AuPmmngrAlloc:PROC
EXTRN	AuPmmngrFree:PROC
EXTRN	P2V:PROC
EXTRN	V2P:PROC
EXTRN	?AuPmmngrMoveHigher@@YAXXZ:PROC			; AuPmmngrMoveHigher
EXTRN	x64_mfence:PROC
EXTRN	x64_read_cr3:PROC
EXTRN	x64_write_cr3:PROC
EXTRN	flush_tlb:PROC
EXTRN	memset:PROC
EXTRN	memcpy:PROC
pdata	SEGMENT
$pdata$?AuVmmngrInitialize@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+14
	DD	imagerel $unwind$?AuVmmngrInitialize@@YAXXZ
$pdata$AuVmmngrGetPage DD imagerel $LN10
	DD	imagerel $LN10+776
	DD	imagerel $unwind$AuVmmngrGetPage
$pdata$AuMapPage DD imagerel $LN7
	DD	imagerel $LN7+637
	DD	imagerel $unwind$AuMapPage
$pdata$AuMapPageEx DD imagerel $LN7
	DD	imagerel $LN7+636
	DD	imagerel $unwind$AuMapPageEx
$pdata$AuMapMMIO DD imagerel $LN6
	DD	imagerel $LN6+162
	DD	imagerel $unwind$AuMapMMIO
$pdata$AuGetFreePage DD imagerel $LN15
	DD	imagerel $LN15+412
	DD	imagerel $unwind$AuGetFreePage
$pdata$AuFreePages DD imagerel $LN8
	DD	imagerel $LN8+377
	DD	imagerel $unwind$AuFreePages
$pdata$AuGetPhysicalAddress DD imagerel $LN5
	DD	imagerel $LN5+205
	DD	imagerel $unwind$AuGetPhysicalAddress
$pdata$AuGetPhysicalAddressEx DD imagerel $LN5
	DD	imagerel $LN5+202
	DD	imagerel $unwind$AuGetPhysicalAddressEx
$pdata$AuCreateVirtualAddressSpace DD imagerel $LN9
	DD	imagerel $LN9+182
	DD	imagerel $unwind$AuCreateVirtualAddressSpace
$pdata$?AuVmmngrBootFree@@YAXXZ DD imagerel $LN6
	DD	imagerel $LN6+79
	DD	imagerel $unwind$?AuVmmngrBootFree@@YAXXZ
$pdata$?AuVmmngrCloneAddressSpace@@YAXPEA_K0@Z DD imagerel $LN19
	DD	imagerel $LN19+738
	DD	imagerel $unwind$?AuVmmngrCloneAddressSpace@@YAXPEA_K0@Z
$pdata$?Au_x86_64_Paging_Init@@YAXXZ DD imagerel $LN12
	DD	imagerel $LN12+393
	DD	imagerel $unwind$?Au_x86_64_Paging_Init@@YAXXZ
pdata	ENDS
xdata	SEGMENT
$unwind$?AuVmmngrInitialize@@YAXXZ DD 010401H
	DD	04204H
$unwind$AuVmmngrGetPage DD 021501H
	DD	0130115H
$unwind$AuMapPage DD 011301H
	DD	0e213H
$unwind$AuMapPageEx DD 011801H
	DD	0e218H
$unwind$AuMapMMIO DD 010e01H
	DD	0820eH
$unwind$AuGetFreePage DD 010d01H
	DD	0c20dH
$unwind$AuFreePages DD 011201H
	DD	0c212H
$unwind$AuGetPhysicalAddress DD 010901H
	DD	0a209H
$unwind$AuGetPhysicalAddressEx DD 010e01H
	DD	0a20eH
$unwind$AuCreateVirtualAddressSpace DD 010401H
	DD	08204H
$unwind$?AuVmmngrBootFree@@YAXXZ DD 010401H
	DD	06204H
$unwind$?AuVmmngrCloneAddressSpace@@YAXPEA_K0@Z DD 021101H
	DD	0110111H
$unwind$?Au_x86_64_Paging_Init@@YAXXZ DD 010401H
	DD	0c204H
xdata	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\mm\vmmngr.cpp
_TEXT	SEGMENT
i$1 = 32
NewCR3$ = 40
i$2 = 48
PDPT$ = 56
OldCR3$ = 64
tv95 = 72
tv140 = 80
?Au_x86_64_Paging_Init@@YAXXZ PROC			; Au_x86_64_Paging_Init

; 80   : void Au_x86_64_Paging_Init() {

$LN12:
	sub	rsp, 104				; 00000068H

; 81   : 	uint64_t *OldCR3 = (uint64_t*)x64_read_cr3();

	call	x64_read_cr3
	mov	QWORD PTR OldCR3$[rsp], rax

; 82   : 	uint64_t *NewCR3 = (uint64_t*)AuPmmngrAlloc();

	call	AuPmmngrAlloc
	mov	QWORD PTR NewCR3$[rsp], rax

; 83   : 	memset(NewCR3, 0, 4096);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR NewCR3$[rsp]
	call	memset

; 84   : 	
; 85   : 	for (int i = 0; i < 512; ++i) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN9@Au_x86_64_
$LN8@Au_x86_64_:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN9@Au_x86_64_:
	cmp	DWORD PTR i$1[rsp], 512			; 00000200H
	jge	SHORT $LN7@Au_x86_64_

; 86   : 		if (i == 511)

	cmp	DWORD PTR i$1[rsp], 511			; 000001ffH
	jne	SHORT $LN6@Au_x86_64_

; 87   : 			continue;

	jmp	SHORT $LN8@Au_x86_64_
$LN6@Au_x86_64_:

; 88   : 
; 89   : 		if ((OldCR3[i] & X86_64_PAGING_PRESENT))

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR OldCR3$[rsp]
	mov	rax, QWORD PTR [rcx+rax*8]
	and	rax, 1
	test	rax, rax
	je	SHORT $LN5@Au_x86_64_

; 90   : 			NewCR3[i] = OldCR3[i];

	movsxd	rax, DWORD PTR i$1[rsp]
	movsxd	rcx, DWORD PTR i$1[rsp]
	mov	rdx, QWORD PTR NewCR3$[rsp]
	mov	r8, QWORD PTR OldCR3$[rsp]
	mov	rax, QWORD PTR [r8+rax*8]
	mov	QWORD PTR [rdx+rcx*8], rax

; 91   : 		else

	jmp	SHORT $LN4@Au_x86_64_
$LN5@Au_x86_64_:

; 92   : 			NewCR3[i] = 0;

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR NewCR3$[rsp]
	mov	QWORD PTR [rcx+rax*8], 0
$LN4@Au_x86_64_:

; 93   : 
; 94   : 	}

	jmp	SHORT $LN8@Au_x86_64_
$LN7@Au_x86_64_:

; 95   : 
; 96   : 	uint64_t* PDPT = (uint64_t*)AuPmmngrAlloc();

	call	AuPmmngrAlloc
	mov	QWORD PTR PDPT$[rsp], rax

; 97   : 	memset(PDPT, 0, 4096);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR PDPT$[rsp]
	call	memset

; 98   : 
; 99   : 	NewCR3[x86_64_pml4_index(PHYSICAL_MEM_BASE)] = (uint64_t)PDPT | X86_64_PAGING_PRESENT | X86_64_PAGING_WRITABLE;

	mov	rax, QWORD PTR PDPT$[rsp]
	or	rax, 1
	or	rax, 2
	mov	QWORD PTR tv95[rsp], rax
	mov	rcx, -140737488355328			; ffff800000000000H
	call	?x86_64_pml4_index@@YA_K_K@Z		; x86_64_pml4_index
	mov	rcx, QWORD PTR NewCR3$[rsp]
	mov	rdx, QWORD PTR tv95[rsp]
	mov	QWORD PTR [rcx+rax*8], rdx

; 100  : 
; 101  : 	for (size_t i = 0; i < 512; i++)

	mov	QWORD PTR i$2[rsp], 0
	jmp	SHORT $LN3@Au_x86_64_
$LN2@Au_x86_64_:
	mov	rax, QWORD PTR i$2[rsp]
	inc	rax
	mov	QWORD PTR i$2[rsp], rax
$LN3@Au_x86_64_:
	cmp	QWORD PTR i$2[rsp], 512			; 00000200H
	jae	SHORT $LN1@Au_x86_64_

; 102  : 		PDPT[x86_64_pdp_index(PHYSICAL_MEM_BASE) + i] = i * 512 * 512 * 4096 | 0x80 | X86_64_PAGING_PRESENT | X86_64_PAGING_WRITABLE;

	imul	rax, QWORD PTR i$2[rsp], 512		; 00000200H
	imul	rax, rax, 512				; 00000200H
	imul	rax, rax, 4096				; 00001000H
	bts	rax, 7
	or	rax, 1
	or	rax, 2
	mov	QWORD PTR tv140[rsp], rax
	mov	rcx, -140737488355328			; ffff800000000000H
	call	?x86_64_pdp_index@@YA_K_K@Z		; x86_64_pdp_index
	add	rax, QWORD PTR i$2[rsp]
	mov	rcx, QWORD PTR PDPT$[rsp]
	mov	rdx, QWORD PTR tv140[rsp]
	mov	QWORD PTR [rcx+rax*8], rdx
	jmp	SHORT $LN2@Au_x86_64_
$LN1@Au_x86_64_:

; 103  : 
; 104  : 
; 105  : 	x64_write_cr3((size_t)NewCR3);

	mov	rcx, QWORD PTR NewCR3$[rsp]
	call	x64_write_cr3

; 106  : 
; 107  : 	_RootPaging = NewCR3;

	mov	rax, QWORD PTR NewCR3$[rsp]
	mov	QWORD PTR ?_RootPaging@@3PEA_KEA, rax	; _RootPaging

; 108  : 
; 109  : 	AuPmmngrMoveHigher();

	call	?AuPmmngrMoveHigher@@YAXXZ		; AuPmmngrMoveHigher

; 110  : 
; 111  : 	_MmioBase = (uint64_t*)MMIO_BASE;

	mov	rax, -1030792151040			; ffffff1000000000H
	mov	QWORD PTR ?_MmioBase@@3PEA_KEA, rax	; _MmioBase

; 112  : }

	add	rsp, 104				; 00000068H
	ret	0
?Au_x86_64_Paging_Init@@YAXXZ ENDP			; Au_x86_64_Paging_Init
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\mm\vmmngr.cpp
_TEXT	SEGMENT
addr$ = 8
?x86_64_p_index@@YA_K_K@Z PROC				; x86_64_p_index

; 71   : size_t x86_64_p_index(uint64_t addr){

	mov	QWORD PTR [rsp+8], rcx

; 72   : 	return (addr & 0x7ff);

	mov	rax, QWORD PTR addr$[rsp]
	and	rax, 2047				; 000007ffH

; 73   : }

	ret	0
?x86_64_p_index@@YA_K_K@Z ENDP				; x86_64_p_index
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\mm\vmmngr.cpp
_TEXT	SEGMENT
addr$ = 8
?x86_64_pt_index@@YA_K_K@Z PROC				; x86_64_pt_index

; 67   : size_t x86_64_pt_index(uint64_t addr){

	mov	QWORD PTR [rsp+8], rcx

; 68   : 	return (addr >> 12) & 0x1ff;

	mov	rax, QWORD PTR addr$[rsp]
	shr	rax, 12
	and	rax, 511				; 000001ffH

; 69   : }

	ret	0
?x86_64_pt_index@@YA_K_K@Z ENDP				; x86_64_pt_index
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\mm\vmmngr.cpp
_TEXT	SEGMENT
addr$ = 8
?x86_64_pd_index@@YA_K_K@Z PROC				; x86_64_pd_index

; 63   : size_t x86_64_pd_index(uint64_t addr){

	mov	QWORD PTR [rsp+8], rcx

; 64   : 	return (addr >> 21) & 0x1ff;

	mov	rax, QWORD PTR addr$[rsp]
	shr	rax, 21
	and	rax, 511				; 000001ffH

; 65   : }

	ret	0
?x86_64_pd_index@@YA_K_K@Z ENDP				; x86_64_pd_index
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\mm\vmmngr.cpp
_TEXT	SEGMENT
addr$ = 8
?x86_64_pdp_index@@YA_K_K@Z PROC			; x86_64_pdp_index

; 59   : size_t x86_64_pdp_index(uint64_t addr){

	mov	QWORD PTR [rsp+8], rcx

; 60   : 	return (addr >> 30) & 0x1ff;

	mov	rax, QWORD PTR addr$[rsp]
	shr	rax, 30
	and	rax, 511				; 000001ffH

; 61   : }

	ret	0
?x86_64_pdp_index@@YA_K_K@Z ENDP			; x86_64_pdp_index
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\mm\vmmngr.cpp
_TEXT	SEGMENT
addr$ = 8
?x86_64_pml4_index@@YA_K_K@Z PROC			; x86_64_pml4_index

; 55   : size_t  x86_64_pml4_index(uint64_t addr){

	mov	QWORD PTR [rsp+8], rcx

; 56   : 	return (addr >> 39) & 0x1ff;

	mov	rax, QWORD PTR addr$[rsp]
	shr	rax, 39					; 00000027H
	and	rax, 511				; 000001ffH

; 57   : }

	ret	0
?x86_64_pml4_index@@YA_K_K@Z ENDP			; x86_64_pml4_index
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\mm\vmmngr.cpp
_TEXT	SEGMENT
j$1 = 32
k$2 = 36
i$3 = 40
m$4 = 44
pt_new$5 = 48
pd_new$6 = 56
pdp_new$7 = 64
pd_in$8 = 72
new_page$9 = 80
pdp_in$10 = 88
pt_in$11 = 96
page$12 = 104
addr$13 = 112
destcr3$ = 144
srccr3$ = 152
?AuVmmngrCloneAddressSpace@@YAXPEA_K0@Z PROC		; AuVmmngrCloneAddressSpace

; 516  : void AuVmmngrCloneAddressSpace(uint64_t *destcr3, uint64_t* srccr3){

$LN19:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 136				; 00000088H

; 517  : 	for (int i = 0; i < 256; ++i) {

	mov	DWORD PTR i$3[rsp], 0
	jmp	SHORT $LN16@AuVmmngrCl
$LN15@AuVmmngrCl:
	mov	eax, DWORD PTR i$3[rsp]
	inc	eax
	mov	DWORD PTR i$3[rsp], eax
$LN16@AuVmmngrCl:
	cmp	DWORD PTR i$3[rsp], 256			; 00000100H
	jge	$LN14@AuVmmngrCl

; 518  : 		if ((srccr3[i] & X86_64_PAGING_PRESENT)) {

	movsxd	rax, DWORD PTR i$3[rsp]
	mov	rcx, QWORD PTR srccr3$[rsp]
	mov	rax, QWORD PTR [rcx+rax*8]
	and	rax, 1
	test	rax, rax
	je	$LN13@AuVmmngrCl

; 519  : 			/* allocate a new pdp */
; 520  : 			uint64_t* pdp_new = (uint64_t*)P2V((size_t)AuPmmngrAlloc());

	call	AuPmmngrAlloc
	mov	rcx, rax
	call	P2V
	mov	QWORD PTR pdp_new$7[rsp], rax

; 521  : 			memset(pdp_new, 0, PAGE_SIZE);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR pdp_new$7[rsp]
	call	memset

; 522  : 			destcr3[i] = V2P((size_t)pdp_new) | X86_64_PAGING_PRESENT | X86_64_PAGING_USER;

	mov	rcx, QWORD PTR pdp_new$7[rsp]
	call	V2P
	or	rax, 1
	or	rax, 4
	movsxd	rcx, DWORD PTR i$3[rsp]
	mov	rdx, QWORD PTR destcr3$[rsp]
	mov	QWORD PTR [rdx+rcx*8], rax

; 523  : 			uint64_t *pdp_in = (uint64_t*)(P2V(srccr3[i]) & ~(4096 - 1));

	movsxd	rax, DWORD PTR i$3[rsp]
	mov	rcx, QWORD PTR srccr3$[rsp]
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	P2V
	and	rax, -4096				; fffffffffffff000H
	mov	QWORD PTR pdp_in$10[rsp], rax

; 524  : 			/* inside page directory pointer */
; 525  : 			for (int j = 0; j < 512; ++j) {

	mov	DWORD PTR j$1[rsp], 0
	jmp	SHORT $LN12@AuVmmngrCl
$LN11@AuVmmngrCl:
	mov	eax, DWORD PTR j$1[rsp]
	inc	eax
	mov	DWORD PTR j$1[rsp], eax
$LN12@AuVmmngrCl:
	cmp	DWORD PTR j$1[rsp], 512			; 00000200H
	jge	$LN10@AuVmmngrCl

; 526  : 				if ((pdp_in[j] & X86_64_PAGING_PRESENT)) {

	movsxd	rax, DWORD PTR j$1[rsp]
	mov	rcx, QWORD PTR pdp_in$10[rsp]
	mov	rax, QWORD PTR [rcx+rax*8]
	and	rax, 1
	test	rax, rax
	je	$LN9@AuVmmngrCl

; 527  : 					uint64_t* pd_new = (uint64_t*)P2V((size_t)AuPmmngrAlloc());

	call	AuPmmngrAlloc
	mov	rcx, rax
	call	P2V
	mov	QWORD PTR pd_new$6[rsp], rax

; 528  : 					memset(pd_new, 0, PAGE_SIZE);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR pd_new$6[rsp]
	call	memset

; 529  : 					pdp_new[j] = V2P((size_t)pd_new) | X86_64_PAGING_PRESENT | X86_64_PAGING_USER;

	mov	rcx, QWORD PTR pd_new$6[rsp]
	call	V2P
	or	rax, 1
	or	rax, 4
	movsxd	rcx, DWORD PTR j$1[rsp]
	mov	rdx, QWORD PTR pdp_new$7[rsp]
	mov	QWORD PTR [rdx+rcx*8], rax

; 530  : 					uint64_t* pd_in = (uint64_t*)(P2V(pdp_in[j]) & ~(4096 - 1));

	movsxd	rax, DWORD PTR j$1[rsp]
	mov	rcx, QWORD PTR pdp_in$10[rsp]
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	P2V
	and	rax, -4096				; fffffffffffff000H
	mov	QWORD PTR pd_in$8[rsp], rax

; 531  : 
; 532  : 					/* inside page directory*/
; 533  : 					for (int k = 0; k < 512; ++k) {

	mov	DWORD PTR k$2[rsp], 0
	jmp	SHORT $LN8@AuVmmngrCl
$LN7@AuVmmngrCl:
	mov	eax, DWORD PTR k$2[rsp]
	inc	eax
	mov	DWORD PTR k$2[rsp], eax
$LN8@AuVmmngrCl:
	cmp	DWORD PTR k$2[rsp], 512			; 00000200H
	jge	$LN6@AuVmmngrCl

; 534  : 						if ((pd_in[k] & X86_64_PAGING_PRESENT)) {

	movsxd	rax, DWORD PTR k$2[rsp]
	mov	rcx, QWORD PTR pd_in$8[rsp]
	mov	rax, QWORD PTR [rcx+rax*8]
	and	rax, 1
	test	rax, rax
	je	$LN5@AuVmmngrCl

; 535  : 							uint64_t* pt_new = (uint64_t*)P2V((size_t)AuPmmngrAlloc());

	call	AuPmmngrAlloc
	mov	rcx, rax
	call	P2V
	mov	QWORD PTR pt_new$5[rsp], rax

; 536  : 							memset(pt_new, 0, PAGE_SIZE);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR pt_new$5[rsp]
	call	memset

; 537  : 							pd_new[k] = V2P((size_t)pt_new) | X86_64_PAGING_PRESENT | X86_64_PAGING_USER;

	mov	rcx, QWORD PTR pt_new$5[rsp]
	call	V2P
	or	rax, 1
	or	rax, 4
	movsxd	rcx, DWORD PTR k$2[rsp]
	mov	rdx, QWORD PTR pd_new$6[rsp]
	mov	QWORD PTR [rdx+rcx*8], rax

; 538  : 							uint64_t* pt_in = (uint64_t*)(P2V(pd_in[k]) & ~(4096 - 1));

	movsxd	rax, DWORD PTR k$2[rsp]
	mov	rcx, QWORD PTR pd_in$8[rsp]
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	P2V
	and	rax, -4096				; fffffffffffff000H
	mov	QWORD PTR pt_in$11[rsp], rax

; 539  : 
; 540  : 							for (int m = 0; m < 512; ++m) {

	mov	DWORD PTR m$4[rsp], 0
	jmp	SHORT $LN4@AuVmmngrCl
$LN3@AuVmmngrCl:
	mov	eax, DWORD PTR m$4[rsp]
	inc	eax
	mov	DWORD PTR m$4[rsp], eax
$LN4@AuVmmngrCl:
	cmp	DWORD PTR m$4[rsp], 512			; 00000200H
	jge	$LN2@AuVmmngrCl

; 541  : 								if ((pt_in[m] & X86_64_PAGING_PRESENT)) {

	movsxd	rax, DWORD PTR m$4[rsp]
	mov	rcx, QWORD PTR pt_in$11[rsp]
	mov	rax, QWORD PTR [rcx+rax*8]
	and	rax, 1
	test	rax, rax
	je	$LN1@AuVmmngrCl

; 542  : 									size_t addr = ((i << (9 * 3 + 12)) | (j << (9 * 2 + 12)) | (k << (9 + 12)) |
; 543  : 										(m << PAGE_SHIFT));

	mov	eax, DWORD PTR i$3[rsp]
	shl	eax, 39					; 00000027H
	mov	ecx, DWORD PTR j$1[rsp]
	shl	ecx, 30
	or	eax, ecx
	mov	ecx, DWORD PTR k$2[rsp]
	shl	ecx, 21
	or	eax, ecx
	mov	ecx, DWORD PTR m$4[rsp]
	shl	ecx, 12
	or	eax, ecx
	cdqe
	mov	QWORD PTR addr$13[rsp], rax

; 544  : 									uint64_t *page = (uint64_t*)(P2V(pt_in[m]) & ~(4096 - 1));

	movsxd	rax, DWORD PTR m$4[rsp]
	mov	rcx, QWORD PTR pt_in$11[rsp]
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	P2V
	and	rax, -4096				; fffffffffffff000H
	mov	QWORD PTR page$12[rsp], rax

; 545  : 									/* here clone the pages to new pages */
; 546  : 									uint64_t* new_page = (uint64_t*)P2V((size_t)AuPmmngrAlloc());

	call	AuPmmngrAlloc
	mov	rcx, rax
	call	P2V
	mov	QWORD PTR new_page$9[rsp], rax

; 547  : 									memcpy(new_page, page, PAGE_SIZE);

	mov	r8d, 4096				; 00001000H
	mov	rdx, QWORD PTR page$12[rsp]
	mov	rcx, QWORD PTR new_page$9[rsp]
	call	memcpy

; 548  : 									pt_new[m] = V2P((size_t)new_page) | X86_64_PAGING_PRESENT | X86_64_PAGING_WRITABLE | X86_64_PAGING_USER;

	mov	rcx, QWORD PTR new_page$9[rsp]
	call	V2P
	or	rax, 1
	or	rax, 2
	or	rax, 4
	movsxd	rcx, DWORD PTR m$4[rsp]
	mov	rdx, QWORD PTR pt_new$5[rsp]
	mov	QWORD PTR [rdx+rcx*8], rax
$LN1@AuVmmngrCl:

; 549  : 									
; 550  : 								}
; 551  : 							}

	jmp	$LN3@AuVmmngrCl
$LN2@AuVmmngrCl:
$LN5@AuVmmngrCl:

; 552  : 						}
; 553  : 					}

	jmp	$LN7@AuVmmngrCl
$LN6@AuVmmngrCl:
$LN9@AuVmmngrCl:

; 554  : 				}
; 555  : 			}

	jmp	$LN11@AuVmmngrCl
$LN10@AuVmmngrCl:
$LN13@AuVmmngrCl:

; 556  : 		}
; 557  : 	}

	jmp	$LN15@AuVmmngrCl
$LN14@AuVmmngrCl:

; 558  : }

	add	rsp, 136				; 00000088H
	ret	0
?AuVmmngrCloneAddressSpace@@YAXPEA_K0@Z ENDP		; AuVmmngrCloneAddressSpace
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\mm\vmmngr.cpp
_TEXT	SEGMENT
i$1 = 32
cr3$ = 40
?AuVmmngrBootFree@@YAXXZ PROC				; AuVmmngrBootFree

; 502  : void AuVmmngrBootFree() {

$LN6:
	sub	rsp, 56					; 00000038H

; 503  : #ifdef ARCH_X64
; 504  : 	uint64_t* cr3 = (uint64_t*)x64_read_cr3();

	call	x64_read_cr3
	mov	QWORD PTR cr3$[rsp], rax

; 505  : 	for (int i = 0; i < 256; i++)

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN3@AuVmmngrBo
$LN2@AuVmmngrBo:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN3@AuVmmngrBo:
	cmp	DWORD PTR i$1[rsp], 256			; 00000100H
	jge	SHORT $LN1@AuVmmngrBo

; 506  : 		cr3[i] = 0;

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR cr3$[rsp]
	mov	QWORD PTR [rcx+rax*8], 0
	jmp	SHORT $LN2@AuVmmngrBo
$LN1@AuVmmngrBo:

; 507  : 	x64_write_cr3((uint64_t)cr3);

	mov	rcx, QWORD PTR cr3$[rsp]
	call	x64_write_cr3

; 508  : #endif
; 509  : }

	add	rsp, 56					; 00000038H
	ret	0
?AuVmmngrBootFree@@YAXXZ ENDP				; AuVmmngrBootFree
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\mm\vmmngr.cpp
_TEXT	SEGMENT
AuGetRootPageTable PROC

; 483  : #ifdef ARCH_X64
; 484  : 	return _RootPaging;

	mov	rax, QWORD PTR ?_RootPaging@@3PEA_KEA	; _RootPaging

; 485  : #endif
; 486  : }

	ret	0
AuGetRootPageTable ENDP
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\mm\vmmngr.cpp
_TEXT	SEGMENT
i$1 = 32
new_cr3$ = 40
root_cr3$ = 48
AuCreateVirtualAddressSpace PROC

; 461  : uint64_t* AuCreateVirtualAddressSpace() {

$LN9:
	sub	rsp, 72					; 00000048H

; 462  : 	uint64_t* root_cr3 = (uint64_t*)P2V((size_t)_RootPaging);

	mov	rcx, QWORD PTR ?_RootPaging@@3PEA_KEA	; _RootPaging
	call	P2V
	mov	QWORD PTR root_cr3$[rsp], rax

; 463  : 	uint64_t* new_cr3 = (uint64_t*)P2V((size_t)AuPmmngrAlloc());

	call	AuPmmngrAlloc
	mov	rcx, rax
	call	P2V
	mov	QWORD PTR new_cr3$[rsp], rax

; 464  : 	memset(new_cr3, 0, PAGE_SIZE);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR new_cr3$[rsp]
	call	memset

; 465  : 
; 466  : 	for (int i = 0; i < 512; i++) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN6@AuCreateVi
$LN5@AuCreateVi:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN6@AuCreateVi:
	cmp	DWORD PTR i$1[rsp], 512			; 00000200H
	jge	SHORT $LN4@AuCreateVi

; 467  : 		if (i < 256)

	cmp	DWORD PTR i$1[rsp], 256			; 00000100H
	jge	SHORT $LN3@AuCreateVi

; 468  : 			continue;

	jmp	SHORT $LN5@AuCreateVi
$LN3@AuCreateVi:

; 469  : 		if (root_cr3[i] & X86_64_PAGING_PRESENT)

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR root_cr3$[rsp]
	mov	rax, QWORD PTR [rcx+rax*8]
	and	rax, 1
	test	rax, rax
	je	SHORT $LN2@AuCreateVi

; 470  : 			new_cr3[i] = root_cr3[i];

	movsxd	rax, DWORD PTR i$1[rsp]
	movsxd	rcx, DWORD PTR i$1[rsp]
	mov	rdx, QWORD PTR new_cr3$[rsp]
	mov	r8, QWORD PTR root_cr3$[rsp]
	mov	rax, QWORD PTR [r8+rax*8]
	mov	QWORD PTR [rdx+rcx*8], rax

; 471  : 		else

	jmp	SHORT $LN1@AuCreateVi
$LN2@AuCreateVi:

; 472  : 			new_cr3[i] = 0;

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR new_cr3$[rsp]
	mov	QWORD PTR [rcx+rax*8], 0
$LN1@AuCreateVi:

; 473  : 	}

	jmp	SHORT $LN5@AuCreateVi
$LN4@AuCreateVi:

; 474  : 
; 475  : 	return new_cr3;

	mov	rax, QWORD PTR new_cr3$[rsp]

; 476  : }

	add	rsp, 72					; 00000048H
	ret	0
AuCreateVirtualAddressSpace ENDP
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\mm\vmmngr.cpp
_TEXT	SEGMENT
i1$ = 32
page$ = 40
pml4_$ = 48
pdpt$ = 56
pd$ = 64
pt$ = 72
cr3$ = 96
virt_addr$ = 104
AuGetPhysicalAddressEx PROC

; 439  : void* AuGetPhysicalAddressEx(uint64_t* cr3, uint64_t virt_addr){

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 440  : 
; 441  : 	const long i1 = x86_64_pml4_index(virt_addr);

	mov	rcx, QWORD PTR virt_addr$[rsp]
	call	?x86_64_pml4_index@@YA_K_K@Z		; x86_64_pml4_index
	mov	DWORD PTR i1$[rsp], eax

; 442  : 
; 443  : 	uint64_t *pml4_ = cr3;

	mov	rax, QWORD PTR cr3$[rsp]
	mov	QWORD PTR pml4_$[rsp], rax

; 444  : 	uint64_t *pdpt = (uint64_t*)(P2V(pml4_[x86_64_pml4_index(virt_addr)]) & ~(4096 - 1));

	mov	rcx, QWORD PTR virt_addr$[rsp]
	call	?x86_64_pml4_index@@YA_K_K@Z		; x86_64_pml4_index
	mov	rcx, QWORD PTR pml4_$[rsp]
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	P2V
	and	rax, -4096				; fffffffffffff000H
	mov	QWORD PTR pdpt$[rsp], rax

; 445  : 	uint64_t *pd = (uint64_t*)(P2V(pdpt[x86_64_pdp_index(virt_addr)]) & ~(4096 - 1));

	mov	rcx, QWORD PTR virt_addr$[rsp]
	call	?x86_64_pdp_index@@YA_K_K@Z		; x86_64_pdp_index
	mov	rcx, QWORD PTR pdpt$[rsp]
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	P2V
	and	rax, -4096				; fffffffffffff000H
	mov	QWORD PTR pd$[rsp], rax

; 446  : 	uint64_t *pt = (uint64_t*)(P2V(pd[x86_64_pd_index(virt_addr)]) & ~(4096 - 1));

	mov	rcx, QWORD PTR virt_addr$[rsp]
	call	?x86_64_pd_index@@YA_K_K@Z		; x86_64_pd_index
	mov	rcx, QWORD PTR pd$[rsp]
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	P2V
	and	rax, -4096				; fffffffffffff000H
	mov	QWORD PTR pt$[rsp], rax

; 447  : 	uint64_t *page = (uint64_t*)(P2V(pt[x86_64_pt_index(virt_addr)]) & ~(4096 - 1));

	mov	rcx, QWORD PTR virt_addr$[rsp]
	call	?x86_64_pt_index@@YA_K_K@Z		; x86_64_pt_index
	mov	rcx, QWORD PTR pt$[rsp]
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	P2V
	and	rax, -4096				; fffffffffffff000H
	mov	QWORD PTR page$[rsp], rax

; 448  : 
; 449  : 	if (page)

	cmp	QWORD PTR page$[rsp], 0
	je	SHORT $LN2@AuGetPhysi

; 450  : 		return page;

	mov	rax, QWORD PTR page$[rsp]
	jmp	SHORT $LN3@AuGetPhysi

; 451  : 	else

	jmp	SHORT $LN1@AuGetPhysi
$LN2@AuGetPhysi:

; 452  : 		return NULL;

	xor	eax, eax
$LN1@AuGetPhysi:
$LN3@AuGetPhysi:

; 453  : 
; 454  : }

	add	rsp, 88					; 00000058H
	ret	0
AuGetPhysicalAddressEx ENDP
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\mm\vmmngr.cpp
_TEXT	SEGMENT
i1$ = 32
page$ = 40
pml4_$ = 48
pdpt$ = 56
pd$ = 64
pt$ = 72
virt_addr$ = 96
AuGetPhysicalAddress PROC

; 416  : void* AuGetPhysicalAddress(uint64_t virt_addr){

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 417  : 
; 418  : 	const long i1 = x86_64_pml4_index(virt_addr);

	mov	rcx, QWORD PTR virt_addr$[rsp]
	call	?x86_64_pml4_index@@YA_K_K@Z		; x86_64_pml4_index
	mov	DWORD PTR i1$[rsp], eax

; 419  : 
; 420  : 	uint64_t *pml4_ = (uint64_t*)P2V(x64_read_cr3());

	call	x64_read_cr3
	mov	rcx, rax
	call	P2V
	mov	QWORD PTR pml4_$[rsp], rax

; 421  : 	uint64_t *pdpt = (uint64_t*)(P2V(pml4_[x86_64_pml4_index(virt_addr)]) & ~(4096 - 1));

	mov	rcx, QWORD PTR virt_addr$[rsp]
	call	?x86_64_pml4_index@@YA_K_K@Z		; x86_64_pml4_index
	mov	rcx, QWORD PTR pml4_$[rsp]
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	P2V
	and	rax, -4096				; fffffffffffff000H
	mov	QWORD PTR pdpt$[rsp], rax

; 422  : 	uint64_t *pd = (uint64_t*)(P2V(pdpt[x86_64_pdp_index(virt_addr)]) & ~(4096 - 1));

	mov	rcx, QWORD PTR virt_addr$[rsp]
	call	?x86_64_pdp_index@@YA_K_K@Z		; x86_64_pdp_index
	mov	rcx, QWORD PTR pdpt$[rsp]
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	P2V
	and	rax, -4096				; fffffffffffff000H
	mov	QWORD PTR pd$[rsp], rax

; 423  : 	uint64_t *pt = (uint64_t*)(P2V(pd[x86_64_pd_index(virt_addr)]) & ~(4096 - 1));

	mov	rcx, QWORD PTR virt_addr$[rsp]
	call	?x86_64_pd_index@@YA_K_K@Z		; x86_64_pd_index
	mov	rcx, QWORD PTR pd$[rsp]
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	P2V
	and	rax, -4096				; fffffffffffff000H
	mov	QWORD PTR pt$[rsp], rax

; 424  : 	uint64_t *page = (uint64_t*)(P2V(pt[x86_64_pt_index(virt_addr)]) & ~(4096 - 1));

	mov	rcx, QWORD PTR virt_addr$[rsp]
	call	?x86_64_pt_index@@YA_K_K@Z		; x86_64_pt_index
	mov	rcx, QWORD PTR pt$[rsp]
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	P2V
	and	rax, -4096				; fffffffffffff000H
	mov	QWORD PTR page$[rsp], rax

; 425  : 
; 426  : 	if (page)

	cmp	QWORD PTR page$[rsp], 0
	je	SHORT $LN2@AuGetPhysi

; 427  : 		return page;

	mov	rax, QWORD PTR page$[rsp]
	jmp	SHORT $LN3@AuGetPhysi

; 428  : 	else

	jmp	SHORT $LN1@AuGetPhysi
$LN2@AuGetPhysi:

; 429  : 		return NULL;

	xor	eax, eax
$LN1@AuGetPhysi:
$LN3@AuGetPhysi:

; 430  : 
; 431  : }

	add	rsp, 88					; 00000058H
	ret	0
AuGetPhysicalAddress ENDP
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\mm\vmmngr.cpp
_TEXT	SEGMENT
i$1 = 32
i1$ = 36
pt$2 = 40
page$3 = 48
tv68 = 56
pml4_$4 = 64
pdpt$5 = 72
pd$6 = 80
virt_addr$ = 112
free_physical$ = 120
s$ = 128
AuFreePages PROC

; 387  : void AuFreePages(uint64_t virt_addr, bool free_physical, size_t s){

$LN8:
	mov	QWORD PTR [rsp+24], r8
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 388  : 
; 389  : 	const long i1 = x86_64_pml4_index(virt_addr);

	mov	rcx, QWORD PTR virt_addr$[rsp]
	call	?x86_64_pml4_index@@YA_K_K@Z		; x86_64_pml4_index
	mov	DWORD PTR i1$[rsp], eax

; 390  : 
; 391  : 	for (int i = 0; i < (s / 4096) + 1; i++) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN5@AuFreePage
$LN4@AuFreePage:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN5@AuFreePage:
	movsxd	rax, DWORD PTR i$1[rsp]
	mov	QWORD PTR tv68[rsp], rax
	xor	edx, edx
	mov	rax, QWORD PTR s$[rsp]
	mov	ecx, 4096				; 00001000H
	div	rcx
	inc	rax
	mov	rcx, QWORD PTR tv68[rsp]
	cmp	rcx, rax
	jae	$LN3@AuFreePage

; 392  : 		uint64_t *pml4_ = (uint64_t*)P2V(x64_read_cr3());

	call	x64_read_cr3
	mov	rcx, rax
	call	P2V
	mov	QWORD PTR pml4_$4[rsp], rax

; 393  : 		uint64_t *pdpt = (uint64_t*)(P2V(pml4_[x86_64_pml4_index(virt_addr)]) & ~(4096 - 1));

	mov	rcx, QWORD PTR virt_addr$[rsp]
	call	?x86_64_pml4_index@@YA_K_K@Z		; x86_64_pml4_index
	mov	rcx, QWORD PTR pml4_$4[rsp]
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	P2V
	and	rax, -4096				; fffffffffffff000H
	mov	QWORD PTR pdpt$5[rsp], rax

; 394  : 		uint64_t *pd = (uint64_t*)(P2V(pdpt[x86_64_pdp_index(virt_addr)]) & ~(4096 - 1));

	mov	rcx, QWORD PTR virt_addr$[rsp]
	call	?x86_64_pdp_index@@YA_K_K@Z		; x86_64_pdp_index
	mov	rcx, QWORD PTR pdpt$5[rsp]
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	P2V
	and	rax, -4096				; fffffffffffff000H
	mov	QWORD PTR pd$6[rsp], rax

; 395  : 		uint64_t *pt = (uint64_t*)(P2V(pd[x86_64_pd_index(virt_addr)]) & ~(4096 - 1));

	mov	rcx, QWORD PTR virt_addr$[rsp]
	call	?x86_64_pd_index@@YA_K_K@Z		; x86_64_pd_index
	mov	rcx, QWORD PTR pd$6[rsp]
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	P2V
	and	rax, -4096				; fffffffffffff000H
	mov	QWORD PTR pt$2[rsp], rax

; 396  : 		uint64_t *page = (uint64_t*)(P2V(pt[x86_64_pt_index(virt_addr)]) & ~(4096 - 1));

	mov	rcx, QWORD PTR virt_addr$[rsp]
	call	?x86_64_pt_index@@YA_K_K@Z		; x86_64_pt_index
	mov	rcx, QWORD PTR pt$2[rsp]
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	P2V
	and	rax, -4096				; fffffffffffff000H
	mov	QWORD PTR page$3[rsp], rax

; 397  : 
; 398  : 		if ((pt[x86_64_pt_index(virt_addr)] & X86_64_PAGING_PRESENT) != 0) {

	mov	rcx, QWORD PTR virt_addr$[rsp]
	call	?x86_64_pt_index@@YA_K_K@Z		; x86_64_pt_index
	mov	rcx, QWORD PTR pt$2[rsp]
	mov	rax, QWORD PTR [rcx+rax*8]
	and	rax, 1
	test	rax, rax
	je	SHORT $LN2@AuFreePage

; 399  : 			pt[x86_64_pt_index(virt_addr)] = 0;

	mov	rcx, QWORD PTR virt_addr$[rsp]
	call	?x86_64_pt_index@@YA_K_K@Z		; x86_64_pt_index
	mov	rcx, QWORD PTR pt$2[rsp]
	mov	QWORD PTR [rcx+rax*8], 0
$LN2@AuFreePage:

; 400  : 		}
; 401  : 
; 402  : 		if (free_physical && page != 0)

	movzx	eax, BYTE PTR free_physical$[rsp]
	test	eax, eax
	je	SHORT $LN1@AuFreePage
	cmp	QWORD PTR page$3[rsp], 0
	je	SHORT $LN1@AuFreePage

; 403  : 			AuPmmngrFree((void*)V2P((size_t)page));

	mov	rcx, QWORD PTR page$3[rsp]
	call	V2P
	mov	rcx, rax
	call	AuPmmngrFree
$LN1@AuFreePage:

; 404  : 		
; 405  : 		virt_addr = virt_addr + i * 4096;

	imul	eax, DWORD PTR i$1[rsp], 4096		; 00001000H
	cdqe
	mov	rcx, QWORD PTR virt_addr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR virt_addr$[rsp], rax

; 406  : 	}

	jmp	$LN4@AuFreePage
$LN3@AuFreePage:

; 407  : 
; 408  : }

	add	rsp, 104				; 00000068H
	ret	0
AuFreePages ENDP
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\mm\vmmngr.cpp
_TEXT	SEGMENT
start$ = 32
pml4$ = 40
pdpt$1 = 48
pd$2 = 56
pt$3 = 64
page$ = 72
end$ = 80
user$ = 112
ptr$ = 120
AuGetFreePage PROC

; 339  : uint64_t* AuGetFreePage(bool user, void* ptr) {

$LN15:
	mov	QWORD PTR [rsp+16], rdx
	mov	BYTE PTR [rsp+8], cl
	sub	rsp, 104				; 00000068H

; 340  : 	uint64_t* page = 0;

	mov	QWORD PTR page$[rsp], 0

; 341  : 	uint64_t start = 0;

	mov	QWORD PTR start$[rsp], 0

; 342  : 	if (user) {

	movzx	eax, BYTE PTR user$[rsp]
	test	eax, eax
	je	SHORT $LN12@AuGetFreeP

; 343  : 		if (ptr)

	cmp	QWORD PTR ptr$[rsp], 0
	je	SHORT $LN11@AuGetFreeP

; 344  : 			start = (uint64_t)ptr;

	mov	rax, QWORD PTR ptr$[rsp]
	mov	QWORD PTR start$[rsp], rax

; 345  : 		else

	jmp	SHORT $LN10@AuGetFreeP
$LN11@AuGetFreeP:

; 346  : 			start = USER_BASE_ADDRESS;

	mov	QWORD PTR start$[rsp], 1610612736	; 60000000H
$LN10@AuGetFreeP:

; 347  : 	}
; 348  : 	else {

	jmp	SHORT $LN9@AuGetFreeP
$LN12@AuGetFreeP:

; 349  : 		if (ptr)

	cmp	QWORD PTR ptr$[rsp], 0
	je	SHORT $LN8@AuGetFreeP

; 350  : 			start = (uint64_t)ptr;

	mov	rax, QWORD PTR ptr$[rsp]
	mov	QWORD PTR start$[rsp], rax

; 351  : 		else

	jmp	SHORT $LN7@AuGetFreeP
$LN8@AuGetFreeP:

; 352  : 			start = KERNEL_BASE_ADDRESS;

	mov	rax, -35184372088832			; ffffe00000000000H
	mov	QWORD PTR start$[rsp], rax
$LN7@AuGetFreeP:
$LN9@AuGetFreeP:

; 353  : 	}
; 354  : 
; 355  : 	uint64_t* end = 0;

	mov	QWORD PTR end$[rsp], 0

; 356  : 	uint64_t *pml4 = (uint64_t*)P2V(x64_read_cr3());

	call	x64_read_cr3
	mov	rcx, rax
	call	P2V
	mov	QWORD PTR pml4$[rsp], rax
$LN6@AuGetFreeP:

; 357  : 
; 358  : 	/* Walk through every page tables */
; 359  : 	for (;;) {
; 360  : 		if (!(pml4[x86_64_pml4_index(start)] & X86_64_PAGING_PRESENT))

	mov	rcx, QWORD PTR start$[rsp]
	call	?x86_64_pml4_index@@YA_K_K@Z		; x86_64_pml4_index
	mov	rcx, QWORD PTR pml4$[rsp]
	mov	rax, QWORD PTR [rcx+rax*8]
	and	rax, 1
	test	rax, rax
	jne	SHORT $LN4@AuGetFreeP

; 361  : 			return (uint64_t*)start;

	mov	rax, QWORD PTR start$[rsp]
	jmp	$LN13@AuGetFreeP
$LN4@AuGetFreeP:

; 362  : 
; 363  : 		uint64_t *pdpt = (uint64_t*)(P2V(pml4[x86_64_pml4_index(start)]) & ~(4096 - 1));

	mov	rcx, QWORD PTR start$[rsp]
	call	?x86_64_pml4_index@@YA_K_K@Z		; x86_64_pml4_index
	mov	rcx, QWORD PTR pml4$[rsp]
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	P2V
	and	rax, -4096				; fffffffffffff000H
	mov	QWORD PTR pdpt$1[rsp], rax

; 364  : 		if (!(pdpt[x86_64_pdp_index(start)] & X86_64_PAGING_PRESENT))

	mov	rcx, QWORD PTR start$[rsp]
	call	?x86_64_pdp_index@@YA_K_K@Z		; x86_64_pdp_index
	mov	rcx, QWORD PTR pdpt$1[rsp]
	mov	rax, QWORD PTR [rcx+rax*8]
	and	rax, 1
	test	rax, rax
	jne	SHORT $LN3@AuGetFreeP

; 365  : 			return (uint64_t*)start;

	mov	rax, QWORD PTR start$[rsp]
	jmp	$LN13@AuGetFreeP
$LN3@AuGetFreeP:

; 366  : 
; 367  : 		uint64_t *pd = (uint64_t*)(P2V(pdpt[x86_64_pdp_index(start)]) & ~(4096 - 1));

	mov	rcx, QWORD PTR start$[rsp]
	call	?x86_64_pdp_index@@YA_K_K@Z		; x86_64_pdp_index
	mov	rcx, QWORD PTR pdpt$1[rsp]
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	P2V
	and	rax, -4096				; fffffffffffff000H
	mov	QWORD PTR pd$2[rsp], rax

; 368  : 		if (!(pd[x86_64_pd_index(start)] & X86_64_PAGING_PRESENT))

	mov	rcx, QWORD PTR start$[rsp]
	call	?x86_64_pd_index@@YA_K_K@Z		; x86_64_pd_index
	mov	rcx, QWORD PTR pd$2[rsp]
	mov	rax, QWORD PTR [rcx+rax*8]
	and	rax, 1
	test	rax, rax
	jne	SHORT $LN2@AuGetFreeP

; 369  : 			return (uint64_t*)start;

	mov	rax, QWORD PTR start$[rsp]
	jmp	SHORT $LN13@AuGetFreeP
$LN2@AuGetFreeP:

; 370  : 
; 371  : 		uint64_t *pt = (uint64_t*)(P2V(pd[x86_64_pd_index(start)]) & ~(4096 - 1));

	mov	rcx, QWORD PTR start$[rsp]
	call	?x86_64_pd_index@@YA_K_K@Z		; x86_64_pd_index
	mov	rcx, QWORD PTR pd$2[rsp]
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	P2V
	and	rax, -4096				; fffffffffffff000H
	mov	QWORD PTR pt$3[rsp], rax

; 372  : 
; 373  : 		if (!(pt[x86_64_pt_index(start)] & X86_64_PAGING_PRESENT))

	mov	rcx, QWORD PTR start$[rsp]
	call	?x86_64_pt_index@@YA_K_K@Z		; x86_64_pt_index
	mov	rcx, QWORD PTR pt$3[rsp]
	mov	rax, QWORD PTR [rcx+rax*8]
	and	rax, 1
	test	rax, rax
	jne	SHORT $LN1@AuGetFreeP

; 374  : 			return (uint64_t*)start;

	mov	rax, QWORD PTR start$[rsp]
	jmp	SHORT $LN13@AuGetFreeP
$LN1@AuGetFreeP:

; 375  : 
; 376  : 		start += 4096;

	mov	rax, QWORD PTR start$[rsp]
	add	rax, 4096				; 00001000H
	mov	QWORD PTR start$[rsp], rax

; 377  : 	}

	jmp	$LN6@AuGetFreeP

; 378  : 	return 0;

	xor	eax, eax
$LN13@AuGetFreeP:

; 379  : }

	add	rsp, 104				; 00000068H
	ret	0
AuGetFreePage ENDP
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\mm\vmmngr.cpp
_TEXT	SEGMENT
i$1 = 32
out$ = 40
address$ = 48
phys_addr$ = 80
page_count$ = 88
AuMapMMIO PROC

; 321  : void* AuMapMMIO(uint64_t phys_addr, size_t page_count) {

$LN6:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 322  : 	uint64_t out = (uint64_t)_MmioBase;

	mov	rax, QWORD PTR ?_MmioBase@@3PEA_KEA	; _MmioBase
	mov	QWORD PTR out$[rsp], rax

; 323  : 	for (size_t i = 0; i < page_count; i++)

	mov	QWORD PTR i$1[rsp], 0
	jmp	SHORT $LN3@AuMapMMIO
$LN2@AuMapMMIO:
	mov	rax, QWORD PTR i$1[rsp]
	inc	rax
	mov	QWORD PTR i$1[rsp], rax
$LN3@AuMapMMIO:
	mov	rax, QWORD PTR page_count$[rsp]
	cmp	QWORD PTR i$1[rsp], rax
	jae	SHORT $LN1@AuMapMMIO

; 324  : 		AuMapPage(phys_addr + i * 4096, out + i * 4096, 0x04 | 0x80000 | 0x200000);

	imul	rax, QWORD PTR i$1[rsp], 4096		; 00001000H
	mov	rcx, QWORD PTR out$[rsp]
	add	rcx, rax
	mov	rax, rcx
	imul	rcx, QWORD PTR i$1[rsp], 4096		; 00001000H
	mov	rdx, QWORD PTR phys_addr$[rsp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r8b, 4
	mov	rdx, rax
	call	AuMapPage
	jmp	SHORT $LN2@AuMapMMIO
$LN1@AuMapMMIO:

; 325  : 
; 326  : 	uint64_t address = out;

	mov	rax, QWORD PTR out$[rsp]
	mov	QWORD PTR address$[rsp], rax

; 327  : 	_MmioBase = (uint64_t*)(address + (page_count * 4096));

	imul	rax, QWORD PTR page_count$[rsp], 4096	; 00001000H
	mov	rcx, QWORD PTR address$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR ?_MmioBase@@3PEA_KEA, rax	; _MmioBase

; 328  : 	return (void*)out;

	mov	rax, QWORD PTR out$[rsp]

; 329  : }

	add	rsp, 72					; 00000048H
	ret	0
AuMapMMIO ENDP
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\mm\vmmngr.cpp
_TEXT	SEGMENT
flags$ = 32
i3$ = 36
i2$ = 40
i4$ = 44
i1$ = 48
pml3$ = 56
pml2$ = 64
pml1$ = 72
page$1 = 80
page$2 = 88
page$3 = 96
pml4i$ = 128
phys_addr$ = 136
virt_addr$ = 144
attrib$ = 152
AuMapPageEx PROC

; 261  : bool AuMapPageEx(uint64_t *pml4i, uint64_t phys_addr, uint64_t virt_addr, uint8_t attrib) {

$LN7:
	mov	BYTE PTR [rsp+32], r9b
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 120				; 00000078H

; 262  : 	uint8_t flags = X86_64_PAGING_PRESENT | X86_64_PAGING_WRITABLE | attrib;

	movzx	eax, BYTE PTR attrib$[rsp]
	or	eax, 3
	mov	BYTE PTR flags$[rsp], al

; 263  : 
; 264  : 	const long i4 = (virt_addr >> 39) & 0x1FF;

	mov	rax, QWORD PTR virt_addr$[rsp]
	shr	rax, 39					; 00000027H
	and	rax, 511				; 000001ffH
	mov	DWORD PTR i4$[rsp], eax

; 265  : 	const long i3 = (virt_addr >> 30) & 0x1FF;

	mov	rax, QWORD PTR virt_addr$[rsp]
	shr	rax, 30
	and	rax, 511				; 000001ffH
	mov	DWORD PTR i3$[rsp], eax

; 266  : 	const long i2 = (virt_addr >> 21) & 0x1FF;

	mov	rax, QWORD PTR virt_addr$[rsp]
	shr	rax, 21
	and	rax, 511				; 000001ffH
	mov	DWORD PTR i2$[rsp], eax

; 267  : 	const long i1 = (virt_addr >> 12) & 0x1FF;

	mov	rax, QWORD PTR virt_addr$[rsp]
	shr	rax, 12
	and	rax, 511				; 000001ffH
	mov	DWORD PTR i1$[rsp], eax

; 268  : 
; 269  : 
; 270  : 	if (!(pml4i[i4] & X86_64_PAGING_PRESENT))

	movsxd	rax, DWORD PTR i4$[rsp]
	mov	rcx, QWORD PTR pml4i$[rsp]
	mov	rax, QWORD PTR [rcx+rax*8]
	and	rax, 1
	test	rax, rax
	jne	SHORT $LN4@AuMapPageE

; 271  : 	{
; 272  : 		const uint64_t page = (uint64_t)AuPmmngrAlloc();

	call	AuPmmngrAlloc
	mov	QWORD PTR page$1[rsp], rax

; 273  : 		pml4i[i4] = page | flags;

	movzx	eax, BYTE PTR flags$[rsp]
	mov	rcx, QWORD PTR page$1[rsp]
	or	rcx, rax
	mov	rax, rcx
	movsxd	rcx, DWORD PTR i4$[rsp]
	mov	rdx, QWORD PTR pml4i$[rsp]
	mov	QWORD PTR [rdx+rcx*8], rax

; 274  : 		memset((void*)P2V(page), 0, 4096);

	mov	rcx, QWORD PTR page$1[rsp]
	call	P2V
	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, rax
	call	memset

; 275  : 		flush_tlb((void*)pml4i);

	mov	rcx, QWORD PTR pml4i$[rsp]
	call	flush_tlb

; 276  : 		x64_mfence();

	call	x64_mfence
$LN4@AuMapPageE:

; 277  : 	}
; 278  : 	uint64_t* pml3 = (uint64_t*)(P2V(pml4i[i4]) & ~(4096 - 1));

	movsxd	rax, DWORD PTR i4$[rsp]
	mov	rcx, QWORD PTR pml4i$[rsp]
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	P2V
	and	rax, -4096				; fffffffffffff000H
	mov	QWORD PTR pml3$[rsp], rax

; 279  : 
; 280  : 	if (!(pml3[i3] & X86_64_PAGING_PRESENT))

	movsxd	rax, DWORD PTR i3$[rsp]
	mov	rcx, QWORD PTR pml3$[rsp]
	mov	rax, QWORD PTR [rcx+rax*8]
	and	rax, 1
	test	rax, rax
	jne	SHORT $LN3@AuMapPageE

; 281  : 	{
; 282  : 		const uint64_t page = (uint64_t)AuPmmngrAlloc();

	call	AuPmmngrAlloc
	mov	QWORD PTR page$2[rsp], rax

; 283  : 		pml3[i3] = page | flags;

	movzx	eax, BYTE PTR flags$[rsp]
	mov	rcx, QWORD PTR page$2[rsp]
	or	rcx, rax
	mov	rax, rcx
	movsxd	rcx, DWORD PTR i3$[rsp]
	mov	rdx, QWORD PTR pml3$[rsp]
	mov	QWORD PTR [rdx+rcx*8], rax

; 284  : 		memset((void*)P2V(page), 0, 4096);

	mov	rcx, QWORD PTR page$2[rsp]
	call	P2V
	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, rax
	call	memset

; 285  : 		flush_tlb((void*)pml3);

	mov	rcx, QWORD PTR pml3$[rsp]
	call	flush_tlb

; 286  : 		x64_mfence();

	call	x64_mfence
$LN3@AuMapPageE:

; 287  : 
; 288  : 	}
; 289  : 
; 290  : 
; 291  : 	uint64_t* pml2 = (uint64_t*)(P2V(pml3[i3]) & ~(4096 - 1));

	movsxd	rax, DWORD PTR i3$[rsp]
	mov	rcx, QWORD PTR pml3$[rsp]
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	P2V
	and	rax, -4096				; fffffffffffff000H
	mov	QWORD PTR pml2$[rsp], rax

; 292  : 
; 293  : 	if (!(pml2[i2] & X86_64_PAGING_PRESENT))

	movsxd	rax, DWORD PTR i2$[rsp]
	mov	rcx, QWORD PTR pml2$[rsp]
	mov	rax, QWORD PTR [rcx+rax*8]
	and	rax, 1
	test	rax, rax
	jne	SHORT $LN2@AuMapPageE

; 294  : 	{
; 295  : 		const uint64_t page = (uint64_t)AuPmmngrAlloc();

	call	AuPmmngrAlloc
	mov	QWORD PTR page$3[rsp], rax

; 296  : 		pml2[i2] = page | flags;

	movzx	eax, BYTE PTR flags$[rsp]
	mov	rcx, QWORD PTR page$3[rsp]
	or	rcx, rax
	mov	rax, rcx
	movsxd	rcx, DWORD PTR i2$[rsp]
	mov	rdx, QWORD PTR pml2$[rsp]
	mov	QWORD PTR [rdx+rcx*8], rax

; 297  : 		memset((void*)P2V(page), 0, 4096);

	mov	rcx, QWORD PTR page$3[rsp]
	call	P2V
	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, rax
	call	memset

; 298  : 		flush_tlb((void*)pml2);

	mov	rcx, QWORD PTR pml2$[rsp]
	call	flush_tlb

; 299  : 		x64_mfence();

	call	x64_mfence
$LN2@AuMapPageE:

; 300  : 
; 301  : 	}
; 302  : 
; 303  : 	uint64_t* pml1 = (uint64_t*)(P2V(pml2[i2]) & ~(4096 - 1));

	movsxd	rax, DWORD PTR i2$[rsp]
	mov	rcx, QWORD PTR pml2$[rsp]
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	P2V
	and	rax, -4096				; fffffffffffff000H
	mov	QWORD PTR pml1$[rsp], rax

; 304  : 	if (pml1[i1] & X86_64_PAGING_PRESENT)

	movsxd	rax, DWORD PTR i1$[rsp]
	mov	rcx, QWORD PTR pml1$[rsp]
	mov	rax, QWORD PTR [rcx+rax*8]
	and	rax, 1
	test	rax, rax
	je	SHORT $LN1@AuMapPageE

; 305  : 	{
; 306  : 		AuPmmngrFree((void*)phys_addr);

	mov	rcx, QWORD PTR phys_addr$[rsp]
	call	AuPmmngrFree

; 307  : 		return false;

	xor	al, al
	jmp	SHORT $LN5@AuMapPageE
$LN1@AuMapPageE:

; 308  : 	}
; 309  : 
; 310  : 	pml1[i1] = phys_addr | flags;

	movzx	eax, BYTE PTR flags$[rsp]
	mov	rcx, QWORD PTR phys_addr$[rsp]
	or	rcx, rax
	mov	rax, rcx
	movsxd	rcx, DWORD PTR i1$[rsp]
	mov	rdx, QWORD PTR pml1$[rsp]
	mov	QWORD PTR [rdx+rcx*8], rax

; 311  : 	flush_tlb((void*)pml1);

	mov	rcx, QWORD PTR pml1$[rsp]
	call	flush_tlb

; 312  : 	x64_mfence();

	call	x64_mfence

; 313  : 	return true;

	mov	al, 1
$LN5@AuMapPageE:

; 314  : }

	add	rsp, 120				; 00000078H
	ret	0
AuMapPageEx ENDP
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\mm\vmmngr.cpp
_TEXT	SEGMENT
flags$ = 32
i3$ = 36
i2$ = 40
i4$ = 44
i1$ = 48
pml4i$ = 56
pml3$ = 64
pml2$ = 72
pml1$ = 80
page$1 = 88
page$2 = 96
page$3 = 104
phys_addr$ = 128
virt_addr$ = 136
attrib$ = 144
AuMapPage PROC

; 196  : bool AuMapPage(uint64_t phys_addr, uint64_t virt_addr, uint8_t attrib) {

$LN7:
	mov	BYTE PTR [rsp+24], r8b
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 120				; 00000078H

; 197  : 	uint8_t flags = X86_64_PAGING_PRESENT | X86_64_PAGING_WRITABLE | attrib;

	movzx	eax, BYTE PTR attrib$[rsp]
	or	eax, 3
	mov	BYTE PTR flags$[rsp], al

; 198  : 
; 199  : 	const long i4 = (virt_addr >> 39) & 0x1FF;

	mov	rax, QWORD PTR virt_addr$[rsp]
	shr	rax, 39					; 00000027H
	and	rax, 511				; 000001ffH
	mov	DWORD PTR i4$[rsp], eax

; 200  : 	const long i3 = (virt_addr >> 30) & 0x1FF;

	mov	rax, QWORD PTR virt_addr$[rsp]
	shr	rax, 30
	and	rax, 511				; 000001ffH
	mov	DWORD PTR i3$[rsp], eax

; 201  : 	const long i2 = (virt_addr >> 21) & 0x1FF;

	mov	rax, QWORD PTR virt_addr$[rsp]
	shr	rax, 21
	and	rax, 511				; 000001ffH
	mov	DWORD PTR i2$[rsp], eax

; 202  : 	const long i1 = (virt_addr >> 12) & 0x1FF;

	mov	rax, QWORD PTR virt_addr$[rsp]
	shr	rax, 12
	and	rax, 511				; 000001ffH
	mov	DWORD PTR i1$[rsp], eax

; 203  : 
; 204  : 	uint64_t *pml4i = (uint64_t*)P2V(x64_read_cr3());

	call	x64_read_cr3
	mov	rcx, rax
	call	P2V
	mov	QWORD PTR pml4i$[rsp], rax

; 205  : 
; 206  : 	if (!(pml4i[i4] & X86_64_PAGING_PRESENT))

	movsxd	rax, DWORD PTR i4$[rsp]
	mov	rcx, QWORD PTR pml4i$[rsp]
	mov	rax, QWORD PTR [rcx+rax*8]
	and	rax, 1
	test	rax, rax
	jne	SHORT $LN4@AuMapPage

; 207  : 	{
; 208  : 		const uint64_t page = (uint64_t)AuPmmngrAlloc();

	call	AuPmmngrAlloc
	mov	QWORD PTR page$2[rsp], rax

; 209  : 		pml4i[i4] = page | flags;

	movzx	eax, BYTE PTR flags$[rsp]
	mov	rcx, QWORD PTR page$2[rsp]
	or	rcx, rax
	mov	rax, rcx
	movsxd	rcx, DWORD PTR i4$[rsp]
	mov	rdx, QWORD PTR pml4i$[rsp]
	mov	QWORD PTR [rdx+rcx*8], rax

; 210  : 		memset((void*)P2V(page), 0, 4096);

	mov	rcx, QWORD PTR page$2[rsp]
	call	P2V
	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, rax
	call	memset

; 211  : 		flush_tlb((void*)pml4i);

	mov	rcx, QWORD PTR pml4i$[rsp]
	call	flush_tlb

; 212  : 		x64_mfence();

	call	x64_mfence
$LN4@AuMapPage:

; 213  : 	}
; 214  : 	uint64_t* pml3 = (uint64_t*)(P2V(pml4i[i4]) & ~(4096 - 1));

	movsxd	rax, DWORD PTR i4$[rsp]
	mov	rcx, QWORD PTR pml4i$[rsp]
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	P2V
	and	rax, -4096				; fffffffffffff000H
	mov	QWORD PTR pml3$[rsp], rax

; 215  : 
; 216  : 	if (!(pml3[i3] & X86_64_PAGING_PRESENT))

	movsxd	rax, DWORD PTR i3$[rsp]
	mov	rcx, QWORD PTR pml3$[rsp]
	mov	rax, QWORD PTR [rcx+rax*8]
	and	rax, 1
	test	rax, rax
	jne	SHORT $LN3@AuMapPage

; 217  : 	{
; 218  : 		const uint64_t page = (uint64_t)AuPmmngrAlloc();

	call	AuPmmngrAlloc
	mov	QWORD PTR page$1[rsp], rax

; 219  : 		pml3[i3] = page | flags;

	movzx	eax, BYTE PTR flags$[rsp]
	mov	rcx, QWORD PTR page$1[rsp]
	or	rcx, rax
	mov	rax, rcx
	movsxd	rcx, DWORD PTR i3$[rsp]
	mov	rdx, QWORD PTR pml3$[rsp]
	mov	QWORD PTR [rdx+rcx*8], rax

; 220  : 		memset((void*)P2V(page), 0, 4096);

	mov	rcx, QWORD PTR page$1[rsp]
	call	P2V
	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, rax
	call	memset

; 221  : 		flush_tlb((void*)pml3);

	mov	rcx, QWORD PTR pml3$[rsp]
	call	flush_tlb

; 222  : 		x64_mfence();

	call	x64_mfence
$LN3@AuMapPage:

; 223  : 
; 224  : 	}
; 225  : 
; 226  : 
; 227  : 	uint64_t* pml2 = (uint64_t*)(P2V(pml3[i3]) & ~(4096 - 1));

	movsxd	rax, DWORD PTR i3$[rsp]
	mov	rcx, QWORD PTR pml3$[rsp]
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	P2V
	and	rax, -4096				; fffffffffffff000H
	mov	QWORD PTR pml2$[rsp], rax

; 228  : 
; 229  : 	if (!(pml2[i2] & X86_64_PAGING_PRESENT))

	movsxd	rax, DWORD PTR i2$[rsp]
	mov	rcx, QWORD PTR pml2$[rsp]
	mov	rax, QWORD PTR [rcx+rax*8]
	and	rax, 1
	test	rax, rax
	jne	SHORT $LN2@AuMapPage

; 230  : 	{
; 231  : 		const uint64_t page = (uint64_t)AuPmmngrAlloc();

	call	AuPmmngrAlloc
	mov	QWORD PTR page$3[rsp], rax

; 232  : 		pml2[i2] = page | flags;

	movzx	eax, BYTE PTR flags$[rsp]
	mov	rcx, QWORD PTR page$3[rsp]
	or	rcx, rax
	mov	rax, rcx
	movsxd	rcx, DWORD PTR i2$[rsp]
	mov	rdx, QWORD PTR pml2$[rsp]
	mov	QWORD PTR [rdx+rcx*8], rax

; 233  : 		memset((void*)P2V(page), 0, 4096);

	mov	rcx, QWORD PTR page$3[rsp]
	call	P2V
	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, rax
	call	memset

; 234  : 		flush_tlb((void*)pml2);

	mov	rcx, QWORD PTR pml2$[rsp]
	call	flush_tlb

; 235  : 		x64_mfence();

	call	x64_mfence
$LN2@AuMapPage:

; 236  : 
; 237  : 	}
; 238  : 
; 239  : 	uint64_t* pml1 = (uint64_t*)(P2V(pml2[i2]) & ~(4096 - 1));

	movsxd	rax, DWORD PTR i2$[rsp]
	mov	rcx, QWORD PTR pml2$[rsp]
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	P2V
	and	rax, -4096				; fffffffffffff000H
	mov	QWORD PTR pml1$[rsp], rax

; 240  : 	if (pml1[i1] & X86_64_PAGING_PRESENT)

	movsxd	rax, DWORD PTR i1$[rsp]
	mov	rcx, QWORD PTR pml1$[rsp]
	mov	rax, QWORD PTR [rcx+rax*8]
	and	rax, 1
	test	rax, rax
	je	SHORT $LN1@AuMapPage

; 241  : 	{
; 242  : 		AuPmmngrFree((void*)phys_addr);

	mov	rcx, QWORD PTR phys_addr$[rsp]
	call	AuPmmngrFree

; 243  : 		return false;

	xor	al, al
	jmp	SHORT $LN5@AuMapPage
$LN1@AuMapPage:

; 244  : 	}
; 245  : 
; 246  : 	pml1[i1] = phys_addr | flags;

	movzx	eax, BYTE PTR flags$[rsp]
	mov	rcx, QWORD PTR phys_addr$[rsp]
	or	rcx, rax
	mov	rax, rcx
	movsxd	rcx, DWORD PTR i1$[rsp]
	mov	rdx, QWORD PTR pml1$[rsp]
	mov	QWORD PTR [rdx+rcx*8], rax

; 247  : 	flush_tlb((void*)pml1);

	mov	rcx, QWORD PTR pml1$[rsp]
	call	flush_tlb

; 248  : 	x64_mfence();

	call	x64_mfence

; 249  : 	return true;

	mov	al, 1
$LN5@AuMapPage:

; 250  : }

	add	rsp, 120				; 00000078H
	ret	0
AuMapPage ENDP
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\mm\vmmngr.cpp
_TEXT	SEGMENT
flags$ = 32
i1$ = 36
i4$ = 40
i2$ = 44
i3$ = 48
pml1$ = 56
pml4i$ = 64
page$1 = 72
pml2$ = 80
page$2 = 88
page$3 = 96
pml3$ = 104
phys_addr$4 = 112
page$5 = 120
vpage$6 = 128
virt_addr$ = 160
_flags$ = 168
mode$ = 176
AuVmmngrGetPage PROC

; 123  : AuVPage * AuVmmngrGetPage(uint64_t virt_addr, uint8_t _flags, uint8_t mode) {

$LN10:
	mov	BYTE PTR [rsp+24], r8b
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 152				; 00000098H

; 124  : 	uint8_t flags = X86_64_PAGING_PRESENT | X86_64_PAGING_WRITABLE | _flags;

	movzx	eax, BYTE PTR _flags$[rsp]
	or	eax, 3
	mov	BYTE PTR flags$[rsp], al

; 125  : 
; 126  : 
; 127  : 	const long i4 = (virt_addr >> 39) & 0x1FF;

	mov	rax, QWORD PTR virt_addr$[rsp]
	shr	rax, 39					; 00000027H
	and	rax, 511				; 000001ffH
	mov	DWORD PTR i4$[rsp], eax

; 128  : 	const long i3 = (virt_addr >> 30) & 0x1FF;

	mov	rax, QWORD PTR virt_addr$[rsp]
	shr	rax, 30
	and	rax, 511				; 000001ffH
	mov	DWORD PTR i3$[rsp], eax

; 129  : 	const long i2 = (virt_addr >> 21) & 0x1FF;

	mov	rax, QWORD PTR virt_addr$[rsp]
	shr	rax, 21
	and	rax, 511				; 000001ffH
	mov	DWORD PTR i2$[rsp], eax

; 130  : 	const long i1 = (virt_addr >> 12) & 0x1FF;

	mov	rax, QWORD PTR virt_addr$[rsp]
	shr	rax, 12
	and	rax, 511				; 000001ffH
	mov	DWORD PTR i1$[rsp], eax

; 131  : 
; 132  : 	uint64_t *pml4i = (uint64_t*)P2V(x64_read_cr3());

	call	x64_read_cr3
	mov	rcx, rax
	call	P2V
	mov	QWORD PTR pml4i$[rsp], rax

; 133  : 
; 134  : 	if (!(pml4i[i4] & X86_64_PAGING_PRESENT))

	movsxd	rax, DWORD PTR i4$[rsp]
	mov	rcx, QWORD PTR pml4i$[rsp]
	mov	rax, QWORD PTR [rcx+rax*8]
	and	rax, 1
	test	rax, rax
	jne	SHORT $LN7@AuVmmngrGe

; 135  : 	{
; 136  : 		const uint64_t page = (uint64_t)AuPmmngrAlloc();

	call	AuPmmngrAlloc
	mov	QWORD PTR page$3[rsp], rax

; 137  : 		pml4i[i4] = page | flags;

	movzx	eax, BYTE PTR flags$[rsp]
	mov	rcx, QWORD PTR page$3[rsp]
	or	rcx, rax
	mov	rax, rcx
	movsxd	rcx, DWORD PTR i4$[rsp]
	mov	rdx, QWORD PTR pml4i$[rsp]
	mov	QWORD PTR [rdx+rcx*8], rax

; 138  : 		memset((void*)P2V(page), 0, 4096);

	mov	rcx, QWORD PTR page$3[rsp]
	call	P2V
	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, rax
	call	memset

; 139  : 		flush_tlb((void*)page);

	mov	rcx, QWORD PTR page$3[rsp]
	call	flush_tlb

; 140  : 		x64_mfence();

	call	x64_mfence
$LN7@AuVmmngrGe:

; 141  : 	}
; 142  : 	uint64_t* pml3 = (uint64_t*)(P2V(pml4i[i4]) & ~(4096 - 1));

	movsxd	rax, DWORD PTR i4$[rsp]
	mov	rcx, QWORD PTR pml4i$[rsp]
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	P2V
	and	rax, -4096				; fffffffffffff000H
	mov	QWORD PTR pml3$[rsp], rax

; 143  : 
; 144  : 	if (!(pml3[i3] & X86_64_PAGING_PRESENT))

	movsxd	rax, DWORD PTR i3$[rsp]
	mov	rcx, QWORD PTR pml3$[rsp]
	mov	rax, QWORD PTR [rcx+rax*8]
	and	rax, 1
	test	rax, rax
	jne	SHORT $LN6@AuVmmngrGe

; 145  : 	{
; 146  : 		const uint64_t page = (uint64_t)AuPmmngrAlloc();

	call	AuPmmngrAlloc
	mov	QWORD PTR page$2[rsp], rax

; 147  : 		pml3[i3] = page | flags;

	movzx	eax, BYTE PTR flags$[rsp]
	mov	rcx, QWORD PTR page$2[rsp]
	or	rcx, rax
	mov	rax, rcx
	movsxd	rcx, DWORD PTR i3$[rsp]
	mov	rdx, QWORD PTR pml3$[rsp]
	mov	QWORD PTR [rdx+rcx*8], rax

; 148  : 		memset((void*)P2V(page), 0, 4096);

	mov	rcx, QWORD PTR page$2[rsp]
	call	P2V
	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, rax
	call	memset

; 149  : 		flush_tlb((void*)page);

	mov	rcx, QWORD PTR page$2[rsp]
	call	flush_tlb

; 150  : 		x64_mfence();

	call	x64_mfence
$LN6@AuVmmngrGe:

; 151  : 
; 152  : 	}
; 153  : 
; 154  : 
; 155  : 	uint64_t* pml2 = (uint64_t*)(P2V(pml3[i3]) & ~(4096 - 1));

	movsxd	rax, DWORD PTR i3$[rsp]
	mov	rcx, QWORD PTR pml3$[rsp]
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	P2V
	and	rax, -4096				; fffffffffffff000H
	mov	QWORD PTR pml2$[rsp], rax

; 156  : 
; 157  : 	if (!(pml2[i2] & X86_64_PAGING_PRESENT))

	movsxd	rax, DWORD PTR i2$[rsp]
	mov	rcx, QWORD PTR pml2$[rsp]
	mov	rax, QWORD PTR [rcx+rax*8]
	and	rax, 1
	test	rax, rax
	jne	SHORT $LN5@AuVmmngrGe

; 158  : 	{
; 159  : 		const uint64_t page = (uint64_t)AuPmmngrAlloc();

	call	AuPmmngrAlloc
	mov	QWORD PTR page$1[rsp], rax

; 160  : 		pml2[i2] = page | flags;

	movzx	eax, BYTE PTR flags$[rsp]
	mov	rcx, QWORD PTR page$1[rsp]
	or	rcx, rax
	mov	rax, rcx
	movsxd	rcx, DWORD PTR i2$[rsp]
	mov	rdx, QWORD PTR pml2$[rsp]
	mov	QWORD PTR [rdx+rcx*8], rax

; 161  : 		memset((void*)P2V(page), 0, 4096);

	mov	rcx, QWORD PTR page$1[rsp]
	call	P2V
	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, rax
	call	memset

; 162  : 		flush_tlb((void*)page);

	mov	rcx, QWORD PTR page$1[rsp]
	call	flush_tlb

; 163  : 		x64_mfence();

	call	x64_mfence
$LN5@AuVmmngrGe:

; 164  : 
; 165  : 	}
; 166  : 
; 167  : 	uint64_t* pml1 = (uint64_t*)(P2V(pml2[i2]) & ~(4096 - 1));

	movsxd	rax, DWORD PTR i2$[rsp]
	mov	rcx, QWORD PTR pml2$[rsp]
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	P2V
	and	rax, -4096				; fffffffffffff000H
	mov	QWORD PTR pml1$[rsp], rax

; 168  : 	if (pml1[i1] & X86_64_PAGING_PRESENT)

	movsxd	rax, DWORD PTR i1$[rsp]
	mov	rcx, QWORD PTR pml1$[rsp]
	mov	rax, QWORD PTR [rcx+rax*8]
	and	rax, 1
	test	rax, rax
	je	SHORT $LN4@AuVmmngrGe

; 169  : 	{
; 170  : 
; 171  : 		AuVPage *page = (AuVPage*)&pml1[i1];

	movsxd	rax, DWORD PTR i1$[rsp]
	mov	rcx, QWORD PTR pml1$[rsp]
	lea	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR page$5[rsp], rax

; 172  : 		return page;

	mov	rax, QWORD PTR page$5[rsp]
	jmp	$LN8@AuVmmngrGe

; 173  : 	}
; 174  : 	else {

	jmp	$LN3@AuVmmngrGe
$LN4@AuVmmngrGe:

; 175  : 		if (mode & VIRT_GETPAGE_CREATE && !(mode & VIRT_GETPAGE_ONLY_RET)) {

	movzx	eax, BYTE PTR mode$[rsp]
	and	eax, 1
	test	eax, eax
	je	$LN2@AuVmmngrGe
	movzx	eax, BYTE PTR mode$[rsp]
	and	eax, 2
	test	eax, eax
	jne	SHORT $LN2@AuVmmngrGe

; 176  : 			uint64_t phys_addr = (uint64_t)AuPmmngrAlloc();

	call	AuPmmngrAlloc
	mov	QWORD PTR phys_addr$4[rsp], rax

; 177  : 			memset((void*)P2V(phys_addr), 0, 4096);

	mov	rcx, QWORD PTR phys_addr$4[rsp]
	call	P2V
	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, rax
	call	memset

; 178  : 			pml1[i1] = phys_addr | flags;

	movzx	eax, BYTE PTR flags$[rsp]
	mov	rcx, QWORD PTR phys_addr$4[rsp]
	or	rcx, rax
	mov	rax, rcx
	movsxd	rcx, DWORD PTR i1$[rsp]
	mov	rdx, QWORD PTR pml1$[rsp]
	mov	QWORD PTR [rdx+rcx*8], rax

; 179  : 			flush_tlb((void*)virt_addr);

	mov	rcx, QWORD PTR virt_addr$[rsp]
	call	flush_tlb

; 180  : 			x64_mfence();

	call	x64_mfence

; 181  : 			AuVPage *vpage = (AuVPage*)&pml1[i1];

	movsxd	rax, DWORD PTR i1$[rsp]
	mov	rcx, QWORD PTR pml1$[rsp]
	lea	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR vpage$6[rsp], rax

; 182  : 			return vpage;

	mov	rax, QWORD PTR vpage$6[rsp]
	jmp	SHORT $LN8@AuVmmngrGe
$LN2@AuVmmngrGe:

; 183  : 		}
; 184  : 		if (mode & VIRT_GETPAGE_ONLY_RET)

	movzx	eax, BYTE PTR mode$[rsp]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN1@AuVmmngrGe

; 185  : 			return NULL;

	xor	eax, eax
$LN1@AuVmmngrGe:
$LN3@AuVmmngrGe:
$LN8@AuVmmngrGe:

; 186  : 	}
; 187  : }

	add	rsp, 152				; 00000098H
	ret	0
AuVmmngrGetPage ENDP
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\mm\vmmngr.cpp
_TEXT	SEGMENT
?AuVmmngrInitialize@@YAXXZ PROC				; AuVmmngrInitialize

; 492  : void AuVmmngrInitialize() {

$LN3:
	sub	rsp, 40					; 00000028H

; 493  : #ifdef ARCH_X64
; 494  : 	Au_x86_64_Paging_Init();

	call	?Au_x86_64_Paging_Init@@YAXXZ		; Au_x86_64_Paging_Init

; 495  : #endif
; 496  : }

	add	rsp, 40					; 00000028H
	ret	0
?AuVmmngrInitialize@@YAXXZ ENDP				; AuVmmngrInitialize
_TEXT	ENDS
END
