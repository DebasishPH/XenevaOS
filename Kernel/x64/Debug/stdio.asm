; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30154.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BB@JGGOGLEG@0123456789ABCDEF@		; `string'
PUBLIC	?integer_buffer@@3PADA				; integer_buffer
PUBLIC	?float_to_string_output@@3PADA			; float_to_string_output
_BSS	SEGMENT
?integer_buffer@@3PADA DB 020H DUP (?)			; integer_buffer
?float_to_string_output@@3PADA DB 020H DUP (?)		; float_to_string_output
_BSS	ENDS
msvcjmc	SEGMENT
__C697DCA6_stdio@cpp DB 01H
msvcjmc	ENDS
;	COMDAT ??_C@_0BB@JGGOGLEG@0123456789ABCDEF@
CONST	SEGMENT
??_C@_0BB@JGGOGLEG@0123456789ABCDEF@ DB '0123456789ABCDEF', 00H ; `string'
CONST	ENDS
PUBLIC	?atoi@@YAHPEBD@Z				; atoi
PUBLIC	?sztoa@@YAPEAD_KPEADH@Z				; sztoa
PUBLIC	printf
PUBLIC	?ftoa@@YAPEADME@Z				; ftoa
PUBLIC	?rand@@YAHXZ					; rand
PUBLIC	?srand@@YAXI@Z					; srand
PUBLIC	?atow@@YAXPEADPEBD@Z				; atow
PUBLIC	?int_to_str@@YAPEBDH@Z				; int_to_str
PUBLIC	__JustMyCode_Default
PUBLIC	__real@41200000
PUBLIC	__real@bf800000
EXTRN	AuTextOut:PROC
EXTRN	isspace:PROC
EXTRN	isdigit:PROC
EXTRN	__CheckForDebuggerJustMyCode:PROC
EXTRN	_fltused:DWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$?atoi@@YAHPEBD@Z DD imagerel $LN13
	DD	imagerel $LN13+195
	DD	imagerel $unwind$?atoi@@YAHPEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?sztoa@@YAPEAD_KPEADH@Z DD imagerel $LN11
	DD	imagerel $LN11+275
	DD	imagerel $unwind$?sztoa@@YAPEAD_KPEADH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$printf DD imagerel $LN3
	DD	imagerel $LN3+57
	DD	imagerel $unwind$printf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ftoa@@YAPEADME@Z DD imagerel $LN9
	DD	imagerel $LN9+299
	DD	imagerel $unwind$?ftoa@@YAPEADME@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?rand@@YAHXZ DD imagerel $LN3
	DD	imagerel $LN3+133
	DD	imagerel $unwind$?rand@@YAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?srand@@YAXI@Z DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$?srand@@YAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?atow@@YAXPEADPEBD@Z DD imagerel $LN5
	DD	imagerel $LN5+93
	DD	imagerel $unwind$?atow@@YAXPEADPEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?int_to_str@@YAPEBDH@Z DD imagerel $LN7
	DD	imagerel $LN7+287
	DD	imagerel $unwind$?int_to_str@@YAPEBDH@Z
pdata	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@41200000
CONST	SEGMENT
__real@41200000 DD 041200000r			; 10
CONST	ENDS
_DATA	SEGMENT
?chars@@3PEADEA DQ FLAT:??_C@_0BB@JGGOGLEG@0123456789ABCDEF@ ; chars
?r_x@@3IA DD	075bcd15H				; r_x
?r_y@@3IA DD	0159a55e5H				; r_y
?r_z@@3IA DD	01f123bb5H				; r_z
?r_w@@3IA DD	05491333H				; r_w
_DATA	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?int_to_str@@YAPEBDH@Z DD 025041101H
	DD	010c2311H
	DD	050050012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?atow@@YAXPEADPEBD@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?srand@@YAXI@Z DD 025030e01H
	DD	0b209230eH
	DD	05005H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?rand@@YAHXZ DD 025030b01H
	DD	0d206230bH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ftoa@@YAPEADME@Z DD 025031701H
	DD	0f2122317H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$printf DD 025031e01H
	DD	0b219231eH
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?sztoa@@YAPEAD_KPEADH@Z DD 025031c01H
	DD	0f217231cH
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?atoi@@YAHPEBD@Z DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\stdio.cpp
;	COMDAT ?int_to_str@@YAPEBDH@Z
_TEXT	SEGMENT
size$ = 0
size_tester$ = 8
index$ = 16
new_value$ = 24
remainder$1 = 32
remainder$ = 33
value$ = 128
?int_to_str@@YAPEBDH@Z PROC				; int_to_str, COMDAT

; 50   : const char* int_to_str(int value) {

$LN7:
	mov	DWORD PTR [rsp+8], ecx
	push	rbp
	sub	rsp, 144				; 00000090H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__C697DCA6_stdio@cpp
	call	__CheckForDebuggerJustMyCode

; 51   : 	uint8_t size = 0;

	mov	BYTE PTR size$[rbp], 0

; 52   : 	uint64_t size_tester = (uint64_t)value;

	movsxd	rax, DWORD PTR value$[rbp]
	mov	QWORD PTR size_tester$[rbp], rax
$LN2@int_to_str:

; 53   : 	while (size_tester / 10 > 0) {

	xor	edx, edx
	mov	rax, QWORD PTR size_tester$[rbp]
	mov	ecx, 10
	div	rcx
	test	rax, rax
	jbe	SHORT $LN3@int_to_str

; 54   : 		size_tester /= 10;

	xor	edx, edx
	mov	rax, QWORD PTR size_tester$[rbp]
	mov	ecx, 10
	div	rcx
	mov	QWORD PTR size_tester$[rbp], rax

; 55   : 		size++;

	movzx	eax, BYTE PTR size$[rbp]
	inc	al
	mov	BYTE PTR size$[rbp], al

; 56   : 	}

	jmp	SHORT $LN2@int_to_str
$LN3@int_to_str:

; 57   : 
; 58   : 	uint8_t index = 0;

	mov	BYTE PTR index$[rbp], 0

; 59   : 	uint64_t new_value = (uint64_t)value;

	movsxd	rax, DWORD PTR value$[rbp]
	mov	QWORD PTR new_value$[rbp], rax
$LN4@int_to_str:

; 60   : 	while (new_value / 10 > 0) {

	xor	edx, edx
	mov	rax, QWORD PTR new_value$[rbp]
	mov	ecx, 10
	div	rcx
	test	rax, rax
	jbe	SHORT $LN5@int_to_str

; 61   : 		uint8_t remainder = new_value % 10;

	xor	edx, edx
	mov	rax, QWORD PTR new_value$[rbp]
	mov	ecx, 10
	div	rcx
	mov	rax, rdx
	mov	BYTE PTR remainder$1[rbp], al

; 62   : 		new_value /= 10;

	xor	edx, edx
	mov	rax, QWORD PTR new_value$[rbp]
	mov	ecx, 10
	div	rcx
	mov	QWORD PTR new_value$[rbp], rax

; 63   : 		integer_buffer[size - index] = remainder + 48;

	movzx	eax, BYTE PTR remainder$1[rbp]
	add	eax, 48					; 00000030H
	movzx	ecx, BYTE PTR size$[rbp]
	movzx	edx, BYTE PTR index$[rbp]
	sub	ecx, edx
	movsxd	rcx, ecx
	lea	rdx, OFFSET FLAT:?integer_buffer@@3PADA	; integer_buffer
	mov	BYTE PTR [rdx+rcx], al

; 64   : 		index++;

	movzx	eax, BYTE PTR index$[rbp]
	inc	al
	mov	BYTE PTR index$[rbp], al

; 65   : 	}

	jmp	SHORT $LN4@int_to_str
$LN5@int_to_str:

; 66   : 
; 67   : 	uint8_t remainder = new_value % 10;

	xor	edx, edx
	mov	rax, QWORD PTR new_value$[rbp]
	mov	ecx, 10
	div	rcx
	mov	rax, rdx
	mov	BYTE PTR remainder$[rbp], al

; 68   : 	integer_buffer[size - index] = remainder + 48;

	movzx	eax, BYTE PTR remainder$[rbp]
	add	eax, 48					; 00000030H
	movzx	ecx, BYTE PTR size$[rbp]
	movzx	edx, BYTE PTR index$[rbp]
	sub	ecx, edx
	movsxd	rcx, ecx
	lea	rdx, OFFSET FLAT:?integer_buffer@@3PADA	; integer_buffer
	mov	BYTE PTR [rdx+rcx], al

; 69   : 	integer_buffer[size + 1] = 0;

	movzx	eax, BYTE PTR size$[rbp]
	inc	eax
	cdqe
	lea	rcx, OFFSET FLAT:?integer_buffer@@3PADA	; integer_buffer
	mov	BYTE PTR [rcx+rax], 0

; 70   : 	return integer_buffer;

	lea	rax, OFFSET FLAT:?integer_buffer@@3PADA	; integer_buffer

; 71   : }

	lea	rsp, QWORD PTR [rbp+112]
	pop	rbp
	ret	0
?int_to_str@@YAPEBDH@Z ENDP				; int_to_str
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\stdio.cpp
;	COMDAT ?atow@@YAXPEADPEBD@Z
_TEXT	SEGMENT
buf$ = 80
source$ = 88
?atow@@YAXPEADPEBD@Z PROC				; atow, COMDAT

; 44   : {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__C697DCA6_stdio@cpp
	call	__CheckForDebuggerJustMyCode
$LN2@atow:

; 45   : 	while (*source != 0)*buf++ = *source++;

	mov	rax, QWORD PTR source$[rbp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN3@atow
	mov	rax, QWORD PTR buf$[rbp]
	mov	rcx, QWORD PTR source$[rbp]
	movzx	ecx, BYTE PTR [rcx]
	mov	BYTE PTR [rax], cl
	mov	rax, QWORD PTR buf$[rbp]
	inc	rax
	mov	QWORD PTR buf$[rbp], rax
	mov	rax, QWORD PTR source$[rbp]
	inc	rax
	mov	QWORD PTR source$[rbp], rax
	jmp	SHORT $LN2@atow
$LN3@atow:

; 46   : 	*buf = '\0';

	mov	rax, QWORD PTR buf$[rbp]
	mov	BYTE PTR [rax], 0

; 47   : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
?atow@@YAXPEADPEBD@Z ENDP				; atow
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\stdio.cpp
;	COMDAT ?srand@@YAXI@Z
_TEXT	SEGMENT
seed$ = 80
?srand@@YAXI@Z PROC					; srand, COMDAT

; 142  : void srand(unsigned int seed) {

$LN3:
	mov	DWORD PTR [rsp+8], ecx
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__C697DCA6_stdio@cpp
	call	__CheckForDebuggerJustMyCode

; 143  : 	r_w ^= seed;

	mov	eax, DWORD PTR seed$[rbp]
	mov	ecx, DWORD PTR ?r_w@@3IA
	xor	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR ?r_w@@3IA, eax

; 144  : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
?srand@@YAXI@Z ENDP					; srand
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\stdio.cpp
;	COMDAT ?rand@@YAHXZ
_TEXT	SEGMENT
t$ = 0
?rand@@YAHXZ PROC					; rand, COMDAT

; 132  : int rand() {

$LN3:
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__C697DCA6_stdio@cpp
	call	__CheckForDebuggerJustMyCode

; 133  : 	uint32_t t;
; 134  : 
; 135  : 	t = r_x ^ (r_x << 11);

	mov	eax, DWORD PTR ?r_x@@3IA
	shl	eax, 11
	mov	ecx, DWORD PTR ?r_x@@3IA
	xor	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR t$[rbp], eax

; 136  : 	r_x = r_y; r_y = r_z; r_z = r_w;

	mov	eax, DWORD PTR ?r_y@@3IA
	mov	DWORD PTR ?r_x@@3IA, eax
	mov	eax, DWORD PTR ?r_z@@3IA
	mov	DWORD PTR ?r_y@@3IA, eax
	mov	eax, DWORD PTR ?r_w@@3IA
	mov	DWORD PTR ?r_z@@3IA, eax

; 137  : 	r_w = r_w ^ (r_w >> 19) ^ t ^ (t >> 8);

	mov	eax, DWORD PTR ?r_w@@3IA
	shr	eax, 19
	mov	ecx, DWORD PTR ?r_w@@3IA
	xor	ecx, eax
	mov	eax, ecx
	xor	eax, DWORD PTR t$[rbp]
	mov	ecx, DWORD PTR t$[rbp]
	shr	ecx, 8
	xor	eax, ecx
	mov	DWORD PTR ?r_w@@3IA, eax

; 138  : 
; 139  : 	return (r_w & RAND_MAX);

	mov	eax, DWORD PTR ?r_w@@3IA
	btr	eax, 31

; 140  : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
?rand@@YAHXZ ENDP					; rand
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\stdio.cpp
;	COMDAT ?ftoa@@YAPEADME@Z
_TEXT	SEGMENT
int_ptr$ = 0
float_ptr$ = 8
new_value$ = 16
i$1 = 20
value$ = 112
decimal_places$ = 120
?ftoa@@YAPEADME@Z PROC					; ftoa, COMDAT

; 74   : char* ftoa(float value, uint8_t decimal_places) {

$LN9:
	mov	BYTE PTR [rsp+16], dl
	movss	DWORD PTR [rsp+8], xmm0
	push	rbp
	sub	rsp, 128				; 00000080H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__C697DCA6_stdio@cpp
	call	__CheckForDebuggerJustMyCode

; 75   : 	char* int_ptr = (char*)int_to_str((int)value);

	cvttss2si eax, DWORD PTR value$[rbp]
	mov	ecx, eax
	call	?int_to_str@@YAPEBDH@Z			; int_to_str
	mov	QWORD PTR int_ptr$[rbp], rax

; 76   : 	char* float_ptr = float_to_string_output;

	lea	rax, OFFSET FLAT:?float_to_string_output@@3PADA ; float_to_string_output
	mov	QWORD PTR float_ptr$[rbp], rax

; 77   : 
; 78   : 	if (value < 0) {

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR value$[rbp]
	jbe	SHORT $LN7@ftoa

; 79   : 		value *= -1;

	movss	xmm0, DWORD PTR value$[rbp]
	mulss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR value$[rbp], xmm0
$LN7@ftoa:
$LN2@ftoa:

; 80   : 	}
; 81   : 
; 82   : 
; 83   : 	while (*int_ptr != 0) {

	mov	rax, QWORD PTR int_ptr$[rbp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN3@ftoa

; 84   : 		*float_ptr = *int_ptr;

	mov	rax, QWORD PTR float_ptr$[rbp]
	mov	rcx, QWORD PTR int_ptr$[rbp]
	movzx	ecx, BYTE PTR [rcx]
	mov	BYTE PTR [rax], cl

; 85   : 		int_ptr++;

	mov	rax, QWORD PTR int_ptr$[rbp]
	inc	rax
	mov	QWORD PTR int_ptr$[rbp], rax

; 86   : 		float_ptr++;

	mov	rax, QWORD PTR float_ptr$[rbp]
	inc	rax
	mov	QWORD PTR float_ptr$[rbp], rax

; 87   : 	}

	jmp	SHORT $LN2@ftoa
$LN3@ftoa:

; 88   : 
; 89   : 	*float_ptr = '.';

	mov	rax, QWORD PTR float_ptr$[rbp]
	mov	BYTE PTR [rax], 46			; 0000002eH

; 90   : 	float_ptr++;

	mov	rax, QWORD PTR float_ptr$[rbp]
	inc	rax
	mov	QWORD PTR float_ptr$[rbp], rax

; 91   : 
; 92   : 	float new_value = value - (int)value;

	cvttss2si eax, DWORD PTR value$[rbp]
	cvtsi2ss xmm0, eax
	movss	xmm1, DWORD PTR value$[rbp]
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR new_value$[rbp], xmm0

; 93   : 
; 94   : 	for (uint8_t i = 0; i < decimal_places; i++) {

	mov	BYTE PTR i$1[rbp], 0
	jmp	SHORT $LN6@ftoa
$LN4@ftoa:
	movzx	eax, BYTE PTR i$1[rbp]
	inc	al
	mov	BYTE PTR i$1[rbp], al
$LN6@ftoa:
	movzx	eax, BYTE PTR i$1[rbp]
	movzx	ecx, BYTE PTR decimal_places$[rbp]
	cmp	eax, ecx
	jge	SHORT $LN5@ftoa

; 95   : 		new_value *= 10;

	movss	xmm0, DWORD PTR new_value$[rbp]
	mulss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR new_value$[rbp], xmm0

; 96   : 		*float_ptr = (int)new_value + 48;

	cvttss2si eax, DWORD PTR new_value$[rbp]
	add	eax, 48					; 00000030H
	mov	rcx, QWORD PTR float_ptr$[rbp]
	mov	BYTE PTR [rcx], al

; 97   : 		new_value -= (int)new_value;

	cvttss2si eax, DWORD PTR new_value$[rbp]
	cvtsi2ss xmm0, eax
	movss	xmm1, DWORD PTR new_value$[rbp]
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	movss	DWORD PTR new_value$[rbp], xmm0

; 98   : 		float_ptr++;

	mov	rax, QWORD PTR float_ptr$[rbp]
	inc	rax
	mov	QWORD PTR float_ptr$[rbp], rax

; 99   : 	}

	jmp	SHORT $LN4@ftoa
$LN5@ftoa:

; 100  : 
; 101  : 	*float_ptr = 0;

	mov	rax, QWORD PTR float_ptr$[rbp]
	mov	BYTE PTR [rax], 0

; 102  : 
; 103  : 	return float_to_string_output;

	lea	rax, OFFSET FLAT:?float_to_string_output@@3PADA ; float_to_string_output

; 104  : }

	lea	rsp, QWORD PTR [rbp+96]
	pop	rbp
	ret	0
?ftoa@@YAPEADME@Z ENDP					; ftoa
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\stdio.cpp
;	COMDAT printf
_TEXT	SEGMENT
format$ = 80
printf	PROC						; COMDAT

; 121  : void printf(const char* format, ...){

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__C697DCA6_stdio@cpp
	call	__CheckForDebuggerJustMyCode

; 122  : 	AuTextOut(format);

	mov	rcx, QWORD PTR format$[rbp]
	call	AuTextOut

; 123  : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
printf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\stdio.cpp
;	COMDAT ?sztoa@@YAPEAD_KPEADH@Z
_TEXT	SEGMENT
i$ = 0
z$1 = 4
tmp$2 = 8
tv74 = 80
tv67 = 80
value$ = 112
str$ = 120
base$ = 128
?sztoa@@YAPEAD_KPEADH@Z PROC				; sztoa, COMDAT

; 24   : {

$LN11:
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 128				; 00000080H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__C697DCA6_stdio@cpp
	call	__CheckForDebuggerJustMyCode

; 25   : 	if (base < 2 || base > 16)

	cmp	DWORD PTR base$[rbp], 2
	jl	SHORT $LN9@sztoa
	cmp	DWORD PTR base$[rbp], 16
	jle	SHORT $LN8@sztoa
$LN9@sztoa:

; 26   : 		return nullptr;

	xor	eax, eax
	jmp	$LN1@sztoa
$LN8@sztoa:

; 27   : 	unsigned int i = 0;

	mov	DWORD PTR i$[rbp], 0
$LN4@sztoa:

; 28   : 	do
; 29   : 	{
; 30   : 		str[++i] = chars[value%base];

	mov	eax, DWORD PTR i$[rbp]
	inc	eax
	mov	DWORD PTR i$[rbp], eax
	mov	eax, DWORD PTR i$[rbp]
	mov	QWORD PTR tv67[rbp], rax
	movsxd	rcx, DWORD PTR base$[rbp]
	xor	edx, edx
	mov	rax, QWORD PTR value$[rbp]
	div	rcx
	mov	rax, rdx
	mov	rcx, QWORD PTR str$[rbp]
	mov	rdx, QWORD PTR ?chars@@3PEADEA
	movzx	eax, BYTE PTR [rdx+rax]
	mov	rdx, QWORD PTR tv67[rbp]
	mov	BYTE PTR [rcx+rdx], al

; 31   : 		value /= base;

	movsxd	rax, DWORD PTR base$[rbp]
	mov	QWORD PTR tv74[rbp], rax
	xor	edx, edx
	mov	rax, QWORD PTR value$[rbp]
	mov	rcx, QWORD PTR tv74[rbp]
	div	rcx
	mov	QWORD PTR value$[rbp], rax

; 32   : 	} while (value != 0);

	cmp	QWORD PTR value$[rbp], 0
	jne	SHORT $LN4@sztoa

; 33   : 	str[0] = '\0';

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR str$[rbp]
	mov	BYTE PTR [rcx+rax], 0

; 34   : 	for (unsigned int z = 0; z < i; ++z, --i)

	mov	DWORD PTR z$1[rbp], 0
	jmp	SHORT $LN7@sztoa
$LN5@sztoa:
	mov	eax, DWORD PTR z$1[rbp]
	inc	eax
	mov	DWORD PTR z$1[rbp], eax
	mov	eax, DWORD PTR i$[rbp]
	dec	eax
	mov	DWORD PTR i$[rbp], eax
$LN7@sztoa:
	mov	eax, DWORD PTR i$[rbp]
	cmp	DWORD PTR z$1[rbp], eax
	jae	SHORT $LN6@sztoa

; 35   : 	{
; 36   : 		char tmp = str[z];

	mov	eax, DWORD PTR z$1[rbp]
	mov	rcx, QWORD PTR str$[rbp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	BYTE PTR tmp$2[rbp], al

; 37   : 		str[z] = str[i];

	mov	eax, DWORD PTR i$[rbp]
	mov	ecx, DWORD PTR z$1[rbp]
	mov	rdx, QWORD PTR str$[rbp]
	mov	r8, QWORD PTR str$[rbp]
	movzx	eax, BYTE PTR [r8+rax]
	mov	BYTE PTR [rdx+rcx], al

; 38   : 		str[i] = tmp;

	mov	eax, DWORD PTR i$[rbp]
	mov	rcx, QWORD PTR str$[rbp]
	movzx	edx, BYTE PTR tmp$2[rbp]
	mov	BYTE PTR [rcx+rax], dl

; 39   : 	}

	jmp	SHORT $LN5@sztoa
$LN6@sztoa:

; 40   : 	return str;

	mov	rax, QWORD PTR str$[rbp]
$LN1@sztoa:

; 41   : }

	lea	rsp, QWORD PTR [rbp+96]
	pop	rbp
	ret	0
?sztoa@@YAPEAD_KPEADH@Z ENDP				; sztoa
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\stdio.cpp
;	COMDAT ?atoi@@YAHPEBD@Z
_TEXT	SEGMENT
n$ = 0
neg$ = 4
tv87 = 72
tv70 = 72
s$ = 96
?atoi@@YAHPEBD@Z PROC					; atoi, COMDAT

; 107  : int atoi(const char* s) {

$LN13:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__C697DCA6_stdio@cpp
	call	__CheckForDebuggerJustMyCode

; 108  : 
; 109  : 	int n = 0, neg = 0;

	mov	DWORD PTR n$[rbp], 0
	mov	DWORD PTR neg$[rbp], 0
$LN2@atoi:

; 110  : 	while (isspace(*s)) s++;

	mov	rax, QWORD PTR s$[rbp]
	movsx	eax, BYTE PTR [rax]
	mov	ecx, eax
	call	isspace
	test	eax, eax
	je	SHORT $LN3@atoi
	mov	rax, QWORD PTR s$[rbp]
	inc	rax
	mov	QWORD PTR s$[rbp], rax
	jmp	SHORT $LN2@atoi
$LN3@atoi:

; 111  : 	switch (*s) {

	mov	rax, QWORD PTR s$[rbp]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR tv70[rbp], al
	cmp	BYTE PTR tv70[rbp], 43			; 0000002bH
	je	SHORT $LN9@atoi
	cmp	BYTE PTR tv70[rbp], 45			; 0000002dH
	je	SHORT $LN8@atoi
	jmp	SHORT $LN4@atoi
$LN8@atoi:

; 112  : 	case '-': neg = 1;

	mov	DWORD PTR neg$[rbp], 1
$LN9@atoi:

; 113  : 	case '+': s++;

	mov	rax, QWORD PTR s$[rbp]
	inc	rax
	mov	QWORD PTR s$[rbp], rax
$LN4@atoi:
$LN6@atoi:

; 114  : 	}
; 115  : 
; 116  : 	while (isdigit(*s))

	mov	rax, QWORD PTR s$[rbp]
	movsx	eax, BYTE PTR [rax]
	mov	ecx, eax
	call	isdigit
	test	eax, eax
	je	SHORT $LN7@atoi

; 117  : 		n = 10 * n - (*s++ - '0');

	imul	eax, DWORD PTR n$[rbp], 10
	mov	rcx, QWORD PTR s$[rbp]
	movsx	ecx, BYTE PTR [rcx]
	sub	ecx, 48					; 00000030H
	sub	eax, ecx
	mov	DWORD PTR n$[rbp], eax
	mov	rax, QWORD PTR s$[rbp]
	inc	rax
	mov	QWORD PTR s$[rbp], rax
	jmp	SHORT $LN6@atoi
$LN7@atoi:

; 118  : 	return neg ? n : -n;

	cmp	DWORD PTR neg$[rbp], 0
	je	SHORT $LN11@atoi
	mov	eax, DWORD PTR n$[rbp]
	mov	DWORD PTR tv87[rbp], eax
	jmp	SHORT $LN12@atoi
$LN11@atoi:
	mov	eax, DWORD PTR n$[rbp]
	neg	eax
	mov	DWORD PTR tv87[rbp], eax
$LN12@atoi:
	mov	eax, DWORD PTR tv87[rbp]

; 119  : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
?atoi@@YAHPEBD@Z ENDP					; atoi
_TEXT	ENDS
END
