; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30154.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?__rtc@@3PEAU__rtc__@@EA			; __rtc
_BSS	SEGMENT
?__rtc@@3PEAU__rtc__@@EA DQ 01H DUP (?)			; __rtc
_BSS	ENDS
msvcjmc	SEGMENT
__4F57593D_rtc@cpp DB 01H
msvcjmc	ENDS
PUBLIC	?AuRTCInitialize@@YAXXZ				; AuRTCInitialize
PUBLIC	AuRTCGetYear
PUBLIC	AuRTCGetCentury
PUBLIC	AuRTCGetMinutes
PUBLIC	AuRTCGetSecond
PUBLIC	AuRTCGetDay
PUBLIC	AuRTCGetHour
PUBLIC	AuRTCGetMonth
PUBLIC	?AuRTCGetRegister@@YAEH@Z			; AuRTCGetRegister
PUBLIC	?AuRTCSetRegister@@YAXGE@Z			; AuRTCSetRegister
PUBLIC	?AuRTCIsUpdating@@YAHXZ				; AuRTCIsUpdating
PUBLIC	?AuRTCReadDateTime@@YAXXZ			; AuRTCReadDateTime
PUBLIC	?AuRTCClockUpdate@@YAX_KPEAX@Z			; AuRTCClockUpdate
PUBLIC	__JustMyCode_Default
EXTRN	x64_inportb:PROC
EXTRN	x64_outportb:PROC
EXTRN	AuHalRegisterIRQ:PROC
EXTRN	AuInterruptEnd:PROC
EXTRN	AuDisableInterrupt:PROC
EXTRN	AuEnableInterrupt:PROC
EXTRN	kmalloc:PROC
EXTRN	memset:PROC
EXTRN	?AuTimerFire@@YAXHHH@Z:PROC			; AuTimerFire
EXTRN	__CheckForDebuggerJustMyCode:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuRTCInitialize@@YAXXZ DD imagerel $LN5
	DD	imagerel $LN5+221
	DD	imagerel $unwind$?AuRTCInitialize@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AuRTCGetYear DD imagerel $LN3
	DD	imagerel $LN3+40
	DD	imagerel $unwind$AuRTCGetYear
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AuRTCGetCentury DD imagerel $LN3
	DD	imagerel $LN3+40
	DD	imagerel $unwind$AuRTCGetCentury
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AuRTCGetMinutes DD imagerel $LN3
	DD	imagerel $LN3+40
	DD	imagerel $unwind$AuRTCGetMinutes
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AuRTCGetSecond DD imagerel $LN3
	DD	imagerel $LN3+40
	DD	imagerel $unwind$AuRTCGetSecond
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AuRTCGetDay DD imagerel $LN3
	DD	imagerel $LN3+40
	DD	imagerel $unwind$AuRTCGetDay
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AuRTCGetHour DD imagerel $LN3
	DD	imagerel $LN3+40
	DD	imagerel $unwind$AuRTCGetHour
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AuRTCGetMonth DD imagerel $LN3
	DD	imagerel $LN3+40
	DD	imagerel $unwind$AuRTCGetMonth
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuRTCGetRegister@@YAEH@Z DD imagerel $LN3
	DD	imagerel $LN3+54
	DD	imagerel $unwind$?AuRTCGetRegister@@YAEH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuRTCSetRegister@@YAXGE@Z DD imagerel $LN3
	DD	imagerel $LN3+63
	DD	imagerel $unwind$?AuRTCSetRegister@@YAXGE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuRTCIsUpdating@@YAHXZ DD imagerel $LN3
	DD	imagerel $LN3+63
	DD	imagerel $unwind$?AuRTCIsUpdating@@YAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuRTCReadDateTime@@YAXXZ DD imagerel $LN6
	DD	imagerel $LN6+561
	DD	imagerel $unwind$?AuRTCReadDateTime@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuRTCClockUpdate@@YAX_KPEAX@Z DD imagerel $LN6
	DD	imagerel $LN6+156
	DD	imagerel $unwind$?AuRTCClockUpdate@@YAX_KPEAX@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuRTCClockUpdate@@YAX_KPEAX@Z DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuRTCReadDateTime@@YAXXZ DD 025030b01H
	DD	0d206230bH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuRTCIsUpdating@@YAHXZ DD 025030b01H
	DD	0d206230bH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuRTCSetRegister@@YAXGE@Z DD 025031301H
	DD	0b20e2313H
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuRTCGetRegister@@YAEH@Z DD 025030e01H
	DD	0b209230eH
	DD	05005H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AuRTCGetMonth DD 025030b01H
	DD	0b206230bH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AuRTCGetHour DD 025030b01H
	DD	0b206230bH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AuRTCGetDay DD 025030b01H
	DD	0b206230bH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AuRTCGetSecond DD 025030b01H
	DD	0b206230bH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AuRTCGetMinutes DD 025030b01H
	DD	0b206230bH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AuRTCGetCentury DD 025030b01H
	DD	0b206230bH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AuRTCGetYear DD 025030b01H
	DD	0b206230bH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuRTCInitialize@@YAXXZ DD 025030b01H
	DD	0d206230bH
	DD	05002H
xdata	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Drivers\rtc.cpp
;	COMDAT ?AuRTCClockUpdate@@YAX_KPEAX@Z
_TEXT	SEGMENT
ready$ = 0
tv69 = 65
tv79 = 68
v$ = 96
p$ = 104
?AuRTCClockUpdate@@YAX_KPEAX@Z PROC			; AuRTCClockUpdate, COMDAT

; 85   : void AuRTCClockUpdate(size_t v, void* p) {

$LN6:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__4F57593D_rtc@cpp
	call	__CheckForDebuggerJustMyCode

; 86   : 	AuDisableInterrupt();

	call	AuDisableInterrupt

; 87   : 
; 88   : 	bool ready = AuRTCGetRegister(0x0C) & 0x10;

	mov	ecx, 12
	call	?AuRTCGetRegister@@YAEH@Z		; AuRTCGetRegister
	movzx	eax, al
	and	eax, 16
	test	eax, eax
	je	SHORT $LN4@AuRTCClock
	mov	BYTE PTR tv69[rbp], 1
	jmp	SHORT $LN5@AuRTCClock
$LN4@AuRTCClock:
	mov	BYTE PTR tv69[rbp], 0
$LN5@AuRTCClock:
	movzx	eax, BYTE PTR tv69[rbp]
	mov	BYTE PTR ready$[rbp], al

; 89   : 	if (ready)

	movzx	eax, BYTE PTR ready$[rbp]
	test	eax, eax
	je	SHORT $LN2@AuRTCClock

; 90   : 		AuRTCReadDateTime();

	call	?AuRTCReadDateTime@@YAXXZ		; AuRTCReadDateTime
$LN2@AuRTCClock:

; 91   : 
; 92   : 	AuTimerFire(__rtc->second, __rtc->minute, __rtc->hour);

	mov	rax, QWORD PTR ?__rtc@@3PEAU__rtc__@@EA	; __rtc
	movzx	eax, BYTE PTR [rax+5]
	mov	rcx, QWORD PTR ?__rtc@@3PEAU__rtc__@@EA	; __rtc
	movzx	ecx, BYTE PTR [rcx+6]
	mov	rdx, QWORD PTR ?__rtc@@3PEAU__rtc__@@EA	; __rtc
	movzx	edx, BYTE PTR [rdx+7]
	mov	DWORD PTR tv79[rbp], edx
	mov	r8d, eax
	mov	edx, ecx
	mov	eax, DWORD PTR tv79[rbp]
	mov	ecx, eax
	call	?AuTimerFire@@YAXHHH@Z			; AuTimerFire

; 93   : 	
; 94   : 	AuEnableInterrupt();

	call	AuEnableInterrupt

; 95   : 	AuInterruptEnd(8);

	mov	cl, 8
	call	AuInterruptEnd

; 96   : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
?AuRTCClockUpdate@@YAX_KPEAX@Z ENDP			; AuRTCClockUpdate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Drivers\rtc.cpp
;	COMDAT ?AuRTCReadDateTime@@YAXXZ
_TEXT	SEGMENT
registerB$ = 0
tv179 = 68
tv169 = 68
tv159 = 68
tv144 = 68
tv134 = 68
tv92 = 68
?AuRTCReadDateTime@@YAXXZ PROC				; AuRTCReadDateTime, COMDAT

; 61   : void AuRTCReadDateTime() {

$LN6:
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__4F57593D_rtc@cpp
	call	__CheckForDebuggerJustMyCode
$LN2@AuRTCReadD:

; 62   : 	// Wait until rtc is not updating
; 63   : 	while (AuRTCIsUpdating());

	call	?AuRTCIsUpdating@@YAHXZ			; AuRTCIsUpdating
	test	eax, eax
	je	SHORT $LN3@AuRTCReadD
	jmp	SHORT $LN2@AuRTCReadD
$LN3@AuRTCReadD:

; 64   : 
; 65   : 	__rtc->second = AuRTCGetRegister(0x00);

	xor	ecx, ecx
	call	?AuRTCGetRegister@@YAEH@Z		; AuRTCGetRegister
	mov	rcx, QWORD PTR ?__rtc@@3PEAU__rtc__@@EA	; __rtc
	mov	BYTE PTR [rcx+7], al

; 66   : 	__rtc->minute = AuRTCGetRegister(0x02);

	mov	ecx, 2
	call	?AuRTCGetRegister@@YAEH@Z		; AuRTCGetRegister
	mov	rcx, QWORD PTR ?__rtc@@3PEAU__rtc__@@EA	; __rtc
	mov	BYTE PTR [rcx+6], al

; 67   : 	__rtc->hour = AuRTCGetRegister(0x04);

	mov	ecx, 4
	call	?AuRTCGetRegister@@YAEH@Z		; AuRTCGetRegister
	mov	rcx, QWORD PTR ?__rtc@@3PEAU__rtc__@@EA	; __rtc
	mov	BYTE PTR [rcx+5], al

; 68   : 	__rtc->day = AuRTCGetRegister(0x07);

	mov	ecx, 7
	call	?AuRTCGetRegister@@YAEH@Z		; AuRTCGetRegister
	mov	rcx, QWORD PTR ?__rtc@@3PEAU__rtc__@@EA	; __rtc
	mov	BYTE PTR [rcx+4], al

; 69   : 	__rtc->month = AuRTCGetRegister(0x08);

	mov	ecx, 8
	call	?AuRTCGetRegister@@YAEH@Z		; AuRTCGetRegister
	mov	rcx, QWORD PTR ?__rtc@@3PEAU__rtc__@@EA	; __rtc
	mov	BYTE PTR [rcx+3], al

; 70   : 	__rtc->year = AuRTCGetRegister(0x09);

	mov	ecx, 9
	call	?AuRTCGetRegister@@YAEH@Z		; AuRTCGetRegister
	mov	rcx, QWORD PTR ?__rtc@@3PEAU__rtc__@@EA	; __rtc
	mov	BYTE PTR [rcx+2], al

; 71   : 
; 72   : 	uint8_t registerB = AuRTCGetRegister(0x0B);

	mov	ecx, 11
	call	?AuRTCGetRegister@@YAEH@Z		; AuRTCGetRegister
	mov	BYTE PTR registerB$[rbp], al

; 73   : 
; 74   : 	// Convert BCD to binary values if necessary
; 75   : 	if (!(registerB & 0x04)) {

	movzx	eax, BYTE PTR registerB$[rbp]
	and	eax, 4
	test	eax, eax
	jne	$LN4@AuRTCReadD

; 76   : 		__rtc->second = (__rtc->second & 0x0F) + ((__rtc->second / 16) * 10);

	mov	rax, QWORD PTR ?__rtc@@3PEAU__rtc__@@EA	; __rtc
	movzx	eax, BYTE PTR [rax+7]
	and	eax, 15
	mov	DWORD PTR tv92[rbp], eax
	mov	rcx, QWORD PTR ?__rtc@@3PEAU__rtc__@@EA	; __rtc
	movzx	ecx, BYTE PTR [rcx+7]
	mov	eax, ecx
	cdq
	and	edx, 15
	add	eax, edx
	sar	eax, 4
	imul	eax, eax, 10
	mov	ecx, DWORD PTR tv92[rbp]
	add	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR ?__rtc@@3PEAU__rtc__@@EA	; __rtc
	mov	BYTE PTR [rcx+7], al

; 77   : 		__rtc->minute = (__rtc->minute & 0x0F) + ((__rtc->minute / 16) * 10);

	mov	rax, QWORD PTR ?__rtc@@3PEAU__rtc__@@EA	; __rtc
	movzx	eax, BYTE PTR [rax+6]
	and	eax, 15
	mov	DWORD PTR tv134[rbp], eax
	mov	rcx, QWORD PTR ?__rtc@@3PEAU__rtc__@@EA	; __rtc
	movzx	ecx, BYTE PTR [rcx+6]
	mov	eax, ecx
	cdq
	and	edx, 15
	add	eax, edx
	sar	eax, 4
	imul	eax, eax, 10
	mov	ecx, DWORD PTR tv134[rbp]
	add	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR ?__rtc@@3PEAU__rtc__@@EA	; __rtc
	mov	BYTE PTR [rcx+6], al

; 78   : 		__rtc->hour = ((__rtc->hour & 0x0F) + (((__rtc->hour & 0x70) / 16) * 10)) | (__rtc->hour & 0x80);

	mov	rax, QWORD PTR ?__rtc@@3PEAU__rtc__@@EA	; __rtc
	movzx	eax, BYTE PTR [rax+5]
	and	eax, 15
	mov	DWORD PTR tv144[rbp], eax
	mov	rcx, QWORD PTR ?__rtc@@3PEAU__rtc__@@EA	; __rtc
	movzx	ecx, BYTE PTR [rcx+5]
	and	ecx, 112				; 00000070H
	mov	eax, ecx
	cdq
	and	edx, 15
	add	eax, edx
	sar	eax, 4
	imul	eax, eax, 10
	mov	ecx, DWORD PTR tv144[rbp]
	add	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR ?__rtc@@3PEAU__rtc__@@EA	; __rtc
	movzx	ecx, BYTE PTR [rcx+5]
	and	ecx, 128				; 00000080H
	or	eax, ecx
	mov	rcx, QWORD PTR ?__rtc@@3PEAU__rtc__@@EA	; __rtc
	mov	BYTE PTR [rcx+5], al

; 79   : 		__rtc->day = (__rtc->day & 0x0F) + ((__rtc->day / 16) * 10);

	mov	rax, QWORD PTR ?__rtc@@3PEAU__rtc__@@EA	; __rtc
	movzx	eax, BYTE PTR [rax+4]
	and	eax, 15
	mov	DWORD PTR tv159[rbp], eax
	mov	rcx, QWORD PTR ?__rtc@@3PEAU__rtc__@@EA	; __rtc
	movzx	ecx, BYTE PTR [rcx+4]
	mov	eax, ecx
	cdq
	and	edx, 15
	add	eax, edx
	sar	eax, 4
	imul	eax, eax, 10
	mov	ecx, DWORD PTR tv159[rbp]
	add	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR ?__rtc@@3PEAU__rtc__@@EA	; __rtc
	mov	BYTE PTR [rcx+4], al

; 80   : 		__rtc->month = (__rtc->month & 0x0F) + ((__rtc->month / 16) * 10);

	mov	rax, QWORD PTR ?__rtc@@3PEAU__rtc__@@EA	; __rtc
	movzx	eax, BYTE PTR [rax+3]
	and	eax, 15
	mov	DWORD PTR tv169[rbp], eax
	mov	rcx, QWORD PTR ?__rtc@@3PEAU__rtc__@@EA	; __rtc
	movzx	ecx, BYTE PTR [rcx+3]
	mov	eax, ecx
	cdq
	and	edx, 15
	add	eax, edx
	sar	eax, 4
	imul	eax, eax, 10
	mov	ecx, DWORD PTR tv169[rbp]
	add	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR ?__rtc@@3PEAU__rtc__@@EA	; __rtc
	mov	BYTE PTR [rcx+3], al

; 81   : 		__rtc->year = (__rtc->year & 0x0F) + ((__rtc->year / 16) * 10);

	mov	rax, QWORD PTR ?__rtc@@3PEAU__rtc__@@EA	; __rtc
	movzx	eax, BYTE PTR [rax+2]
	and	eax, 15
	mov	DWORD PTR tv179[rbp], eax
	mov	rcx, QWORD PTR ?__rtc@@3PEAU__rtc__@@EA	; __rtc
	movzx	ecx, BYTE PTR [rcx+2]
	mov	eax, ecx
	cdq
	and	edx, 15
	add	eax, edx
	sar	eax, 4
	imul	eax, eax, 10
	mov	ecx, DWORD PTR tv179[rbp]
	add	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR ?__rtc@@3PEAU__rtc__@@EA	; __rtc
	mov	BYTE PTR [rcx+2], al
$LN4@AuRTCReadD:

; 82   : 	}
; 83   : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
?AuRTCReadDateTime@@YAXXZ ENDP				; AuRTCReadDateTime
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Drivers\rtc.cpp
;	COMDAT ?AuRTCIsUpdating@@YAHXZ
_TEXT	SEGMENT
status$ = 0
?AuRTCIsUpdating@@YAHXZ PROC				; AuRTCIsUpdating, COMDAT

; 52   : int AuRTCIsUpdating() {

$LN3:
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__4F57593D_rtc@cpp
	call	__CheckForDebuggerJustMyCode

; 53   : 	x64_outportb(CMOS_ADDR, 0x0A);

	mov	dl, 10
	mov	cx, 112					; 00000070H
	call	x64_outportb

; 54   : 	uint32_t status = x64_inportb(CMOS_DATA);

	mov	cx, 113					; 00000071H
	call	x64_inportb
	movzx	eax, al
	mov	DWORD PTR status$[rbp], eax

; 55   : 	return (status & 0x80);

	mov	eax, DWORD PTR status$[rbp]
	and	eax, 128				; 00000080H

; 56   : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
?AuRTCIsUpdating@@YAHXZ ENDP				; AuRTCIsUpdating
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Drivers\rtc.cpp
;	COMDAT ?AuRTCSetRegister@@YAXGE@Z
_TEXT	SEGMENT
reg_num$ = 80
val$ = 88
?AuRTCSetRegister@@YAXGE@Z PROC				; AuRTCSetRegister, COMDAT

; 47   : void AuRTCSetRegister(uint16_t reg_num, uint8_t val) {

$LN3:
	mov	BYTE PTR [rsp+16], dl
	mov	WORD PTR [rsp+8], cx
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__4F57593D_rtc@cpp
	call	__CheckForDebuggerJustMyCode

; 48   : 	x64_outportb(CMOS_ADDR, reg_num);

	movzx	edx, BYTE PTR reg_num$[rbp]
	mov	cx, 112					; 00000070H
	call	x64_outportb

; 49   : 	x64_outportb(CMOS_DATA, val);

	movzx	edx, BYTE PTR val$[rbp]
	mov	cx, 113					; 00000071H
	call	x64_outportb

; 50   : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
?AuRTCSetRegister@@YAXGE@Z ENDP				; AuRTCSetRegister
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Drivers\rtc.cpp
;	COMDAT ?AuRTCGetRegister@@YAEH@Z
_TEXT	SEGMENT
reg_num$ = 80
?AuRTCGetRegister@@YAEH@Z PROC				; AuRTCGetRegister, COMDAT

; 42   : uint8_t AuRTCGetRegister(int reg_num) {

$LN3:
	mov	DWORD PTR [rsp+8], ecx
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__4F57593D_rtc@cpp
	call	__CheckForDebuggerJustMyCode

; 43   : 	x64_outportb(CMOS_ADDR, reg_num);

	movzx	edx, BYTE PTR reg_num$[rbp]
	mov	cx, 112					; 00000070H
	call	x64_outportb

; 44   : 	return x64_inportb(CMOS_DATA);

	mov	cx, 113					; 00000071H
	call	x64_inportb

; 45   : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
?AuRTCGetRegister@@YAEH@Z ENDP				; AuRTCGetRegister
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Drivers\rtc.cpp
;	COMDAT AuRTCGetMonth
_TEXT	SEGMENT
AuRTCGetMonth PROC					; COMDAT

; 173  : uint8_t AuRTCGetMonth() {

$LN3:
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__4F57593D_rtc@cpp
	call	__CheckForDebuggerJustMyCode

; 174  : 	return __rtc->month;

	mov	rax, QWORD PTR ?__rtc@@3PEAU__rtc__@@EA	; __rtc
	movzx	eax, BYTE PTR [rax+3]

; 175  : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
AuRTCGetMonth ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Drivers\rtc.cpp
;	COMDAT AuRTCGetHour
_TEXT	SEGMENT
AuRTCGetHour PROC					; COMDAT

; 165  : uint8_t AuRTCGetHour() {

$LN3:
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__4F57593D_rtc@cpp
	call	__CheckForDebuggerJustMyCode

; 166  : 	return __rtc->hour;

	mov	rax, QWORD PTR ?__rtc@@3PEAU__rtc__@@EA	; __rtc
	movzx	eax, BYTE PTR [rax+5]

; 167  : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
AuRTCGetHour ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Drivers\rtc.cpp
;	COMDAT AuRTCGetDay
_TEXT	SEGMENT
AuRTCGetDay PROC					; COMDAT

; 157  : uint8_t AuRTCGetDay() {

$LN3:
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__4F57593D_rtc@cpp
	call	__CheckForDebuggerJustMyCode

; 158  : 	return __rtc->day;

	mov	rax, QWORD PTR ?__rtc@@3PEAU__rtc__@@EA	; __rtc
	movzx	eax, BYTE PTR [rax+4]

; 159  : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
AuRTCGetDay ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Drivers\rtc.cpp
;	COMDAT AuRTCGetSecond
_TEXT	SEGMENT
AuRTCGetSecond PROC					; COMDAT

; 149  : uint8_t AuRTCGetSecond() {

$LN3:
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__4F57593D_rtc@cpp
	call	__CheckForDebuggerJustMyCode

; 150  : 	return __rtc->second;

	mov	rax, QWORD PTR ?__rtc@@3PEAU__rtc__@@EA	; __rtc
	movzx	eax, BYTE PTR [rax+7]

; 151  : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
AuRTCGetSecond ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Drivers\rtc.cpp
;	COMDAT AuRTCGetMinutes
_TEXT	SEGMENT
AuRTCGetMinutes PROC					; COMDAT

; 141  : uint8_t AuRTCGetMinutes() {

$LN3:
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__4F57593D_rtc@cpp
	call	__CheckForDebuggerJustMyCode

; 142  : 	return __rtc->minute;

	mov	rax, QWORD PTR ?__rtc@@3PEAU__rtc__@@EA	; __rtc
	movzx	eax, BYTE PTR [rax+6]

; 143  : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
AuRTCGetMinutes ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Drivers\rtc.cpp
;	COMDAT AuRTCGetCentury
_TEXT	SEGMENT
AuRTCGetCentury PROC					; COMDAT

; 133  : uint8_t AuRTCGetCentury() {

$LN3:
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__4F57593D_rtc@cpp
	call	__CheckForDebuggerJustMyCode

; 134  : 	return __rtc->century;

	mov	rax, QWORD PTR ?__rtc@@3PEAU__rtc__@@EA	; __rtc
	movzx	eax, BYTE PTR [rax+1]

; 135  : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
AuRTCGetCentury ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Drivers\rtc.cpp
;	COMDAT AuRTCGetYear
_TEXT	SEGMENT
AuRTCGetYear PROC					; COMDAT

; 125  : uint8_t AuRTCGetYear() {

$LN3:
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__4F57593D_rtc@cpp
	call	__CheckForDebuggerJustMyCode

; 126  : 	return __rtc->year;

	mov	rax, QWORD PTR ?__rtc@@3PEAU__rtc__@@EA	; __rtc
	movzx	eax, BYTE PTR [rax+2]

; 127  : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
AuRTCGetYear ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Drivers\rtc.cpp
;	COMDAT ?AuRTCInitialize@@YAXXZ
_TEXT	SEGMENT
status$ = 0
tv87 = 68
?AuRTCInitialize@@YAXXZ PROC				; AuRTCInitialize, COMDAT

; 101  : void AuRTCInitialize() {

$LN5:
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__4F57593D_rtc@cpp
	call	__CheckForDebuggerJustMyCode

; 102  : 	__rtc = (AuRTC*)kmalloc(sizeof(AuRTC));

	mov	ecx, 8
	call	kmalloc
	mov	QWORD PTR ?__rtc@@3PEAU__rtc__@@EA, rax	; __rtc

; 103  : 	memset(__rtc, 0, sizeof(AuRTC));

	mov	r8d, 8
	xor	edx, edx
	mov	rcx, QWORD PTR ?__rtc@@3PEAU__rtc__@@EA	; __rtc
	call	memset

; 104  : 
; 105  : 	uint8_t status = AuRTCGetRegister(0x0b);

	mov	ecx, 11
	call	?AuRTCGetRegister@@YAEH@Z		; AuRTCGetRegister
	mov	BYTE PTR status$[rbp], al

; 106  : 	status |= 0x02;

	movzx	eax, BYTE PTR status$[rbp]
	or	eax, 2
	mov	BYTE PTR status$[rbp], al

; 107  : 	status |= 0x10;

	movzx	eax, BYTE PTR status$[rbp]
	or	eax, 16
	mov	BYTE PTR status$[rbp], al

; 108  : 	status &= ~0x20;

	movzx	eax, BYTE PTR status$[rbp]
	and	eax, -33				; ffffffffffffffdfH
	mov	BYTE PTR status$[rbp], al

; 109  : 	status &= ~0x40;

	movzx	eax, BYTE PTR status$[rbp]
	and	eax, -65				; ffffffffffffffbfH
	mov	BYTE PTR status$[rbp], al

; 110  : 	__rtc->bcd = !(status & 0x04);

	movzx	eax, BYTE PTR status$[rbp]
	and	eax, 4
	test	eax, eax
	jne	SHORT $LN3@AuRTCIniti
	mov	DWORD PTR tv87[rbp], 1
	jmp	SHORT $LN4@AuRTCIniti
$LN3@AuRTCIniti:
	mov	DWORD PTR tv87[rbp], 0
$LN4@AuRTCIniti:
	mov	rax, QWORD PTR ?__rtc@@3PEAU__rtc__@@EA	; __rtc
	movzx	ecx, BYTE PTR tv87[rbp]
	mov	BYTE PTR [rax], cl

; 111  : 
; 112  : 	x64_outportb(0x70, 0x0B);

	mov	dl, 11
	mov	cx, 112					; 00000070H
	call	x64_outportb

; 113  : 	x64_outportb(0x71, status);

	movzx	edx, BYTE PTR status$[rbp]
	mov	cx, 113					; 00000071H
	call	x64_outportb

; 114  : 
; 115  : 	AuRTCGetRegister(0x0C);

	mov	ecx, 12
	call	?AuRTCGetRegister@@YAEH@Z		; AuRTCGetRegister

; 116  : 	AuRTCReadDateTime();

	call	?AuRTCReadDateTime@@YAXXZ		; AuRTCReadDateTime

; 117  : 
; 118  : 	AuHalRegisterIRQ(8, AuRTCClockUpdate, 8, false);

	xor	r9d, r9d
	mov	r8b, 8
	lea	rdx, OFFSET FLAT:?AuRTCClockUpdate@@YAX_KPEAX@Z ; AuRTCClockUpdate
	mov	ecx, 8
	call	AuHalRegisterIRQ

; 119  : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
?AuRTCInitialize@@YAXXZ ENDP				; AuRTCInitialize
_TEXT	ENDS
END
