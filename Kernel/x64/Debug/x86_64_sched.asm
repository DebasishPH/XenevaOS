; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.21005.1 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?thread_list_head@@3PEAU_au_thread_@@EA		; thread_list_head
PUBLIC	?thread_list_last@@3PEAU_au_thread_@@EA		; thread_list_last
PUBLIC	?blocked_thr_head@@3PEAU_au_thread_@@EA		; blocked_thr_head
PUBLIC	?blocked_thr_last@@3PEAU_au_thread_@@EA		; blocked_thr_last
PUBLIC	?trash_thr_head@@3PEAU_au_thread_@@EA		; trash_thr_head
PUBLIC	?trash_thr_last@@3PEAU_au_thread_@@EA		; trash_thr_last
PUBLIC	?_x86_64_sched_enable@@3_NA			; _x86_64_sched_enable
PUBLIC	?_idle_thr@@3PEAU_au_thread_@@EA		; _idle_thr
PUBLIC	?_idle_lock@@3PEAU_spinlock_@@EA		; _idle_lock
PUBLIC	?_x86_64_sched_init@@3_NA			; _x86_64_sched_init
_BSS	SEGMENT
?thread_list_head@@3PEAU_au_thread_@@EA DQ 01H DUP (?)	; thread_list_head
?thread_list_last@@3PEAU_au_thread_@@EA DQ 01H DUP (?)	; thread_list_last
?blocked_thr_head@@3PEAU_au_thread_@@EA DQ 01H DUP (?)	; blocked_thr_head
?blocked_thr_last@@3PEAU_au_thread_@@EA DQ 01H DUP (?)	; blocked_thr_last
?trash_thr_head@@3PEAU_au_thread_@@EA DQ 01H DUP (?)	; trash_thr_head
?trash_thr_last@@3PEAU_au_thread_@@EA DQ 01H DUP (?)	; trash_thr_last
?_x86_64_sched_enable@@3_NA DB 01H DUP (?)		; _x86_64_sched_enable
	ALIGN	8

?_idle_thr@@3PEAU_au_thread_@@EA DQ 01H DUP (?)		; _idle_thr
?_idle_lock@@3PEAU_spinlock_@@EA DQ 01H DUP (?)		; _idle_lock
?_x86_64_sched_init@@3_NA DB 01H DUP (?)		; _x86_64_sched_init
_BSS	ENDS
CONST	SEGMENT
$SG3702	DB	'FRAME USER KERN ESP -> %x ', 0aH, 00H
	ORG $+4
$SG3711	DB	'_idle id -> %d  ', 0dH, 0aH, 00H
	ORG $+1
$SG3720	DB	'Idle', 00H
	ORG $+7
$SG3765	DB	'CR3 -> %x ', 0dH, 0aH, 00H
CONST	ENDS
PUBLIC	?AuSchedulerStart@@YAXXZ			; AuSchedulerStart
PUBLIC	?AuSchedulerInitialise@@YAXXZ			; AuSchedulerInitialise
PUBLIC	?AuSchedulerInitAp@@YAXXZ			; AuSchedulerInitAp
PUBLIC	AuCreateKthread
PUBLIC	?AuCreateUthread@@YAPEAU_au_thread_@@P6AXPEAX@Z_K2PEAD@Z ; AuCreateUthread
PUBLIC	AuGetCurrentThread
PUBLIC	?AuKThreadCopy@@YAXPEAU_au_thread_@@0@Z		; AuKThreadCopy
PUBLIC	AuBlockThread
PUBLIC	AuSleepThread
PUBLIC	AuUnblockThread
PUBLIC	?AuThreadMoveToTrash@@YAXPEAU_au_thread_@@@Z	; AuThreadMoveToTrash
PUBLIC	?AuThreadCleanTrash@@YAXPEAU_au_thread_@@@Z	; AuThreadCleanTrash
PUBLIC	AuThreadFindByID
PUBLIC	AuForceScheduler
PUBLIC	?AuIsSchedulerInitialised@@YA_NXZ		; AuIsSchedulerInitialised
PUBLIC	?AuMapKStack@@YA_KPEA_K@Z			; AuMapKStack
PUBLIC	?AuThreadInsert@@YAXPEAU_au_thread_@@@Z		; AuThreadInsert
PUBLIC	?AuThreadDelete@@YAXPEAU_au_thread_@@@Z		; AuThreadDelete
PUBLIC	?AuThreadInsertBlock@@YAXPEAU_au_thread_@@@Z	; AuThreadInsertBlock
PUBLIC	?AuThreadDeleteBlock@@YAXPEAU_au_thread_@@@Z	; AuThreadDeleteBlock
PUBLIC	?AuThreadInsertTrash@@YAXPEAU_au_thread_@@@Z	; AuThreadInsertTrash
PUBLIC	?AuThreadDeleteTrash@@YAXPEAU_au_thread_@@@Z	; AuThreadDeleteTrash
PUBLIC	?AuIdleThread@@YAX_K@Z				; AuIdleThread
PUBLIC	?AuNextThread@@YAXXZ				; AuNextThread
PUBLIC	?x8664SchedulerISR@@YAX_KPEAX@Z			; x8664SchedulerISR
PUBLIC	AuPrintStack
EXTRN	setvect:PROC
EXTRN	AuCreateSpinlock:PROC
EXTRN	?x86_64_get_tss@@YAPEAU_tss@@XZ:PROC		; x86_64_get_tss
EXTRN	?x86_64_is_cpu_fxsave_supported@@YA_NXZ:PROC	; x86_64_is_cpu_fxsave_supported
EXTRN	x64_cli:PROC
EXTRN	x64_read_cr3:PROC
EXTRN	x64_fxsave:PROC
EXTRN	x64_fxrstor:PROC
EXTRN	x64_ldmxcsr:PROC
EXTRN	x64_set_kstack:PROC
EXTRN	x64_get_kstack:PROC
EXTRN	x64_force_sched:PROC
EXTRN	AuInterruptEnd:PROC
EXTRN	?AuCheckSignal@@YA_NPEAU_au_thread_@@PEAUinterrupt_stack_frame@@@Z:PROC ; AuCheckSignal
EXTRN	?AuGetSignal@@YAPEAU_signal_@@PEAU_au_thread_@@@Z:PROC ; AuGetSignal
EXTRN	?AuPrepareSignal@@YAXPEAU_au_thread_@@PEAUinterrupt_stack_frame@@PEAU_signal_@@@Z:PROC ; AuPrepareSignal
EXTRN	strcpy:PROC
EXTRN	strncpy:PROC
EXTRN	memset:PROC
EXTRN	SeTextOut:PROC
EXTRN	kmalloc:PROC
EXTRN	AuMapPageEx:PROC
EXTRN	?AuPerCPUGetCpuID@@YAEXZ:PROC			; AuPerCPUGetCpuID
EXTRN	?AuPerCPUSetCurrentThread@@YAXPEAX@Z:PROC	; AuPerCPUSetCurrentThread
EXTRN	?AuPerCPUGetCurrentThread@@YAPEAU_au_thread_@@XZ:PROC ; AuPerCPUGetCurrentThread
EXTRN	?AuPerCPUGetKernelTSS@@YAPEAU_tss@@XZ:PROC	; AuPerCPUGetKernelTSS
EXTRN	AuPmmngrAlloc:PROC
EXTRN	P2V:PROC
EXTRN	V2P:PROC
EXTRN	AuTextOut:PROC
EXTRN	save_context:PROC
EXTRN	execute_idle:PROC
_BSS	SEGMENT
	ALIGN	4

thread_id DW	01H DUP (?)
_BSS	ENDS
pdata	SEGMENT
$pdata$?AuSchedulerStart@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+61
	DD	imagerel $unwind$?AuSchedulerStart@@YAXXZ
$pdata$?AuSchedulerInitialise@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+198
	DD	imagerel $unwind$?AuSchedulerInitialise@@YAXXZ
$pdata$?AuSchedulerInitAp@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+21
	DD	imagerel $unwind$?AuSchedulerInitAp@@YAXXZ
$pdata$AuCreateKthread DD imagerel $LN4
	DD	imagerel $LN4+839
	DD	imagerel $unwind$AuCreateKthread
$pdata$?AuCreateUthread@@YAPEAU_au_thread_@@P6AXPEAX@Z_K2PEAD@Z DD imagerel $LN3
	DD	imagerel $LN3+712
	DD	imagerel $unwind$?AuCreateUthread@@YAPEAU_au_thread_@@P6AXPEAX@Z_K2PEAD@Z
$pdata$AuGetCurrentThread DD imagerel $LN3
	DD	imagerel $LN3+14
	DD	imagerel $unwind$AuGetCurrentThread
$pdata$AuBlockThread DD imagerel $LN3
	DD	imagerel $LN3+46
	DD	imagerel $unwind$AuBlockThread
$pdata$AuUnblockThread DD imagerel $LN8
	DD	imagerel $LN8+120
	DD	imagerel $unwind$AuUnblockThread
$pdata$?AuThreadMoveToTrash@@YAXPEAU_au_thread_@@@Z DD imagerel $LN11
	DD	imagerel $LN11+162
	DD	imagerel $unwind$?AuThreadMoveToTrash@@YAXPEAU_au_thread_@@@Z
$pdata$?AuThreadCleanTrash@@YAXPEAU_au_thread_@@@Z DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$?AuThreadCleanTrash@@YAXPEAU_au_thread_@@@Z
$pdata$AuThreadFindByID DD imagerel $LN7
	DD	imagerel $LN7+77
	DD	imagerel $unwind$AuThreadFindByID
$pdata$AuForceScheduler DD imagerel $LN3
	DD	imagerel $LN3+14
	DD	imagerel $unwind$AuForceScheduler
$pdata$?AuMapKStack@@YA_KPEA_K@Z DD imagerel $LN6
	DD	imagerel $LN6+121
	DD	imagerel $unwind$?AuMapKStack@@YA_KPEA_K@Z
$pdata$?AuIdleThread@@YAX_K@Z DD imagerel $LN5
	DD	imagerel $LN5+45
	DD	imagerel $unwind$?AuIdleThread@@YAX_K@Z
$pdata$?AuNextThread@@YAXXZ DD imagerel $LN9
	DD	imagerel $LN9+155
	DD	imagerel $unwind$?AuNextThread@@YAXXZ
$pdata$?x8664SchedulerISR@@YAX_KPEAX@Z DD imagerel $LN9
	DD	imagerel $LN9+337
	DD	imagerel $unwind$?x8664SchedulerISR@@YAX_KPEAX@Z
$pdata$AuPrintStack DD imagerel $LN3
	DD	imagerel $LN3+29
	DD	imagerel $unwind$AuPrintStack
pdata	ENDS
xdata	SEGMENT
$unwind$?AuSchedulerStart@@YAXXZ DD 010401H
	DD	06204H
$unwind$?AuSchedulerInitialise@@YAXXZ DD 010401H
	DD	06204H
$unwind$?AuSchedulerInitAp@@YAXXZ DD 010401H
	DD	04204H
$unwind$AuCreateKthread DD 011801H
	DD	06218H
$unwind$?AuCreateUthread@@YAPEAU_au_thread_@@P6AXPEAX@Z_K2PEAD@Z DD 011801H
	DD	06218H
$unwind$AuGetCurrentThread DD 010401H
	DD	04204H
$unwind$AuBlockThread DD 010901H
	DD	04209H
$unwind$AuUnblockThread DD 010901H
	DD	06209H
$unwind$?AuThreadMoveToTrash@@YAXPEAU_au_thread_@@@Z DD 010901H
	DD	06209H
$unwind$?AuThreadCleanTrash@@YAXPEAU_au_thread_@@@Z DD 010901H
	DD	04209H
$unwind$AuThreadFindByID DD 010901H
	DD	02209H
$unwind$AuForceScheduler DD 010401H
	DD	04204H
$unwind$?AuMapKStack@@YA_KPEA_K@Z DD 010901H
	DD	08209H
$unwind$?AuIdleThread@@YAX_K@Z DD 010901H
	DD	04209H
$unwind$?AuNextThread@@YAXXZ DD 010401H
	DD	06204H
$unwind$?x8664SchedulerISR@@YAX_KPEAX@Z DD 010e01H
	DD	0820eH
$unwind$AuPrintStack DD 010401H
	DD	04204H
xdata	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\hal\x86_64_sched.cpp
_TEXT	SEGMENT
AuPrintStack PROC

; 482  : extern "C" void AuPrintStack() {

$LN3:
	sub	rsp, 40					; 00000028H

; 483  : 	SeTextOut("CR3 -> %x \r\n", x64_read_cr3());

	call	x64_read_cr3
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG3765
	call	SeTextOut

; 484  : }

	add	rsp, 40					; 00000028H
	ret	0
AuPrintStack ENDP
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\hal\x86_64_sched.cpp
_TEXT	SEGMENT
current_thread$ = 32
ktss$ = 40
frame$ = 48
sig$1 = 56
v$ = 80
param$ = 88
?x8664SchedulerISR@@YAX_KPEAX@Z PROC			; x8664SchedulerISR

; 412  : void x8664SchedulerISR(size_t v, void* param) {

$LN9:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 413  : 	x64_cli();

	call	x64_cli

; 414  : 	interrupt_stack_frame *frame = (interrupt_stack_frame*)param;

	mov	rax, QWORD PTR param$[rsp]
	mov	QWORD PTR frame$[rsp], rax

; 415  : 
; 416  : 	if (_x86_64_sched_enable == false)

	movzx	eax, BYTE PTR ?_x86_64_sched_enable@@3_NA ; _x86_64_sched_enable
	test	eax, eax
	jne	SHORT $LN6@x8664Sched

; 417  : 		goto sched_end;

	jmp	$LN5@x8664Sched
	jmp	$sched_end$10
$LN6@x8664Sched:

; 418  : 
; 419  : 	TSS *ktss = AuPerCPUGetKernelTSS();

	call	?AuPerCPUGetKernelTSS@@YAPEAU_tss@@XZ	; AuPerCPUGetKernelTSS
	mov	QWORD PTR ktss$[rsp], rax

; 420  : 	AuThread* current_thread = AuPerCPUGetCurrentThread();

	call	?AuPerCPUGetCurrentThread@@YAPEAU_au_thread_@@XZ ; AuPerCPUGetCurrentThread
	mov	QWORD PTR current_thread$[rsp], rax

; 421  : 	if (save_context(current_thread, ktss) == 0) {

	mov	rdx, QWORD PTR ktss$[rsp]
	mov	rcx, QWORD PTR current_thread$[rsp]
	call	save_context
	test	eax, eax
	jne	$LN4@x8664Sched

; 422  : 		current_thread->frame.cr3 = x64_read_cr3();

	call	x64_read_cr3
	mov	rcx, QWORD PTR current_thread$[rsp]
	mov	QWORD PTR [rcx+192], rax

; 423  : 
; 424  : 		current_thread->frame.kern_esp = x64_get_kstack(ktss);

	mov	rcx, QWORD PTR ktss$[rsp]
	call	x64_get_kstack
	mov	rcx, QWORD PTR current_thread$[rsp]
	mov	QWORD PTR [rcx+200], rax

; 425  : 
; 426  : 		/* check for any signal */
; 427  : 		if (AuCheckSignal(current_thread, frame)) {

	mov	rdx, QWORD PTR frame$[rsp]
	mov	rcx, QWORD PTR current_thread$[rsp]
	call	?AuCheckSignal@@YA_NPEAU_au_thread_@@PEAUinterrupt_stack_frame@@@Z ; AuCheckSignal
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@x8664Sched

; 428  : 			Signal* sig = AuGetSignal(current_thread);

	mov	rcx, QWORD PTR current_thread$[rsp]
	call	?AuGetSignal@@YAPEAU_signal_@@PEAU_au_thread_@@@Z ; AuGetSignal
	mov	QWORD PTR sig$1[rsp], rax

; 429  : 			AuPrepareSignal(current_thread, frame, sig);

	mov	r8, QWORD PTR sig$1[rsp]
	mov	rdx, QWORD PTR frame$[rsp]
	mov	rcx, QWORD PTR current_thread$[rsp]
	call	?AuPrepareSignal@@YAXPEAU_au_thread_@@PEAUinterrupt_stack_frame@@PEAU_signal_@@@Z ; AuPrepareSignal
$LN3@x8664Sched:

; 430  : 		}
; 431  : 
; 432  : 		if (x86_64_is_cpu_fxsave_supported())

	call	?x86_64_is_cpu_fxsave_supported@@YA_NXZ	; x86_64_is_cpu_fxsave_supported
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@x8664Sched

; 433  : 			x64_fxsave(current_thread->fx_state);

	mov	rax, QWORD PTR current_thread$[rsp]
	mov	rcx, QWORD PTR [rax+272]
	call	x64_fxsave
$LN2@x8664Sched:

; 434  : 
; 435  : 		
; 436  : 		AuNextThread();

	call	?AuNextThread@@YAXXZ			; AuNextThread

; 437  : 		current_thread = AuPerCPUGetCurrentThread();

	call	?AuPerCPUGetCurrentThread@@YAPEAU_au_thread_@@XZ ; AuPerCPUGetCurrentThread
	mov	QWORD PTR current_thread$[rsp], rax

; 438  : 		
; 439  : 		AuInterruptEnd(0);

	xor	ecx, ecx
	call	AuInterruptEnd

; 440  : 		
; 441  : 		if (x86_64_is_cpu_fxsave_supported())

	call	?x86_64_is_cpu_fxsave_supported@@YA_NXZ	; x86_64_is_cpu_fxsave_supported
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@x8664Sched

; 442  : 			x64_fxrstor(current_thread->fx_state);

	mov	rax, QWORD PTR current_thread$[rsp]
	mov	rcx, QWORD PTR [rax+272]
	call	x64_fxrstor
$LN1@x8664Sched:

; 443  : 
; 444  : 		x64_set_kstack(ktss, current_thread->frame.kern_esp);

	mov	rax, QWORD PTR current_thread$[rsp]
	mov	rdx, QWORD PTR [rax+200]
	mov	rcx, QWORD PTR ktss$[rsp]
	call	x64_set_kstack

; 445  : 
; 446  : 		x64_ldmxcsr(&current_thread->mxcsr);

	mov	rax, QWORD PTR current_thread$[rsp]
	add	rax, 280				; 00000118H
	mov	rcx, rax
	call	x64_ldmxcsr

; 447  : 
; 448  : 		execute_idle(current_thread, ktss);

	mov	rdx, QWORD PTR ktss$[rsp]
	mov	rcx, QWORD PTR current_thread$[rsp]
	call	execute_idle
$LN4@x8664Sched:
$LN5@x8664Sched:
$sched_end$10:

; 449  : 	}
; 450  : 
; 451  : sched_end:
; 452  : 	AuInterruptEnd(0);

	xor	ecx, ecx
	call	AuInterruptEnd

; 453  : }

	add	rsp, 72					; 00000048H
	ret	0
?x8664SchedulerISR@@YAX_KPEAX@Z ENDP			; x8664SchedulerISR
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\hal\x86_64_sched.cpp
_TEXT	SEGMENT
thread$ = 32
?AuNextThread@@YAXXZ PROC				; AuNextThread

; 387  : void AuNextThread() {

$LN9:
	sub	rsp, 56					; 00000038H

; 388  : 	AuThread* thread = AuPerCPUGetCurrentThread();

	call	?AuPerCPUGetCurrentThread@@YAPEAU_au_thread_@@XZ ; AuPerCPUGetCurrentThread
	mov	QWORD PTR thread$[rsp], rax
$LN6@AuNextThre:

; 389  : 	do {
; 390  : 		if (thread->state == THREAD_STATE_SLEEP) {

	mov	rax, QWORD PTR thread$[rsp]
	movzx	eax, BYTE PTR [rax+300]
	cmp	eax, 4
	jne	SHORT $LN3@AuNextThre

; 391  : 			if (thread->quanta == 0) {

	mov	rax, QWORD PTR thread$[rsp]
	movzx	eax, WORD PTR [rax+303]
	test	eax, eax
	jne	SHORT $LN2@AuNextThre

; 392  : 				thread->state = THREAD_STATE_READY;

	mov	rax, QWORD PTR thread$[rsp]
	mov	BYTE PTR [rax+300], 1
$LN2@AuNextThre:

; 393  : 			}
; 394  : 			thread->quanta--;

	mov	rax, QWORD PTR thread$[rsp]
	movzx	eax, WORD PTR [rax+303]
	dec	ax
	mov	rcx, QWORD PTR thread$[rsp]
	mov	WORD PTR [rcx+303], ax
$LN3@AuNextThre:

; 395  : 		}
; 396  : 		thread = thread->next;

	mov	rax, QWORD PTR thread$[rsp]
	mov	rax, QWORD PTR [rax+643]
	mov	QWORD PTR thread$[rsp], rax

; 397  : 		if (thread == NULL) {

	cmp	QWORD PTR thread$[rsp], 0
	jne	SHORT $LN1@AuNextThre

; 398  : 			thread = thread_list_head;

	mov	rax, QWORD PTR ?thread_list_head@@3PEAU_au_thread_@@EA ; thread_list_head
	mov	QWORD PTR thread$[rsp], rax
$LN1@AuNextThre:

; 399  : 		}
; 400  : 	} while (thread->state != THREAD_STATE_READY);

	mov	rax, QWORD PTR thread$[rsp]
	movzx	eax, BYTE PTR [rax+300]
	cmp	eax, 1
	jne	SHORT $LN6@AuNextThre
$end$10:

; 401  : 
; 402  : end:
; 403  : 	//current_thread = thread;
; 404  : 	AuPerCPUSetCurrentThread(thread);

	mov	rcx, QWORD PTR thread$[rsp]
	call	?AuPerCPUSetCurrentThread@@YAXPEAX@Z	; AuPerCPUSetCurrentThread

; 405  : }

	add	rsp, 56					; 00000038H
	ret	0
?AuNextThread@@YAXXZ ENDP				; AuNextThread
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\hal\x86_64_sched.cpp
_TEXT	SEGMENT
t$ = 48
?AuIdleThread@@YAX_K@Z PROC				; AuIdleThread

; 349  : void AuIdleThread(uint64_t t) {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 350  : 	SeTextOut("_idle id -> %d  \r\n", AuPerCPUGetCpuID());

	call	?AuPerCPUGetCpuID@@YAEXZ		; AuPerCPUGetCpuID
	movzx	eax, al
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG3711
	call	SeTextOut
$LN2@AuIdleThre:

; 351  : 	while (1) {

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN1@AuIdleThre

; 352  : 	}

	jmp	SHORT $LN2@AuIdleThre
$LN1@AuIdleThre:

; 353  : }

	add	rsp, 40					; 00000028H
	ret	0
?AuIdleThread@@YAX_K@Z ENDP				; AuIdleThread
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\hal\x86_64_sched.cpp
_TEXT	SEGMENT
thread$ = 8
?AuThreadDeleteTrash@@YAXPEAU_au_thread_@@@Z PROC	; AuThreadDeleteTrash

; 176  : void AuThreadDeleteTrash(AuThread* thread) {

	mov	QWORD PTR [rsp+8], rcx

; 177  : 
; 178  : 	if (trash_thr_head == NULL)

	cmp	QWORD PTR ?trash_thr_head@@3PEAU_au_thread_@@EA, 0 ; trash_thr_head
	jne	SHORT $LN5@AuThreadDe

; 179  : 		return;

	jmp	$LN6@AuThreadDe
$LN5@AuThreadDe:

; 180  : 
; 181  : 	if (thread == trash_thr_head) {

	mov	rax, QWORD PTR ?trash_thr_head@@3PEAU_au_thread_@@EA ; trash_thr_head
	cmp	QWORD PTR thread$[rsp], rax
	jne	SHORT $LN4@AuThreadDe

; 182  : 		trash_thr_head = trash_thr_head->next;

	mov	rax, QWORD PTR ?trash_thr_head@@3PEAU_au_thread_@@EA ; trash_thr_head
	mov	rax, QWORD PTR [rax+643]
	mov	QWORD PTR ?trash_thr_head@@3PEAU_au_thread_@@EA, rax ; trash_thr_head

; 183  : 	}
; 184  : 	else {

	jmp	SHORT $LN3@AuThreadDe
$LN4@AuThreadDe:

; 185  : 		thread->prev->next = thread->next;

	mov	rax, QWORD PTR thread$[rsp]
	mov	rax, QWORD PTR [rax+651]
	mov	rcx, QWORD PTR thread$[rsp]
	mov	rcx, QWORD PTR [rcx+643]
	mov	QWORD PTR [rax+643], rcx
$LN3@AuThreadDe:

; 186  : 	}
; 187  : 
; 188  : 	if (thread == trash_thr_last) {

	mov	rax, QWORD PTR ?trash_thr_last@@3PEAU_au_thread_@@EA ; trash_thr_last
	cmp	QWORD PTR thread$[rsp], rax
	jne	SHORT $LN2@AuThreadDe

; 189  : 		trash_thr_last = thread->prev;

	mov	rax, QWORD PTR thread$[rsp]
	mov	rax, QWORD PTR [rax+651]
	mov	QWORD PTR ?trash_thr_last@@3PEAU_au_thread_@@EA, rax ; trash_thr_last

; 190  : 	}
; 191  : 	else {

	jmp	SHORT $LN1@AuThreadDe
$LN2@AuThreadDe:

; 192  : 		thread->next->prev = thread->prev;

	mov	rax, QWORD PTR thread$[rsp]
	mov	rax, QWORD PTR [rax+643]
	mov	rcx, QWORD PTR thread$[rsp]
	mov	rcx, QWORD PTR [rcx+651]
	mov	QWORD PTR [rax+651], rcx
$LN1@AuThreadDe:
$LN6@AuThreadDe:

; 193  : 	}
; 194  : }

	ret	0
?AuThreadDeleteTrash@@YAXPEAU_au_thread_@@@Z ENDP	; AuThreadDeleteTrash
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\hal\x86_64_sched.cpp
_TEXT	SEGMENT
new_task$ = 8
?AuThreadInsertTrash@@YAXPEAU_au_thread_@@@Z PROC	; AuThreadInsertTrash

; 157  : void AuThreadInsertTrash(AuThread* new_task) {

	mov	QWORD PTR [rsp+8], rcx

; 158  : 	new_task->next = NULL;

	mov	rax, QWORD PTR new_task$[rsp]
	mov	QWORD PTR [rax+643], 0

; 159  : 	new_task->prev = NULL;

	mov	rax, QWORD PTR new_task$[rsp]
	mov	QWORD PTR [rax+651], 0

; 160  : 
; 161  : 	if (trash_thr_head == NULL) {

	cmp	QWORD PTR ?trash_thr_head@@3PEAU_au_thread_@@EA, 0 ; trash_thr_head
	jne	SHORT $LN2@AuThreadIn

; 162  : 		trash_thr_last = new_task;

	mov	rax, QWORD PTR new_task$[rsp]
	mov	QWORD PTR ?trash_thr_last@@3PEAU_au_thread_@@EA, rax ; trash_thr_last

; 163  : 		trash_thr_head = new_task;

	mov	rax, QWORD PTR new_task$[rsp]
	mov	QWORD PTR ?trash_thr_head@@3PEAU_au_thread_@@EA, rax ; trash_thr_head

; 164  : 	}
; 165  : 	else {

	jmp	SHORT $LN1@AuThreadIn
$LN2@AuThreadIn:

; 166  : 		trash_thr_last->next = new_task;

	mov	rax, QWORD PTR ?trash_thr_last@@3PEAU_au_thread_@@EA ; trash_thr_last
	mov	rcx, QWORD PTR new_task$[rsp]
	mov	QWORD PTR [rax+643], rcx

; 167  : 		new_task->prev = trash_thr_last;

	mov	rax, QWORD PTR new_task$[rsp]
	mov	rcx, QWORD PTR ?trash_thr_last@@3PEAU_au_thread_@@EA ; trash_thr_last
	mov	QWORD PTR [rax+651], rcx
$LN1@AuThreadIn:

; 168  : 	}
; 169  : 	trash_thr_last = new_task;

	mov	rax, QWORD PTR new_task$[rsp]
	mov	QWORD PTR ?trash_thr_last@@3PEAU_au_thread_@@EA, rax ; trash_thr_last

; 170  : }

	ret	0
?AuThreadInsertTrash@@YAXPEAU_au_thread_@@@Z ENDP	; AuThreadInsertTrash
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\hal\x86_64_sched.cpp
_TEXT	SEGMENT
thread$ = 8
?AuThreadDeleteBlock@@YAXPEAU_au_thread_@@@Z PROC	; AuThreadDeleteBlock

; 132  : void AuThreadDeleteBlock(AuThread* thread) {

	mov	QWORD PTR [rsp+8], rcx

; 133  : 
; 134  : 	if (blocked_thr_head == NULL)

	cmp	QWORD PTR ?blocked_thr_head@@3PEAU_au_thread_@@EA, 0 ; blocked_thr_head
	jne	SHORT $LN5@AuThreadDe

; 135  : 		return;

	jmp	$LN6@AuThreadDe
$LN5@AuThreadDe:

; 136  : 
; 137  : 	if (thread == blocked_thr_head) {

	mov	rax, QWORD PTR ?blocked_thr_head@@3PEAU_au_thread_@@EA ; blocked_thr_head
	cmp	QWORD PTR thread$[rsp], rax
	jne	SHORT $LN4@AuThreadDe

; 138  : 		blocked_thr_head = blocked_thr_head->next;

	mov	rax, QWORD PTR ?blocked_thr_head@@3PEAU_au_thread_@@EA ; blocked_thr_head
	mov	rax, QWORD PTR [rax+643]
	mov	QWORD PTR ?blocked_thr_head@@3PEAU_au_thread_@@EA, rax ; blocked_thr_head

; 139  : 	}
; 140  : 	else {

	jmp	SHORT $LN3@AuThreadDe
$LN4@AuThreadDe:

; 141  : 		thread->prev->next = thread->next;

	mov	rax, QWORD PTR thread$[rsp]
	mov	rax, QWORD PTR [rax+651]
	mov	rcx, QWORD PTR thread$[rsp]
	mov	rcx, QWORD PTR [rcx+643]
	mov	QWORD PTR [rax+643], rcx
$LN3@AuThreadDe:

; 142  : 	}
; 143  : 
; 144  : 	if (thread == blocked_thr_last) {

	mov	rax, QWORD PTR ?blocked_thr_last@@3PEAU_au_thread_@@EA ; blocked_thr_last
	cmp	QWORD PTR thread$[rsp], rax
	jne	SHORT $LN2@AuThreadDe

; 145  : 		blocked_thr_last = thread->prev;

	mov	rax, QWORD PTR thread$[rsp]
	mov	rax, QWORD PTR [rax+651]
	mov	QWORD PTR ?blocked_thr_last@@3PEAU_au_thread_@@EA, rax ; blocked_thr_last

; 146  : 	}
; 147  : 	else {

	jmp	SHORT $LN1@AuThreadDe
$LN2@AuThreadDe:

; 148  : 		thread->next->prev = thread->prev;

	mov	rax, QWORD PTR thread$[rsp]
	mov	rax, QWORD PTR [rax+643]
	mov	rcx, QWORD PTR thread$[rsp]
	mov	rcx, QWORD PTR [rcx+651]
	mov	QWORD PTR [rax+651], rcx
$LN1@AuThreadDe:
$LN6@AuThreadDe:

; 149  : 	}
; 150  : }

	ret	0
?AuThreadDeleteBlock@@YAXPEAU_au_thread_@@@Z ENDP	; AuThreadDeleteBlock
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\hal\x86_64_sched.cpp
_TEXT	SEGMENT
new_task$ = 8
?AuThreadInsertBlock@@YAXPEAU_au_thread_@@@Z PROC	; AuThreadInsertBlock

; 113  : void AuThreadInsertBlock(AuThread* new_task) {

	mov	QWORD PTR [rsp+8], rcx

; 114  : 	new_task->next = NULL;

	mov	rax, QWORD PTR new_task$[rsp]
	mov	QWORD PTR [rax+643], 0

; 115  : 	new_task->prev = NULL;

	mov	rax, QWORD PTR new_task$[rsp]
	mov	QWORD PTR [rax+651], 0

; 116  : 
; 117  : 	if (blocked_thr_head == NULL) {

	cmp	QWORD PTR ?blocked_thr_head@@3PEAU_au_thread_@@EA, 0 ; blocked_thr_head
	jne	SHORT $LN2@AuThreadIn

; 118  : 		blocked_thr_last = new_task;

	mov	rax, QWORD PTR new_task$[rsp]
	mov	QWORD PTR ?blocked_thr_last@@3PEAU_au_thread_@@EA, rax ; blocked_thr_last

; 119  : 		blocked_thr_head = new_task;

	mov	rax, QWORD PTR new_task$[rsp]
	mov	QWORD PTR ?blocked_thr_head@@3PEAU_au_thread_@@EA, rax ; blocked_thr_head

; 120  : 	}
; 121  : 	else {

	jmp	SHORT $LN1@AuThreadIn
$LN2@AuThreadIn:

; 122  : 		blocked_thr_last->next = new_task;

	mov	rax, QWORD PTR ?blocked_thr_last@@3PEAU_au_thread_@@EA ; blocked_thr_last
	mov	rcx, QWORD PTR new_task$[rsp]
	mov	QWORD PTR [rax+643], rcx

; 123  : 		new_task->prev = blocked_thr_last;

	mov	rax, QWORD PTR new_task$[rsp]
	mov	rcx, QWORD PTR ?blocked_thr_last@@3PEAU_au_thread_@@EA ; blocked_thr_last
	mov	QWORD PTR [rax+651], rcx
$LN1@AuThreadIn:

; 124  : 	}
; 125  : 	blocked_thr_last = new_task;

	mov	rax, QWORD PTR new_task$[rsp]
	mov	QWORD PTR ?blocked_thr_last@@3PEAU_au_thread_@@EA, rax ; blocked_thr_last

; 126  : }

	ret	0
?AuThreadInsertBlock@@YAXPEAU_au_thread_@@@Z ENDP	; AuThreadInsertBlock
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\hal\x86_64_sched.cpp
_TEXT	SEGMENT
thread$ = 8
?AuThreadDelete@@YAXPEAU_au_thread_@@@Z PROC		; AuThreadDelete

; 82   : void AuThreadDelete(AuThread* thread) {

	mov	QWORD PTR [rsp+8], rcx

; 83   : 
; 84   : 	if (thread_list_head == NULL)

	cmp	QWORD PTR ?thread_list_head@@3PEAU_au_thread_@@EA, 0 ; thread_list_head
	jne	SHORT $LN5@AuThreadDe

; 85   : 		return;

	jmp	$LN6@AuThreadDe
$LN5@AuThreadDe:

; 86   : 
; 87   : 	if (thread == thread_list_head) {

	mov	rax, QWORD PTR ?thread_list_head@@3PEAU_au_thread_@@EA ; thread_list_head
	cmp	QWORD PTR thread$[rsp], rax
	jne	SHORT $LN4@AuThreadDe

; 88   : 		thread_list_head = thread_list_head->next;

	mov	rax, QWORD PTR ?thread_list_head@@3PEAU_au_thread_@@EA ; thread_list_head
	mov	rax, QWORD PTR [rax+643]
	mov	QWORD PTR ?thread_list_head@@3PEAU_au_thread_@@EA, rax ; thread_list_head

; 89   : 	}
; 90   : 	else {

	jmp	SHORT $LN3@AuThreadDe
$LN4@AuThreadDe:

; 91   : 		thread->prev->next = thread->next;

	mov	rax, QWORD PTR thread$[rsp]
	mov	rax, QWORD PTR [rax+651]
	mov	rcx, QWORD PTR thread$[rsp]
	mov	rcx, QWORD PTR [rcx+643]
	mov	QWORD PTR [rax+643], rcx
$LN3@AuThreadDe:

; 92   : 	}
; 93   : 
; 94   : 	if (thread == thread_list_last) {

	mov	rax, QWORD PTR ?thread_list_last@@3PEAU_au_thread_@@EA ; thread_list_last
	cmp	QWORD PTR thread$[rsp], rax
	jne	SHORT $LN2@AuThreadDe

; 95   : 		thread_list_last = thread->prev;

	mov	rax, QWORD PTR thread$[rsp]
	mov	rax, QWORD PTR [rax+651]
	mov	QWORD PTR ?thread_list_last@@3PEAU_au_thread_@@EA, rax ; thread_list_last

; 96   : 	}
; 97   : 	else {

	jmp	SHORT $LN1@AuThreadDe
$LN2@AuThreadDe:

; 98   : 		thread->next->prev = thread->prev;

	mov	rax, QWORD PTR thread$[rsp]
	mov	rax, QWORD PTR [rax+643]
	mov	rcx, QWORD PTR thread$[rsp]
	mov	rcx, QWORD PTR [rcx+651]
	mov	QWORD PTR [rax+651], rcx
$LN1@AuThreadDe:
$LN6@AuThreadDe:

; 99   : 	}
; 100  : 
; 101  : 	/* donot free the thread, cuz when thread needs
; 102  : 	* to move from runnable queue to blocked queue
; 103  : 	* same address is used, rather call 'free'
; 104  : 	* externally
; 105  : 	*/
; 106  : }

	ret	0
?AuThreadDelete@@YAXPEAU_au_thread_@@@Z ENDP		; AuThreadDelete
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\hal\x86_64_sched.cpp
_TEXT	SEGMENT
new_task$ = 8
?AuThreadInsert@@YAXPEAU_au_thread_@@@Z PROC		; AuThreadInsert

; 63   : void AuThreadInsert(AuThread* new_task) {

	mov	QWORD PTR [rsp+8], rcx

; 64   : 	new_task->next = NULL;

	mov	rax, QWORD PTR new_task$[rsp]
	mov	QWORD PTR [rax+643], 0

; 65   : 	new_task->prev = NULL;

	mov	rax, QWORD PTR new_task$[rsp]
	mov	QWORD PTR [rax+651], 0

; 66   : 
; 67   : 	if (thread_list_head == NULL) {

	cmp	QWORD PTR ?thread_list_head@@3PEAU_au_thread_@@EA, 0 ; thread_list_head
	jne	SHORT $LN2@AuThreadIn

; 68   : 		thread_list_last = new_task;

	mov	rax, QWORD PTR new_task$[rsp]
	mov	QWORD PTR ?thread_list_last@@3PEAU_au_thread_@@EA, rax ; thread_list_last

; 69   : 		thread_list_head = new_task;

	mov	rax, QWORD PTR new_task$[rsp]
	mov	QWORD PTR ?thread_list_head@@3PEAU_au_thread_@@EA, rax ; thread_list_head

; 70   : 	}
; 71   : 	else {

	jmp	SHORT $LN1@AuThreadIn
$LN2@AuThreadIn:

; 72   : 		thread_list_last->next = new_task;

	mov	rax, QWORD PTR ?thread_list_last@@3PEAU_au_thread_@@EA ; thread_list_last
	mov	rcx, QWORD PTR new_task$[rsp]
	mov	QWORD PTR [rax+643], rcx

; 73   : 		new_task->prev = thread_list_last;

	mov	rax, QWORD PTR new_task$[rsp]
	mov	rcx, QWORD PTR ?thread_list_last@@3PEAU_au_thread_@@EA ; thread_list_last
	mov	QWORD PTR [rax+651], rcx
$LN1@AuThreadIn:

; 74   : 	}
; 75   : 	thread_list_last = new_task;

	mov	rax, QWORD PTR new_task$[rsp]
	mov	QWORD PTR ?thread_list_last@@3PEAU_au_thread_@@EA, rax ; thread_list_last

; 76   : }

	ret	0
?AuThreadInsert@@YAXPEAU_au_thread_@@@Z ENDP		; AuThreadInsert
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\hal\x86_64_sched.cpp
_TEXT	SEGMENT
i$1 = 32
location$ = 40
p$2 = 48
cr3$ = 80
?AuMapKStack@@YA_KPEA_K@Z PROC				; AuMapKStack

; 471  : uint64_t AuMapKStack(uint64_t *cr3) {

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 472  : 	uint64_t location = KERNEL_STACK_LOCATION;

	mov	rax, -5497558138880			; fffffb0000000000H
	mov	QWORD PTR location$[rsp], rax

; 473  : 
; 474  : 	for (int i = 0; i < 8192 / 4096; i++) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN3@AuMapKStac
$LN2@AuMapKStac:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN3@AuMapKStac:
	cmp	DWORD PTR i$1[rsp], 2
	jge	SHORT $LN1@AuMapKStac

; 475  : 		void* p = AuPmmngrAlloc();

	call	AuPmmngrAlloc
	mov	QWORD PTR p$2[rsp], rax

; 476  : 		AuMapPageEx(cr3, (uint64_t)p, location + i * 4096, 0);

	imul	eax, DWORD PTR i$1[rsp], 4096		; 00001000H
	cdqe
	mov	rcx, QWORD PTR location$[rsp]
	add	rcx, rax
	mov	rax, rcx
	xor	r9d, r9d
	mov	r8, rax
	mov	rdx, QWORD PTR p$2[rsp]
	mov	rcx, QWORD PTR cr3$[rsp]
	call	AuMapPageEx

; 477  : 	}

	jmp	SHORT $LN2@AuMapKStac
$LN1@AuMapKStac:

; 478  : 
; 479  : 	return (location + 8192);

	mov	rax, QWORD PTR location$[rsp]
	add	rax, 8192				; 00002000H

; 480  : }

	add	rsp, 72					; 00000048H
	ret	0
?AuMapKStack@@YA_KPEA_K@Z ENDP				; AuMapKStack
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\hal\x86_64_sched.cpp
_TEXT	SEGMENT
?AuIsSchedulerInitialised@@YA_NXZ PROC			; AuIsSchedulerInitialised

; 589  : 	return _x86_64_sched_init;

	movzx	eax, BYTE PTR ?_x86_64_sched_init@@3_NA	; _x86_64_sched_init

; 590  : }

	ret	0
?AuIsSchedulerInitialised@@YA_NXZ ENDP			; AuIsSchedulerInitialised
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\hal\x86_64_sched.cpp
_TEXT	SEGMENT
AuForceScheduler PROC

; 583  : AU_EXTERN AU_EXPORT void AuForceScheduler() {

$LN3:
	sub	rsp, 40					; 00000028H

; 584  : 	x64_force_sched();

	call	x64_force_sched

; 585  : }

	add	rsp, 40					; 00000028H
	ret	0
AuForceScheduler ENDP
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\hal\x86_64_sched.cpp
_TEXT	SEGMENT
ready_queue_$1 = 0
id$ = 32
AuThreadFindByID PROC

; 572  : AuThread* AuThreadFindByID(uint16_t id) {

$LN7:
	mov	WORD PTR [rsp+8], cx
	sub	rsp, 24

; 573  : 	for (AuThread* ready_queue_ = thread_list_head; ready_queue_ != NULL; ready_queue_ = ready_queue_->next) {

	mov	rax, QWORD PTR ?thread_list_head@@3PEAU_au_thread_@@EA ; thread_list_head
	mov	QWORD PTR ready_queue_$1[rsp], rax
	jmp	SHORT $LN4@AuThreadFi
$LN3@AuThreadFi:
	mov	rax, QWORD PTR ready_queue_$1[rsp]
	mov	rax, QWORD PTR [rax+643]
	mov	QWORD PTR ready_queue_$1[rsp], rax
$LN4@AuThreadFi:
	cmp	QWORD PTR ready_queue_$1[rsp], 0
	je	SHORT $LN2@AuThreadFi

; 574  : 		if (ready_queue_->id == id)

	mov	rax, QWORD PTR ready_queue_$1[rsp]
	movzx	eax, WORD PTR [rax+301]
	movzx	ecx, WORD PTR id$[rsp]
	cmp	eax, ecx
	jne	SHORT $LN1@AuThreadFi

; 575  : 			return ready_queue_;

	mov	rax, QWORD PTR ready_queue_$1[rsp]
	jmp	SHORT $LN5@AuThreadFi
$LN1@AuThreadFi:

; 576  : 	}

	jmp	SHORT $LN3@AuThreadFi
$LN2@AuThreadFi:
$LN5@AuThreadFi:

; 577  : }

	add	rsp, 24
	ret	0
AuThreadFindByID ENDP
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\hal\x86_64_sched.cpp
_TEXT	SEGMENT
t$ = 48
?AuThreadCleanTrash@@YAXPEAU_au_thread_@@@Z PROC	; AuThreadCleanTrash

; 563  : void AuThreadCleanTrash(AuThread* t) {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 564  : 	AuThreadDeleteTrash(t);

	mov	rcx, QWORD PTR t$[rsp]
	call	?AuThreadDeleteTrash@@YAXPEAU_au_thread_@@@Z ; AuThreadDeleteTrash

; 565  : }

	add	rsp, 40					; 00000028H
	ret	0
?AuThreadCleanTrash@@YAXPEAU_au_thread_@@@Z ENDP	; AuThreadCleanTrash
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\hal\x86_64_sched.cpp
_TEXT	SEGMENT
ready_queue_$1 = 32
block_queue_$2 = 40
t$ = 64
?AuThreadMoveToTrash@@YAXPEAU_au_thread_@@@Z PROC	; AuThreadMoveToTrash

; 539  : void AuThreadMoveToTrash(AuThread* t) {

$LN11:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 540  : 	t->state = THREAD_STATE_KILLABLE;

	mov	rax, QWORD PTR t$[rsp]
	mov	BYTE PTR [rax+300], 5

; 541  : 
; 542  : 	/* search the thread in ready queue*/
; 543  : 	for (AuThread* ready_queue_ = thread_list_head; ready_queue_ != NULL; ready_queue_ = ready_queue_->next) {

	mov	rax, QWORD PTR ?thread_list_head@@3PEAU_au_thread_@@EA ; thread_list_head
	mov	QWORD PTR ready_queue_$1[rsp], rax
	jmp	SHORT $LN8@AuThreadMo
$LN7@AuThreadMo:
	mov	rax, QWORD PTR ready_queue_$1[rsp]
	mov	rax, QWORD PTR [rax+643]
	mov	QWORD PTR ready_queue_$1[rsp], rax
$LN8@AuThreadMo:
	cmp	QWORD PTR ready_queue_$1[rsp], 0
	je	SHORT $LN6@AuThreadMo

; 544  : 		if (ready_queue_ == t) 

	mov	rax, QWORD PTR t$[rsp]
	cmp	QWORD PTR ready_queue_$1[rsp], rax
	jne	SHORT $LN5@AuThreadMo

; 545  : 			AuThreadDelete(t);

	mov	rcx, QWORD PTR t$[rsp]
	call	?AuThreadDelete@@YAXPEAU_au_thread_@@@Z	; AuThreadDelete
$LN5@AuThreadMo:

; 546  : 	}

	jmp	SHORT $LN7@AuThreadMo
$LN6@AuThreadMo:

; 547  : 
; 548  : 	/* search the thread in block queue*/
; 549  : 	for (AuThread* block_queue_ = blocked_thr_head; block_queue_ != NULL; block_queue_ = block_queue_->next) {

	mov	rax, QWORD PTR ?blocked_thr_head@@3PEAU_au_thread_@@EA ; blocked_thr_head
	mov	QWORD PTR block_queue_$2[rsp], rax
	jmp	SHORT $LN4@AuThreadMo
$LN3@AuThreadMo:
	mov	rax, QWORD PTR block_queue_$2[rsp]
	mov	rax, QWORD PTR [rax+643]
	mov	QWORD PTR block_queue_$2[rsp], rax
$LN4@AuThreadMo:
	cmp	QWORD PTR block_queue_$2[rsp], 0
	je	SHORT $LN2@AuThreadMo

; 550  : 		if (block_queue_ == t)

	mov	rax, QWORD PTR t$[rsp]
	cmp	QWORD PTR block_queue_$2[rsp], rax
	jne	SHORT $LN1@AuThreadMo

; 551  : 			AuThreadDeleteBlock(t);

	mov	rcx, QWORD PTR t$[rsp]
	call	?AuThreadDeleteBlock@@YAXPEAU_au_thread_@@@Z ; AuThreadDeleteBlock
$LN1@AuThreadMo:

; 552  : 	}

	jmp	SHORT $LN3@AuThreadMo
$LN2@AuThreadMo:

; 553  : 
; 554  : 	/* insert it in the trash list */
; 555  : 	AuThreadInsertTrash(t);

	mov	rcx, QWORD PTR t$[rsp]
	call	?AuThreadInsertTrash@@YAXPEAU_au_thread_@@@Z ; AuThreadInsertTrash

; 556  : }

	add	rsp, 56					; 00000038H
	ret	0
?AuThreadMoveToTrash@@YAXPEAU_au_thread_@@@Z ENDP	; AuThreadMoveToTrash
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\hal\x86_64_sched.cpp
_TEXT	SEGMENT
found_$ = 32
thr$1 = 40
t$ = 64
AuUnblockThread PROC

; 520  : AU_EXTERN AU_EXPORT void AuUnblockThread(AuThread *t) {

$LN8:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 521  : 	t->state = THREAD_STATE_READY;

	mov	rax, QWORD PTR t$[rsp]
	mov	BYTE PTR [rax+300], 1

; 522  : 	bool found_ = false;

	mov	BYTE PTR found_$[rsp], 0

; 523  : 	for (AuThread *thr = blocked_thr_head; thr != NULL; thr = thr->next) {

	mov	rax, QWORD PTR ?blocked_thr_head@@3PEAU_au_thread_@@EA ; blocked_thr_head
	mov	QWORD PTR thr$1[rsp], rax
	jmp	SHORT $LN5@AuUnblockT
$LN4@AuUnblockT:
	mov	rax, QWORD PTR thr$1[rsp]
	mov	rax, QWORD PTR [rax+643]
	mov	QWORD PTR thr$1[rsp], rax
$LN5@AuUnblockT:
	cmp	QWORD PTR thr$1[rsp], 0
	je	SHORT $LN3@AuUnblockT

; 524  : 		if (thr == t) {

	mov	rax, QWORD PTR t$[rsp]
	cmp	QWORD PTR thr$1[rsp], rax
	jne	SHORT $LN2@AuUnblockT

; 525  : 			AuThreadDeleteBlock(thr);

	mov	rcx, QWORD PTR thr$1[rsp]
	call	?AuThreadDeleteBlock@@YAXPEAU_au_thread_@@@Z ; AuThreadDeleteBlock

; 526  : 			found_ = true;

	mov	BYTE PTR found_$[rsp], 1

; 527  : 			break;

	jmp	SHORT $LN3@AuUnblockT
$LN2@AuUnblockT:

; 528  : 		}
; 529  : 	}

	jmp	SHORT $LN4@AuUnblockT
$LN3@AuUnblockT:

; 530  : 	if (found_)

	movzx	eax, BYTE PTR found_$[rsp]
	test	eax, eax
	je	SHORT $LN1@AuUnblockT

; 531  : 		AuThreadInsert(t);

	mov	rcx, QWORD PTR t$[rsp]
	call	?AuThreadInsert@@YAXPEAU_au_thread_@@@Z	; AuThreadInsert
$LN1@AuUnblockT:

; 532  : }

	add	rsp, 56					; 00000038H
	ret	0
AuUnblockThread ENDP
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\hal\x86_64_sched.cpp
_TEXT	SEGMENT
thread$ = 8
ms$ = 16
AuSleepThread PROC

; 509  : AU_EXTERN AU_EXPORT void AuSleepThread(AuThread *thread, uint64_t ms) {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 510  : 	thread->state = THREAD_STATE_SLEEP;

	mov	rax, QWORD PTR thread$[rsp]
	mov	BYTE PTR [rax+300], 4

; 511  : 	thread->quanta = ms;

	mov	rax, QWORD PTR thread$[rsp]
	movzx	ecx, WORD PTR ms$[rsp]
	mov	WORD PTR [rax+303], cx

; 512  : }

	ret	0
AuSleepThread ENDP
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\hal\x86_64_sched.cpp
_TEXT	SEGMENT
thread$ = 48
AuBlockThread PROC

; 500  : AU_EXTERN AU_EXPORT void AuBlockThread(AuThread *thread) {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 501  : 	thread->state = THREAD_STATE_BLOCKED;

	mov	rax, QWORD PTR thread$[rsp]
	mov	BYTE PTR [rax+300], 3

; 502  : 	AuThreadDelete(thread);

	mov	rcx, QWORD PTR thread$[rsp]
	call	?AuThreadDelete@@YAXPEAU_au_thread_@@@Z	; AuThreadDelete

; 503  : 	AuThreadInsertBlock(thread);

	mov	rcx, QWORD PTR thread$[rsp]
	call	?AuThreadInsertBlock@@YAXPEAU_au_thread_@@@Z ; AuThreadInsertBlock

; 504  : }

	add	rsp, 40					; 00000028H
	ret	0
AuBlockThread ENDP
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\hal\x86_64_sched.cpp
_TEXT	SEGMENT
dest$ = 8
src$ = 16
?AuKThreadCopy@@YAXPEAU_au_thread_@@0@Z PROC		; AuKThreadCopy

; 323  : void AuKThreadCopy(AuThread* dest, AuThread* src) {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 324  : 	dest->frame.r15 = src->frame.r15;

	mov	rax, QWORD PTR dest$[rsp]
	mov	rcx, QWORD PTR src$[rsp]
	mov	rcx, QWORD PTR [rcx+152]
	mov	QWORD PTR [rax+152], rcx

; 325  : 	dest->frame.r14 = src->frame.r14;

	mov	rax, QWORD PTR dest$[rsp]
	mov	rcx, QWORD PTR src$[rsp]
	mov	rcx, QWORD PTR [rcx+144]
	mov	QWORD PTR [rax+144], rcx

; 326  : 	dest->frame.r13 = src->frame.r13;

	mov	rax, QWORD PTR dest$[rsp]
	mov	rcx, QWORD PTR src$[rsp]
	mov	rcx, QWORD PTR [rcx+136]
	mov	QWORD PTR [rax+136], rcx

; 327  : 	dest->frame.r12 = src->frame.r12;

	mov	rax, QWORD PTR dest$[rsp]
	mov	rcx, QWORD PTR src$[rsp]
	mov	rcx, QWORD PTR [rcx+128]
	mov	QWORD PTR [rax+128], rcx

; 328  : 	dest->frame.r11 = src->frame.r11;

	mov	rax, QWORD PTR dest$[rsp]
	mov	rcx, QWORD PTR src$[rsp]
	mov	rcx, QWORD PTR [rcx+120]
	mov	QWORD PTR [rax+120], rcx

; 329  : 	dest->frame.r10 = src->frame.r10;

	mov	rax, QWORD PTR dest$[rsp]
	mov	rcx, QWORD PTR src$[rsp]
	mov	rcx, QWORD PTR [rcx+112]
	mov	QWORD PTR [rax+112], rcx

; 330  : 	dest->frame.r9 = src->frame.r9;

	mov	rax, QWORD PTR dest$[rsp]
	mov	rcx, QWORD PTR src$[rsp]
	mov	rcx, QWORD PTR [rcx+104]
	mov	QWORD PTR [rax+104], rcx

; 331  : 	dest->frame.r8 = src->frame.r8;

	mov	rax, QWORD PTR dest$[rsp]
	mov	rcx, QWORD PTR src$[rsp]
	mov	rcx, QWORD PTR [rcx+96]
	mov	QWORD PTR [rax+96], rcx

; 332  : 	dest->frame.rdi = src->frame.rdi;

	mov	rax, QWORD PTR dest$[rsp]
	mov	rcx, QWORD PTR src$[rsp]
	mov	rcx, QWORD PTR [rcx+80]
	mov	QWORD PTR [rax+80], rcx

; 333  : 	dest->frame.rsi = src->frame.rsi;

	mov	rax, QWORD PTR dest$[rsp]
	mov	rcx, QWORD PTR src$[rsp]
	mov	rcx, QWORD PTR [rcx+72]
	mov	QWORD PTR [rax+72], rcx

; 334  : 	dest->frame.rdx = src->frame.rdx;

	mov	rax, QWORD PTR dest$[rsp]
	mov	rcx, QWORD PTR src$[rsp]
	mov	rcx, QWORD PTR [rcx+64]
	mov	QWORD PTR [rax+64], rcx

; 335  : 	dest->frame.rcx = src->frame.rcx;

	mov	rax, QWORD PTR dest$[rsp]
	mov	rcx, QWORD PTR src$[rsp]
	mov	rcx, QWORD PTR [rcx+56]
	mov	QWORD PTR [rax+56], rcx

; 336  : 	dest->frame.rbx = src->frame.rbx;

	mov	rax, QWORD PTR dest$[rsp]
	mov	rcx, QWORD PTR src$[rsp]
	mov	rcx, QWORD PTR [rcx+48]
	mov	QWORD PTR [rax+48], rcx

; 337  : 	dest->frame.rax = src->frame.rax;

	mov	rax, QWORD PTR dest$[rsp]
	mov	rcx, QWORD PTR src$[rsp]
	mov	rcx, QWORD PTR [rcx+40]
	mov	QWORD PTR [rax+40], rcx

; 338  : 	dest->frame.rip = src->frame.rip;

	mov	rax, QWORD PTR dest$[rsp]
	mov	rcx, QWORD PTR src$[rsp]
	mov	rcx, QWORD PTR [rcx+32]
	mov	QWORD PTR [rax+32], rcx

; 339  : 	dest->frame.cs = src->frame.cs;

	mov	rax, QWORD PTR dest$[rsp]
	mov	rcx, QWORD PTR src$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	mov	QWORD PTR [rax+24], rcx

; 340  : 	dest->frame.rflags = src->frame.rflags;

	mov	rax, QWORD PTR dest$[rsp]
	mov	rcx, QWORD PTR src$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	mov	QWORD PTR [rax+16], rcx

; 341  : 	dest->frame.ss = src->frame.ss;

	mov	rax, QWORD PTR dest$[rsp]
	mov	rcx, QWORD PTR src$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax], rcx

; 342  : 	dest->frame.ds = src->frame.ds;

	mov	rax, QWORD PTR dest$[rsp]
	mov	rcx, QWORD PTR src$[rsp]
	mov	rcx, QWORD PTR [rcx+160]
	mov	QWORD PTR [rax+160], rcx

; 343  : 	dest->frame.es = src->frame.es;

	mov	rax, QWORD PTR dest$[rsp]
	mov	rcx, QWORD PTR src$[rsp]
	mov	rcx, QWORD PTR [rcx+168]
	mov	QWORD PTR [rax+168], rcx

; 344  : 	dest->frame.fs = src->frame.fs;

	mov	rax, QWORD PTR dest$[rsp]
	mov	rcx, QWORD PTR src$[rsp]
	mov	rcx, QWORD PTR [rcx+176]
	mov	QWORD PTR [rax+176], rcx

; 345  : 	dest->frame.gs = src->frame.gs;

	mov	rax, QWORD PTR dest$[rsp]
	mov	rcx, QWORD PTR src$[rsp]
	mov	rcx, QWORD PTR [rcx+184]
	mov	QWORD PTR [rax+184], rcx

; 346  : }

	ret	0
?AuKThreadCopy@@YAXPEAU_au_thread_@@0@Z ENDP		; AuKThreadCopy
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\hal\x86_64_sched.cpp
_TEXT	SEGMENT
AuGetCurrentThread PROC

; 491  : AuThread* AuGetCurrentThread() {

$LN3:
	sub	rsp, 40					; 00000028H

; 492  : 	return AuPerCPUGetCurrentThread();

	call	?AuPerCPUGetCurrentThread@@YAPEAU_au_thread_@@XZ ; AuPerCPUGetCurrentThread

; 493  : }

	add	rsp, 40					; 00000028H
	ret	0
AuGetCurrentThread ENDP
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\hal\x86_64_sched.cpp
_TEXT	SEGMENT
t$ = 32
k_esp$ = 40
entry$ = 64
stack$ = 72
cr3$ = 80
name$ = 88
?AuCreateUthread@@YAPEAU_au_thread_@@P6AXPEAX@Z_K2PEAD@Z PROC ; AuCreateUthread

; 272  : {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 273  : 	AuThread *t = (AuThread*)kmalloc(sizeof(AuThread));

	mov	ecx, 659				; 00000293H
	call	kmalloc
	mov	QWORD PTR t$[rsp], rax

; 274  : 	memset(t, 0, sizeof(AuThread));

	mov	r8d, 659				; 00000293H
	xor	edx, edx
	mov	rcx, QWORD PTR t$[rsp]
	call	memset

; 275  : 	t->frame.r15 = 0;

	mov	rax, QWORD PTR t$[rsp]
	mov	QWORD PTR [rax+152], 0

; 276  : 	t->frame.r14 = 0;

	mov	rax, QWORD PTR t$[rsp]
	mov	QWORD PTR [rax+144], 0

; 277  : 	t->frame.r13 = 0;

	mov	rax, QWORD PTR t$[rsp]
	mov	QWORD PTR [rax+136], 0

; 278  : 	t->frame.r12 = 0;

	mov	rax, QWORD PTR t$[rsp]
	mov	QWORD PTR [rax+128], 0

; 279  : 	t->frame.r11 = 0;

	mov	rax, QWORD PTR t$[rsp]
	mov	QWORD PTR [rax+120], 0

; 280  : 	t->frame.r10 = 0;

	mov	rax, QWORD PTR t$[rsp]
	mov	QWORD PTR [rax+112], 0

; 281  : 	t->frame.r9 = 0;

	mov	rax, QWORD PTR t$[rsp]
	mov	QWORD PTR [rax+104], 0

; 282  : 	t->frame.r8 = 0;

	mov	rax, QWORD PTR t$[rsp]
	mov	QWORD PTR [rax+96], 0

; 283  : 	t->frame.rbp = stack;

	mov	rax, QWORD PTR t$[rsp]
	mov	rcx, QWORD PTR stack$[rsp]
	mov	QWORD PTR [rax+88], rcx

; 284  : 	t->frame.rdi = 0;

	mov	rax, QWORD PTR t$[rsp]
	mov	QWORD PTR [rax+80], 0

; 285  : 	t->frame.rsi = 0;

	mov	rax, QWORD PTR t$[rsp]
	mov	QWORD PTR [rax+72], 0

; 286  : 	t->frame.rdx = 0;

	mov	rax, QWORD PTR t$[rsp]
	mov	QWORD PTR [rax+64], 0

; 287  : 	t->frame.rcx = 0;

	mov	rax, QWORD PTR t$[rsp]
	mov	QWORD PTR [rax+56], 0

; 288  : 	t->frame.rbx = 0;

	mov	rax, QWORD PTR t$[rsp]
	mov	QWORD PTR [rax+48], 0

; 289  : 	t->frame.rax = 0;

	mov	rax, QWORD PTR t$[rsp]
	mov	QWORD PTR [rax+40], 0

; 290  : 	t->frame.rip = (uint64_t)entry;

	mov	rax, QWORD PTR t$[rsp]
	mov	rcx, QWORD PTR entry$[rsp]
	mov	QWORD PTR [rax+32], rcx

; 291  : 	t->frame.cs = SEGVAL(GDT_ENTRY_USER_CODE, 3);

	mov	rax, QWORD PTR t$[rsp]
	mov	QWORD PTR [rax+24], 43			; 0000002bH

; 292  : 	t->frame.rflags = 0x202;

	mov	rax, QWORD PTR t$[rsp]
	mov	QWORD PTR [rax+16], 514			; 00000202H

; 293  : 	t->frame.rsp = stack;

	mov	rax, QWORD PTR t$[rsp]
	mov	rcx, QWORD PTR stack$[rsp]
	mov	QWORD PTR [rax+8], rcx

; 294  : 	t->frame.ss = SEGVAL(GDT_ENTRY_USER_DATA, 3);

	mov	rax, QWORD PTR t$[rsp]
	mov	QWORD PTR [rax], 35			; 00000023H

; 295  : 	t->frame.ds = t->frame.es = t->frame.fs = t->frame.gs = SEGVAL(GDT_ENTRY_USER_DATA, 3);

	mov	rax, QWORD PTR t$[rsp]
	mov	QWORD PTR [rax+184], 35			; 00000023H
	mov	rax, QWORD PTR t$[rsp]
	mov	QWORD PTR [rax+176], 35			; 00000023H
	mov	rax, QWORD PTR t$[rsp]
	mov	QWORD PTR [rax+168], 35			; 00000023H
	mov	rax, QWORD PTR t$[rsp]
	mov	QWORD PTR [rax+160], 35			; 00000023H

; 296  : 	uint64_t k_esp = AuMapKStack((uint64_t*)cr3);

	mov	rcx, QWORD PTR cr3$[rsp]
	call	?AuMapKStack@@YA_KPEA_K@Z		; AuMapKStack
	mov	QWORD PTR k_esp$[rsp], rax

; 297  : 	/** Kernel stack is important for syscall or interruption in the system **/
; 298  : 	t->frame.kern_esp = k_esp;

	mov	rax, QWORD PTR t$[rsp]
	mov	rcx, QWORD PTR k_esp$[rsp]
	mov	QWORD PTR [rax+200], rcx

; 299  : 	AuTextOut("FRAME USER KERN ESP -> %x \n", t->frame.kern_esp);

	mov	rax, QWORD PTR t$[rsp]
	mov	rdx, QWORD PTR [rax+200]
	lea	rcx, OFFSET FLAT:$SG3702
	call	AuTextOut

; 300  : 	t->user_stack = stack;

	mov	rax, QWORD PTR t$[rsp]
	mov	rcx, QWORD PTR stack$[rsp]
	mov	QWORD PTR [rax+216], rcx

; 301  : 	t->frame.cr3 = V2P(cr3);

	mov	rcx, QWORD PTR cr3$[rsp]
	call	V2P
	mov	rcx, QWORD PTR t$[rsp]
	mov	QWORD PTR [rcx+192], rax

; 302  : 	t->frame.user_ = 1;

	mov	rax, QWORD PTR t$[rsp]
	mov	BYTE PTR [rax+208], 1

; 303  : 	memset(t->name, 0, 8);

	mov	rax, QWORD PTR t$[rsp]
	add	rax, 284				; 0000011cH
	mov	r8d, 8
	xor	edx, edx
	mov	rcx, rax
	call	memset

; 304  : 	strncpy(t->name, name, 8);

	mov	rax, QWORD PTR t$[rsp]
	add	rax, 284				; 0000011cH
	mov	r8d, 8
	mov	rdx, QWORD PTR name$[rsp]
	mov	rcx, rax
	call	strncpy

; 305  : 	t->id = thread_id++;

	mov	rax, QWORD PTR t$[rsp]
	movzx	ecx, WORD PTR thread_id
	mov	WORD PTR [rax+301], cx
	movzx	eax, WORD PTR thread_id
	inc	ax
	mov	WORD PTR thread_id, ax

; 306  : 	t->quanta = 0;

	xor	eax, eax
	mov	rcx, QWORD PTR t$[rsp]
	mov	WORD PTR [rcx+303], ax

; 307  : 
; 308  : 	t->fx_state = (uint8_t*)kmalloc(512);

	mov	ecx, 512				; 00000200H
	call	kmalloc
	mov	rcx, QWORD PTR t$[rsp]
	mov	QWORD PTR [rcx+272], rax

; 309  : 	memset(t->fx_state, 0, 512);

	mov	r8d, 512				; 00000200H
	xor	edx, edx
	mov	rax, QWORD PTR t$[rsp]
	mov	rcx, QWORD PTR [rax+272]
	call	memset

; 310  : 	t->mxcsr = 0x1f80;

	mov	rax, QWORD PTR t$[rsp]
	mov	DWORD PTR [rax+280], 8064		; 00001f80H

; 311  : 	t->priviledge = THREAD_LEVEL_USER;

	mov	rax, QWORD PTR t$[rsp]
	mov	BYTE PTR [rax+305], 2

; 312  : 	t->state = THREAD_STATE_READY;

	mov	rax, QWORD PTR t$[rsp]
	mov	BYTE PTR [rax+300], 1

; 313  : 	AuThreadInsert(t);

	mov	rcx, QWORD PTR t$[rsp]
	call	?AuThreadInsert@@YAXPEAU_au_thread_@@@Z	; AuThreadInsert

; 314  : 	return 0;

	xor	eax, eax

; 315  : }

	add	rsp, 56					; 00000038H
	ret	0
?AuCreateUthread@@YAPEAU_au_thread_@@P6AXPEAX@Z_K2PEAD@Z ENDP ; AuCreateUthread
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\hal\x86_64_sched.cpp
_TEXT	SEGMENT
t$ = 32
fx_addr$ = 40
entry$ = 64
stack$ = 72
cr3$ = 80
name$ = 88
AuCreateKthread PROC

; 206  : {

$LN4:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 207  : 	AuThread *t = (AuThread*)kmalloc(sizeof(AuThread));

	mov	ecx, 659				; 00000293H
	call	kmalloc
	mov	QWORD PTR t$[rsp], rax

; 208  : 	memset(t, 0, sizeof(AuThread));

	mov	r8d, 659				; 00000293H
	xor	edx, edx
	mov	rcx, QWORD PTR t$[rsp]
	call	memset

; 209  : 	t->frame.r15 = 0;

	mov	rax, QWORD PTR t$[rsp]
	mov	QWORD PTR [rax+152], 0

; 210  : 	t->frame.r14 = 0;

	mov	rax, QWORD PTR t$[rsp]
	mov	QWORD PTR [rax+144], 0

; 211  : 	t->frame.r13 = 0;

	mov	rax, QWORD PTR t$[rsp]
	mov	QWORD PTR [rax+136], 0

; 212  : 	t->frame.r12 = 0;

	mov	rax, QWORD PTR t$[rsp]
	mov	QWORD PTR [rax+128], 0

; 213  : 	t->frame.r11 = 0;

	mov	rax, QWORD PTR t$[rsp]
	mov	QWORD PTR [rax+120], 0

; 214  : 	t->frame.r10 = 0;

	mov	rax, QWORD PTR t$[rsp]
	mov	QWORD PTR [rax+112], 0

; 215  : 	t->frame.r9 = 0;

	mov	rax, QWORD PTR t$[rsp]
	mov	QWORD PTR [rax+104], 0

; 216  : 	t->frame.r8 = 0;

	mov	rax, QWORD PTR t$[rsp]
	mov	QWORD PTR [rax+96], 0

; 217  : 	t->frame.rbp = stack;

	mov	rax, QWORD PTR t$[rsp]
	mov	rcx, QWORD PTR stack$[rsp]
	mov	QWORD PTR [rax+88], rcx

; 218  : 	t->frame.rdi = 0;

	mov	rax, QWORD PTR t$[rsp]
	mov	QWORD PTR [rax+80], 0

; 219  : 	t->frame.rsi = 0;

	mov	rax, QWORD PTR t$[rsp]
	mov	QWORD PTR [rax+72], 0

; 220  : 	t->frame.rdx = 0;

	mov	rax, QWORD PTR t$[rsp]
	mov	QWORD PTR [rax+64], 0

; 221  : 	t->frame.rcx = 0;

	mov	rax, QWORD PTR t$[rsp]
	mov	QWORD PTR [rax+56], 0

; 222  : 	t->frame.rbx = 0;

	mov	rax, QWORD PTR t$[rsp]
	mov	QWORD PTR [rax+48], 0

; 223  : 	t->frame.rax = 0;

	mov	rax, QWORD PTR t$[rsp]
	mov	QWORD PTR [rax+40], 0

; 224  : 	t->frame.rip = (uint64_t)entry;

	mov	rax, QWORD PTR t$[rsp]
	mov	rcx, QWORD PTR entry$[rsp]
	mov	QWORD PTR [rax+32], rcx

; 225  : 	t->frame.cs = 0x08;

	mov	rax, QWORD PTR t$[rsp]
	mov	QWORD PTR [rax+24], 8

; 226  : 	t->frame.rflags = 0x202;

	mov	rax, QWORD PTR t$[rsp]
	mov	QWORD PTR [rax+16], 514			; 00000202H

; 227  : 	t->frame.rsp = stack;

	mov	rax, QWORD PTR t$[rsp]
	mov	rcx, QWORD PTR stack$[rsp]
	mov	QWORD PTR [rax+8], rcx

; 228  : 	t->frame.ss = 0x10;

	mov	rax, QWORD PTR t$[rsp]
	mov	QWORD PTR [rax], 16

; 229  : 	t->frame.kern_esp = stack;

	mov	rax, QWORD PTR t$[rsp]
	mov	rcx, QWORD PTR stack$[rsp]
	mov	QWORD PTR [rax+200], rcx

; 230  : 	t->user_stack = stack;

	mov	rax, QWORD PTR t$[rsp]
	mov	rcx, QWORD PTR stack$[rsp]
	mov	QWORD PTR [rax+216], rcx

; 231  : 	t->quanta = 0;

	xor	eax, eax
	mov	rcx, QWORD PTR t$[rsp]
	mov	WORD PTR [rcx+303], ax

; 232  : 	t->frame.cr3 = cr3;

	mov	rax, QWORD PTR t$[rsp]
	mov	rcx, QWORD PTR cr3$[rsp]
	mov	QWORD PTR [rax+192], rcx

; 233  : 	t->priviledge = THREAD_LEVEL_KERNEL;

	mov	rax, QWORD PTR t$[rsp]
	mov	BYTE PTR [rax+305], 1

; 234  : 	t->state = THREAD_STATE_READY;

	mov	rax, QWORD PTR t$[rsp]
	mov	BYTE PTR [rax+300], 1

; 235  : 	t->frame.ds = t->frame.es = t->frame.fs = t->frame.gs = SEGVAL(GDT_ENTRY_KERNEL_DATA, 0);

	mov	rax, QWORD PTR t$[rsp]
	mov	QWORD PTR [rax+184], 16
	mov	rax, QWORD PTR t$[rsp]
	mov	QWORD PTR [rax+176], 16
	mov	rax, QWORD PTR t$[rsp]
	mov	QWORD PTR [rax+168], 16
	mov	rax, QWORD PTR t$[rsp]
	mov	QWORD PTR [rax+160], 16

; 236  : 	t->frame.user_ = 0;

	mov	rax, QWORD PTR t$[rsp]
	mov	BYTE PTR [rax+208], 0

; 237  : 
; 238  : 	t->syscall_param.param1 = t->syscall_param.param2 = 0;

	mov	rax, QWORD PTR t$[rsp]
	mov	QWORD PTR [rax+232], 0
	mov	rax, QWORD PTR t$[rsp]
	mov	QWORD PTR [rax+224], 0

; 239  : 	t->syscall_param.param3 = t->syscall_param.param4 = 0;

	mov	rax, QWORD PTR t$[rsp]
	mov	QWORD PTR [rax+248], 0
	mov	rax, QWORD PTR t$[rsp]
	mov	QWORD PTR [rax+240], 0

; 240  : 	t->syscall_param.param5 = t->syscall_param.param6 = 0;

	mov	rax, QWORD PTR t$[rsp]
	mov	QWORD PTR [rax+264], 0
	mov	rax, QWORD PTR t$[rsp]
	mov	QWORD PTR [rax+256], 0

; 241  : 
; 242  : 	/* process will fill uentry */
; 243  : 	t->uentry = NULL; 

	mov	rax, QWORD PTR t$[rsp]
	mov	QWORD PTR [rax+635], 0

; 244  : 	memset(t->name, 0,16);

	mov	rax, QWORD PTR t$[rsp]
	add	rax, 284				; 0000011cH
	mov	r8d, 16
	xor	edx, edx
	mov	rcx, rax
	call	memset

; 245  : 	strcpy(t->name, name);

	mov	rax, QWORD PTR t$[rsp]
	add	rax, 284				; 0000011cH
	mov	rdx, QWORD PTR name$[rsp]
	mov	rcx, rax
	call	strcpy

; 246  : 	t->id = thread_id++;

	mov	rax, QWORD PTR t$[rsp]
	movzx	ecx, WORD PTR thread_id
	mov	WORD PTR [rax+301], cx
	movzx	eax, WORD PTR thread_id
	inc	ax
	mov	WORD PTR thread_id, ax

; 247  : 
; 248  : 	t->fx_state = (uint8_t*)kmalloc(512);

	mov	ecx, 512				; 00000200H
	call	kmalloc
	mov	rcx, QWORD PTR t$[rsp]
	mov	QWORD PTR [rcx+272], rax

; 249  : 
; 250  : 	/* align the fx_state memory to 16-byte boundary */
; 251  : 	size_t fx_addr = (size_t)t->fx_state;

	mov	rax, QWORD PTR t$[rsp]
	mov	rax, QWORD PTR [rax+272]
	mov	QWORD PTR fx_addr$[rsp], rax

; 252  : 	if ((size_t)t->fx_state & (16 - 1)) 

	mov	rax, QWORD PTR t$[rsp]
	mov	rax, QWORD PTR [rax+272]
	and	rax, 15
	test	rax, rax
	je	SHORT $LN1@AuCreateKt

; 253  : 		t->fx_state = (uint8_t*)(fx_addr | 16 - 1) + 1;

	mov	rax, QWORD PTR fx_addr$[rsp]
	or	rax, 15
	inc	rax
	mov	rcx, QWORD PTR t$[rsp]
	mov	QWORD PTR [rcx+272], rax
$LN1@AuCreateKt:

; 254  : 	
; 255  : 	memset(t->fx_state, 0, 512);

	mov	r8d, 512				; 00000200H
	xor	edx, edx
	mov	rax, QWORD PTR t$[rsp]
	mov	rcx, QWORD PTR [rax+272]
	call	memset

; 256  : 
; 257  : 	t->mxcsr = 0x1f80;

	mov	rax, QWORD PTR t$[rsp]
	mov	DWORD PTR [rax+280], 8064		; 00001f80H

; 258  : 	AuThreadInsert(t);

	mov	rcx, QWORD PTR t$[rsp]
	call	?AuThreadInsert@@YAXPEAU_au_thread_@@@Z	; AuThreadInsert

; 259  : 	return t;

	mov	rax, QWORD PTR t$[rsp]

; 260  : }

	add	rsp, 56					; 00000038H
	ret	0
AuCreateKthread ENDP
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\hal\x86_64_sched.cpp
_TEXT	SEGMENT
?AuSchedulerInitAp@@YAXXZ PROC				; AuSchedulerInitAp

; 379  : void AuSchedulerInitAp() {

$LN3:
	sub	rsp, 40					; 00000028H

; 380  : 	AuPerCPUSetCurrentThread(_idle_thr);

	mov	rcx, QWORD PTR ?_idle_thr@@3PEAU_au_thread_@@EA ; _idle_thr
	call	?AuPerCPUSetCurrentThread@@YAXPEAX@Z	; AuPerCPUSetCurrentThread

; 381  : }

	add	rsp, 40					; 00000028H
	ret	0
?AuSchedulerInitAp@@YAXXZ ENDP				; AuSchedulerInitAp
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\hal\x86_64_sched.cpp
_TEXT	SEGMENT
idle_$ = 32
tv68 = 40
?AuSchedulerInitialise@@YAXXZ PROC			; AuSchedulerInitialise

; 359  : void AuSchedulerInitialise() {

$LN3:
	sub	rsp, 56					; 00000038H

; 360  : 	thread_id = 0;

	xor	eax, eax
	mov	WORD PTR thread_id, ax

; 361  : 	thread_list_head = NULL;

	mov	QWORD PTR ?thread_list_head@@3PEAU_au_thread_@@EA, 0 ; thread_list_head

; 362  : 	thread_list_last = NULL;

	mov	QWORD PTR ?thread_list_last@@3PEAU_au_thread_@@EA, 0 ; thread_list_last

; 363  : 	blocked_thr_head = NULL;

	mov	QWORD PTR ?blocked_thr_head@@3PEAU_au_thread_@@EA, 0 ; blocked_thr_head

; 364  : 	blocked_thr_last = NULL;

	mov	QWORD PTR ?blocked_thr_last@@3PEAU_au_thread_@@EA, 0 ; blocked_thr_last

; 365  : 	trash_thr_head = NULL;

	mov	QWORD PTR ?trash_thr_head@@3PEAU_au_thread_@@EA, 0 ; trash_thr_head

; 366  : 	trash_thr_last = NULL;

	mov	QWORD PTR ?trash_thr_last@@3PEAU_au_thread_@@EA, 0 ; trash_thr_last

; 367  : 	_x86_64_sched_enable = true;

	mov	BYTE PTR ?_x86_64_sched_enable@@3_NA, 1	; _x86_64_sched_enable

; 368  : 	_x86_64_sched_init = false;

	mov	BYTE PTR ?_x86_64_sched_init@@3_NA, 0	; _x86_64_sched_init

; 369  : 	_idle_lock = AuCreateSpinlock(false);

	xor	ecx, ecx
	call	AuCreateSpinlock
	mov	QWORD PTR ?_idle_lock@@3PEAU_spinlock_@@EA, rax ; _idle_lock

; 370  : 	AuThread *idle_ = AuCreateKthread(AuIdleThread, (uint64_t)P2V((uint64_t)AuPmmngrAlloc() + 4096), x64_read_cr3(), "Idle");

	call	x64_read_cr3
	mov	QWORD PTR tv68[rsp], rax
	call	AuPmmngrAlloc
	add	rax, 4096				; 00001000H
	mov	rcx, rax
	call	P2V
	lea	r9, OFFSET FLAT:$SG3720
	mov	rcx, QWORD PTR tv68[rsp]
	mov	r8, rcx
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:?AuIdleThread@@YAX_K@Z	; AuIdleThread
	call	AuCreateKthread
	mov	QWORD PTR idle_$[rsp], rax

; 371  : 	_idle_thr = idle_;

	mov	rax, QWORD PTR idle_$[rsp]
	mov	QWORD PTR ?_idle_thr@@3PEAU_au_thread_@@EA, rax ; _idle_thr

; 372  : 	AuPerCPUSetCurrentThread(idle_);

	mov	rcx, QWORD PTR idle_$[rsp]
	call	?AuPerCPUSetCurrentThread@@YAXPEAX@Z	; AuPerCPUSetCurrentThread

; 373  : }

	add	rsp, 56					; 00000038H
	ret	0
?AuSchedulerInitialise@@YAXXZ ENDP			; AuSchedulerInitialise
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\hal\x86_64_sched.cpp
_TEXT	SEGMENT
current_thread$ = 32
?AuSchedulerStart@@YAXXZ PROC				; AuSchedulerStart

; 459  : void AuSchedulerStart() {

$LN3:
	sub	rsp, 56					; 00000038H

; 460  : 	_x86_64_sched_init = true;

	mov	BYTE PTR ?_x86_64_sched_init@@3_NA, 1	; _x86_64_sched_init

; 461  :     setvect(0x40,x8664SchedulerISR);

	lea	rdx, OFFSET FLAT:?x8664SchedulerISR@@YAX_KPEAX@Z ; x8664SchedulerISR
	mov	ecx, 64					; 00000040H
	call	setvect

; 462  : 	AuThread* current_thread = AuPerCPUGetCurrentThread();

	call	?AuPerCPUGetCurrentThread@@YAPEAU_au_thread_@@XZ ; AuPerCPUGetCurrentThread
	mov	QWORD PTR current_thread$[rsp], rax

; 463  : 	execute_idle(current_thread, x86_64_get_tss());

	call	?x86_64_get_tss@@YAPEAU_tss@@XZ		; x86_64_get_tss
	mov	rdx, rax
	mov	rcx, QWORD PTR current_thread$[rsp]
	call	execute_idle

; 464  : }

	add	rsp, 56					; 00000038H
	ret	0
?AuSchedulerStart@@YAXXZ ENDP				; AuSchedulerStart
_TEXT	ENDS
END
