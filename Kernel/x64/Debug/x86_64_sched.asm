; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.21005.1 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?thread_list_head@@3PEAU_au_thread_@@EA		; thread_list_head
PUBLIC	?thread_list_last@@3PEAU_au_thread_@@EA		; thread_list_last
PUBLIC	?blocked_thr_head@@3PEAU_au_thread_@@EA		; blocked_thr_head
PUBLIC	?blocked_thr_last@@3PEAU_au_thread_@@EA		; blocked_thr_last
PUBLIC	?trash_thr_head@@3PEAU_au_thread_@@EA		; trash_thr_head
PUBLIC	?trash_thr_last@@3PEAU_au_thread_@@EA		; trash_thr_last
PUBLIC	?_x86_64_sched_enable@@3_NA			; _x86_64_sched_enable
PUBLIC	?_idle_thr@@3PEAU_au_thread_@@EA		; _idle_thr
PUBLIC	?_idle_lock@@3PEAU_spinlock_@@EA		; _idle_lock
PUBLIC	?_x86_64_sched_init@@3_NA			; _x86_64_sched_init
_BSS	SEGMENT
?thread_list_head@@3PEAU_au_thread_@@EA DQ 01H DUP (?)	; thread_list_head
?thread_list_last@@3PEAU_au_thread_@@EA DQ 01H DUP (?)	; thread_list_last
?blocked_thr_head@@3PEAU_au_thread_@@EA DQ 01H DUP (?)	; blocked_thr_head
?blocked_thr_last@@3PEAU_au_thread_@@EA DQ 01H DUP (?)	; blocked_thr_last
?trash_thr_head@@3PEAU_au_thread_@@EA DQ 01H DUP (?)	; trash_thr_head
?trash_thr_last@@3PEAU_au_thread_@@EA DQ 01H DUP (?)	; trash_thr_last
?_x86_64_sched_enable@@3_NA DB 01H DUP (?)		; _x86_64_sched_enable
	ALIGN	8

?_idle_thr@@3PEAU_au_thread_@@EA DQ 01H DUP (?)		; _idle_thr
?_idle_lock@@3PEAU_spinlock_@@EA DQ 01H DUP (?)		; _idle_lock
?_x86_64_sched_init@@3_NA DB 01H DUP (?)		; _x86_64_sched_init
_BSS	ENDS
CONST	SEGMENT
$SG3792	DB	'_idle id -> %d  ', 0dH, 0aH, 00H
	ORG $+5
$SG3796	DB	'IDLE ', 0dH, 0aH, 00H
$SG3802	DB	'Idle', 00H
	ORG $+3
$SG3842	DB	'CR3 -> %x ', 0dH, 0aH, 00H
CONST	ENDS
PUBLIC	?AuSchedulerStart@@YAXXZ			; AuSchedulerStart
PUBLIC	?AuSchedulerInitialise@@YAXXZ			; AuSchedulerInitialise
PUBLIC	?AuSchedulerInitAp@@YAXXZ			; AuSchedulerInitAp
PUBLIC	AuCreateKthread
PUBLIC	AuGetCurrentThread
PUBLIC	?AuKThreadCopy@@YAXPEAU_au_thread_@@0@Z		; AuKThreadCopy
PUBLIC	AuBlockThread
PUBLIC	AuSleepThread
PUBLIC	AuUnblockThread
PUBLIC	?AuThreadMoveToTrash@@YAXPEAU_au_thread_@@@Z	; AuThreadMoveToTrash
PUBLIC	?AuThreadCleanTrash@@YAXPEAU_au_thread_@@@Z	; AuThreadCleanTrash
PUBLIC	AuThreadFindByID
PUBLIC	AuThreadFindByIDBlockList
PUBLIC	AuForceScheduler
PUBLIC	?AuIsSchedulerInitialised@@YA_NXZ		; AuIsSchedulerInitialised
PUBLIC	AuGetSystemTimerTick
PUBLIC	?AuThreadInsert@@YAXPEAU_au_thread_@@@Z		; AuThreadInsert
PUBLIC	?AuThreadDelete@@YAXPEAU_au_thread_@@@Z		; AuThreadDelete
PUBLIC	?AuThreadInsertBlock@@YAXPEAU_au_thread_@@@Z	; AuThreadInsertBlock
PUBLIC	?AuThreadDeleteBlock@@YAXPEAU_au_thread_@@@Z	; AuThreadDeleteBlock
PUBLIC	?AuThreadInsertTrash@@YAXPEAU_au_thread_@@@Z	; AuThreadInsertTrash
PUBLIC	?AuThreadDeleteTrash@@YAXPEAU_au_thread_@@@Z	; AuThreadDeleteTrash
PUBLIC	?AuIdleThread@@YAX_K@Z				; AuIdleThread
PUBLIC	?AuNextThread@@YAXXZ				; AuNextThread
PUBLIC	?x8664SchedulerISR@@YAX_KPEAX@Z			; x8664SchedulerISR
PUBLIC	AuPrintStack
EXTRN	setvect:PROC
EXTRN	AuCreateSpinlock:PROC
EXTRN	?x86_64_get_tss@@YAPEAU_tss@@XZ:PROC		; x86_64_get_tss
EXTRN	?x86_64_is_cpu_fxsave_supported@@YA_NXZ:PROC	; x86_64_is_cpu_fxsave_supported
EXTRN	x64_cli:PROC
EXTRN	x64_hlt:PROC
EXTRN	x64_read_cr3:PROC
EXTRN	x64_fxsave:PROC
EXTRN	x64_fxrstor:PROC
EXTRN	x64_ldmxcsr:PROC
EXTRN	x64_set_kstack:PROC
EXTRN	x64_get_kstack:PROC
EXTRN	x64_force_sched:PROC
EXTRN	AuInterruptEnd:PROC
EXTRN	?AuCheckSignal@@YA_NPEAU_au_thread_@@PEAUinterrupt_stack_frame@@@Z:PROC ; AuCheckSignal
EXTRN	?AuGetSignal@@YAPEAU_signal_@@PEAU_au_thread_@@@Z:PROC ; AuGetSignal
EXTRN	?AuPrepareSignal@@YAXPEAU_au_thread_@@PEAUinterrupt_stack_frame@@PEAU_signal_@@@Z:PROC ; AuPrepareSignal
EXTRN	strcpy:PROC
EXTRN	memset:PROC
EXTRN	SeTextOut:PROC
EXTRN	kmalloc:PROC
EXTRN	?AuPerCPUGetCpuID@@YAEXZ:PROC			; AuPerCPUGetCpuID
EXTRN	?AuPerCPUSetCurrentThread@@YAXPEAX@Z:PROC	; AuPerCPUSetCurrentThread
EXTRN	?AuPerCPUGetCurrentThread@@YAPEAU_au_thread_@@XZ:PROC ; AuPerCPUGetCurrentThread
EXTRN	?AuPerCPUGetKernelTSS@@YAPEAU_tss@@XZ:PROC	; AuPerCPUGetKernelTSS
EXTRN	AuPmmngrAlloc:PROC
EXTRN	P2V:PROC
EXTRN	save_context:PROC
EXTRN	execute_idle:PROC
_BSS	SEGMENT
	ALIGN	4

thread_id DW	01H DUP (?)
	ALIGN	8

scheduler_tick DQ 01H DUP (?)
_BSS	ENDS
pdata	SEGMENT
$pdata$?AuSchedulerStart@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+61
	DD	imagerel $unwind$?AuSchedulerStart@@YAXXZ
$pdata$?AuSchedulerInitialise@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+209
	DD	imagerel $unwind$?AuSchedulerInitialise@@YAXXZ
$pdata$?AuSchedulerInitAp@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+21
	DD	imagerel $unwind$?AuSchedulerInitAp@@YAXXZ
$pdata$AuCreateKthread DD imagerel $LN4
	DD	imagerel $LN4+829
	DD	imagerel $unwind$AuCreateKthread
$pdata$AuGetCurrentThread DD imagerel $LN3
	DD	imagerel $LN3+14
	DD	imagerel $unwind$AuGetCurrentThread
$pdata$AuBlockThread DD imagerel $LN3
	DD	imagerel $LN3+46
	DD	imagerel $unwind$AuBlockThread
$pdata$AuUnblockThread DD imagerel $LN8
	DD	imagerel $LN8+120
	DD	imagerel $unwind$AuUnblockThread
$pdata$?AuThreadMoveToTrash@@YAXPEAU_au_thread_@@@Z DD imagerel $LN12
	DD	imagerel $LN12+175
	DD	imagerel $unwind$?AuThreadMoveToTrash@@YAXPEAU_au_thread_@@@Z
$pdata$?AuThreadCleanTrash@@YAXPEAU_au_thread_@@@Z DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$?AuThreadCleanTrash@@YAXPEAU_au_thread_@@@Z
$pdata$AuThreadFindByID DD imagerel $LN7
	DD	imagerel $LN7+79
	DD	imagerel $unwind$AuThreadFindByID
$pdata$AuThreadFindByIDBlockList DD imagerel $LN7
	DD	imagerel $LN7+79
	DD	imagerel $unwind$AuThreadFindByIDBlockList
$pdata$AuForceScheduler DD imagerel $LN3
	DD	imagerel $LN3+14
	DD	imagerel $unwind$AuForceScheduler
$pdata$?AuIdleThread@@YAX_K@Z DD imagerel $LN5
	DD	imagerel $LN5+62
	DD	imagerel $unwind$?AuIdleThread@@YAX_K@Z
$pdata$?AuNextThread@@YAXXZ DD imagerel $LN13
	DD	imagerel $LN13+232
	DD	imagerel $unwind$?AuNextThread@@YAXXZ
$pdata$?x8664SchedulerISR@@YAX_KPEAX@Z DD imagerel $LN9
	DD	imagerel $LN9+354
	DD	imagerel $unwind$?x8664SchedulerISR@@YAX_KPEAX@Z
$pdata$AuPrintStack DD imagerel $LN3
	DD	imagerel $LN3+29
	DD	imagerel $unwind$AuPrintStack
pdata	ENDS
xdata	SEGMENT
$unwind$?AuSchedulerStart@@YAXXZ DD 010401H
	DD	06204H
$unwind$?AuSchedulerInitialise@@YAXXZ DD 010401H
	DD	06204H
$unwind$?AuSchedulerInitAp@@YAXXZ DD 010401H
	DD	04204H
$unwind$AuCreateKthread DD 011801H
	DD	06218H
$unwind$AuGetCurrentThread DD 010401H
	DD	04204H
$unwind$AuBlockThread DD 010901H
	DD	04209H
$unwind$AuUnblockThread DD 010901H
	DD	06209H
$unwind$?AuThreadMoveToTrash@@YAXPEAU_au_thread_@@@Z DD 010901H
	DD	06209H
$unwind$?AuThreadCleanTrash@@YAXPEAU_au_thread_@@@Z DD 010901H
	DD	04209H
$unwind$AuThreadFindByID DD 010901H
	DD	02209H
$unwind$AuThreadFindByIDBlockList DD 010901H
	DD	02209H
$unwind$AuForceScheduler DD 010401H
	DD	04204H
$unwind$?AuIdleThread@@YAX_K@Z DD 010901H
	DD	04209H
$unwind$?AuNextThread@@YAXXZ DD 010401H
	DD	06204H
$unwind$?x8664SchedulerISR@@YAX_KPEAX@Z DD 010e01H
	DD	0820eH
$unwind$AuPrintStack DD 010401H
	DD	04204H
xdata	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\hal\x86_64_sched.cpp
_TEXT	SEGMENT
AuPrintStack PROC

; 437  : extern "C" void AuPrintStack() {

$LN3:
	sub	rsp, 40					; 00000028H

; 438  : 	SeTextOut("CR3 -> %x \r\n", x64_read_cr3());

	call	x64_read_cr3
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG3842
	call	SeTextOut

; 439  : }

	add	rsp, 40					; 00000028H
	ret	0
AuPrintStack ENDP
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\hal\x86_64_sched.cpp
_TEXT	SEGMENT
current_thread$ = 32
ktss$ = 40
frame$ = 48
sig$1 = 56
v$ = 80
param$ = 88
?x8664SchedulerISR@@YAX_KPEAX@Z PROC			; x8664SchedulerISR

; 377  : void x8664SchedulerISR(size_t v, void* param) {

$LN9:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 378  : 	x64_cli();

	call	x64_cli

; 379  : 	interrupt_stack_frame *frame = (interrupt_stack_frame*)param;

	mov	rax, QWORD PTR param$[rsp]
	mov	QWORD PTR frame$[rsp], rax

; 380  : 
; 381  : 	if (_x86_64_sched_enable == false)

	movzx	eax, BYTE PTR ?_x86_64_sched_enable@@3_NA ; _x86_64_sched_enable
	test	eax, eax
	jne	SHORT $LN6@x8664Sched

; 382  : 		goto sched_end;

	jmp	$LN5@x8664Sched
	jmp	$sched_end$10
$LN6@x8664Sched:

; 383  : 
; 384  : 	TSS *ktss = AuPerCPUGetKernelTSS();

	call	?AuPerCPUGetKernelTSS@@YAPEAU_tss@@XZ	; AuPerCPUGetKernelTSS
	mov	QWORD PTR ktss$[rsp], rax

; 385  : 	AuThread* current_thread = AuPerCPUGetCurrentThread();

	call	?AuPerCPUGetCurrentThread@@YAPEAU_au_thread_@@XZ ; AuPerCPUGetCurrentThread
	mov	QWORD PTR current_thread$[rsp], rax

; 386  : 	if (save_context(current_thread, ktss) == 0) {

	mov	rdx, QWORD PTR ktss$[rsp]
	mov	rcx, QWORD PTR current_thread$[rsp]
	call	save_context
	test	eax, eax
	jne	$LN4@x8664Sched

; 387  : 		current_thread->frame.cr3 = x64_read_cr3();

	call	x64_read_cr3
	mov	rcx, QWORD PTR current_thread$[rsp]
	mov	QWORD PTR [rcx+192], rax

; 388  : 
; 389  : 		current_thread->frame.kern_esp = x64_get_kstack(ktss);

	mov	rcx, QWORD PTR ktss$[rsp]
	call	x64_get_kstack
	mov	rcx, QWORD PTR current_thread$[rsp]
	mov	QWORD PTR [rcx+200], rax

; 390  : 
; 391  : 		/* check for any signal */
; 392  : 		if (AuCheckSignal(current_thread, frame)) {

	mov	rdx, QWORD PTR frame$[rsp]
	mov	rcx, QWORD PTR current_thread$[rsp]
	call	?AuCheckSignal@@YA_NPEAU_au_thread_@@PEAUinterrupt_stack_frame@@@Z ; AuCheckSignal
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@x8664Sched

; 393  : 			Signal* sig = AuGetSignal(current_thread);

	mov	rcx, QWORD PTR current_thread$[rsp]
	call	?AuGetSignal@@YAPEAU_signal_@@PEAU_au_thread_@@@Z ; AuGetSignal
	mov	QWORD PTR sig$1[rsp], rax

; 394  : 			AuPrepareSignal(current_thread, frame, sig);

	mov	r8, QWORD PTR sig$1[rsp]
	mov	rdx, QWORD PTR frame$[rsp]
	mov	rcx, QWORD PTR current_thread$[rsp]
	call	?AuPrepareSignal@@YAXPEAU_au_thread_@@PEAUinterrupt_stack_frame@@PEAU_signal_@@@Z ; AuPrepareSignal
$LN3@x8664Sched:

; 395  : 
; 396  : 			/* actually, signal should be executed immediately
; 397  : 			 * here, AuSignalHandle() 
; 398  : 			 */
; 399  : 		}
; 400  : 
; 401  : 		if (x86_64_is_cpu_fxsave_supported())

	call	?x86_64_is_cpu_fxsave_supported@@YA_NXZ	; x86_64_is_cpu_fxsave_supported
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@x8664Sched

; 402  : 			x64_fxsave(current_thread->fx_state);

	mov	rax, QWORD PTR current_thread$[rsp]
	mov	rcx, QWORD PTR [rax+272]
	call	x64_fxsave
$LN2@x8664Sched:

; 403  : 
; 404  : 		scheduler_tick++;

	mov	rax, QWORD PTR scheduler_tick
	inc	rax
	mov	QWORD PTR scheduler_tick, rax

; 405  : 		AuNextThread();

	call	?AuNextThread@@YAXXZ			; AuNextThread

; 406  : 		current_thread = AuPerCPUGetCurrentThread();

	call	?AuPerCPUGetCurrentThread@@YAPEAU_au_thread_@@XZ ; AuPerCPUGetCurrentThread
	mov	QWORD PTR current_thread$[rsp], rax

; 407  : 		
; 408  : 		AuInterruptEnd(0);

	xor	ecx, ecx
	call	AuInterruptEnd

; 409  : 		
; 410  : 		if (x86_64_is_cpu_fxsave_supported())

	call	?x86_64_is_cpu_fxsave_supported@@YA_NXZ	; x86_64_is_cpu_fxsave_supported
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@x8664Sched

; 411  : 			x64_fxrstor(current_thread->fx_state);

	mov	rax, QWORD PTR current_thread$[rsp]
	mov	rcx, QWORD PTR [rax+272]
	call	x64_fxrstor
$LN1@x8664Sched:

; 412  : 
; 413  : 		x64_set_kstack(ktss, current_thread->frame.kern_esp);

	mov	rax, QWORD PTR current_thread$[rsp]
	mov	rdx, QWORD PTR [rax+200]
	mov	rcx, QWORD PTR ktss$[rsp]
	call	x64_set_kstack

; 414  : 
; 415  : 		x64_ldmxcsr(&current_thread->mxcsr);

	mov	rax, QWORD PTR current_thread$[rsp]
	add	rax, 280				; 00000118H
	mov	rcx, rax
	call	x64_ldmxcsr

; 416  : 
; 417  : 		execute_idle(current_thread, ktss);

	mov	rdx, QWORD PTR ktss$[rsp]
	mov	rcx, QWORD PTR current_thread$[rsp]
	call	execute_idle
$LN4@x8664Sched:
$LN5@x8664Sched:
$sched_end$10:

; 418  : 	}
; 419  : 
; 420  : sched_end:
; 421  : 	AuInterruptEnd(0);

	xor	ecx, ecx
	call	AuInterruptEnd

; 422  : }

	add	rsp, 72					; 00000048H
	ret	0
?x8664SchedulerISR@@YAX_KPEAX@Z ENDP			; x8664SchedulerISR
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\hal\x86_64_sched.cpp
_TEXT	SEGMENT
_run_idle$ = 32
thread$ = 40
?AuNextThread@@YAXXZ PROC				; AuNextThread

; 338  : void AuNextThread() {

$LN13:
	sub	rsp, 56					; 00000038H

; 339  : 	AuThread* thread = AuPerCPUGetCurrentThread();

	call	?AuPerCPUGetCurrentThread@@YAPEAU_au_thread_@@XZ ; AuPerCPUGetCurrentThread
	mov	QWORD PTR thread$[rsp], rax

; 340  : 	bool _run_idle = false;

	mov	BYTE PTR _run_idle$[rsp], 0
$LN10@AuNextThre:

; 341  : 	do {
; 342  : 		if (thread->state == THREAD_STATE_SLEEP) {

	mov	rax, QWORD PTR thread$[rsp]
	movzx	eax, BYTE PTR [rax+300]
	cmp	eax, 4
	jne	SHORT $LN7@AuNextThre

; 343  : 			if (thread->quanta == 0) {

	mov	rax, QWORD PTR thread$[rsp]
	cmp	QWORD PTR [rax+303], 0
	jne	SHORT $LN6@AuNextThre

; 344  : 				thread->state = THREAD_STATE_READY;

	mov	rax, QWORD PTR thread$[rsp]
	mov	BYTE PTR [rax+300], 1

; 345  : 			}
; 346  : 			else{

	jmp	SHORT $LN5@AuNextThre
$LN6@AuNextThre:

; 347  : 				thread->quanta--;

	mov	rax, QWORD PTR thread$[rsp]
	mov	rax, QWORD PTR [rax+303]
	dec	rax
	mov	rcx, QWORD PTR thread$[rsp]
	mov	QWORD PTR [rcx+303], rax
$LN5@AuNextThre:
$LN7@AuNextThre:

; 348  : 			}
; 349  : 		}
; 350  : 		thread = thread->next;

	mov	rax, QWORD PTR thread$[rsp]
	mov	rax, QWORD PTR [rax+657]
	mov	QWORD PTR thread$[rsp], rax

; 351  : 		if (thread == NULL) {

	cmp	QWORD PTR thread$[rsp], 0
	jne	SHORT $LN4@AuNextThre

; 352  : 			thread = thread_list_head;

	mov	rax, QWORD PTR ?thread_list_head@@3PEAU_au_thread_@@EA ; thread_list_head
	mov	QWORD PTR thread$[rsp], rax
$LN4@AuNextThre:

; 353  : 		}
; 354  : 
; 355  : 		if (thread == _idle_thr)

	mov	rax, QWORD PTR ?_idle_thr@@3PEAU_au_thread_@@EA ; _idle_thr
	cmp	QWORD PTR thread$[rsp], rax
	jne	SHORT $LN3@AuNextThre

; 356  : 			thread = thread->next;

	mov	rax, QWORD PTR thread$[rsp]
	mov	rax, QWORD PTR [rax+657]
	mov	QWORD PTR thread$[rsp], rax
$LN3@AuNextThre:

; 357  : 
; 358  : 		if (!thread){

	cmp	QWORD PTR thread$[rsp], 0
	jne	SHORT $LN2@AuNextThre

; 359  : 			_run_idle = true;

	mov	BYTE PTR _run_idle$[rsp], 1

; 360  : 			break;

	jmp	SHORT $LN8@AuNextThre
$LN2@AuNextThre:

; 361  : 		}
; 362  : 	} while (thread->state != THREAD_STATE_READY);

	mov	rax, QWORD PTR thread$[rsp]
	movzx	eax, BYTE PTR [rax+300]
	cmp	eax, 1
	jne	$LN10@AuNextThre
$LN8@AuNextThre:
$end$14:

; 363  : 
; 364  : end:
; 365  : 	if (_run_idle)

	movzx	eax, BYTE PTR _run_idle$[rsp]
	test	eax, eax
	je	SHORT $LN1@AuNextThre

; 366  : 		thread = _idle_thr;

	mov	rax, QWORD PTR ?_idle_thr@@3PEAU_au_thread_@@EA ; _idle_thr
	mov	QWORD PTR thread$[rsp], rax
$LN1@AuNextThre:

; 367  : 
; 368  : 	//current_thread = thread;
; 369  : 	AuPerCPUSetCurrentThread(thread);

	mov	rcx, QWORD PTR thread$[rsp]
	call	?AuPerCPUSetCurrentThread@@YAXPEAX@Z	; AuPerCPUSetCurrentThread

; 370  : }

	add	rsp, 56					; 00000038H
	ret	0
?AuNextThread@@YAXXZ ENDP				; AuNextThread
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\hal\x86_64_sched.cpp
_TEXT	SEGMENT
t$ = 48
?AuIdleThread@@YAX_K@Z PROC				; AuIdleThread

; 297  : void AuIdleThread(uint64_t t) {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 298  : 	SeTextOut("_idle id -> %d  \r\n", AuPerCPUGetCpuID());

	call	?AuPerCPUGetCpuID@@YAEXZ		; AuPerCPUGetCpuID
	movzx	eax, al
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG3792
	call	SeTextOut
$LN2@AuIdleThre:

; 299  : 	while (1) {

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN1@AuIdleThre

; 300  : 		SeTextOut("IDLE \r\n");

	lea	rcx, OFFSET FLAT:$SG3796
	call	SeTextOut

; 301  : 		x64_hlt();

	call	x64_hlt

; 302  : 	}

	jmp	SHORT $LN2@AuIdleThre
$LN1@AuIdleThre:

; 303  : }

	add	rsp, 40					; 00000028H
	ret	0
?AuIdleThread@@YAX_K@Z ENDP				; AuIdleThread
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\hal\x86_64_sched.cpp
_TEXT	SEGMENT
thread$ = 8
?AuThreadDeleteTrash@@YAXPEAU_au_thread_@@@Z PROC	; AuThreadDeleteTrash

; 178  : void AuThreadDeleteTrash(AuThread* thread) {

	mov	QWORD PTR [rsp+8], rcx

; 179  : 
; 180  : 	if (trash_thr_head == NULL)

	cmp	QWORD PTR ?trash_thr_head@@3PEAU_au_thread_@@EA, 0 ; trash_thr_head
	jne	SHORT $LN5@AuThreadDe

; 181  : 		return;

	jmp	$LN6@AuThreadDe
$LN5@AuThreadDe:

; 182  : 
; 183  : 	if (thread == trash_thr_head) {

	mov	rax, QWORD PTR ?trash_thr_head@@3PEAU_au_thread_@@EA ; trash_thr_head
	cmp	QWORD PTR thread$[rsp], rax
	jne	SHORT $LN4@AuThreadDe

; 184  : 		trash_thr_head = trash_thr_head->next;

	mov	rax, QWORD PTR ?trash_thr_head@@3PEAU_au_thread_@@EA ; trash_thr_head
	mov	rax, QWORD PTR [rax+657]
	mov	QWORD PTR ?trash_thr_head@@3PEAU_au_thread_@@EA, rax ; trash_thr_head

; 185  : 	}
; 186  : 	else {

	jmp	SHORT $LN3@AuThreadDe
$LN4@AuThreadDe:

; 187  : 		thread->prev->next = thread->next;

	mov	rax, QWORD PTR thread$[rsp]
	mov	rax, QWORD PTR [rax+665]
	mov	rcx, QWORD PTR thread$[rsp]
	mov	rcx, QWORD PTR [rcx+657]
	mov	QWORD PTR [rax+657], rcx
$LN3@AuThreadDe:

; 188  : 	}
; 189  : 
; 190  : 	if (thread == trash_thr_last) {

	mov	rax, QWORD PTR ?trash_thr_last@@3PEAU_au_thread_@@EA ; trash_thr_last
	cmp	QWORD PTR thread$[rsp], rax
	jne	SHORT $LN2@AuThreadDe

; 191  : 		trash_thr_last = thread->prev;

	mov	rax, QWORD PTR thread$[rsp]
	mov	rax, QWORD PTR [rax+665]
	mov	QWORD PTR ?trash_thr_last@@3PEAU_au_thread_@@EA, rax ; trash_thr_last

; 192  : 	}
; 193  : 	else {

	jmp	SHORT $LN1@AuThreadDe
$LN2@AuThreadDe:

; 194  : 		thread->next->prev = thread->prev;

	mov	rax, QWORD PTR thread$[rsp]
	mov	rax, QWORD PTR [rax+657]
	mov	rcx, QWORD PTR thread$[rsp]
	mov	rcx, QWORD PTR [rcx+665]
	mov	QWORD PTR [rax+665], rcx
$LN1@AuThreadDe:
$LN6@AuThreadDe:

; 195  : 	}
; 196  : }

	ret	0
?AuThreadDeleteTrash@@YAXPEAU_au_thread_@@@Z ENDP	; AuThreadDeleteTrash
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\hal\x86_64_sched.cpp
_TEXT	SEGMENT
new_task$ = 8
?AuThreadInsertTrash@@YAXPEAU_au_thread_@@@Z PROC	; AuThreadInsertTrash

; 159  : void AuThreadInsertTrash(AuThread* new_task) {

	mov	QWORD PTR [rsp+8], rcx

; 160  : 	new_task->next = NULL;

	mov	rax, QWORD PTR new_task$[rsp]
	mov	QWORD PTR [rax+657], 0

; 161  : 	new_task->prev = NULL;

	mov	rax, QWORD PTR new_task$[rsp]
	mov	QWORD PTR [rax+665], 0

; 162  : 
; 163  : 	if (trash_thr_head == NULL) {

	cmp	QWORD PTR ?trash_thr_head@@3PEAU_au_thread_@@EA, 0 ; trash_thr_head
	jne	SHORT $LN2@AuThreadIn

; 164  : 		trash_thr_last = new_task;

	mov	rax, QWORD PTR new_task$[rsp]
	mov	QWORD PTR ?trash_thr_last@@3PEAU_au_thread_@@EA, rax ; trash_thr_last

; 165  : 		trash_thr_head = new_task;

	mov	rax, QWORD PTR new_task$[rsp]
	mov	QWORD PTR ?trash_thr_head@@3PEAU_au_thread_@@EA, rax ; trash_thr_head

; 166  : 	}
; 167  : 	else {

	jmp	SHORT $LN1@AuThreadIn
$LN2@AuThreadIn:

; 168  : 		trash_thr_last->next = new_task;

	mov	rax, QWORD PTR ?trash_thr_last@@3PEAU_au_thread_@@EA ; trash_thr_last
	mov	rcx, QWORD PTR new_task$[rsp]
	mov	QWORD PTR [rax+657], rcx

; 169  : 		new_task->prev = trash_thr_last;

	mov	rax, QWORD PTR new_task$[rsp]
	mov	rcx, QWORD PTR ?trash_thr_last@@3PEAU_au_thread_@@EA ; trash_thr_last
	mov	QWORD PTR [rax+665], rcx
$LN1@AuThreadIn:

; 170  : 	}
; 171  : 	trash_thr_last = new_task;

	mov	rax, QWORD PTR new_task$[rsp]
	mov	QWORD PTR ?trash_thr_last@@3PEAU_au_thread_@@EA, rax ; trash_thr_last

; 172  : }

	ret	0
?AuThreadInsertTrash@@YAXPEAU_au_thread_@@@Z ENDP	; AuThreadInsertTrash
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\hal\x86_64_sched.cpp
_TEXT	SEGMENT
thread$ = 8
?AuThreadDeleteBlock@@YAXPEAU_au_thread_@@@Z PROC	; AuThreadDeleteBlock

; 134  : void AuThreadDeleteBlock(AuThread* thread) {

	mov	QWORD PTR [rsp+8], rcx

; 135  : 
; 136  : 	if (blocked_thr_head == NULL)

	cmp	QWORD PTR ?blocked_thr_head@@3PEAU_au_thread_@@EA, 0 ; blocked_thr_head
	jne	SHORT $LN5@AuThreadDe

; 137  : 		return;

	jmp	$LN6@AuThreadDe
$LN5@AuThreadDe:

; 138  : 
; 139  : 	if (thread == blocked_thr_head) {

	mov	rax, QWORD PTR ?blocked_thr_head@@3PEAU_au_thread_@@EA ; blocked_thr_head
	cmp	QWORD PTR thread$[rsp], rax
	jne	SHORT $LN4@AuThreadDe

; 140  : 		blocked_thr_head = blocked_thr_head->next;

	mov	rax, QWORD PTR ?blocked_thr_head@@3PEAU_au_thread_@@EA ; blocked_thr_head
	mov	rax, QWORD PTR [rax+657]
	mov	QWORD PTR ?blocked_thr_head@@3PEAU_au_thread_@@EA, rax ; blocked_thr_head

; 141  : 	}
; 142  : 	else {

	jmp	SHORT $LN3@AuThreadDe
$LN4@AuThreadDe:

; 143  : 		thread->prev->next = thread->next;

	mov	rax, QWORD PTR thread$[rsp]
	mov	rax, QWORD PTR [rax+665]
	mov	rcx, QWORD PTR thread$[rsp]
	mov	rcx, QWORD PTR [rcx+657]
	mov	QWORD PTR [rax+657], rcx
$LN3@AuThreadDe:

; 144  : 	}
; 145  : 
; 146  : 	if (thread == blocked_thr_last) {

	mov	rax, QWORD PTR ?blocked_thr_last@@3PEAU_au_thread_@@EA ; blocked_thr_last
	cmp	QWORD PTR thread$[rsp], rax
	jne	SHORT $LN2@AuThreadDe

; 147  : 		blocked_thr_last = thread->prev;

	mov	rax, QWORD PTR thread$[rsp]
	mov	rax, QWORD PTR [rax+665]
	mov	QWORD PTR ?blocked_thr_last@@3PEAU_au_thread_@@EA, rax ; blocked_thr_last

; 148  : 	}
; 149  : 	else {

	jmp	SHORT $LN1@AuThreadDe
$LN2@AuThreadDe:

; 150  : 		thread->next->prev = thread->prev;

	mov	rax, QWORD PTR thread$[rsp]
	mov	rax, QWORD PTR [rax+657]
	mov	rcx, QWORD PTR thread$[rsp]
	mov	rcx, QWORD PTR [rcx+665]
	mov	QWORD PTR [rax+665], rcx
$LN1@AuThreadDe:
$LN6@AuThreadDe:

; 151  : 	}
; 152  : }

	ret	0
?AuThreadDeleteBlock@@YAXPEAU_au_thread_@@@Z ENDP	; AuThreadDeleteBlock
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\hal\x86_64_sched.cpp
_TEXT	SEGMENT
new_task$ = 8
?AuThreadInsertBlock@@YAXPEAU_au_thread_@@@Z PROC	; AuThreadInsertBlock

; 115  : void AuThreadInsertBlock(AuThread* new_task) {

	mov	QWORD PTR [rsp+8], rcx

; 116  : 	new_task->next = NULL;

	mov	rax, QWORD PTR new_task$[rsp]
	mov	QWORD PTR [rax+657], 0

; 117  : 	new_task->prev = NULL;

	mov	rax, QWORD PTR new_task$[rsp]
	mov	QWORD PTR [rax+665], 0

; 118  : 
; 119  : 	if (blocked_thr_head == NULL) {

	cmp	QWORD PTR ?blocked_thr_head@@3PEAU_au_thread_@@EA, 0 ; blocked_thr_head
	jne	SHORT $LN2@AuThreadIn

; 120  : 		blocked_thr_last = new_task;

	mov	rax, QWORD PTR new_task$[rsp]
	mov	QWORD PTR ?blocked_thr_last@@3PEAU_au_thread_@@EA, rax ; blocked_thr_last

; 121  : 		blocked_thr_head = new_task;

	mov	rax, QWORD PTR new_task$[rsp]
	mov	QWORD PTR ?blocked_thr_head@@3PEAU_au_thread_@@EA, rax ; blocked_thr_head

; 122  : 	}
; 123  : 	else {

	jmp	SHORT $LN1@AuThreadIn
$LN2@AuThreadIn:

; 124  : 		blocked_thr_last->next = new_task;

	mov	rax, QWORD PTR ?blocked_thr_last@@3PEAU_au_thread_@@EA ; blocked_thr_last
	mov	rcx, QWORD PTR new_task$[rsp]
	mov	QWORD PTR [rax+657], rcx

; 125  : 		new_task->prev = blocked_thr_last;

	mov	rax, QWORD PTR new_task$[rsp]
	mov	rcx, QWORD PTR ?blocked_thr_last@@3PEAU_au_thread_@@EA ; blocked_thr_last
	mov	QWORD PTR [rax+665], rcx
$LN1@AuThreadIn:

; 126  : 	}
; 127  : 	blocked_thr_last = new_task;

	mov	rax, QWORD PTR new_task$[rsp]
	mov	QWORD PTR ?blocked_thr_last@@3PEAU_au_thread_@@EA, rax ; blocked_thr_last

; 128  : }

	ret	0
?AuThreadInsertBlock@@YAXPEAU_au_thread_@@@Z ENDP	; AuThreadInsertBlock
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\hal\x86_64_sched.cpp
_TEXT	SEGMENT
thread$ = 8
?AuThreadDelete@@YAXPEAU_au_thread_@@@Z PROC		; AuThreadDelete

; 84   : void AuThreadDelete(AuThread* thread) {

	mov	QWORD PTR [rsp+8], rcx

; 85   : 
; 86   : 	if (thread_list_head == NULL)

	cmp	QWORD PTR ?thread_list_head@@3PEAU_au_thread_@@EA, 0 ; thread_list_head
	jne	SHORT $LN5@AuThreadDe

; 87   : 		return;

	jmp	$LN6@AuThreadDe
$LN5@AuThreadDe:

; 88   : 
; 89   : 	if (thread == thread_list_head) {

	mov	rax, QWORD PTR ?thread_list_head@@3PEAU_au_thread_@@EA ; thread_list_head
	cmp	QWORD PTR thread$[rsp], rax
	jne	SHORT $LN4@AuThreadDe

; 90   : 		thread_list_head = thread_list_head->next;

	mov	rax, QWORD PTR ?thread_list_head@@3PEAU_au_thread_@@EA ; thread_list_head
	mov	rax, QWORD PTR [rax+657]
	mov	QWORD PTR ?thread_list_head@@3PEAU_au_thread_@@EA, rax ; thread_list_head

; 91   : 	}
; 92   : 	else {

	jmp	SHORT $LN3@AuThreadDe
$LN4@AuThreadDe:

; 93   : 		thread->prev->next = thread->next;

	mov	rax, QWORD PTR thread$[rsp]
	mov	rax, QWORD PTR [rax+665]
	mov	rcx, QWORD PTR thread$[rsp]
	mov	rcx, QWORD PTR [rcx+657]
	mov	QWORD PTR [rax+657], rcx
$LN3@AuThreadDe:

; 94   : 	}
; 95   : 
; 96   : 	if (thread == thread_list_last) {

	mov	rax, QWORD PTR ?thread_list_last@@3PEAU_au_thread_@@EA ; thread_list_last
	cmp	QWORD PTR thread$[rsp], rax
	jne	SHORT $LN2@AuThreadDe

; 97   : 		thread_list_last = thread->prev;

	mov	rax, QWORD PTR thread$[rsp]
	mov	rax, QWORD PTR [rax+665]
	mov	QWORD PTR ?thread_list_last@@3PEAU_au_thread_@@EA, rax ; thread_list_last

; 98   : 	}
; 99   : 	else {

	jmp	SHORT $LN1@AuThreadDe
$LN2@AuThreadDe:

; 100  : 		thread->next->prev = thread->prev;

	mov	rax, QWORD PTR thread$[rsp]
	mov	rax, QWORD PTR [rax+657]
	mov	rcx, QWORD PTR thread$[rsp]
	mov	rcx, QWORD PTR [rcx+665]
	mov	QWORD PTR [rax+665], rcx
$LN1@AuThreadDe:
$LN6@AuThreadDe:

; 101  : 	}
; 102  : 
; 103  : 	/* donot free the thread, cuz when thread needs
; 104  : 	* to move from runnable queue to blocked queue
; 105  : 	* same address is used, rather call 'free'
; 106  : 	* externally
; 107  : 	*/
; 108  : }

	ret	0
?AuThreadDelete@@YAXPEAU_au_thread_@@@Z ENDP		; AuThreadDelete
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\hal\x86_64_sched.cpp
_TEXT	SEGMENT
new_task$ = 8
?AuThreadInsert@@YAXPEAU_au_thread_@@@Z PROC		; AuThreadInsert

; 65   : void AuThreadInsert(AuThread* new_task) {

	mov	QWORD PTR [rsp+8], rcx

; 66   : 	new_task->next = NULL;

	mov	rax, QWORD PTR new_task$[rsp]
	mov	QWORD PTR [rax+657], 0

; 67   : 	new_task->prev = NULL;

	mov	rax, QWORD PTR new_task$[rsp]
	mov	QWORD PTR [rax+665], 0

; 68   : 
; 69   : 	if (thread_list_head == NULL) {

	cmp	QWORD PTR ?thread_list_head@@3PEAU_au_thread_@@EA, 0 ; thread_list_head
	jne	SHORT $LN2@AuThreadIn

; 70   : 		thread_list_last = new_task;

	mov	rax, QWORD PTR new_task$[rsp]
	mov	QWORD PTR ?thread_list_last@@3PEAU_au_thread_@@EA, rax ; thread_list_last

; 71   : 		thread_list_head = new_task;

	mov	rax, QWORD PTR new_task$[rsp]
	mov	QWORD PTR ?thread_list_head@@3PEAU_au_thread_@@EA, rax ; thread_list_head

; 72   : 	}
; 73   : 	else {

	jmp	SHORT $LN1@AuThreadIn
$LN2@AuThreadIn:

; 74   : 		thread_list_last->next = new_task;

	mov	rax, QWORD PTR ?thread_list_last@@3PEAU_au_thread_@@EA ; thread_list_last
	mov	rcx, QWORD PTR new_task$[rsp]
	mov	QWORD PTR [rax+657], rcx

; 75   : 		new_task->prev = thread_list_last;

	mov	rax, QWORD PTR new_task$[rsp]
	mov	rcx, QWORD PTR ?thread_list_last@@3PEAU_au_thread_@@EA ; thread_list_last
	mov	QWORD PTR [rax+665], rcx
$LN1@AuThreadIn:

; 76   : 	}
; 77   : 	thread_list_last = new_task;

	mov	rax, QWORD PTR new_task$[rsp]
	mov	QWORD PTR ?thread_list_last@@3PEAU_au_thread_@@EA, rax ; thread_list_last

; 78   : }

	ret	0
?AuThreadInsert@@YAXPEAU_au_thread_@@@Z ENDP		; AuThreadInsert
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\hal\x86_64_sched.cpp
_TEXT	SEGMENT
AuGetSystemTimerTick PROC

; 569  : 	return scheduler_tick;

	mov	rax, QWORD PTR scheduler_tick

; 570  : }

	ret	0
AuGetSystemTimerTick ENDP
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\hal\x86_64_sched.cpp
_TEXT	SEGMENT
?AuIsSchedulerInitialised@@YA_NXZ PROC			; AuIsSchedulerInitialised

; 561  : 	return _x86_64_sched_init;

	movzx	eax, BYTE PTR ?_x86_64_sched_init@@3_NA	; _x86_64_sched_init

; 562  : }

	ret	0
?AuIsSchedulerInitialised@@YA_NXZ ENDP			; AuIsSchedulerInitialised
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\hal\x86_64_sched.cpp
_TEXT	SEGMENT
AuForceScheduler PROC

; 555  : AU_EXTERN AU_EXPORT void AuForceScheduler() {

$LN3:
	sub	rsp, 40					; 00000028H

; 556  : 	x64_force_sched();

	call	x64_force_sched

; 557  : }

	add	rsp, 40					; 00000028H
	ret	0
AuForceScheduler ENDP
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\hal\x86_64_sched.cpp
_TEXT	SEGMENT
block_queue$1 = 0
id$ = 32
AuThreadFindByIDBlockList PROC

; 543  : AuThread* AuThreadFindByIDBlockList(uint16_t id){

$LN7:
	mov	WORD PTR [rsp+8], cx
	sub	rsp, 24

; 544  : 	for (AuThread* block_queue = blocked_thr_head; block_queue != NULL; block_queue = block_queue->next){

	mov	rax, QWORD PTR ?blocked_thr_head@@3PEAU_au_thread_@@EA ; blocked_thr_head
	mov	QWORD PTR block_queue$1[rsp], rax
	jmp	SHORT $LN4@AuThreadFi
$LN3@AuThreadFi:
	mov	rax, QWORD PTR block_queue$1[rsp]
	mov	rax, QWORD PTR [rax+657]
	mov	QWORD PTR block_queue$1[rsp], rax
$LN4@AuThreadFi:
	cmp	QWORD PTR block_queue$1[rsp], 0
	je	SHORT $LN2@AuThreadFi

; 545  : 		if (block_queue->id == id)

	mov	rax, QWORD PTR block_queue$1[rsp]
	movzx	eax, WORD PTR [rax+301]
	movzx	ecx, WORD PTR id$[rsp]
	cmp	eax, ecx
	jne	SHORT $LN1@AuThreadFi

; 546  : 			return block_queue;

	mov	rax, QWORD PTR block_queue$1[rsp]
	jmp	SHORT $LN5@AuThreadFi
$LN1@AuThreadFi:

; 547  : 	}

	jmp	SHORT $LN3@AuThreadFi
$LN2@AuThreadFi:

; 548  : 	return NULL;

	xor	eax, eax
$LN5@AuThreadFi:

; 549  : }

	add	rsp, 24
	ret	0
AuThreadFindByIDBlockList ENDP
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\hal\x86_64_sched.cpp
_TEXT	SEGMENT
ready_queue_$1 = 0
id$ = 32
AuThreadFindByID PROC

; 530  : AuThread* AuThreadFindByID(uint16_t id) {

$LN7:
	mov	WORD PTR [rsp+8], cx
	sub	rsp, 24

; 531  : 	for (AuThread* ready_queue_ = thread_list_head; ready_queue_ != NULL; ready_queue_ = ready_queue_->next) {

	mov	rax, QWORD PTR ?thread_list_head@@3PEAU_au_thread_@@EA ; thread_list_head
	mov	QWORD PTR ready_queue_$1[rsp], rax
	jmp	SHORT $LN4@AuThreadFi
$LN3@AuThreadFi:
	mov	rax, QWORD PTR ready_queue_$1[rsp]
	mov	rax, QWORD PTR [rax+657]
	mov	QWORD PTR ready_queue_$1[rsp], rax
$LN4@AuThreadFi:
	cmp	QWORD PTR ready_queue_$1[rsp], 0
	je	SHORT $LN2@AuThreadFi

; 532  : 		if (ready_queue_->id == id)

	mov	rax, QWORD PTR ready_queue_$1[rsp]
	movzx	eax, WORD PTR [rax+301]
	movzx	ecx, WORD PTR id$[rsp]
	cmp	eax, ecx
	jne	SHORT $LN1@AuThreadFi

; 533  : 			return ready_queue_;

	mov	rax, QWORD PTR ready_queue_$1[rsp]
	jmp	SHORT $LN5@AuThreadFi
$LN1@AuThreadFi:

; 534  : 	}

	jmp	SHORT $LN3@AuThreadFi
$LN2@AuThreadFi:

; 535  : 	return NULL;

	xor	eax, eax
$LN5@AuThreadFi:

; 536  : }

	add	rsp, 24
	ret	0
AuThreadFindByID ENDP
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\hal\x86_64_sched.cpp
_TEXT	SEGMENT
t$ = 48
?AuThreadCleanTrash@@YAXPEAU_au_thread_@@@Z PROC	; AuThreadCleanTrash

; 521  : void AuThreadCleanTrash(AuThread* t) {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 522  : 	AuThreadDeleteTrash(t);

	mov	rcx, QWORD PTR t$[rsp]
	call	?AuThreadDeleteTrash@@YAXPEAU_au_thread_@@@Z ; AuThreadDeleteTrash

; 523  : }

	add	rsp, 40					; 00000028H
	ret	0
?AuThreadCleanTrash@@YAXPEAU_au_thread_@@@Z ENDP	; AuThreadCleanTrash
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\hal\x86_64_sched.cpp
_TEXT	SEGMENT
ready_queue_$1 = 32
block_queue_$2 = 40
t$ = 64
?AuThreadMoveToTrash@@YAXPEAU_au_thread_@@@Z PROC	; AuThreadMoveToTrash

; 494  : void AuThreadMoveToTrash(AuThread* t) {

$LN12:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 495  : 	if (!t)

	cmp	QWORD PTR t$[rsp], 0
	jne	SHORT $LN9@AuThreadMo

; 496  : 		return;

	jmp	$LN10@AuThreadMo
$LN9@AuThreadMo:

; 497  : 
; 498  : 	t->state = THREAD_STATE_KILLABLE;

	mov	rax, QWORD PTR t$[rsp]
	mov	BYTE PTR [rax+300], 5

; 499  : 
; 500  : 	/* search the thread in ready queue*/
; 501  : 	for (AuThread* ready_queue_ = thread_list_head; ready_queue_ != NULL; ready_queue_ = ready_queue_->next) {

	mov	rax, QWORD PTR ?thread_list_head@@3PEAU_au_thread_@@EA ; thread_list_head
	mov	QWORD PTR ready_queue_$1[rsp], rax
	jmp	SHORT $LN8@AuThreadMo
$LN7@AuThreadMo:
	mov	rax, QWORD PTR ready_queue_$1[rsp]
	mov	rax, QWORD PTR [rax+657]
	mov	QWORD PTR ready_queue_$1[rsp], rax
$LN8@AuThreadMo:
	cmp	QWORD PTR ready_queue_$1[rsp], 0
	je	SHORT $LN6@AuThreadMo

; 502  : 		if (ready_queue_ == t) 

	mov	rax, QWORD PTR t$[rsp]
	cmp	QWORD PTR ready_queue_$1[rsp], rax
	jne	SHORT $LN5@AuThreadMo

; 503  : 			AuThreadDelete(t);

	mov	rcx, QWORD PTR t$[rsp]
	call	?AuThreadDelete@@YAXPEAU_au_thread_@@@Z	; AuThreadDelete
$LN5@AuThreadMo:

; 504  : 	}

	jmp	SHORT $LN7@AuThreadMo
$LN6@AuThreadMo:

; 505  : 
; 506  : 	/* search the thread in block queue*/
; 507  : 	for (AuThread* block_queue_ = blocked_thr_head; block_queue_ != NULL; block_queue_ = block_queue_->next) {

	mov	rax, QWORD PTR ?blocked_thr_head@@3PEAU_au_thread_@@EA ; blocked_thr_head
	mov	QWORD PTR block_queue_$2[rsp], rax
	jmp	SHORT $LN4@AuThreadMo
$LN3@AuThreadMo:
	mov	rax, QWORD PTR block_queue_$2[rsp]
	mov	rax, QWORD PTR [rax+657]
	mov	QWORD PTR block_queue_$2[rsp], rax
$LN4@AuThreadMo:
	cmp	QWORD PTR block_queue_$2[rsp], 0
	je	SHORT $LN2@AuThreadMo

; 508  : 		if (block_queue_ == t)

	mov	rax, QWORD PTR t$[rsp]
	cmp	QWORD PTR block_queue_$2[rsp], rax
	jne	SHORT $LN1@AuThreadMo

; 509  : 			AuThreadDeleteBlock(t);

	mov	rcx, QWORD PTR t$[rsp]
	call	?AuThreadDeleteBlock@@YAXPEAU_au_thread_@@@Z ; AuThreadDeleteBlock
$LN1@AuThreadMo:

; 510  : 	}

	jmp	SHORT $LN3@AuThreadMo
$LN2@AuThreadMo:

; 511  : 
; 512  : 	/* insert it in the trash list */
; 513  : 	AuThreadInsertTrash(t);

	mov	rcx, QWORD PTR t$[rsp]
	call	?AuThreadInsertTrash@@YAXPEAU_au_thread_@@@Z ; AuThreadInsertTrash
$LN10@AuThreadMo:

; 514  : }

	add	rsp, 56					; 00000038H
	ret	0
?AuThreadMoveToTrash@@YAXPEAU_au_thread_@@@Z ENDP	; AuThreadMoveToTrash
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\hal\x86_64_sched.cpp
_TEXT	SEGMENT
found_$ = 32
thr$1 = 40
t$ = 64
AuUnblockThread PROC

; 475  : AU_EXTERN AU_EXPORT void AuUnblockThread(AuThread *t) {

$LN8:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 476  : 	t->state = THREAD_STATE_READY;

	mov	rax, QWORD PTR t$[rsp]
	mov	BYTE PTR [rax+300], 1

; 477  : 	bool found_ = false;

	mov	BYTE PTR found_$[rsp], 0

; 478  : 	for (AuThread *thr = blocked_thr_head; thr != NULL; thr = thr->next) {

	mov	rax, QWORD PTR ?blocked_thr_head@@3PEAU_au_thread_@@EA ; blocked_thr_head
	mov	QWORD PTR thr$1[rsp], rax
	jmp	SHORT $LN5@AuUnblockT
$LN4@AuUnblockT:
	mov	rax, QWORD PTR thr$1[rsp]
	mov	rax, QWORD PTR [rax+657]
	mov	QWORD PTR thr$1[rsp], rax
$LN5@AuUnblockT:
	cmp	QWORD PTR thr$1[rsp], 0
	je	SHORT $LN3@AuUnblockT

; 479  : 		if (thr == t) {

	mov	rax, QWORD PTR t$[rsp]
	cmp	QWORD PTR thr$1[rsp], rax
	jne	SHORT $LN2@AuUnblockT

; 480  : 			AuThreadDeleteBlock(thr);

	mov	rcx, QWORD PTR thr$1[rsp]
	call	?AuThreadDeleteBlock@@YAXPEAU_au_thread_@@@Z ; AuThreadDeleteBlock

; 481  : 			found_ = true;

	mov	BYTE PTR found_$[rsp], 1

; 482  : 			break;

	jmp	SHORT $LN3@AuUnblockT
$LN2@AuUnblockT:

; 483  : 		}
; 484  : 	}

	jmp	SHORT $LN4@AuUnblockT
$LN3@AuUnblockT:

; 485  : 	if (found_)

	movzx	eax, BYTE PTR found_$[rsp]
	test	eax, eax
	je	SHORT $LN1@AuUnblockT

; 486  : 		AuThreadInsert(t);

	mov	rcx, QWORD PTR t$[rsp]
	call	?AuThreadInsert@@YAXPEAU_au_thread_@@@Z	; AuThreadInsert
$LN1@AuUnblockT:

; 487  : }

	add	rsp, 56					; 00000038H
	ret	0
AuUnblockThread ENDP
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\hal\x86_64_sched.cpp
_TEXT	SEGMENT
thread$ = 8
ms$ = 16
AuSleepThread PROC

; 464  : AU_EXTERN AU_EXPORT void AuSleepThread(AuThread *thread, uint64_t ms) {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 465  : 	thread->state = THREAD_STATE_SLEEP;

	mov	rax, QWORD PTR thread$[rsp]
	mov	BYTE PTR [rax+300], 4

; 466  : 	thread->quanta = ms;

	mov	rax, QWORD PTR thread$[rsp]
	mov	rcx, QWORD PTR ms$[rsp]
	mov	QWORD PTR [rax+303], rcx

; 467  : }

	ret	0
AuSleepThread ENDP
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\hal\x86_64_sched.cpp
_TEXT	SEGMENT
thread$ = 48
AuBlockThread PROC

; 455  : AU_EXTERN AU_EXPORT void AuBlockThread(AuThread *thread) {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 456  : 	thread->state = THREAD_STATE_BLOCKED;

	mov	rax, QWORD PTR thread$[rsp]
	mov	BYTE PTR [rax+300], 3

; 457  : 	AuThreadDelete(thread);

	mov	rcx, QWORD PTR thread$[rsp]
	call	?AuThreadDelete@@YAXPEAU_au_thread_@@@Z	; AuThreadDelete

; 458  : 	AuThreadInsertBlock(thread);

	mov	rcx, QWORD PTR thread$[rsp]
	call	?AuThreadInsertBlock@@YAXPEAU_au_thread_@@@Z ; AuThreadInsertBlock

; 459  : }

	add	rsp, 40					; 00000028H
	ret	0
AuBlockThread ENDP
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\hal\x86_64_sched.cpp
_TEXT	SEGMENT
dest$ = 8
src$ = 16
?AuKThreadCopy@@YAXPEAU_au_thread_@@0@Z PROC		; AuKThreadCopy

; 271  : void AuKThreadCopy(AuThread* dest, AuThread* src) {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 272  : 	dest->frame.r15 = src->frame.r15;

	mov	rax, QWORD PTR dest$[rsp]
	mov	rcx, QWORD PTR src$[rsp]
	mov	rcx, QWORD PTR [rcx+152]
	mov	QWORD PTR [rax+152], rcx

; 273  : 	dest->frame.r14 = src->frame.r14;

	mov	rax, QWORD PTR dest$[rsp]
	mov	rcx, QWORD PTR src$[rsp]
	mov	rcx, QWORD PTR [rcx+144]
	mov	QWORD PTR [rax+144], rcx

; 274  : 	dest->frame.r13 = src->frame.r13;

	mov	rax, QWORD PTR dest$[rsp]
	mov	rcx, QWORD PTR src$[rsp]
	mov	rcx, QWORD PTR [rcx+136]
	mov	QWORD PTR [rax+136], rcx

; 275  : 	dest->frame.r12 = src->frame.r12;

	mov	rax, QWORD PTR dest$[rsp]
	mov	rcx, QWORD PTR src$[rsp]
	mov	rcx, QWORD PTR [rcx+128]
	mov	QWORD PTR [rax+128], rcx

; 276  : 	dest->frame.r11 = src->frame.r11;

	mov	rax, QWORD PTR dest$[rsp]
	mov	rcx, QWORD PTR src$[rsp]
	mov	rcx, QWORD PTR [rcx+120]
	mov	QWORD PTR [rax+120], rcx

; 277  : 	dest->frame.r10 = src->frame.r10;

	mov	rax, QWORD PTR dest$[rsp]
	mov	rcx, QWORD PTR src$[rsp]
	mov	rcx, QWORD PTR [rcx+112]
	mov	QWORD PTR [rax+112], rcx

; 278  : 	dest->frame.r9 = src->frame.r9;

	mov	rax, QWORD PTR dest$[rsp]
	mov	rcx, QWORD PTR src$[rsp]
	mov	rcx, QWORD PTR [rcx+104]
	mov	QWORD PTR [rax+104], rcx

; 279  : 	dest->frame.r8 = src->frame.r8;

	mov	rax, QWORD PTR dest$[rsp]
	mov	rcx, QWORD PTR src$[rsp]
	mov	rcx, QWORD PTR [rcx+96]
	mov	QWORD PTR [rax+96], rcx

; 280  : 	dest->frame.rdi = src->frame.rdi;

	mov	rax, QWORD PTR dest$[rsp]
	mov	rcx, QWORD PTR src$[rsp]
	mov	rcx, QWORD PTR [rcx+80]
	mov	QWORD PTR [rax+80], rcx

; 281  : 	dest->frame.rsi = src->frame.rsi;

	mov	rax, QWORD PTR dest$[rsp]
	mov	rcx, QWORD PTR src$[rsp]
	mov	rcx, QWORD PTR [rcx+72]
	mov	QWORD PTR [rax+72], rcx

; 282  : 	dest->frame.rdx = src->frame.rdx;

	mov	rax, QWORD PTR dest$[rsp]
	mov	rcx, QWORD PTR src$[rsp]
	mov	rcx, QWORD PTR [rcx+64]
	mov	QWORD PTR [rax+64], rcx

; 283  : 	dest->frame.rcx = src->frame.rcx;

	mov	rax, QWORD PTR dest$[rsp]
	mov	rcx, QWORD PTR src$[rsp]
	mov	rcx, QWORD PTR [rcx+56]
	mov	QWORD PTR [rax+56], rcx

; 284  : 	dest->frame.rbx = src->frame.rbx;

	mov	rax, QWORD PTR dest$[rsp]
	mov	rcx, QWORD PTR src$[rsp]
	mov	rcx, QWORD PTR [rcx+48]
	mov	QWORD PTR [rax+48], rcx

; 285  : 	dest->frame.rax = src->frame.rax;

	mov	rax, QWORD PTR dest$[rsp]
	mov	rcx, QWORD PTR src$[rsp]
	mov	rcx, QWORD PTR [rcx+40]
	mov	QWORD PTR [rax+40], rcx

; 286  : 	dest->frame.rip = src->frame.rip;

	mov	rax, QWORD PTR dest$[rsp]
	mov	rcx, QWORD PTR src$[rsp]
	mov	rcx, QWORD PTR [rcx+32]
	mov	QWORD PTR [rax+32], rcx

; 287  : 	dest->frame.cs = src->frame.cs;

	mov	rax, QWORD PTR dest$[rsp]
	mov	rcx, QWORD PTR src$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	mov	QWORD PTR [rax+24], rcx

; 288  : 	dest->frame.rflags = src->frame.rflags;

	mov	rax, QWORD PTR dest$[rsp]
	mov	rcx, QWORD PTR src$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	mov	QWORD PTR [rax+16], rcx

; 289  : 	dest->frame.ss = src->frame.ss;

	mov	rax, QWORD PTR dest$[rsp]
	mov	rcx, QWORD PTR src$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax], rcx

; 290  : 	dest->frame.ds = src->frame.ds;

	mov	rax, QWORD PTR dest$[rsp]
	mov	rcx, QWORD PTR src$[rsp]
	mov	rcx, QWORD PTR [rcx+160]
	mov	QWORD PTR [rax+160], rcx

; 291  : 	dest->frame.es = src->frame.es;

	mov	rax, QWORD PTR dest$[rsp]
	mov	rcx, QWORD PTR src$[rsp]
	mov	rcx, QWORD PTR [rcx+168]
	mov	QWORD PTR [rax+168], rcx

; 292  : 	dest->frame.fs = src->frame.fs;

	mov	rax, QWORD PTR dest$[rsp]
	mov	rcx, QWORD PTR src$[rsp]
	mov	rcx, QWORD PTR [rcx+176]
	mov	QWORD PTR [rax+176], rcx

; 293  : 	dest->frame.gs = src->frame.gs;

	mov	rax, QWORD PTR dest$[rsp]
	mov	rcx, QWORD PTR src$[rsp]
	mov	rcx, QWORD PTR [rcx+184]
	mov	QWORD PTR [rax+184], rcx

; 294  : }

	ret	0
?AuKThreadCopy@@YAXPEAU_au_thread_@@0@Z ENDP		; AuKThreadCopy
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\hal\x86_64_sched.cpp
_TEXT	SEGMENT
AuGetCurrentThread PROC

; 446  : AuThread* AuGetCurrentThread() {

$LN3:
	sub	rsp, 40					; 00000028H

; 447  : 	return AuPerCPUGetCurrentThread();

	call	?AuPerCPUGetCurrentThread@@YAPEAU_au_thread_@@XZ ; AuPerCPUGetCurrentThread

; 448  : }

	add	rsp, 40					; 00000028H
	ret	0
AuGetCurrentThread ENDP
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\hal\x86_64_sched.cpp
_TEXT	SEGMENT
t$ = 32
fx_addr$ = 40
entry$ = 64
stack$ = 72
cr3$ = 80
name$ = 88
AuCreateKthread PROC

; 208  : {

$LN4:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 209  : 	AuThread *t = (AuThread*)kmalloc(sizeof(AuThread));

	mov	ecx, 673				; 000002a1H
	call	kmalloc
	mov	QWORD PTR t$[rsp], rax

; 210  : 	memset(t, 0, sizeof(AuThread));

	mov	r8d, 673				; 000002a1H
	xor	edx, edx
	mov	rcx, QWORD PTR t$[rsp]
	call	memset

; 211  : 	t->frame.r15 = 0;

	mov	rax, QWORD PTR t$[rsp]
	mov	QWORD PTR [rax+152], 0

; 212  : 	t->frame.r14 = 0;

	mov	rax, QWORD PTR t$[rsp]
	mov	QWORD PTR [rax+144], 0

; 213  : 	t->frame.r13 = 0;

	mov	rax, QWORD PTR t$[rsp]
	mov	QWORD PTR [rax+136], 0

; 214  : 	t->frame.r12 = 0;

	mov	rax, QWORD PTR t$[rsp]
	mov	QWORD PTR [rax+128], 0

; 215  : 	t->frame.r11 = 0;

	mov	rax, QWORD PTR t$[rsp]
	mov	QWORD PTR [rax+120], 0

; 216  : 	t->frame.r10 = 0;

	mov	rax, QWORD PTR t$[rsp]
	mov	QWORD PTR [rax+112], 0

; 217  : 	t->frame.r9 = 0;

	mov	rax, QWORD PTR t$[rsp]
	mov	QWORD PTR [rax+104], 0

; 218  : 	t->frame.r8 = 0;

	mov	rax, QWORD PTR t$[rsp]
	mov	QWORD PTR [rax+96], 0

; 219  : 	t->frame.rbp = stack;

	mov	rax, QWORD PTR t$[rsp]
	mov	rcx, QWORD PTR stack$[rsp]
	mov	QWORD PTR [rax+88], rcx

; 220  : 	t->frame.rdi = 0;

	mov	rax, QWORD PTR t$[rsp]
	mov	QWORD PTR [rax+80], 0

; 221  : 	t->frame.rsi = 0;

	mov	rax, QWORD PTR t$[rsp]
	mov	QWORD PTR [rax+72], 0

; 222  : 	t->frame.rdx = 0;

	mov	rax, QWORD PTR t$[rsp]
	mov	QWORD PTR [rax+64], 0

; 223  : 	t->frame.rcx = 0;

	mov	rax, QWORD PTR t$[rsp]
	mov	QWORD PTR [rax+56], 0

; 224  : 	t->frame.rbx = 0;

	mov	rax, QWORD PTR t$[rsp]
	mov	QWORD PTR [rax+48], 0

; 225  : 	t->frame.rax = 0;

	mov	rax, QWORD PTR t$[rsp]
	mov	QWORD PTR [rax+40], 0

; 226  : 	t->frame.rip = (uint64_t)entry;

	mov	rax, QWORD PTR t$[rsp]
	mov	rcx, QWORD PTR entry$[rsp]
	mov	QWORD PTR [rax+32], rcx

; 227  : 	t->frame.cs = 0x08;

	mov	rax, QWORD PTR t$[rsp]
	mov	QWORD PTR [rax+24], 8

; 228  : 	t->frame.rflags = 0x286;

	mov	rax, QWORD PTR t$[rsp]
	mov	QWORD PTR [rax+16], 646			; 00000286H

; 229  : 	t->frame.rsp = stack;

	mov	rax, QWORD PTR t$[rsp]
	mov	rcx, QWORD PTR stack$[rsp]
	mov	QWORD PTR [rax+8], rcx

; 230  : 	t->frame.ss = 0x10;

	mov	rax, QWORD PTR t$[rsp]
	mov	QWORD PTR [rax], 16

; 231  : 	t->frame.kern_esp = stack;

	mov	rax, QWORD PTR t$[rsp]
	mov	rcx, QWORD PTR stack$[rsp]
	mov	QWORD PTR [rax+200], rcx

; 232  : 	t->user_stack = stack;

	mov	rax, QWORD PTR t$[rsp]
	mov	rcx, QWORD PTR stack$[rsp]
	mov	QWORD PTR [rax+216], rcx

; 233  : 	t->quanta = 0;

	mov	rax, QWORD PTR t$[rsp]
	mov	QWORD PTR [rax+303], 0

; 234  : 	t->frame.cr3 = cr3;

	mov	rax, QWORD PTR t$[rsp]
	mov	rcx, QWORD PTR cr3$[rsp]
	mov	QWORD PTR [rax+192], rcx

; 235  : 	t->priviledge = THREAD_LEVEL_KERNEL;

	mov	rax, QWORD PTR t$[rsp]
	mov	BYTE PTR [rax+311], 1

; 236  : 	t->state = THREAD_STATE_READY;

	mov	rax, QWORD PTR t$[rsp]
	mov	BYTE PTR [rax+300], 1

; 237  : 	t->frame.ds = t->frame.es = t->frame.fs = t->frame.gs = SEGVAL(GDT_ENTRY_KERNEL_DATA, 0);

	mov	rax, QWORD PTR t$[rsp]
	mov	QWORD PTR [rax+184], 16
	mov	rax, QWORD PTR t$[rsp]
	mov	QWORD PTR [rax+176], 16
	mov	rax, QWORD PTR t$[rsp]
	mov	QWORD PTR [rax+168], 16
	mov	rax, QWORD PTR t$[rsp]
	mov	QWORD PTR [rax+160], 16

; 238  : 	//t->frame.user_ = 0;
; 239  : 
; 240  : 	t->syscall_param.param1 = t->syscall_param.param2 = 0;

	mov	rax, QWORD PTR t$[rsp]
	mov	QWORD PTR [rax+232], 0
	mov	rax, QWORD PTR t$[rsp]
	mov	QWORD PTR [rax+224], 0

; 241  : 	t->syscall_param.param3 = t->syscall_param.param4 = 0;

	mov	rax, QWORD PTR t$[rsp]
	mov	QWORD PTR [rax+248], 0
	mov	rax, QWORD PTR t$[rsp]
	mov	QWORD PTR [rax+240], 0

; 242  : 	t->syscall_param.param5 = t->syscall_param.param6 = 0;

	mov	rax, QWORD PTR t$[rsp]
	mov	QWORD PTR [rax+264], 0
	mov	rax, QWORD PTR t$[rsp]
	mov	QWORD PTR [rax+256], 0

; 243  : 
; 244  : 	/* process will fill uentry */
; 245  : 	t->uentry = NULL; 

	mov	rax, QWORD PTR t$[rsp]
	mov	QWORD PTR [rax+641], 0

; 246  : 	memset(t->name, 0,16);

	mov	rax, QWORD PTR t$[rsp]
	add	rax, 284				; 0000011cH
	mov	r8d, 16
	xor	edx, edx
	mov	rcx, rax
	call	memset

; 247  : 	strcpy(t->name, name);

	mov	rax, QWORD PTR t$[rsp]
	add	rax, 284				; 0000011cH
	mov	rdx, QWORD PTR name$[rsp]
	mov	rcx, rax
	call	strcpy

; 248  : 	t->id = thread_id++;

	mov	rax, QWORD PTR t$[rsp]
	movzx	ecx, WORD PTR thread_id
	mov	WORD PTR [rax+301], cx
	movzx	eax, WORD PTR thread_id
	inc	ax
	mov	WORD PTR thread_id, ax

; 249  : 
; 250  : 	t->fx_state = (uint8_t*)kmalloc(512);

	mov	ecx, 512				; 00000200H
	call	kmalloc
	mov	rcx, QWORD PTR t$[rsp]
	mov	QWORD PTR [rcx+272], rax

; 251  : 
; 252  : 	/* align the fx_state memory to 16-byte boundary */
; 253  : 	size_t fx_addr = (size_t)t->fx_state;

	mov	rax, QWORD PTR t$[rsp]
	mov	rax, QWORD PTR [rax+272]
	mov	QWORD PTR fx_addr$[rsp], rax

; 254  : 	if ((size_t)t->fx_state & (16 - 1)) 

	mov	rax, QWORD PTR t$[rsp]
	mov	rax, QWORD PTR [rax+272]
	and	rax, 15
	test	rax, rax
	je	SHORT $LN1@AuCreateKt

; 255  : 		t->fx_state = (uint8_t*)(fx_addr | 16 - 1) + 1;

	mov	rax, QWORD PTR fx_addr$[rsp]
	or	rax, 15
	inc	rax
	mov	rcx, QWORD PTR t$[rsp]
	mov	QWORD PTR [rcx+272], rax
$LN1@AuCreateKt:

; 256  : 	
; 257  : 	memset(t->fx_state, 0, 512);

	mov	r8d, 512				; 00000200H
	xor	edx, edx
	mov	rax, QWORD PTR t$[rsp]
	mov	rcx, QWORD PTR [rax+272]
	call	memset

; 258  : 
; 259  : 	t->mxcsr = 0x1f80;

	mov	rax, QWORD PTR t$[rsp]
	mov	DWORD PTR [rax+280], 8064		; 00001f80H

; 260  : 	AuThreadInsert(t);

	mov	rcx, QWORD PTR t$[rsp]
	call	?AuThreadInsert@@YAXPEAU_au_thread_@@@Z	; AuThreadInsert

; 261  : 	return t;

	mov	rax, QWORD PTR t$[rsp]

; 262  : }

	add	rsp, 56					; 00000038H
	ret	0
AuCreateKthread ENDP
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\hal\x86_64_sched.cpp
_TEXT	SEGMENT
?AuSchedulerInitAp@@YAXXZ PROC				; AuSchedulerInitAp

; 330  : void AuSchedulerInitAp() {

$LN3:
	sub	rsp, 40					; 00000028H

; 331  : 	AuPerCPUSetCurrentThread(_idle_thr);

	mov	rcx, QWORD PTR ?_idle_thr@@3PEAU_au_thread_@@EA ; _idle_thr
	call	?AuPerCPUSetCurrentThread@@YAXPEAX@Z	; AuPerCPUSetCurrentThread

; 332  : }

	add	rsp, 40					; 00000028H
	ret	0
?AuSchedulerInitAp@@YAXXZ ENDP				; AuSchedulerInitAp
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\hal\x86_64_sched.cpp
_TEXT	SEGMENT
idle_$ = 32
tv68 = 40
?AuSchedulerInitialise@@YAXXZ PROC			; AuSchedulerInitialise

; 309  : void AuSchedulerInitialise() {

$LN3:
	sub	rsp, 56					; 00000038H

; 310  : 	thread_id = 0;

	xor	eax, eax
	mov	WORD PTR thread_id, ax

; 311  : 	thread_list_head = NULL;

	mov	QWORD PTR ?thread_list_head@@3PEAU_au_thread_@@EA, 0 ; thread_list_head

; 312  : 	thread_list_last = NULL;

	mov	QWORD PTR ?thread_list_last@@3PEAU_au_thread_@@EA, 0 ; thread_list_last

; 313  : 	blocked_thr_head = NULL;

	mov	QWORD PTR ?blocked_thr_head@@3PEAU_au_thread_@@EA, 0 ; blocked_thr_head

; 314  : 	blocked_thr_last = NULL;

	mov	QWORD PTR ?blocked_thr_last@@3PEAU_au_thread_@@EA, 0 ; blocked_thr_last

; 315  : 	trash_thr_head = NULL;

	mov	QWORD PTR ?trash_thr_head@@3PEAU_au_thread_@@EA, 0 ; trash_thr_head

; 316  : 	trash_thr_last = NULL;

	mov	QWORD PTR ?trash_thr_last@@3PEAU_au_thread_@@EA, 0 ; trash_thr_last

; 317  : 	_x86_64_sched_enable = true;

	mov	BYTE PTR ?_x86_64_sched_enable@@3_NA, 1	; _x86_64_sched_enable

; 318  : 	_x86_64_sched_init = false;

	mov	BYTE PTR ?_x86_64_sched_init@@3_NA, 0	; _x86_64_sched_init

; 319  : 	scheduler_tick = 0;

	mov	QWORD PTR scheduler_tick, 0

; 320  : 	_idle_lock = AuCreateSpinlock(false);

	xor	ecx, ecx
	call	AuCreateSpinlock
	mov	QWORD PTR ?_idle_lock@@3PEAU_spinlock_@@EA, rax ; _idle_lock

; 321  : 	AuThread *idle_ = AuCreateKthread(AuIdleThread, (uint64_t)P2V((uint64_t)AuPmmngrAlloc() + 4096), x64_read_cr3(), "Idle");

	call	x64_read_cr3
	mov	QWORD PTR tv68[rsp], rax
	call	AuPmmngrAlloc
	add	rax, 4096				; 00001000H
	mov	rcx, rax
	call	P2V
	lea	r9, OFFSET FLAT:$SG3802
	mov	rcx, QWORD PTR tv68[rsp]
	mov	r8, rcx
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:?AuIdleThread@@YAX_K@Z	; AuIdleThread
	call	AuCreateKthread
	mov	QWORD PTR idle_$[rsp], rax

; 322  : 	_idle_thr = idle_;

	mov	rax, QWORD PTR idle_$[rsp]
	mov	QWORD PTR ?_idle_thr@@3PEAU_au_thread_@@EA, rax ; _idle_thr

; 323  : 	AuPerCPUSetCurrentThread(idle_);

	mov	rcx, QWORD PTR idle_$[rsp]
	call	?AuPerCPUSetCurrentThread@@YAXPEAX@Z	; AuPerCPUSetCurrentThread

; 324  : }

	add	rsp, 56					; 00000038H
	ret	0
?AuSchedulerInitialise@@YAXXZ ENDP			; AuSchedulerInitialise
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\hal\x86_64_sched.cpp
_TEXT	SEGMENT
current_thread$ = 32
?AuSchedulerStart@@YAXXZ PROC				; AuSchedulerStart

; 428  : void AuSchedulerStart() {

$LN3:
	sub	rsp, 56					; 00000038H

; 429  : 	_x86_64_sched_init = true;

	mov	BYTE PTR ?_x86_64_sched_init@@3_NA, 1	; _x86_64_sched_init

; 430  : 	setvect(0x40, x8664SchedulerISR);  //0x40

	lea	rdx, OFFSET FLAT:?x8664SchedulerISR@@YAX_KPEAX@Z ; x8664SchedulerISR
	mov	ecx, 64					; 00000040H
	call	setvect

; 431  : 	AuThread* current_thread = AuPerCPUGetCurrentThread();

	call	?AuPerCPUGetCurrentThread@@YAPEAU_au_thread_@@XZ ; AuPerCPUGetCurrentThread
	mov	QWORD PTR current_thread$[rsp], rax

; 432  : 	execute_idle(current_thread, x86_64_get_tss());

	call	?x86_64_get_tss@@YAPEAU_tss@@XZ		; x86_64_get_tss
	mov	rdx, rax
	mov	rcx, QWORD PTR current_thread$[rsp]
	call	execute_idle

; 433  : }

	add	rsp, 56					; 00000038H
	ret	0
?AuSchedulerStart@@YAXXZ ENDP				; AuSchedulerStart
_TEXT	ENDS
END
