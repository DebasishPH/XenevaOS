; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30154.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?thread_list_head@@3PEAU_au_thread_@@EA		; thread_list_head
PUBLIC	?thread_list_last@@3PEAU_au_thread_@@EA		; thread_list_last
PUBLIC	?blocked_thr_head@@3PEAU_au_thread_@@EA		; blocked_thr_head
PUBLIC	?blocked_thr_last@@3PEAU_au_thread_@@EA		; blocked_thr_last
PUBLIC	?trash_thr_head@@3PEAU_au_thread_@@EA		; trash_thr_head
PUBLIC	?trash_thr_last@@3PEAU_au_thread_@@EA		; trash_thr_last
PUBLIC	?_x86_64_sched_enable@@3_NA			; _x86_64_sched_enable
PUBLIC	?_idle_thr@@3PEAU_au_thread_@@EA		; _idle_thr
PUBLIC	?_idle_lock@@3PEAU_spinlock_@@EA		; _idle_lock
PUBLIC	?_x86_64_sched_init@@3_NA			; _x86_64_sched_init
_BSS	SEGMENT
?thread_list_head@@3PEAU_au_thread_@@EA DQ 01H DUP (?)	; thread_list_head
?thread_list_last@@3PEAU_au_thread_@@EA DQ 01H DUP (?)	; thread_list_last
?blocked_thr_head@@3PEAU_au_thread_@@EA DQ 01H DUP (?)	; blocked_thr_head
?blocked_thr_last@@3PEAU_au_thread_@@EA DQ 01H DUP (?)	; blocked_thr_last
?trash_thr_head@@3PEAU_au_thread_@@EA DQ 01H DUP (?)	; trash_thr_head
?trash_thr_last@@3PEAU_au_thread_@@EA DQ 01H DUP (?)	; trash_thr_last
?_x86_64_sched_enable@@3_NA DB 01H DUP (?)		; _x86_64_sched_enable
	ALIGN	8

?_idle_thr@@3PEAU_au_thread_@@EA DQ 01H DUP (?)		; _idle_thr
?_idle_lock@@3PEAU_spinlock_@@EA DQ 01H DUP (?)		; _idle_lock
?_x86_64_sched_init@@3_NA DB 01H DUP (?)		; _x86_64_sched_init
_BSS	ENDS
msvcjmc	SEGMENT
__5A99B057_x86_64_sched@cpp DB 01H
msvcjmc	ENDS
PUBLIC	?AuSchedulerStart@@YAXXZ			; AuSchedulerStart
PUBLIC	?AuSchedulerInitialise@@YAXXZ			; AuSchedulerInitialise
PUBLIC	?AuSchedulerInitAp@@YAXXZ			; AuSchedulerInitAp
PUBLIC	AuCreateKthread
PUBLIC	AuGetCurrentThread
PUBLIC	?AuKThreadCopy@@YAXPEAU_au_thread_@@0@Z		; AuKThreadCopy
PUBLIC	AuBlockThread
PUBLIC	AuSleepThread
PUBLIC	AuUnblockThread
PUBLIC	?AuThreadMoveToTrash@@YAXPEAU_au_thread_@@@Z	; AuThreadMoveToTrash
PUBLIC	?AuThreadCleanTrash@@YAXPEAU_au_thread_@@@Z	; AuThreadCleanTrash
PUBLIC	AuThreadFindByID
PUBLIC	AuThreadFindByIDBlockList
PUBLIC	AuForceScheduler
PUBLIC	?AuIsSchedulerInitialised@@YA_NXZ		; AuIsSchedulerInitialised
PUBLIC	AuGetSystemTimerTick
PUBLIC	?AuThreadInsert@@YAXPEAU_au_thread_@@@Z		; AuThreadInsert
PUBLIC	?AuThreadDelete@@YAXPEAU_au_thread_@@@Z		; AuThreadDelete
PUBLIC	?AuThreadInsertBlock@@YAXPEAU_au_thread_@@@Z	; AuThreadInsertBlock
PUBLIC	?AuThreadDeleteBlock@@YAXPEAU_au_thread_@@@Z	; AuThreadDeleteBlock
PUBLIC	?AuThreadInsertTrash@@YAXPEAU_au_thread_@@@Z	; AuThreadInsertTrash
PUBLIC	?AuThreadDeleteTrash@@YAXPEAU_au_thread_@@@Z	; AuThreadDeleteTrash
PUBLIC	?AuIdleThread@@YAX_K@Z				; AuIdleThread
PUBLIC	?AuNextThread@@YAXXZ				; AuNextThread
PUBLIC	?x8664SchedulerISR@@YAX_KPEAX@Z			; x8664SchedulerISR
PUBLIC	AuPrintStack
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_0BD@BJBFFDAL@_idle?5id?5?9?$DO?5?$CFd?5?5?$AN?6@ ; `string'
PUBLIC	??_C@_07KGMHGBPD@IDLE?5?$AN?6@			; `string'
PUBLIC	??_C@_04IBDNPPCI@Idle@				; `string'
PUBLIC	??_C@_0N@DONLFIAN@CR3?5?9?$DO?5?$CFx?5?$AN?6@	; `string'
EXTRN	setvect:PROC
EXTRN	AuCreateSpinlock:PROC
EXTRN	?x86_64_get_tss@@YAPEAU_tss@@XZ:PROC		; x86_64_get_tss
EXTRN	?x86_64_is_cpu_fxsave_supported@@YA_NXZ:PROC	; x86_64_is_cpu_fxsave_supported
EXTRN	x64_cli:PROC
EXTRN	x64_hlt:PROC
EXTRN	x64_read_cr3:PROC
EXTRN	x64_fxsave:PROC
EXTRN	x64_fxrstor:PROC
EXTRN	x64_ldmxcsr:PROC
EXTRN	x64_set_kstack:PROC
EXTRN	x64_get_kstack:PROC
EXTRN	x64_force_sched:PROC
EXTRN	AuInterruptEnd:PROC
EXTRN	?AuCheckSignal@@YA_NPEAU_au_thread_@@PEAUinterrupt_stack_frame@@@Z:PROC ; AuCheckSignal
EXTRN	?AuGetSignal@@YAPEAU_signal_@@PEAU_au_thread_@@@Z:PROC ; AuGetSignal
EXTRN	?AuPrepareSignal@@YAXPEAU_au_thread_@@PEAUinterrupt_stack_frame@@PEAU_signal_@@@Z:PROC ; AuPrepareSignal
EXTRN	strcpy:PROC
EXTRN	memset:PROC
EXTRN	SeTextOut:PROC
EXTRN	kmalloc:PROC
EXTRN	?AuPerCPUGetCpuID@@YAEXZ:PROC			; AuPerCPUGetCpuID
EXTRN	?AuPerCPUSetCurrentThread@@YAXPEAX@Z:PROC	; AuPerCPUSetCurrentThread
EXTRN	?AuPerCPUGetCurrentThread@@YAPEAU_au_thread_@@XZ:PROC ; AuPerCPUGetCurrentThread
EXTRN	?AuPerCPUGetKernelTSS@@YAPEAU_tss@@XZ:PROC	; AuPerCPUGetKernelTSS
EXTRN	AuPmmngrAlloc:PROC
EXTRN	P2V:PROC
EXTRN	save_context:PROC
EXTRN	execute_idle:PROC
EXTRN	__CheckForDebuggerJustMyCode:PROC
_BSS	SEGMENT
	ALIGN	4

?thread_id@@3GA DW 01H DUP (?)				; thread_id
	ALIGN	8

?scheduler_tick@@3_KA DQ 01H DUP (?)			; scheduler_tick
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuSchedulerStart@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$?AuSchedulerStart@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuSchedulerInitialise@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+224
	DD	imagerel $unwind$?AuSchedulerInitialise@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuSchedulerInitAp@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+41
	DD	imagerel $unwind$?AuSchedulerInitAp@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AuCreateKthread DD imagerel $LN4
	DD	imagerel $LN4+789
	DD	imagerel $unwind$AuCreateKthread
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AuGetCurrentThread DD imagerel $LN3
	DD	imagerel $LN3+34
	DD	imagerel $unwind$AuGetCurrentThread
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuKThreadCopy@@YAXPEAU_au_thread_@@0@Z DD imagerel $LN3
	DD	imagerel $LN3+436
	DD	imagerel $unwind$?AuKThreadCopy@@YAXPEAU_au_thread_@@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AuBlockThread DD imagerel $LN3
	DD	imagerel $LN3+62
	DD	imagerel $unwind$AuBlockThread
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AuSleepThread DD imagerel $LN3
	DD	imagerel $LN3+64
	DD	imagerel $unwind$AuSleepThread
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AuUnblockThread DD imagerel $LN8
	DD	imagerel $LN8+127
	DD	imagerel $unwind$AuUnblockThread
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuThreadMoveToTrash@@YAXPEAU_au_thread_@@@Z DD imagerel $LN12
	DD	imagerel $LN12+177
	DD	imagerel $unwind$?AuThreadMoveToTrash@@YAXPEAU_au_thread_@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuThreadCleanTrash@@YAXPEAU_au_thread_@@@Z DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$?AuThreadCleanTrash@@YAXPEAU_au_thread_@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AuThreadFindByID DD imagerel $LN7
	DD	imagerel $LN7+97
	DD	imagerel $unwind$AuThreadFindByID
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AuThreadFindByIDBlockList DD imagerel $LN7
	DD	imagerel $LN7+97
	DD	imagerel $unwind$AuThreadFindByIDBlockList
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AuForceScheduler DD imagerel $LN3
	DD	imagerel $LN3+34
	DD	imagerel $unwind$AuForceScheduler
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuIsSchedulerInitialised@@YA_NXZ DD imagerel $LN3
	DD	imagerel $LN3+36
	DD	imagerel $unwind$?AuIsSchedulerInitialised@@YA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AuGetSystemTimerTick DD imagerel $LN3
	DD	imagerel $LN3+36
	DD	imagerel $unwind$AuGetSystemTimerTick
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuThreadInsert@@YAXPEAU_au_thread_@@@Z DD imagerel $LN5
	DD	imagerel $LN5+144
	DD	imagerel $unwind$?AuThreadInsert@@YAXPEAU_au_thread_@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuThreadDelete@@YAXPEAU_au_thread_@@@Z DD imagerel $LN8
	DD	imagerel $LN8+172
	DD	imagerel $unwind$?AuThreadDelete@@YAXPEAU_au_thread_@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuThreadInsertBlock@@YAXPEAU_au_thread_@@@Z DD imagerel $LN5
	DD	imagerel $LN5+144
	DD	imagerel $unwind$?AuThreadInsertBlock@@YAXPEAU_au_thread_@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuThreadDeleteBlock@@YAXPEAU_au_thread_@@@Z DD imagerel $LN8
	DD	imagerel $LN8+172
	DD	imagerel $unwind$?AuThreadDeleteBlock@@YAXPEAU_au_thread_@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuThreadInsertTrash@@YAXPEAU_au_thread_@@@Z DD imagerel $LN5
	DD	imagerel $LN5+144
	DD	imagerel $unwind$?AuThreadInsertTrash@@YAXPEAU_au_thread_@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuThreadDeleteTrash@@YAXPEAU_au_thread_@@@Z DD imagerel $LN8
	DD	imagerel $LN8+172
	DD	imagerel $unwind$?AuThreadDeleteTrash@@YAXPEAU_au_thread_@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuIdleThread@@YAX_K@Z DD imagerel $LN5
	DD	imagerel $LN5+81
	DD	imagerel $unwind$?AuIdleThread@@YAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuNextThread@@YAXXZ DD imagerel $LN13
	DD	imagerel $LN13+232
	DD	imagerel $unwind$?AuNextThread@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?x8664SchedulerISR@@YAX_KPEAX@Z DD imagerel $LN9
	DD	imagerel $LN9+352
	DD	imagerel $unwind$?x8664SchedulerISR@@YAX_KPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AuPrintStack DD imagerel $LN3
	DD	imagerel $LN3+49
	DD	imagerel $unwind$AuPrintStack
pdata	ENDS
;	COMDAT ??_C@_0N@DONLFIAN@CR3?5?9?$DO?5?$CFx?5?$AN?6@
CONST	SEGMENT
??_C@_0N@DONLFIAN@CR3?5?9?$DO?5?$CFx?5?$AN?6@ DB 'CR3 -> %x ', 0dH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04IBDNPPCI@Idle@
CONST	SEGMENT
??_C@_04IBDNPPCI@Idle@ DB 'Idle', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07KGMHGBPD@IDLE?5?$AN?6@
CONST	SEGMENT
??_C@_07KGMHGBPD@IDLE?5?$AN?6@ DB 'IDLE ', 0dH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@BJBFFDAL@_idle?5id?5?9?$DO?5?$CFd?5?5?$AN?6@
CONST	SEGMENT
??_C@_0BD@BJBFFDAL@_idle?5id?5?9?$DO?5?$CFd?5?5?$AN?6@ DB '_idle id -> %d'
	DB	'  ', 0dH, 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AuPrintStack DD 025030b01H
	DD	0b206230bH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?x8664SchedulerISR@@YAX_KPEAX@Z DD 025031701H
	DD	0f2122317H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuNextThread@@YAXXZ DD 025030b01H
	DD	0d206230bH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuIdleThread@@YAX_K@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuThreadDeleteTrash@@YAXPEAU_au_thread_@@@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuThreadInsertTrash@@YAXPEAU_au_thread_@@@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuThreadDeleteBlock@@YAXPEAU_au_thread_@@@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuThreadInsertBlock@@YAXPEAU_au_thread_@@@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuThreadDelete@@YAXPEAU_au_thread_@@@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuThreadInsert@@YAXPEAU_au_thread_@@@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AuGetSystemTimerTick DD 025030b01H
	DD	0b206230bH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuIsSchedulerInitialised@@YA_NXZ DD 025030b01H
	DD	0b206230bH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AuForceScheduler DD 025030b01H
	DD	0b206230bH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AuThreadFindByIDBlockList DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AuThreadFindByID DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuThreadCleanTrash@@YAXPEAU_au_thread_@@@Z DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuThreadMoveToTrash@@YAXPEAU_au_thread_@@@Z DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AuUnblockThread DD 025030f01H
	DD	0d20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AuSleepThread DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AuBlockThread DD 025030f01H
	DD	0b20a230fH
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuKThreadCopy@@YAXPEAU_au_thread_@@0@Z DD 025031401H
	DD	0b20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AuGetCurrentThread DD 025030b01H
	DD	0b206230bH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AuCreateKthread DD 025031e01H
	DD	0d219231eH
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuSchedulerInitAp@@YAXXZ DD 025030b01H
	DD	0b206230bH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuSchedulerInitialise@@YAXXZ DD 025030b01H
	DD	0d206230bH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuSchedulerStart@@YAXXZ DD 025030b01H
	DD	0d206230bH
	DD	05002H
xdata	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\x86_64_sched.cpp
;	COMDAT AuPrintStack
_TEXT	SEGMENT
AuPrintStack PROC					; COMDAT

; 437  : extern "C" void AuPrintStack() {

$LN3:
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__5A99B057_x86_64_sched@cpp
	call	__CheckForDebuggerJustMyCode

; 438  : 	SeTextOut("CR3 -> %x \r\n", x64_read_cr3());

	call	x64_read_cr3
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:??_C@_0N@DONLFIAN@CR3?5?9?$DO?5?$CFx?5?$AN?6@
	call	SeTextOut

; 439  : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
AuPrintStack ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\x86_64_sched.cpp
;	COMDAT ?x8664SchedulerISR@@YAX_KPEAX@Z
_TEXT	SEGMENT
frame$ = 0
ktss$ = 8
current_thread$ = 16
sig$1 = 24
v$ = 112
param$ = 120
?x8664SchedulerISR@@YAX_KPEAX@Z PROC			; x8664SchedulerISR, COMDAT

; 377  : void x8664SchedulerISR(size_t v, void* param) {

$LN9:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 128				; 00000080H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__5A99B057_x86_64_sched@cpp
	call	__CheckForDebuggerJustMyCode

; 378  : 	x64_cli();

	call	x64_cli

; 379  : 	interrupt_stack_frame *frame = (interrupt_stack_frame*)param;

	mov	rax, QWORD PTR param$[rbp]
	mov	QWORD PTR frame$[rbp], rax

; 380  : 
; 381  : 	if (_x86_64_sched_enable == false)

	movzx	eax, BYTE PTR ?_x86_64_sched_enable@@3_NA ; _x86_64_sched_enable
	test	eax, eax
	jne	SHORT $LN2@x8664Sched

; 382  : 		goto sched_end;

	jmp	$LN3@x8664Sched
	jmp	$sched_end$10
$LN2@x8664Sched:

; 383  : 
; 384  : 	TSS *ktss = AuPerCPUGetKernelTSS();

	call	?AuPerCPUGetKernelTSS@@YAPEAU_tss@@XZ	; AuPerCPUGetKernelTSS
	mov	QWORD PTR ktss$[rbp], rax

; 385  : 	AuThread* current_thread = AuPerCPUGetCurrentThread();

	call	?AuPerCPUGetCurrentThread@@YAPEAU_au_thread_@@XZ ; AuPerCPUGetCurrentThread
	mov	QWORD PTR current_thread$[rbp], rax

; 386  : 	if (save_context(current_thread, ktss) == 0) {

	mov	rdx, QWORD PTR ktss$[rbp]
	mov	rcx, QWORD PTR current_thread$[rbp]
	call	save_context
	test	eax, eax
	jne	$LN4@x8664Sched

; 387  : 		current_thread->frame.cr3 = x64_read_cr3();

	call	x64_read_cr3
	mov	rcx, QWORD PTR current_thread$[rbp]
	mov	QWORD PTR [rcx+192], rax

; 388  : 
; 389  : 		current_thread->frame.kern_esp = x64_get_kstack(ktss);

	mov	rcx, QWORD PTR ktss$[rbp]
	call	x64_get_kstack
	mov	rcx, QWORD PTR current_thread$[rbp]
	mov	QWORD PTR [rcx+200], rax

; 390  : 
; 391  : 		/* check for any signal */
; 392  : 		if (AuCheckSignal(current_thread, frame)) {

	mov	rdx, QWORD PTR frame$[rbp]
	mov	rcx, QWORD PTR current_thread$[rbp]
	call	?AuCheckSignal@@YA_NPEAU_au_thread_@@PEAUinterrupt_stack_frame@@@Z ; AuCheckSignal
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN5@x8664Sched

; 393  : 			Signal* sig = AuGetSignal(current_thread);

	mov	rcx, QWORD PTR current_thread$[rbp]
	call	?AuGetSignal@@YAPEAU_signal_@@PEAU_au_thread_@@@Z ; AuGetSignal
	mov	QWORD PTR sig$1[rbp], rax

; 394  : 			AuPrepareSignal(current_thread, frame, sig);

	mov	r8, QWORD PTR sig$1[rbp]
	mov	rdx, QWORD PTR frame$[rbp]
	mov	rcx, QWORD PTR current_thread$[rbp]
	call	?AuPrepareSignal@@YAXPEAU_au_thread_@@PEAUinterrupt_stack_frame@@PEAU_signal_@@@Z ; AuPrepareSignal
$LN5@x8664Sched:

; 395  : 
; 396  : 			/* actually, signal should be executed immediately
; 397  : 			 * here, AuSignalHandle() 
; 398  : 			 */
; 399  : 		}
; 400  : 
; 401  : 		if (x86_64_is_cpu_fxsave_supported())

	call	?x86_64_is_cpu_fxsave_supported@@YA_NXZ	; x86_64_is_cpu_fxsave_supported
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN6@x8664Sched

; 402  : 			x64_fxsave(current_thread->fx_state);

	mov	rax, QWORD PTR current_thread$[rbp]
	mov	rcx, QWORD PTR [rax+272]
	call	x64_fxsave
$LN6@x8664Sched:

; 403  : 
; 404  : 		scheduler_tick++;

	mov	rax, QWORD PTR ?scheduler_tick@@3_KA
	inc	rax
	mov	QWORD PTR ?scheduler_tick@@3_KA, rax

; 405  : 		AuNextThread();

	call	?AuNextThread@@YAXXZ			; AuNextThread

; 406  : 		current_thread = AuPerCPUGetCurrentThread();

	call	?AuPerCPUGetCurrentThread@@YAPEAU_au_thread_@@XZ ; AuPerCPUGetCurrentThread
	mov	QWORD PTR current_thread$[rbp], rax

; 407  : 		
; 408  : 		AuInterruptEnd(0);

	xor	ecx, ecx
	call	AuInterruptEnd

; 409  : 		
; 410  : 		if (x86_64_is_cpu_fxsave_supported())

	call	?x86_64_is_cpu_fxsave_supported@@YA_NXZ	; x86_64_is_cpu_fxsave_supported
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN7@x8664Sched

; 411  : 			x64_fxrstor(current_thread->fx_state);

	mov	rax, QWORD PTR current_thread$[rbp]
	mov	rcx, QWORD PTR [rax+272]
	call	x64_fxrstor
$LN7@x8664Sched:

; 412  : 
; 413  : 		x64_set_kstack(ktss, current_thread->frame.kern_esp);

	mov	rax, QWORD PTR current_thread$[rbp]
	mov	rdx, QWORD PTR [rax+200]
	mov	rcx, QWORD PTR ktss$[rbp]
	call	x64_set_kstack

; 414  : 
; 415  : 		x64_ldmxcsr(&current_thread->mxcsr);

	mov	rax, QWORD PTR current_thread$[rbp]
	add	rax, 280				; 00000118H
	mov	rcx, rax
	call	x64_ldmxcsr

; 416  : 
; 417  : 		execute_idle(current_thread, ktss);

	mov	rdx, QWORD PTR ktss$[rbp]
	mov	rcx, QWORD PTR current_thread$[rbp]
	call	execute_idle
$LN4@x8664Sched:
$LN3@x8664Sched:
$sched_end$10:

; 418  : 	}
; 419  : 
; 420  : sched_end:
; 421  : 	AuInterruptEnd(0);

	xor	ecx, ecx
	call	AuInterruptEnd

; 422  : }

	lea	rsp, QWORD PTR [rbp+96]
	pop	rbp
	ret	0
?x8664SchedulerISR@@YAX_KPEAX@Z ENDP			; x8664SchedulerISR
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\x86_64_sched.cpp
;	COMDAT ?AuNextThread@@YAXXZ
_TEXT	SEGMENT
thread$ = 0
_run_idle$ = 8
?AuNextThread@@YAXXZ PROC				; AuNextThread, COMDAT

; 338  : void AuNextThread() {

$LN13:
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__5A99B057_x86_64_sched@cpp
	call	__CheckForDebuggerJustMyCode

; 339  : 	AuThread* thread = AuPerCPUGetCurrentThread();

	call	?AuPerCPUGetCurrentThread@@YAPEAU_au_thread_@@XZ ; AuPerCPUGetCurrentThread
	mov	QWORD PTR thread$[rbp], rax

; 340  : 	bool _run_idle = false;

	mov	BYTE PTR _run_idle$[rbp], 0
$LN4@AuNextThre:

; 341  : 	do {
; 342  : 		if (thread->state == THREAD_STATE_SLEEP) {

	mov	rax, QWORD PTR thread$[rbp]
	movzx	eax, BYTE PTR [rax+300]
	cmp	eax, 4
	jne	SHORT $LN5@AuNextThre

; 343  : 			if (thread->quanta == 0) {

	mov	rax, QWORD PTR thread$[rbp]
	cmp	QWORD PTR [rax+303], 0
	jne	SHORT $LN6@AuNextThre

; 344  : 				thread->state = THREAD_STATE_READY;

	mov	rax, QWORD PTR thread$[rbp]
	mov	BYTE PTR [rax+300], 1

; 345  : 			}

	jmp	SHORT $LN7@AuNextThre
$LN6@AuNextThre:

; 346  : 			else{
; 347  : 				thread->quanta--;

	mov	rax, QWORD PTR thread$[rbp]
	mov	rax, QWORD PTR [rax+303]
	dec	rax
	mov	rcx, QWORD PTR thread$[rbp]
	mov	QWORD PTR [rcx+303], rax
$LN7@AuNextThre:
$LN5@AuNextThre:

; 348  : 			}
; 349  : 		}
; 350  : 		thread = thread->next;

	mov	rax, QWORD PTR thread$[rbp]
	mov	rax, QWORD PTR [rax+657]
	mov	QWORD PTR thread$[rbp], rax

; 351  : 		if (thread == NULL) {

	cmp	QWORD PTR thread$[rbp], 0
	jne	SHORT $LN8@AuNextThre

; 352  : 			thread = thread_list_head;

	mov	rax, QWORD PTR ?thread_list_head@@3PEAU_au_thread_@@EA ; thread_list_head
	mov	QWORD PTR thread$[rbp], rax
$LN8@AuNextThre:

; 353  : 		}
; 354  : 
; 355  : 		if (thread == _idle_thr)

	mov	rax, QWORD PTR ?_idle_thr@@3PEAU_au_thread_@@EA ; _idle_thr
	cmp	QWORD PTR thread$[rbp], rax
	jne	SHORT $LN9@AuNextThre

; 356  : 			thread = thread->next;

	mov	rax, QWORD PTR thread$[rbp]
	mov	rax, QWORD PTR [rax+657]
	mov	QWORD PTR thread$[rbp], rax
$LN9@AuNextThre:

; 357  : 
; 358  : 		if (!thread){

	cmp	QWORD PTR thread$[rbp], 0
	jne	SHORT $LN10@AuNextThre

; 359  : 			_run_idle = true;

	mov	BYTE PTR _run_idle$[rbp], 1

; 360  : 			break;

	jmp	SHORT $LN3@AuNextThre
$LN10@AuNextThre:

; 361  : 		}
; 362  : 	} while (thread->state != THREAD_STATE_READY);

	mov	rax, QWORD PTR thread$[rbp]
	movzx	eax, BYTE PTR [rax+300]
	cmp	eax, 1
	jne	$LN4@AuNextThre
$LN3@AuNextThre:
$end$14:

; 363  : 
; 364  : end:
; 365  : 	if (_run_idle)

	movzx	eax, BYTE PTR _run_idle$[rbp]
	test	eax, eax
	je	SHORT $LN11@AuNextThre

; 366  : 		thread = _idle_thr;

	mov	rax, QWORD PTR ?_idle_thr@@3PEAU_au_thread_@@EA ; _idle_thr
	mov	QWORD PTR thread$[rbp], rax
$LN11@AuNextThre:

; 367  : 
; 368  : 	//current_thread = thread;
; 369  : 	AuPerCPUSetCurrentThread(thread);

	mov	rcx, QWORD PTR thread$[rbp]
	call	?AuPerCPUSetCurrentThread@@YAXPEAX@Z	; AuPerCPUSetCurrentThread

; 370  : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
?AuNextThread@@YAXXZ ENDP				; AuNextThread
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\x86_64_sched.cpp
;	COMDAT ?AuIdleThread@@YAX_K@Z
_TEXT	SEGMENT
t$ = 80
?AuIdleThread@@YAX_K@Z PROC				; AuIdleThread, COMDAT

; 297  : void AuIdleThread(uint64_t t) {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__5A99B057_x86_64_sched@cpp
	call	__CheckForDebuggerJustMyCode

; 298  : 	SeTextOut("_idle id -> %d  \r\n", AuPerCPUGetCpuID());

	call	?AuPerCPUGetCpuID@@YAEXZ		; AuPerCPUGetCpuID
	movzx	eax, al
	mov	edx, eax
	lea	rcx, OFFSET FLAT:??_C@_0BD@BJBFFDAL@_idle?5id?5?9?$DO?5?$CFd?5?5?$AN?6@
	call	SeTextOut
$LN2@AuIdleThre:

; 299  : 	while (1) {

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN3@AuIdleThre

; 300  : 		SeTextOut("IDLE \r\n");

	lea	rcx, OFFSET FLAT:??_C@_07KGMHGBPD@IDLE?5?$AN?6@
	call	SeTextOut

; 301  : 		x64_hlt();

	call	x64_hlt

; 302  : 	}

	jmp	SHORT $LN2@AuIdleThre
$LN3@AuIdleThre:

; 303  : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
?AuIdleThread@@YAX_K@Z ENDP				; AuIdleThread
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\x86_64_sched.cpp
;	COMDAT ?AuThreadDeleteTrash@@YAXPEAU_au_thread_@@@Z
_TEXT	SEGMENT
thread$ = 80
?AuThreadDeleteTrash@@YAXPEAU_au_thread_@@@Z PROC	; AuThreadDeleteTrash, COMDAT

; 178  : void AuThreadDeleteTrash(AuThread* thread) {

$LN8:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__5A99B057_x86_64_sched@cpp
	call	__CheckForDebuggerJustMyCode

; 179  : 
; 180  : 	if (trash_thr_head == NULL)

	cmp	QWORD PTR ?trash_thr_head@@3PEAU_au_thread_@@EA, 0 ; trash_thr_head
	jne	SHORT $LN2@AuThreadDe

; 181  : 		return;

	jmp	SHORT $LN1@AuThreadDe
$LN2@AuThreadDe:

; 182  : 
; 183  : 	if (thread == trash_thr_head) {

	mov	rax, QWORD PTR ?trash_thr_head@@3PEAU_au_thread_@@EA ; trash_thr_head
	cmp	QWORD PTR thread$[rbp], rax
	jne	SHORT $LN3@AuThreadDe

; 184  : 		trash_thr_head = trash_thr_head->next;

	mov	rax, QWORD PTR ?trash_thr_head@@3PEAU_au_thread_@@EA ; trash_thr_head
	mov	rax, QWORD PTR [rax+657]
	mov	QWORD PTR ?trash_thr_head@@3PEAU_au_thread_@@EA, rax ; trash_thr_head

; 185  : 	}

	jmp	SHORT $LN4@AuThreadDe
$LN3@AuThreadDe:

; 186  : 	else {
; 187  : 		thread->prev->next = thread->next;

	mov	rax, QWORD PTR thread$[rbp]
	mov	rax, QWORD PTR [rax+665]
	mov	rcx, QWORD PTR thread$[rbp]
	mov	rcx, QWORD PTR [rcx+657]
	mov	QWORD PTR [rax+657], rcx
$LN4@AuThreadDe:

; 188  : 	}
; 189  : 
; 190  : 	if (thread == trash_thr_last) {

	mov	rax, QWORD PTR ?trash_thr_last@@3PEAU_au_thread_@@EA ; trash_thr_last
	cmp	QWORD PTR thread$[rbp], rax
	jne	SHORT $LN5@AuThreadDe

; 191  : 		trash_thr_last = thread->prev;

	mov	rax, QWORD PTR thread$[rbp]
	mov	rax, QWORD PTR [rax+665]
	mov	QWORD PTR ?trash_thr_last@@3PEAU_au_thread_@@EA, rax ; trash_thr_last

; 192  : 	}

	jmp	SHORT $LN6@AuThreadDe
$LN5@AuThreadDe:

; 193  : 	else {
; 194  : 		thread->next->prev = thread->prev;

	mov	rax, QWORD PTR thread$[rbp]
	mov	rax, QWORD PTR [rax+657]
	mov	rcx, QWORD PTR thread$[rbp]
	mov	rcx, QWORD PTR [rcx+665]
	mov	QWORD PTR [rax+665], rcx
$LN6@AuThreadDe:
$LN1@AuThreadDe:

; 195  : 	}
; 196  : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
?AuThreadDeleteTrash@@YAXPEAU_au_thread_@@@Z ENDP	; AuThreadDeleteTrash
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\x86_64_sched.cpp
;	COMDAT ?AuThreadInsertTrash@@YAXPEAU_au_thread_@@@Z
_TEXT	SEGMENT
new_task$ = 80
?AuThreadInsertTrash@@YAXPEAU_au_thread_@@@Z PROC	; AuThreadInsertTrash, COMDAT

; 159  : void AuThreadInsertTrash(AuThread* new_task) {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__5A99B057_x86_64_sched@cpp
	call	__CheckForDebuggerJustMyCode

; 160  : 	new_task->next = NULL;

	mov	rax, QWORD PTR new_task$[rbp]
	mov	QWORD PTR [rax+657], 0

; 161  : 	new_task->prev = NULL;

	mov	rax, QWORD PTR new_task$[rbp]
	mov	QWORD PTR [rax+665], 0

; 162  : 
; 163  : 	if (trash_thr_head == NULL) {

	cmp	QWORD PTR ?trash_thr_head@@3PEAU_au_thread_@@EA, 0 ; trash_thr_head
	jne	SHORT $LN2@AuThreadIn

; 164  : 		trash_thr_last = new_task;

	mov	rax, QWORD PTR new_task$[rbp]
	mov	QWORD PTR ?trash_thr_last@@3PEAU_au_thread_@@EA, rax ; trash_thr_last

; 165  : 		trash_thr_head = new_task;

	mov	rax, QWORD PTR new_task$[rbp]
	mov	QWORD PTR ?trash_thr_head@@3PEAU_au_thread_@@EA, rax ; trash_thr_head

; 166  : 	}

	jmp	SHORT $LN3@AuThreadIn
$LN2@AuThreadIn:

; 167  : 	else {
; 168  : 		trash_thr_last->next = new_task;

	mov	rax, QWORD PTR ?trash_thr_last@@3PEAU_au_thread_@@EA ; trash_thr_last
	mov	rcx, QWORD PTR new_task$[rbp]
	mov	QWORD PTR [rax+657], rcx

; 169  : 		new_task->prev = trash_thr_last;

	mov	rax, QWORD PTR new_task$[rbp]
	mov	rcx, QWORD PTR ?trash_thr_last@@3PEAU_au_thread_@@EA ; trash_thr_last
	mov	QWORD PTR [rax+665], rcx
$LN3@AuThreadIn:

; 170  : 	}
; 171  : 	trash_thr_last = new_task;

	mov	rax, QWORD PTR new_task$[rbp]
	mov	QWORD PTR ?trash_thr_last@@3PEAU_au_thread_@@EA, rax ; trash_thr_last

; 172  : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
?AuThreadInsertTrash@@YAXPEAU_au_thread_@@@Z ENDP	; AuThreadInsertTrash
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\x86_64_sched.cpp
;	COMDAT ?AuThreadDeleteBlock@@YAXPEAU_au_thread_@@@Z
_TEXT	SEGMENT
thread$ = 80
?AuThreadDeleteBlock@@YAXPEAU_au_thread_@@@Z PROC	; AuThreadDeleteBlock, COMDAT

; 134  : void AuThreadDeleteBlock(AuThread* thread) {

$LN8:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__5A99B057_x86_64_sched@cpp
	call	__CheckForDebuggerJustMyCode

; 135  : 
; 136  : 	if (blocked_thr_head == NULL)

	cmp	QWORD PTR ?blocked_thr_head@@3PEAU_au_thread_@@EA, 0 ; blocked_thr_head
	jne	SHORT $LN2@AuThreadDe

; 137  : 		return;

	jmp	SHORT $LN1@AuThreadDe
$LN2@AuThreadDe:

; 138  : 
; 139  : 	if (thread == blocked_thr_head) {

	mov	rax, QWORD PTR ?blocked_thr_head@@3PEAU_au_thread_@@EA ; blocked_thr_head
	cmp	QWORD PTR thread$[rbp], rax
	jne	SHORT $LN3@AuThreadDe

; 140  : 		blocked_thr_head = blocked_thr_head->next;

	mov	rax, QWORD PTR ?blocked_thr_head@@3PEAU_au_thread_@@EA ; blocked_thr_head
	mov	rax, QWORD PTR [rax+657]
	mov	QWORD PTR ?blocked_thr_head@@3PEAU_au_thread_@@EA, rax ; blocked_thr_head

; 141  : 	}

	jmp	SHORT $LN4@AuThreadDe
$LN3@AuThreadDe:

; 142  : 	else {
; 143  : 		thread->prev->next = thread->next;

	mov	rax, QWORD PTR thread$[rbp]
	mov	rax, QWORD PTR [rax+665]
	mov	rcx, QWORD PTR thread$[rbp]
	mov	rcx, QWORD PTR [rcx+657]
	mov	QWORD PTR [rax+657], rcx
$LN4@AuThreadDe:

; 144  : 	}
; 145  : 
; 146  : 	if (thread == blocked_thr_last) {

	mov	rax, QWORD PTR ?blocked_thr_last@@3PEAU_au_thread_@@EA ; blocked_thr_last
	cmp	QWORD PTR thread$[rbp], rax
	jne	SHORT $LN5@AuThreadDe

; 147  : 		blocked_thr_last = thread->prev;

	mov	rax, QWORD PTR thread$[rbp]
	mov	rax, QWORD PTR [rax+665]
	mov	QWORD PTR ?blocked_thr_last@@3PEAU_au_thread_@@EA, rax ; blocked_thr_last

; 148  : 	}

	jmp	SHORT $LN6@AuThreadDe
$LN5@AuThreadDe:

; 149  : 	else {
; 150  : 		thread->next->prev = thread->prev;

	mov	rax, QWORD PTR thread$[rbp]
	mov	rax, QWORD PTR [rax+657]
	mov	rcx, QWORD PTR thread$[rbp]
	mov	rcx, QWORD PTR [rcx+665]
	mov	QWORD PTR [rax+665], rcx
$LN6@AuThreadDe:
$LN1@AuThreadDe:

; 151  : 	}
; 152  : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
?AuThreadDeleteBlock@@YAXPEAU_au_thread_@@@Z ENDP	; AuThreadDeleteBlock
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\x86_64_sched.cpp
;	COMDAT ?AuThreadInsertBlock@@YAXPEAU_au_thread_@@@Z
_TEXT	SEGMENT
new_task$ = 80
?AuThreadInsertBlock@@YAXPEAU_au_thread_@@@Z PROC	; AuThreadInsertBlock, COMDAT

; 115  : void AuThreadInsertBlock(AuThread* new_task) {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__5A99B057_x86_64_sched@cpp
	call	__CheckForDebuggerJustMyCode

; 116  : 	new_task->next = NULL;

	mov	rax, QWORD PTR new_task$[rbp]
	mov	QWORD PTR [rax+657], 0

; 117  : 	new_task->prev = NULL;

	mov	rax, QWORD PTR new_task$[rbp]
	mov	QWORD PTR [rax+665], 0

; 118  : 
; 119  : 	if (blocked_thr_head == NULL) {

	cmp	QWORD PTR ?blocked_thr_head@@3PEAU_au_thread_@@EA, 0 ; blocked_thr_head
	jne	SHORT $LN2@AuThreadIn

; 120  : 		blocked_thr_last = new_task;

	mov	rax, QWORD PTR new_task$[rbp]
	mov	QWORD PTR ?blocked_thr_last@@3PEAU_au_thread_@@EA, rax ; blocked_thr_last

; 121  : 		blocked_thr_head = new_task;

	mov	rax, QWORD PTR new_task$[rbp]
	mov	QWORD PTR ?blocked_thr_head@@3PEAU_au_thread_@@EA, rax ; blocked_thr_head

; 122  : 	}

	jmp	SHORT $LN3@AuThreadIn
$LN2@AuThreadIn:

; 123  : 	else {
; 124  : 		blocked_thr_last->next = new_task;

	mov	rax, QWORD PTR ?blocked_thr_last@@3PEAU_au_thread_@@EA ; blocked_thr_last
	mov	rcx, QWORD PTR new_task$[rbp]
	mov	QWORD PTR [rax+657], rcx

; 125  : 		new_task->prev = blocked_thr_last;

	mov	rax, QWORD PTR new_task$[rbp]
	mov	rcx, QWORD PTR ?blocked_thr_last@@3PEAU_au_thread_@@EA ; blocked_thr_last
	mov	QWORD PTR [rax+665], rcx
$LN3@AuThreadIn:

; 126  : 	}
; 127  : 	blocked_thr_last = new_task;

	mov	rax, QWORD PTR new_task$[rbp]
	mov	QWORD PTR ?blocked_thr_last@@3PEAU_au_thread_@@EA, rax ; blocked_thr_last

; 128  : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
?AuThreadInsertBlock@@YAXPEAU_au_thread_@@@Z ENDP	; AuThreadInsertBlock
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\x86_64_sched.cpp
;	COMDAT ?AuThreadDelete@@YAXPEAU_au_thread_@@@Z
_TEXT	SEGMENT
thread$ = 80
?AuThreadDelete@@YAXPEAU_au_thread_@@@Z PROC		; AuThreadDelete, COMDAT

; 84   : void AuThreadDelete(AuThread* thread) {

$LN8:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__5A99B057_x86_64_sched@cpp
	call	__CheckForDebuggerJustMyCode

; 85   : 
; 86   : 	if (thread_list_head == NULL)

	cmp	QWORD PTR ?thread_list_head@@3PEAU_au_thread_@@EA, 0 ; thread_list_head
	jne	SHORT $LN2@AuThreadDe

; 87   : 		return;

	jmp	SHORT $LN1@AuThreadDe
$LN2@AuThreadDe:

; 88   : 
; 89   : 	if (thread == thread_list_head) {

	mov	rax, QWORD PTR ?thread_list_head@@3PEAU_au_thread_@@EA ; thread_list_head
	cmp	QWORD PTR thread$[rbp], rax
	jne	SHORT $LN3@AuThreadDe

; 90   : 		thread_list_head = thread_list_head->next;

	mov	rax, QWORD PTR ?thread_list_head@@3PEAU_au_thread_@@EA ; thread_list_head
	mov	rax, QWORD PTR [rax+657]
	mov	QWORD PTR ?thread_list_head@@3PEAU_au_thread_@@EA, rax ; thread_list_head

; 91   : 	}

	jmp	SHORT $LN4@AuThreadDe
$LN3@AuThreadDe:

; 92   : 	else {
; 93   : 		thread->prev->next = thread->next;

	mov	rax, QWORD PTR thread$[rbp]
	mov	rax, QWORD PTR [rax+665]
	mov	rcx, QWORD PTR thread$[rbp]
	mov	rcx, QWORD PTR [rcx+657]
	mov	QWORD PTR [rax+657], rcx
$LN4@AuThreadDe:

; 94   : 	}
; 95   : 
; 96   : 	if (thread == thread_list_last) {

	mov	rax, QWORD PTR ?thread_list_last@@3PEAU_au_thread_@@EA ; thread_list_last
	cmp	QWORD PTR thread$[rbp], rax
	jne	SHORT $LN5@AuThreadDe

; 97   : 		thread_list_last = thread->prev;

	mov	rax, QWORD PTR thread$[rbp]
	mov	rax, QWORD PTR [rax+665]
	mov	QWORD PTR ?thread_list_last@@3PEAU_au_thread_@@EA, rax ; thread_list_last

; 98   : 	}

	jmp	SHORT $LN6@AuThreadDe
$LN5@AuThreadDe:

; 99   : 	else {
; 100  : 		thread->next->prev = thread->prev;

	mov	rax, QWORD PTR thread$[rbp]
	mov	rax, QWORD PTR [rax+657]
	mov	rcx, QWORD PTR thread$[rbp]
	mov	rcx, QWORD PTR [rcx+665]
	mov	QWORD PTR [rax+665], rcx
$LN6@AuThreadDe:
$LN1@AuThreadDe:

; 101  : 	}
; 102  : 
; 103  : 	/* donot free the thread, cuz when thread needs
; 104  : 	* to move from runnable queue to blocked queue
; 105  : 	* same address is used, rather call 'free'
; 106  : 	* externally
; 107  : 	*/
; 108  : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
?AuThreadDelete@@YAXPEAU_au_thread_@@@Z ENDP		; AuThreadDelete
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\x86_64_sched.cpp
;	COMDAT ?AuThreadInsert@@YAXPEAU_au_thread_@@@Z
_TEXT	SEGMENT
new_task$ = 80
?AuThreadInsert@@YAXPEAU_au_thread_@@@Z PROC		; AuThreadInsert, COMDAT

; 65   : void AuThreadInsert(AuThread* new_task) {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__5A99B057_x86_64_sched@cpp
	call	__CheckForDebuggerJustMyCode

; 66   : 	new_task->next = NULL;

	mov	rax, QWORD PTR new_task$[rbp]
	mov	QWORD PTR [rax+657], 0

; 67   : 	new_task->prev = NULL;

	mov	rax, QWORD PTR new_task$[rbp]
	mov	QWORD PTR [rax+665], 0

; 68   : 
; 69   : 	if (thread_list_head == NULL) {

	cmp	QWORD PTR ?thread_list_head@@3PEAU_au_thread_@@EA, 0 ; thread_list_head
	jne	SHORT $LN2@AuThreadIn

; 70   : 		thread_list_last = new_task;

	mov	rax, QWORD PTR new_task$[rbp]
	mov	QWORD PTR ?thread_list_last@@3PEAU_au_thread_@@EA, rax ; thread_list_last

; 71   : 		thread_list_head = new_task;

	mov	rax, QWORD PTR new_task$[rbp]
	mov	QWORD PTR ?thread_list_head@@3PEAU_au_thread_@@EA, rax ; thread_list_head

; 72   : 	}

	jmp	SHORT $LN3@AuThreadIn
$LN2@AuThreadIn:

; 73   : 	else {
; 74   : 		thread_list_last->next = new_task;

	mov	rax, QWORD PTR ?thread_list_last@@3PEAU_au_thread_@@EA ; thread_list_last
	mov	rcx, QWORD PTR new_task$[rbp]
	mov	QWORD PTR [rax+657], rcx

; 75   : 		new_task->prev = thread_list_last;

	mov	rax, QWORD PTR new_task$[rbp]
	mov	rcx, QWORD PTR ?thread_list_last@@3PEAU_au_thread_@@EA ; thread_list_last
	mov	QWORD PTR [rax+665], rcx
$LN3@AuThreadIn:

; 76   : 	}
; 77   : 	thread_list_last = new_task;

	mov	rax, QWORD PTR new_task$[rbp]
	mov	QWORD PTR ?thread_list_last@@3PEAU_au_thread_@@EA, rax ; thread_list_last

; 78   : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
?AuThreadInsert@@YAXPEAU_au_thread_@@@Z ENDP		; AuThreadInsert
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\x86_64_sched.cpp
;	COMDAT AuGetSystemTimerTick
_TEXT	SEGMENT
AuGetSystemTimerTick PROC				; COMDAT

; 568  : uint64_t AuGetSystemTimerTick() {

$LN3:
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__5A99B057_x86_64_sched@cpp
	call	__CheckForDebuggerJustMyCode

; 569  : 	return scheduler_tick;

	mov	rax, QWORD PTR ?scheduler_tick@@3_KA

; 570  : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
AuGetSystemTimerTick ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\x86_64_sched.cpp
;	COMDAT ?AuIsSchedulerInitialised@@YA_NXZ
_TEXT	SEGMENT
?AuIsSchedulerInitialised@@YA_NXZ PROC			; AuIsSchedulerInitialised, COMDAT

; 560  : bool AuIsSchedulerInitialised() {

$LN3:
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__5A99B057_x86_64_sched@cpp
	call	__CheckForDebuggerJustMyCode

; 561  : 	return _x86_64_sched_init;

	movzx	eax, BYTE PTR ?_x86_64_sched_init@@3_NA	; _x86_64_sched_init

; 562  : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
?AuIsSchedulerInitialised@@YA_NXZ ENDP			; AuIsSchedulerInitialised
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\x86_64_sched.cpp
;	COMDAT AuForceScheduler
_TEXT	SEGMENT
AuForceScheduler PROC					; COMDAT

; 555  : AU_EXTERN AU_EXPORT void AuForceScheduler() {

$LN3:
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__5A99B057_x86_64_sched@cpp
	call	__CheckForDebuggerJustMyCode

; 556  : 	x64_force_sched();

	call	x64_force_sched

; 557  : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
AuForceScheduler ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\x86_64_sched.cpp
;	COMDAT AuThreadFindByIDBlockList
_TEXT	SEGMENT
block_queue$1 = 0
id$ = 96
AuThreadFindByIDBlockList PROC				; COMDAT

; 543  : AuThread* AuThreadFindByIDBlockList(uint16_t id){

$LN7:
	mov	WORD PTR [rsp+8], cx
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__5A99B057_x86_64_sched@cpp
	call	__CheckForDebuggerJustMyCode

; 544  : 	for (AuThread* block_queue = blocked_thr_head; block_queue != NULL; block_queue = block_queue->next){

	mov	rax, QWORD PTR ?blocked_thr_head@@3PEAU_au_thread_@@EA ; blocked_thr_head
	mov	QWORD PTR block_queue$1[rbp], rax
	jmp	SHORT $LN4@AuThreadFi
$LN2@AuThreadFi:
	mov	rax, QWORD PTR block_queue$1[rbp]
	mov	rax, QWORD PTR [rax+657]
	mov	QWORD PTR block_queue$1[rbp], rax
$LN4@AuThreadFi:
	cmp	QWORD PTR block_queue$1[rbp], 0
	je	SHORT $LN3@AuThreadFi

; 545  : 		if (block_queue->id == id)

	mov	rax, QWORD PTR block_queue$1[rbp]
	movzx	eax, WORD PTR [rax+301]
	movzx	ecx, WORD PTR id$[rbp]
	cmp	eax, ecx
	jne	SHORT $LN5@AuThreadFi

; 546  : 			return block_queue;

	mov	rax, QWORD PTR block_queue$1[rbp]
	jmp	SHORT $LN1@AuThreadFi
$LN5@AuThreadFi:

; 547  : 	}

	jmp	SHORT $LN2@AuThreadFi
$LN3@AuThreadFi:

; 548  : 	return NULL;

	xor	eax, eax
$LN1@AuThreadFi:

; 549  : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
AuThreadFindByIDBlockList ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\x86_64_sched.cpp
;	COMDAT AuThreadFindByID
_TEXT	SEGMENT
ready_queue_$1 = 0
id$ = 96
AuThreadFindByID PROC					; COMDAT

; 530  : AuThread* AuThreadFindByID(uint16_t id) {

$LN7:
	mov	WORD PTR [rsp+8], cx
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__5A99B057_x86_64_sched@cpp
	call	__CheckForDebuggerJustMyCode

; 531  : 	for (AuThread* ready_queue_ = thread_list_head; ready_queue_ != NULL; ready_queue_ = ready_queue_->next) {

	mov	rax, QWORD PTR ?thread_list_head@@3PEAU_au_thread_@@EA ; thread_list_head
	mov	QWORD PTR ready_queue_$1[rbp], rax
	jmp	SHORT $LN4@AuThreadFi
$LN2@AuThreadFi:
	mov	rax, QWORD PTR ready_queue_$1[rbp]
	mov	rax, QWORD PTR [rax+657]
	mov	QWORD PTR ready_queue_$1[rbp], rax
$LN4@AuThreadFi:
	cmp	QWORD PTR ready_queue_$1[rbp], 0
	je	SHORT $LN3@AuThreadFi

; 532  : 		if (ready_queue_->id == id)

	mov	rax, QWORD PTR ready_queue_$1[rbp]
	movzx	eax, WORD PTR [rax+301]
	movzx	ecx, WORD PTR id$[rbp]
	cmp	eax, ecx
	jne	SHORT $LN5@AuThreadFi

; 533  : 			return ready_queue_;

	mov	rax, QWORD PTR ready_queue_$1[rbp]
	jmp	SHORT $LN1@AuThreadFi
$LN5@AuThreadFi:

; 534  : 	}

	jmp	SHORT $LN2@AuThreadFi
$LN3@AuThreadFi:

; 535  : 	return NULL;

	xor	eax, eax
$LN1@AuThreadFi:

; 536  : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
AuThreadFindByID ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\x86_64_sched.cpp
;	COMDAT ?AuThreadCleanTrash@@YAXPEAU_au_thread_@@@Z
_TEXT	SEGMENT
t$ = 80
?AuThreadCleanTrash@@YAXPEAU_au_thread_@@@Z PROC	; AuThreadCleanTrash, COMDAT

; 521  : void AuThreadCleanTrash(AuThread* t) {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__5A99B057_x86_64_sched@cpp
	call	__CheckForDebuggerJustMyCode

; 522  : 	AuThreadDeleteTrash(t);

	mov	rcx, QWORD PTR t$[rbp]
	call	?AuThreadDeleteTrash@@YAXPEAU_au_thread_@@@Z ; AuThreadDeleteTrash

; 523  : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
?AuThreadCleanTrash@@YAXPEAU_au_thread_@@@Z ENDP	; AuThreadCleanTrash
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\x86_64_sched.cpp
;	COMDAT ?AuThreadMoveToTrash@@YAXPEAU_au_thread_@@@Z
_TEXT	SEGMENT
ready_queue_$1 = 0
block_queue_$2 = 8
t$ = 96
?AuThreadMoveToTrash@@YAXPEAU_au_thread_@@@Z PROC	; AuThreadMoveToTrash, COMDAT

; 494  : void AuThreadMoveToTrash(AuThread* t) {

$LN12:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__5A99B057_x86_64_sched@cpp
	call	__CheckForDebuggerJustMyCode

; 495  : 	if (!t)

	cmp	QWORD PTR t$[rbp], 0
	jne	SHORT $LN8@AuThreadMo

; 496  : 		return;

	jmp	$LN1@AuThreadMo
$LN8@AuThreadMo:

; 497  : 
; 498  : 	t->state = THREAD_STATE_KILLABLE;

	mov	rax, QWORD PTR t$[rbp]
	mov	BYTE PTR [rax+300], 5

; 499  : 
; 500  : 	/* search the thread in ready queue*/
; 501  : 	for (AuThread* ready_queue_ = thread_list_head; ready_queue_ != NULL; ready_queue_ = ready_queue_->next) {

	mov	rax, QWORD PTR ?thread_list_head@@3PEAU_au_thread_@@EA ; thread_list_head
	mov	QWORD PTR ready_queue_$1[rbp], rax
	jmp	SHORT $LN4@AuThreadMo
$LN2@AuThreadMo:
	mov	rax, QWORD PTR ready_queue_$1[rbp]
	mov	rax, QWORD PTR [rax+657]
	mov	QWORD PTR ready_queue_$1[rbp], rax
$LN4@AuThreadMo:
	cmp	QWORD PTR ready_queue_$1[rbp], 0
	je	SHORT $LN3@AuThreadMo

; 502  : 		if (ready_queue_ == t) 

	mov	rax, QWORD PTR t$[rbp]
	cmp	QWORD PTR ready_queue_$1[rbp], rax
	jne	SHORT $LN9@AuThreadMo

; 503  : 			AuThreadDelete(t);

	mov	rcx, QWORD PTR t$[rbp]
	call	?AuThreadDelete@@YAXPEAU_au_thread_@@@Z	; AuThreadDelete
$LN9@AuThreadMo:

; 504  : 	}

	jmp	SHORT $LN2@AuThreadMo
$LN3@AuThreadMo:

; 505  : 
; 506  : 	/* search the thread in block queue*/
; 507  : 	for (AuThread* block_queue_ = blocked_thr_head; block_queue_ != NULL; block_queue_ = block_queue_->next) {

	mov	rax, QWORD PTR ?blocked_thr_head@@3PEAU_au_thread_@@EA ; blocked_thr_head
	mov	QWORD PTR block_queue_$2[rbp], rax
	jmp	SHORT $LN7@AuThreadMo
$LN5@AuThreadMo:
	mov	rax, QWORD PTR block_queue_$2[rbp]
	mov	rax, QWORD PTR [rax+657]
	mov	QWORD PTR block_queue_$2[rbp], rax
$LN7@AuThreadMo:
	cmp	QWORD PTR block_queue_$2[rbp], 0
	je	SHORT $LN6@AuThreadMo

; 508  : 		if (block_queue_ == t)

	mov	rax, QWORD PTR t$[rbp]
	cmp	QWORD PTR block_queue_$2[rbp], rax
	jne	SHORT $LN10@AuThreadMo

; 509  : 			AuThreadDeleteBlock(t);

	mov	rcx, QWORD PTR t$[rbp]
	call	?AuThreadDeleteBlock@@YAXPEAU_au_thread_@@@Z ; AuThreadDeleteBlock
$LN10@AuThreadMo:

; 510  : 	}

	jmp	SHORT $LN5@AuThreadMo
$LN6@AuThreadMo:

; 511  : 
; 512  : 	/* insert it in the trash list */
; 513  : 	AuThreadInsertTrash(t);

	mov	rcx, QWORD PTR t$[rbp]
	call	?AuThreadInsertTrash@@YAXPEAU_au_thread_@@@Z ; AuThreadInsertTrash
$LN1@AuThreadMo:

; 514  : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
?AuThreadMoveToTrash@@YAXPEAU_au_thread_@@@Z ENDP	; AuThreadMoveToTrash
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\x86_64_sched.cpp
;	COMDAT AuUnblockThread
_TEXT	SEGMENT
found_$ = 0
thr$1 = 8
t$ = 96
AuUnblockThread PROC					; COMDAT

; 475  : AU_EXTERN AU_EXPORT void AuUnblockThread(AuThread *t) {

$LN8:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__5A99B057_x86_64_sched@cpp
	call	__CheckForDebuggerJustMyCode

; 476  : 	t->state = THREAD_STATE_READY;

	mov	rax, QWORD PTR t$[rbp]
	mov	BYTE PTR [rax+300], 1

; 477  : 	bool found_ = false;

	mov	BYTE PTR found_$[rbp], 0

; 478  : 	for (AuThread *thr = blocked_thr_head; thr != NULL; thr = thr->next) {

	mov	rax, QWORD PTR ?blocked_thr_head@@3PEAU_au_thread_@@EA ; blocked_thr_head
	mov	QWORD PTR thr$1[rbp], rax
	jmp	SHORT $LN4@AuUnblockT
$LN2@AuUnblockT:
	mov	rax, QWORD PTR thr$1[rbp]
	mov	rax, QWORD PTR [rax+657]
	mov	QWORD PTR thr$1[rbp], rax
$LN4@AuUnblockT:
	cmp	QWORD PTR thr$1[rbp], 0
	je	SHORT $LN3@AuUnblockT

; 479  : 		if (thr == t) {

	mov	rax, QWORD PTR t$[rbp]
	cmp	QWORD PTR thr$1[rbp], rax
	jne	SHORT $LN5@AuUnblockT

; 480  : 			AuThreadDeleteBlock(thr);

	mov	rcx, QWORD PTR thr$1[rbp]
	call	?AuThreadDeleteBlock@@YAXPEAU_au_thread_@@@Z ; AuThreadDeleteBlock

; 481  : 			found_ = true;

	mov	BYTE PTR found_$[rbp], 1

; 482  : 			break;

	jmp	SHORT $LN3@AuUnblockT
$LN5@AuUnblockT:

; 483  : 		}
; 484  : 	}

	jmp	SHORT $LN2@AuUnblockT
$LN3@AuUnblockT:

; 485  : 	if (found_)

	movzx	eax, BYTE PTR found_$[rbp]
	test	eax, eax
	je	SHORT $LN6@AuUnblockT

; 486  : 		AuThreadInsert(t);

	mov	rcx, QWORD PTR t$[rbp]
	call	?AuThreadInsert@@YAXPEAU_au_thread_@@@Z	; AuThreadInsert
$LN6@AuUnblockT:

; 487  : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
AuUnblockThread ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\x86_64_sched.cpp
;	COMDAT AuSleepThread
_TEXT	SEGMENT
thread$ = 80
ms$ = 88
AuSleepThread PROC					; COMDAT

; 464  : AU_EXTERN AU_EXPORT void AuSleepThread(AuThread *thread, uint64_t ms) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__5A99B057_x86_64_sched@cpp
	call	__CheckForDebuggerJustMyCode

; 465  : 	thread->state = THREAD_STATE_SLEEP;

	mov	rax, QWORD PTR thread$[rbp]
	mov	BYTE PTR [rax+300], 4

; 466  : 	thread->quanta = ms;

	mov	rax, QWORD PTR thread$[rbp]
	mov	rcx, QWORD PTR ms$[rbp]
	mov	QWORD PTR [rax+303], rcx

; 467  : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
AuSleepThread ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\x86_64_sched.cpp
;	COMDAT AuBlockThread
_TEXT	SEGMENT
thread$ = 80
AuBlockThread PROC					; COMDAT

; 455  : AU_EXTERN AU_EXPORT void AuBlockThread(AuThread *thread) {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__5A99B057_x86_64_sched@cpp
	call	__CheckForDebuggerJustMyCode

; 456  : 	thread->state = THREAD_STATE_BLOCKED;

	mov	rax, QWORD PTR thread$[rbp]
	mov	BYTE PTR [rax+300], 3

; 457  : 	AuThreadDelete(thread);

	mov	rcx, QWORD PTR thread$[rbp]
	call	?AuThreadDelete@@YAXPEAU_au_thread_@@@Z	; AuThreadDelete

; 458  : 	AuThreadInsertBlock(thread);

	mov	rcx, QWORD PTR thread$[rbp]
	call	?AuThreadInsertBlock@@YAXPEAU_au_thread_@@@Z ; AuThreadInsertBlock

; 459  : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
AuBlockThread ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\x86_64_sched.cpp
;	COMDAT ?AuKThreadCopy@@YAXPEAU_au_thread_@@0@Z
_TEXT	SEGMENT
dest$ = 80
src$ = 88
?AuKThreadCopy@@YAXPEAU_au_thread_@@0@Z PROC		; AuKThreadCopy, COMDAT

; 271  : void AuKThreadCopy(AuThread* dest, AuThread* src) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__5A99B057_x86_64_sched@cpp
	call	__CheckForDebuggerJustMyCode

; 272  : 	dest->frame.r15 = src->frame.r15;

	mov	rax, QWORD PTR dest$[rbp]
	mov	rcx, QWORD PTR src$[rbp]
	mov	rcx, QWORD PTR [rcx+152]
	mov	QWORD PTR [rax+152], rcx

; 273  : 	dest->frame.r14 = src->frame.r14;

	mov	rax, QWORD PTR dest$[rbp]
	mov	rcx, QWORD PTR src$[rbp]
	mov	rcx, QWORD PTR [rcx+144]
	mov	QWORD PTR [rax+144], rcx

; 274  : 	dest->frame.r13 = src->frame.r13;

	mov	rax, QWORD PTR dest$[rbp]
	mov	rcx, QWORD PTR src$[rbp]
	mov	rcx, QWORD PTR [rcx+136]
	mov	QWORD PTR [rax+136], rcx

; 275  : 	dest->frame.r12 = src->frame.r12;

	mov	rax, QWORD PTR dest$[rbp]
	mov	rcx, QWORD PTR src$[rbp]
	mov	rcx, QWORD PTR [rcx+128]
	mov	QWORD PTR [rax+128], rcx

; 276  : 	dest->frame.r11 = src->frame.r11;

	mov	rax, QWORD PTR dest$[rbp]
	mov	rcx, QWORD PTR src$[rbp]
	mov	rcx, QWORD PTR [rcx+120]
	mov	QWORD PTR [rax+120], rcx

; 277  : 	dest->frame.r10 = src->frame.r10;

	mov	rax, QWORD PTR dest$[rbp]
	mov	rcx, QWORD PTR src$[rbp]
	mov	rcx, QWORD PTR [rcx+112]
	mov	QWORD PTR [rax+112], rcx

; 278  : 	dest->frame.r9 = src->frame.r9;

	mov	rax, QWORD PTR dest$[rbp]
	mov	rcx, QWORD PTR src$[rbp]
	mov	rcx, QWORD PTR [rcx+104]
	mov	QWORD PTR [rax+104], rcx

; 279  : 	dest->frame.r8 = src->frame.r8;

	mov	rax, QWORD PTR dest$[rbp]
	mov	rcx, QWORD PTR src$[rbp]
	mov	rcx, QWORD PTR [rcx+96]
	mov	QWORD PTR [rax+96], rcx

; 280  : 	dest->frame.rdi = src->frame.rdi;

	mov	rax, QWORD PTR dest$[rbp]
	mov	rcx, QWORD PTR src$[rbp]
	mov	rcx, QWORD PTR [rcx+80]
	mov	QWORD PTR [rax+80], rcx

; 281  : 	dest->frame.rsi = src->frame.rsi;

	mov	rax, QWORD PTR dest$[rbp]
	mov	rcx, QWORD PTR src$[rbp]
	mov	rcx, QWORD PTR [rcx+72]
	mov	QWORD PTR [rax+72], rcx

; 282  : 	dest->frame.rdx = src->frame.rdx;

	mov	rax, QWORD PTR dest$[rbp]
	mov	rcx, QWORD PTR src$[rbp]
	mov	rcx, QWORD PTR [rcx+64]
	mov	QWORD PTR [rax+64], rcx

; 283  : 	dest->frame.rcx = src->frame.rcx;

	mov	rax, QWORD PTR dest$[rbp]
	mov	rcx, QWORD PTR src$[rbp]
	mov	rcx, QWORD PTR [rcx+56]
	mov	QWORD PTR [rax+56], rcx

; 284  : 	dest->frame.rbx = src->frame.rbx;

	mov	rax, QWORD PTR dest$[rbp]
	mov	rcx, QWORD PTR src$[rbp]
	mov	rcx, QWORD PTR [rcx+48]
	mov	QWORD PTR [rax+48], rcx

; 285  : 	dest->frame.rax = src->frame.rax;

	mov	rax, QWORD PTR dest$[rbp]
	mov	rcx, QWORD PTR src$[rbp]
	mov	rcx, QWORD PTR [rcx+40]
	mov	QWORD PTR [rax+40], rcx

; 286  : 	dest->frame.rip = src->frame.rip;

	mov	rax, QWORD PTR dest$[rbp]
	mov	rcx, QWORD PTR src$[rbp]
	mov	rcx, QWORD PTR [rcx+32]
	mov	QWORD PTR [rax+32], rcx

; 287  : 	dest->frame.cs = src->frame.cs;

	mov	rax, QWORD PTR dest$[rbp]
	mov	rcx, QWORD PTR src$[rbp]
	mov	rcx, QWORD PTR [rcx+24]
	mov	QWORD PTR [rax+24], rcx

; 288  : 	dest->frame.rflags = src->frame.rflags;

	mov	rax, QWORD PTR dest$[rbp]
	mov	rcx, QWORD PTR src$[rbp]
	mov	rcx, QWORD PTR [rcx+16]
	mov	QWORD PTR [rax+16], rcx

; 289  : 	dest->frame.ss = src->frame.ss;

	mov	rax, QWORD PTR dest$[rbp]
	mov	rcx, QWORD PTR src$[rbp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax], rcx

; 290  : 	dest->frame.ds = src->frame.ds;

	mov	rax, QWORD PTR dest$[rbp]
	mov	rcx, QWORD PTR src$[rbp]
	mov	rcx, QWORD PTR [rcx+160]
	mov	QWORD PTR [rax+160], rcx

; 291  : 	dest->frame.es = src->frame.es;

	mov	rax, QWORD PTR dest$[rbp]
	mov	rcx, QWORD PTR src$[rbp]
	mov	rcx, QWORD PTR [rcx+168]
	mov	QWORD PTR [rax+168], rcx

; 292  : 	dest->frame.fs = src->frame.fs;

	mov	rax, QWORD PTR dest$[rbp]
	mov	rcx, QWORD PTR src$[rbp]
	mov	rcx, QWORD PTR [rcx+176]
	mov	QWORD PTR [rax+176], rcx

; 293  : 	dest->frame.gs = src->frame.gs;

	mov	rax, QWORD PTR dest$[rbp]
	mov	rcx, QWORD PTR src$[rbp]
	mov	rcx, QWORD PTR [rcx+184]
	mov	QWORD PTR [rax+184], rcx

; 294  : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
?AuKThreadCopy@@YAXPEAU_au_thread_@@0@Z ENDP		; AuKThreadCopy
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\x86_64_sched.cpp
;	COMDAT AuGetCurrentThread
_TEXT	SEGMENT
AuGetCurrentThread PROC					; COMDAT

; 446  : AuThread* AuGetCurrentThread() {

$LN3:
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__5A99B057_x86_64_sched@cpp
	call	__CheckForDebuggerJustMyCode

; 447  : 	return AuPerCPUGetCurrentThread();

	call	?AuPerCPUGetCurrentThread@@YAPEAU_au_thread_@@XZ ; AuPerCPUGetCurrentThread

; 448  : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
AuGetCurrentThread ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\x86_64_sched.cpp
;	COMDAT AuCreateKthread
_TEXT	SEGMENT
t$ = 0
fx_addr$ = 8
entry$ = 96
stack$ = 104
cr3$ = 112
name$ = 120
AuCreateKthread PROC					; COMDAT

; 208  : {

$LN4:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__5A99B057_x86_64_sched@cpp
	call	__CheckForDebuggerJustMyCode

; 209  : 	AuThread *t = (AuThread*)kmalloc(sizeof(AuThread));

	mov	ecx, 673				; 000002a1H
	call	kmalloc
	mov	QWORD PTR t$[rbp], rax

; 210  : 	memset(t, 0, sizeof(AuThread));

	mov	r8d, 673				; 000002a1H
	xor	edx, edx
	mov	rcx, QWORD PTR t$[rbp]
	call	memset

; 211  : 	t->frame.r15 = 0;

	mov	rax, QWORD PTR t$[rbp]
	mov	QWORD PTR [rax+152], 0

; 212  : 	t->frame.r14 = 0;

	mov	rax, QWORD PTR t$[rbp]
	mov	QWORD PTR [rax+144], 0

; 213  : 	t->frame.r13 = 0;

	mov	rax, QWORD PTR t$[rbp]
	mov	QWORD PTR [rax+136], 0

; 214  : 	t->frame.r12 = 0;

	mov	rax, QWORD PTR t$[rbp]
	mov	QWORD PTR [rax+128], 0

; 215  : 	t->frame.r11 = 0;

	mov	rax, QWORD PTR t$[rbp]
	mov	QWORD PTR [rax+120], 0

; 216  : 	t->frame.r10 = 0;

	mov	rax, QWORD PTR t$[rbp]
	mov	QWORD PTR [rax+112], 0

; 217  : 	t->frame.r9 = 0;

	mov	rax, QWORD PTR t$[rbp]
	mov	QWORD PTR [rax+104], 0

; 218  : 	t->frame.r8 = 0;

	mov	rax, QWORD PTR t$[rbp]
	mov	QWORD PTR [rax+96], 0

; 219  : 	t->frame.rbp = stack;

	mov	rax, QWORD PTR t$[rbp]
	mov	rcx, QWORD PTR stack$[rbp]
	mov	QWORD PTR [rax+88], rcx

; 220  : 	t->frame.rdi = 0;

	mov	rax, QWORD PTR t$[rbp]
	mov	QWORD PTR [rax+80], 0

; 221  : 	t->frame.rsi = 0;

	mov	rax, QWORD PTR t$[rbp]
	mov	QWORD PTR [rax+72], 0

; 222  : 	t->frame.rdx = 0;

	mov	rax, QWORD PTR t$[rbp]
	mov	QWORD PTR [rax+64], 0

; 223  : 	t->frame.rcx = 0;

	mov	rax, QWORD PTR t$[rbp]
	mov	QWORD PTR [rax+56], 0

; 224  : 	t->frame.rbx = 0;

	mov	rax, QWORD PTR t$[rbp]
	mov	QWORD PTR [rax+48], 0

; 225  : 	t->frame.rax = 0;

	mov	rax, QWORD PTR t$[rbp]
	mov	QWORD PTR [rax+40], 0

; 226  : 	t->frame.rip = (uint64_t)entry;

	mov	rax, QWORD PTR t$[rbp]
	mov	rcx, QWORD PTR entry$[rbp]
	mov	QWORD PTR [rax+32], rcx

; 227  : 	t->frame.cs = 0x08;

	mov	rax, QWORD PTR t$[rbp]
	mov	QWORD PTR [rax+24], 8

; 228  : 	t->frame.rflags = 0x286;

	mov	rax, QWORD PTR t$[rbp]
	mov	QWORD PTR [rax+16], 646			; 00000286H

; 229  : 	t->frame.rsp = stack;

	mov	rax, QWORD PTR t$[rbp]
	mov	rcx, QWORD PTR stack$[rbp]
	mov	QWORD PTR [rax+8], rcx

; 230  : 	t->frame.ss = 0x10;

	mov	rax, QWORD PTR t$[rbp]
	mov	QWORD PTR [rax], 16

; 231  : 	t->frame.kern_esp = stack;

	mov	rax, QWORD PTR t$[rbp]
	mov	rcx, QWORD PTR stack$[rbp]
	mov	QWORD PTR [rax+200], rcx

; 232  : 	t->user_stack = stack;

	mov	rax, QWORD PTR t$[rbp]
	mov	rcx, QWORD PTR stack$[rbp]
	mov	QWORD PTR [rax+216], rcx

; 233  : 	t->quanta = 0;

	mov	rax, QWORD PTR t$[rbp]
	mov	QWORD PTR [rax+303], 0

; 234  : 	t->frame.cr3 = cr3;

	mov	rax, QWORD PTR t$[rbp]
	mov	rcx, QWORD PTR cr3$[rbp]
	mov	QWORD PTR [rax+192], rcx

; 235  : 	t->priviledge = THREAD_LEVEL_KERNEL;

	mov	rax, QWORD PTR t$[rbp]
	mov	BYTE PTR [rax+311], 1

; 236  : 	t->state = THREAD_STATE_READY;

	mov	rax, QWORD PTR t$[rbp]
	mov	BYTE PTR [rax+300], 1

; 237  : 	t->frame.ds = t->frame.es = t->frame.fs = t->frame.gs = SEGVAL(GDT_ENTRY_KERNEL_DATA, 0);

	mov	rax, QWORD PTR t$[rbp]
	mov	QWORD PTR [rax+184], 16
	mov	rax, QWORD PTR t$[rbp]
	mov	QWORD PTR [rax+176], 16
	mov	rax, QWORD PTR t$[rbp]
	mov	QWORD PTR [rax+168], 16
	mov	rax, QWORD PTR t$[rbp]
	mov	QWORD PTR [rax+160], 16

; 238  : 	//t->frame.user_ = 0;
; 239  : 
; 240  : 	t->syscall_param.param1 = t->syscall_param.param2 = 0;

	mov	rax, QWORD PTR t$[rbp]
	mov	QWORD PTR [rax+232], 0
	mov	rax, QWORD PTR t$[rbp]
	mov	QWORD PTR [rax+224], 0

; 241  : 	t->syscall_param.param3 = t->syscall_param.param4 = 0;

	mov	rax, QWORD PTR t$[rbp]
	mov	QWORD PTR [rax+248], 0
	mov	rax, QWORD PTR t$[rbp]
	mov	QWORD PTR [rax+240], 0

; 242  : 	t->syscall_param.param5 = t->syscall_param.param6 = 0;

	mov	rax, QWORD PTR t$[rbp]
	mov	QWORD PTR [rax+264], 0
	mov	rax, QWORD PTR t$[rbp]
	mov	QWORD PTR [rax+256], 0

; 243  : 
; 244  : 	/* process will fill uentry */
; 245  : 	t->uentry = NULL; 

	mov	rax, QWORD PTR t$[rbp]
	mov	QWORD PTR [rax+641], 0

; 246  : 	memset(t->name, 0,16);

	mov	rax, QWORD PTR t$[rbp]
	add	rax, 284				; 0000011cH
	mov	r8d, 16
	xor	edx, edx
	mov	rcx, rax
	call	memset

; 247  : 	strcpy(t->name, name);

	mov	rax, QWORD PTR t$[rbp]
	add	rax, 284				; 0000011cH
	mov	rdx, QWORD PTR name$[rbp]
	mov	rcx, rax
	call	strcpy

; 248  : 	t->id = thread_id++;

	mov	rax, QWORD PTR t$[rbp]
	movzx	ecx, WORD PTR ?thread_id@@3GA
	mov	WORD PTR [rax+301], cx
	movzx	eax, WORD PTR ?thread_id@@3GA
	inc	ax
	mov	WORD PTR ?thread_id@@3GA, ax

; 249  : 
; 250  : 	t->fx_state = (uint8_t*)kmalloc(512);

	mov	ecx, 512				; 00000200H
	call	kmalloc
	mov	rcx, QWORD PTR t$[rbp]
	mov	QWORD PTR [rcx+272], rax

; 251  : 
; 252  : 	/* align the fx_state memory to 16-byte boundary */
; 253  : 	size_t fx_addr = (size_t)t->fx_state;

	mov	rax, QWORD PTR t$[rbp]
	mov	rax, QWORD PTR [rax+272]
	mov	QWORD PTR fx_addr$[rbp], rax

; 254  : 	if ((size_t)t->fx_state & (16 - 1)) 

	mov	rax, QWORD PTR t$[rbp]
	mov	rax, QWORD PTR [rax+272]
	and	rax, 15
	test	rax, rax
	je	SHORT $LN2@AuCreateKt

; 255  : 		t->fx_state = (uint8_t*)(fx_addr | 16 - 1) + 1;

	mov	rax, QWORD PTR fx_addr$[rbp]
	or	rax, 15
	inc	rax
	mov	rcx, QWORD PTR t$[rbp]
	mov	QWORD PTR [rcx+272], rax
$LN2@AuCreateKt:

; 256  : 	
; 257  : 	memset(t->fx_state, 0, 512);

	mov	r8d, 512				; 00000200H
	xor	edx, edx
	mov	rax, QWORD PTR t$[rbp]
	mov	rcx, QWORD PTR [rax+272]
	call	memset

; 258  : 
; 259  : 	t->mxcsr = 0x1f80;

	mov	rax, QWORD PTR t$[rbp]
	mov	DWORD PTR [rax+280], 8064		; 00001f80H

; 260  : 	AuThreadInsert(t);

	mov	rcx, QWORD PTR t$[rbp]
	call	?AuThreadInsert@@YAXPEAU_au_thread_@@@Z	; AuThreadInsert

; 261  : 	return t;

	mov	rax, QWORD PTR t$[rbp]

; 262  : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
AuCreateKthread ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\x86_64_sched.cpp
;	COMDAT ?AuSchedulerInitAp@@YAXXZ
_TEXT	SEGMENT
?AuSchedulerInitAp@@YAXXZ PROC				; AuSchedulerInitAp, COMDAT

; 330  : void AuSchedulerInitAp() {

$LN3:
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__5A99B057_x86_64_sched@cpp
	call	__CheckForDebuggerJustMyCode

; 331  : 	AuPerCPUSetCurrentThread(_idle_thr);

	mov	rcx, QWORD PTR ?_idle_thr@@3PEAU_au_thread_@@EA ; _idle_thr
	call	?AuPerCPUSetCurrentThread@@YAXPEAX@Z	; AuPerCPUSetCurrentThread

; 332  : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
?AuSchedulerInitAp@@YAXXZ ENDP				; AuSchedulerInitAp
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\x86_64_sched.cpp
;	COMDAT ?AuSchedulerInitialise@@YAXXZ
_TEXT	SEGMENT
idle_$ = 0
tv68 = 72
?AuSchedulerInitialise@@YAXXZ PROC			; AuSchedulerInitialise, COMDAT

; 309  : void AuSchedulerInitialise() {

$LN3:
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__5A99B057_x86_64_sched@cpp
	call	__CheckForDebuggerJustMyCode

; 310  : 	thread_id = 0;

	xor	eax, eax
	mov	WORD PTR ?thread_id@@3GA, ax

; 311  : 	thread_list_head = NULL;

	mov	QWORD PTR ?thread_list_head@@3PEAU_au_thread_@@EA, 0 ; thread_list_head

; 312  : 	thread_list_last = NULL;

	mov	QWORD PTR ?thread_list_last@@3PEAU_au_thread_@@EA, 0 ; thread_list_last

; 313  : 	blocked_thr_head = NULL;

	mov	QWORD PTR ?blocked_thr_head@@3PEAU_au_thread_@@EA, 0 ; blocked_thr_head

; 314  : 	blocked_thr_last = NULL;

	mov	QWORD PTR ?blocked_thr_last@@3PEAU_au_thread_@@EA, 0 ; blocked_thr_last

; 315  : 	trash_thr_head = NULL;

	mov	QWORD PTR ?trash_thr_head@@3PEAU_au_thread_@@EA, 0 ; trash_thr_head

; 316  : 	trash_thr_last = NULL;

	mov	QWORD PTR ?trash_thr_last@@3PEAU_au_thread_@@EA, 0 ; trash_thr_last

; 317  : 	_x86_64_sched_enable = true;

	mov	BYTE PTR ?_x86_64_sched_enable@@3_NA, 1	; _x86_64_sched_enable

; 318  : 	_x86_64_sched_init = false;

	mov	BYTE PTR ?_x86_64_sched_init@@3_NA, 0	; _x86_64_sched_init

; 319  : 	scheduler_tick = 0;

	mov	QWORD PTR ?scheduler_tick@@3_KA, 0

; 320  : 	_idle_lock = AuCreateSpinlock(false);

	xor	ecx, ecx
	call	AuCreateSpinlock
	mov	QWORD PTR ?_idle_lock@@3PEAU_spinlock_@@EA, rax ; _idle_lock

; 321  : 	AuThread *idle_ = AuCreateKthread(AuIdleThread, (uint64_t)P2V((uint64_t)AuPmmngrAlloc() + 4096), x64_read_cr3(), "Idle");

	call	x64_read_cr3
	mov	QWORD PTR tv68[rbp], rax
	call	AuPmmngrAlloc
	add	rax, 4096				; 00001000H
	mov	rcx, rax
	call	P2V
	lea	r9, OFFSET FLAT:??_C@_04IBDNPPCI@Idle@
	mov	rcx, QWORD PTR tv68[rbp]
	mov	r8, rcx
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:?AuIdleThread@@YAX_K@Z	; AuIdleThread
	call	AuCreateKthread
	mov	QWORD PTR idle_$[rbp], rax

; 322  : 	_idle_thr = idle_;

	mov	rax, QWORD PTR idle_$[rbp]
	mov	QWORD PTR ?_idle_thr@@3PEAU_au_thread_@@EA, rax ; _idle_thr

; 323  : 	AuPerCPUSetCurrentThread(idle_);

	mov	rcx, QWORD PTR idle_$[rbp]
	call	?AuPerCPUSetCurrentThread@@YAXPEAX@Z	; AuPerCPUSetCurrentThread

; 324  : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
?AuSchedulerInitialise@@YAXXZ ENDP			; AuSchedulerInitialise
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\Hal\x86_64_sched.cpp
;	COMDAT ?AuSchedulerStart@@YAXXZ
_TEXT	SEGMENT
current_thread$ = 0
?AuSchedulerStart@@YAXXZ PROC				; AuSchedulerStart, COMDAT

; 428  : void AuSchedulerStart() {

$LN3:
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__5A99B057_x86_64_sched@cpp
	call	__CheckForDebuggerJustMyCode

; 429  : 	_x86_64_sched_init = true;

	mov	BYTE PTR ?_x86_64_sched_init@@3_NA, 1	; _x86_64_sched_init

; 430  : 	setvect(0x40, x8664SchedulerISR);  //0x40

	lea	rdx, OFFSET FLAT:?x8664SchedulerISR@@YAX_KPEAX@Z ; x8664SchedulerISR
	mov	ecx, 64					; 00000040H
	call	setvect

; 431  : 	AuThread* current_thread = AuPerCPUGetCurrentThread();

	call	?AuPerCPUGetCurrentThread@@YAPEAU_au_thread_@@XZ ; AuPerCPUGetCurrentThread
	mov	QWORD PTR current_thread$[rbp], rax

; 432  : 	execute_idle(current_thread, x86_64_get_tss());

	call	?x86_64_get_tss@@YAPEAU_tss@@XZ		; x86_64_get_tss
	mov	rdx, rax
	mov	rcx, QWORD PTR current_thread$[rbp]
	call	execute_idle

; 433  : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
?AuSchedulerStart@@YAXXZ ENDP				; AuSchedulerStart
_TEXT	ENDS
END
