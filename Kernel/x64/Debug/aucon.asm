; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.21005.1 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?font_data@@3PEAEEA				; font_data
PUBLIC	?console_x@@3IA					; console_x
PUBLIC	?console_y@@3IA					; console_y
PUBLIC	?__framebuffer@@3PEAIEA				; __framebuffer
PUBLIC	?aucon@@3PEAU_aucon_@@EA			; aucon
PUBLIC	?early_@@3_NA					; early_
PUBLIC	?_print_func@@3P6AXPEBDZZEA			; _print_func
_BSS	SEGMENT
?font_data@@3PEAEEA DQ 01H DUP (?)			; font_data
?console_x@@3IA DD 01H DUP (?)				; console_x
?console_y@@3IA DD 01H DUP (?)				; console_y
?__framebuffer@@3PEAIEA DQ 01H DUP (?)			; __framebuffer
?aucon@@3PEAU_aucon_@@EA DQ 01H DUP (?)			; aucon
?early_@@3_NA DB 01H DUP (?)				; early_
	ALIGN	8

?_print_func@@3P6AXPEBDZZEA DQ 01H DUP (?)		; _print_func
_BSS	ENDS
CONST	SEGMENT
$SG3015	DB	'.', 00H
CONST	ENDS
PUBLIC	?AuConsoleInitialize@@YAXPEAU_KERNEL_BOOT_INFO_@@_N@Z ; AuConsoleInitialize
PUBLIC	?AuConsolePostInitialise@@YAXPEAU_KERNEL_BOOT_INFO_@@@Z ; AuConsolePostInitialise
PUBLIC	AuTextOut
PUBLIC	?AuConsoleEarlyEnable@@YAX_N@Z			; AuConsoleEarlyEnable
PUBLIC	?AuPutC@@YAXD@Z					; AuPutC
PUBLIC	?AuPutS@@YAXPEAD@Z				; AuPutS
EXTRN	AuMapPage:PROC
EXTRN	AuPmmngrAlloc:PROC
EXTRN	P2V:PROC
EXTRN	kmalloc:PROC
EXTRN	strlen:PROC
EXTRN	memset:PROC
EXTRN	memcpy:PROC
EXTRN	?sztoa@@YAPEAD_KPEADH@Z:PROC			; sztoa
EXTRN	?ftoa@@YAPEADME@Z:PROC				; ftoa
EXTRN	_fltused:DWORD
pdata	SEGMENT
$pdata$?AuConsolePostInitialise@@YAXPEAU_KERNEL_BOOT_INFO_@@@Z DD imagerel $LN12
	DD	imagerel $LN12+531
	DD	imagerel $unwind$?AuConsolePostInitialise@@YAXPEAU_KERNEL_BOOT_INFO_@@@Z
$pdata$AuTextOut DD imagerel $LN26
	DD	imagerel $LN26+887
	DD	imagerel $unwind$AuTextOut
$pdata$?AuPutC@@YAXD@Z DD imagerel $LN14
	DD	imagerel $LN14+531
	DD	imagerel $unwind$?AuPutC@@YAXD@Z
$pdata$?AuPutS@@YAXPEAD@Z DD imagerel $LN21
	DD	imagerel $LN21+624
	DD	imagerel $unwind$?AuPutS@@YAXPEAD@Z
pdata	ENDS
xdata	SEGMENT
$unwind$?AuConsolePostInitialise@@YAXPEAU_KERNEL_BOOT_INFO_@@@Z DD 010901H
	DD	08209H
$unwind$AuTextOut DD 021b01H
	DD	023011bH
$unwind$?AuPutC@@YAXD@Z DD 010801H
	DD	08208H
$unwind$?AuPutS@@YAXPEAD@Z DD 010901H
	DD	08209H
xdata	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\aucon.cpp
_TEXT	SEGMENT
line$ = 0
font$ = 8
x$ = 16
offs$ = 20
mask$ = 24
y$ = 28
tv86 = 32
tv145 = 36
bpl$ = 40
tv202 = 44
glyph$1 = 48
s$ = 80
?AuPutS@@YAXPEAD@Z PROC					; AuPutS

; 139  : void AuPutS(char *s){

$LN21:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 140  : 	if (font_data == NULL)

	cmp	QWORD PTR ?font_data@@3PEAEEA, 0	; font_data
	jne	SHORT $LN14@AuPutS

; 141  : 		return;

	jmp	$LN15@AuPutS
$LN14@AuPutS:

; 142  : 
; 143  : 	psf2_t *font = (psf2_t*)font_data;

	mov	rax, QWORD PTR ?font_data@@3PEAEEA	; font_data
	mov	QWORD PTR font$[rsp], rax

; 144  : 	int x, y, line, mask, offs;
; 145  : 	int bpl = (font->width + 7) / 8;

	mov	rax, QWORD PTR font$[rsp]
	mov	eax, DWORD PTR [rax+28]
	add	eax, 7
	xor	edx, edx
	mov	ecx, 8
	div	ecx
	mov	DWORD PTR bpl$[rsp], eax
$LN13@AuPutS:

; 146  : 	while (*s) {

	mov	rax, QWORD PTR s$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	$LN12@AuPutS

; 147  : 		if (*s == '\n') {

	mov	rax, QWORD PTR s$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 10
	jne	SHORT $LN11@AuPutS

; 148  : 
; 149  : 			console_y += 16;

	mov	eax, DWORD PTR ?console_y@@3IA		; console_y
	add	eax, 16
	mov	DWORD PTR ?console_y@@3IA, eax		; console_y

; 150  : 			console_x = 0;

	mov	DWORD PTR ?console_x@@3IA, 0		; console_x
	jmp	$LN10@AuPutS
$LN11@AuPutS:

; 151  : 			//!Scroll
; 152  : 			/*if (console_y >= aucon->height) {
; 153  : 				for (int line_y = 0; line_y < aucon->height - 16; line_y++) {
; 154  : 					for (int code_x = 0; code_x < aucon->width - 8; code_x++) {
; 155  : 						aucon->buffer[line_y * aucon->width + code_x] = aucon->buffer[(line_y + 16) * aucon->width + code_x];
; 156  : 					}
; 157  : 				}
; 158  : 				console_y -= 16;
; 159  : 			}*/
; 160  : 
; 161  : 		}
; 162  : 		else if (*s == '\b') {

	mov	rax, QWORD PTR s$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 8
	jne	SHORT $LN9@AuPutS

; 163  : 			if (console_x > 0) {

	cmp	DWORD PTR ?console_x@@3IA, 0		; console_x
	jbe	SHORT $LN8@AuPutS

; 164  : 				console_x--;

	mov	eax, DWORD PTR ?console_x@@3IA		; console_x
	dec	eax
	mov	DWORD PTR ?console_x@@3IA, eax		; console_x
$LN8@AuPutS:

; 165  : 			}
; 166  : 		}
; 167  : 		else {

	jmp	$LN7@AuPutS
$LN9@AuPutS:

; 168  : 			unsigned char *glyph = (unsigned char*)font_data + font->headersize +
; 169  : 				(*s>0 && *s<font->numglyph ? *s : 0)*font->bytesperglyph;

	mov	rax, QWORD PTR s$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	jle	SHORT $LN17@AuPutS
	mov	rax, QWORD PTR s$[rsp]
	movsx	eax, BYTE PTR [rax]
	mov	rcx, QWORD PTR font$[rsp]
	cmp	eax, DWORD PTR [rcx+16]
	jae	SHORT $LN17@AuPutS
	mov	rax, QWORD PTR s$[rsp]
	movsx	eax, BYTE PTR [rax]
	mov	DWORD PTR tv86[rsp], eax
	jmp	SHORT $LN18@AuPutS
$LN17@AuPutS:
	mov	DWORD PTR tv86[rsp], 0
$LN18@AuPutS:
	mov	rax, QWORD PTR font$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	rcx, QWORD PTR ?font_data@@3PEAEEA	; font_data
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR font$[rsp]
	mov	edx, DWORD PTR tv86[rsp]
	imul	edx, DWORD PTR [rcx+20]
	mov	ecx, edx
	mov	ecx, ecx
	add	rax, rcx
	mov	QWORD PTR glyph$1[rsp], rax

; 170  : 			offs = console_x * (font->width + 1);// * 4);

	mov	rax, QWORD PTR font$[rsp]
	mov	eax, DWORD PTR [rax+28]
	inc	eax
	mov	ecx, DWORD PTR ?console_x@@3IA		; console_x
	imul	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR offs$[rsp], eax

; 171  : 			for (y = 0; y<font->height; y++) {

	mov	DWORD PTR y$[rsp], 0
	jmp	SHORT $LN6@AuPutS
$LN5@AuPutS:
	mov	eax, DWORD PTR y$[rsp]
	inc	eax
	mov	DWORD PTR y$[rsp], eax
$LN6@AuPutS:
	mov	rax, QWORD PTR font$[rsp]
	mov	eax, DWORD PTR [rax+24]
	cmp	DWORD PTR y$[rsp], eax
	jae	$LN4@AuPutS

; 172  : 				line = offs; mask = 1 << (font->width - 1);

	mov	eax, DWORD PTR offs$[rsp]
	mov	DWORD PTR line$[rsp], eax
	mov	rax, QWORD PTR font$[rsp]
	mov	eax, DWORD PTR [rax+28]
	dec	eax
	mov	ecx, 1
	mov	DWORD PTR tv202[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv202[rsp]
	shl	eax, cl
	mov	DWORD PTR mask$[rsp], eax

; 173  : 				for (x = 0; x<font->width; x++) {

	mov	DWORD PTR x$[rsp], 0
	jmp	SHORT $LN3@AuPutS
$LN2@AuPutS:
	mov	eax, DWORD PTR x$[rsp]
	inc	eax
	mov	DWORD PTR x$[rsp], eax
$LN3@AuPutS:
	mov	rax, QWORD PTR font$[rsp]
	mov	eax, DWORD PTR [rax+28]
	cmp	DWORD PTR x$[rsp], eax
	jae	SHORT $LN1@AuPutS

; 174  : 					aucon->buffer[line + console_y * aucon->width] = ((int)*glyph) & (mask) ? 0xFFFFFF : 0;

	mov	rax, QWORD PTR glyph$1[rsp]
	movzx	eax, BYTE PTR [rax]
	and	eax, DWORD PTR mask$[rsp]
	test	eax, eax
	je	SHORT $LN19@AuPutS
	mov	DWORD PTR tv145[rsp], 16777215		; 00ffffffH
	jmp	SHORT $LN20@AuPutS
$LN19@AuPutS:
	mov	DWORD PTR tv145[rsp], 0
$LN20@AuPutS:
	mov	rax, QWORD PTR ?aucon@@3PEAU_aucon_@@EA	; aucon
	mov	ecx, DWORD PTR ?console_y@@3IA		; console_y
	imul	ecx, DWORD PTR [rax]
	mov	eax, ecx
	mov	ecx, DWORD PTR line$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	eax, eax
	mov	rcx, QWORD PTR ?aucon@@3PEAU_aucon_@@EA	; aucon
	mov	rcx, QWORD PTR [rcx+8]
	mov	edx, DWORD PTR tv145[rsp]
	mov	DWORD PTR [rcx+rax*4], edx

; 175  : 					mask >>= 1; line += 1;

	mov	eax, DWORD PTR mask$[rsp]
	sar	eax, 1
	mov	DWORD PTR mask$[rsp], eax
	mov	eax, DWORD PTR line$[rsp]
	inc	eax
	mov	DWORD PTR line$[rsp], eax

; 176  : 				}

	jmp	SHORT $LN2@AuPutS
$LN1@AuPutS:

; 177  : 				aucon->buffer[line + console_y * aucon->width] = 0; glyph += bpl; offs += aucon->scanline;

	mov	rax, QWORD PTR ?aucon@@3PEAU_aucon_@@EA	; aucon
	mov	ecx, DWORD PTR ?console_y@@3IA		; console_y
	imul	ecx, DWORD PTR [rax]
	mov	eax, ecx
	mov	ecx, DWORD PTR line$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	eax, eax
	mov	rcx, QWORD PTR ?aucon@@3PEAU_aucon_@@EA	; aucon
	mov	rcx, QWORD PTR [rcx+8]
	mov	DWORD PTR [rcx+rax*4], 0
	movsxd	rax, DWORD PTR bpl$[rsp]
	mov	rcx, QWORD PTR glyph$1[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR glyph$1[rsp], rax
	mov	rax, QWORD PTR ?aucon@@3PEAU_aucon_@@EA	; aucon
	movzx	eax, WORD PTR [rax+20]
	mov	ecx, DWORD PTR offs$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR offs$[rsp], eax

; 178  : 			}

	jmp	$LN5@AuPutS
$LN4@AuPutS:

; 179  : 			console_x++;

	mov	eax, DWORD PTR ?console_x@@3IA		; console_x
	inc	eax
	mov	DWORD PTR ?console_x@@3IA, eax		; console_x
$LN7@AuPutS:
$LN10@AuPutS:

; 180  : 		}
; 181  : 		s++;

	mov	rax, QWORD PTR s$[rsp]
	inc	rax
	mov	QWORD PTR s$[rsp], rax

; 182  : 	}

	jmp	$LN13@AuPutS
$LN12@AuPutS:
$LN15@AuPutS:

; 183  : 
; 184  : 
; 185  : }

	add	rsp, 72					; 00000048H
	ret	0
?AuPutS@@YAXPEAD@Z ENDP					; AuPutS
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\aucon.cpp
_TEXT	SEGMENT
line$ = 0
font$ = 8
x$ = 16
offs$ = 20
mask$ = 24
y$ = 28
tv77 = 32
tv137 = 36
bpl$ = 40
tv189 = 44
kx$ = 48
glyph$ = 56
c$ = 80
?AuPutC@@YAXD@Z PROC					; AuPutC

; 113  : void AuPutC(char c) {

$LN14:
	mov	BYTE PTR [rsp+8], cl
	sub	rsp, 72					; 00000048H

; 114  : 	if (font_data == NULL)

	cmp	QWORD PTR ?font_data@@3PEAEEA, 0	; font_data
	jne	SHORT $LN7@AuPutC

; 115  : 		return;

	jmp	$LN8@AuPutC
$LN7@AuPutC:

; 116  : 
; 117  : 	psf2_t *font = (psf2_t*)font_data;

	mov	rax, QWORD PTR ?font_data@@3PEAEEA	; font_data
	mov	QWORD PTR font$[rsp], rax

; 118  : 	int x, y, kx = 0, line, mask, offs;

	mov	DWORD PTR kx$[rsp], 0

; 119  : 	int bpl = (font->width + 7) / 8;

	mov	rax, QWORD PTR font$[rsp]
	mov	eax, DWORD PTR [rax+28]
	add	eax, 7
	xor	edx, edx
	mov	ecx, 8
	div	ecx
	mov	DWORD PTR bpl$[rsp], eax

; 120  : 
; 121  : 
; 122  : 	unsigned char *glyph = (unsigned char*)font_data + font->headersize +
; 123  : 		(c>0 && c<font->numglyph ? c : 0)*font->bytesperglyph;

	movsx	eax, BYTE PTR c$[rsp]
	test	eax, eax
	jle	SHORT $LN10@AuPutC
	movsx	eax, BYTE PTR c$[rsp]
	mov	rcx, QWORD PTR font$[rsp]
	cmp	eax, DWORD PTR [rcx+16]
	jae	SHORT $LN10@AuPutC
	movsx	eax, BYTE PTR c$[rsp]
	mov	DWORD PTR tv77[rsp], eax
	jmp	SHORT $LN11@AuPutC
$LN10@AuPutC:
	mov	DWORD PTR tv77[rsp], 0
$LN11@AuPutC:
	mov	rax, QWORD PTR font$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	rcx, QWORD PTR ?font_data@@3PEAEEA	; font_data
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR font$[rsp]
	mov	edx, DWORD PTR tv77[rsp]
	imul	edx, DWORD PTR [rcx+20]
	mov	ecx, edx
	mov	ecx, ecx
	add	rax, rcx
	mov	QWORD PTR glyph$[rsp], rax

; 124  : 	offs = kx * (font->width + 1);// * 4);

	mov	rax, QWORD PTR font$[rsp]
	mov	eax, DWORD PTR [rax+28]
	inc	eax
	mov	ecx, DWORD PTR kx$[rsp]
	imul	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR offs$[rsp], eax

; 125  : 	for (y = 0; y<font->height; y++) {

	mov	DWORD PTR y$[rsp], 0
	jmp	SHORT $LN6@AuPutC
$LN5@AuPutC:
	mov	eax, DWORD PTR y$[rsp]
	inc	eax
	mov	DWORD PTR y$[rsp], eax
$LN6@AuPutC:
	mov	rax, QWORD PTR font$[rsp]
	mov	eax, DWORD PTR [rax+24]
	cmp	DWORD PTR y$[rsp], eax
	jae	$LN4@AuPutC

; 126  : 		line = offs; mask = 1 << (font->width - 1);

	mov	eax, DWORD PTR offs$[rsp]
	mov	DWORD PTR line$[rsp], eax
	mov	rax, QWORD PTR font$[rsp]
	mov	eax, DWORD PTR [rax+28]
	dec	eax
	mov	ecx, 1
	mov	DWORD PTR tv189[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv189[rsp]
	shl	eax, cl
	mov	DWORD PTR mask$[rsp], eax

; 127  : 		for (x = 0; x<font->width; x++) {

	mov	DWORD PTR x$[rsp], 0
	jmp	SHORT $LN3@AuPutC
$LN2@AuPutC:
	mov	eax, DWORD PTR x$[rsp]
	inc	eax
	mov	DWORD PTR x$[rsp], eax
$LN3@AuPutC:
	mov	rax, QWORD PTR font$[rsp]
	mov	eax, DWORD PTR [rax+28]
	cmp	DWORD PTR x$[rsp], eax
	jae	SHORT $LN1@AuPutC

; 128  : 			aucon->buffer[line + console_x + console_y * aucon->width] = ((int)*glyph) & (mask) ? 0xFFFFFF : 0;

	mov	rax, QWORD PTR glyph$[rsp]
	movzx	eax, BYTE PTR [rax]
	and	eax, DWORD PTR mask$[rsp]
	test	eax, eax
	je	SHORT $LN12@AuPutC
	mov	DWORD PTR tv137[rsp], 16777215		; 00ffffffH
	jmp	SHORT $LN13@AuPutC
$LN12@AuPutC:
	mov	DWORD PTR tv137[rsp], 0
$LN13@AuPutC:
	mov	eax, DWORD PTR ?console_x@@3IA		; console_x
	mov	ecx, DWORD PTR line$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR ?aucon@@3PEAU_aucon_@@EA	; aucon
	mov	edx, DWORD PTR ?console_y@@3IA		; console_y
	imul	edx, DWORD PTR [rcx]
	mov	ecx, edx
	add	eax, ecx
	mov	eax, eax
	mov	rcx, QWORD PTR ?aucon@@3PEAU_aucon_@@EA	; aucon
	mov	rcx, QWORD PTR [rcx+8]
	mov	edx, DWORD PTR tv137[rsp]
	mov	DWORD PTR [rcx+rax*4], edx

; 129  : 			mask >>= 1; line += 1;

	mov	eax, DWORD PTR mask$[rsp]
	sar	eax, 1
	mov	DWORD PTR mask$[rsp], eax
	mov	eax, DWORD PTR line$[rsp]
	inc	eax
	mov	DWORD PTR line$[rsp], eax

; 130  : 		}

	jmp	$LN2@AuPutC
$LN1@AuPutC:

; 131  : 		aucon->buffer[line + console_x + console_y * aucon->width] = 0; glyph += bpl; offs += aucon->scanline;

	mov	eax, DWORD PTR ?console_x@@3IA		; console_x
	mov	ecx, DWORD PTR line$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR ?aucon@@3PEAU_aucon_@@EA	; aucon
	mov	edx, DWORD PTR ?console_y@@3IA		; console_y
	imul	edx, DWORD PTR [rcx]
	mov	ecx, edx
	add	eax, ecx
	mov	eax, eax
	mov	rcx, QWORD PTR ?aucon@@3PEAU_aucon_@@EA	; aucon
	mov	rcx, QWORD PTR [rcx+8]
	mov	DWORD PTR [rcx+rax*4], 0
	movsxd	rax, DWORD PTR bpl$[rsp]
	mov	rcx, QWORD PTR glyph$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR glyph$[rsp], rax
	mov	rax, QWORD PTR ?aucon@@3PEAU_aucon_@@EA	; aucon
	movzx	eax, WORD PTR [rax+20]
	mov	ecx, DWORD PTR offs$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR offs$[rsp], eax

; 132  : 	}

	jmp	$LN5@AuPutC
$LN4@AuPutC:

; 133  : 	console_x += font->width + 1;

	mov	rax, QWORD PTR font$[rsp]
	mov	eax, DWORD PTR [rax+28]
	mov	ecx, DWORD PTR ?console_x@@3IA		; console_x
	lea	eax, DWORD PTR [rcx+rax+1]
	mov	DWORD PTR ?console_x@@3IA, eax		; console_x
$LN8@AuPutC:

; 134  : }

	add	rsp, 72					; 00000048H
	ret	0
?AuPutC@@YAXD@Z ENDP					; AuPutC
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\aucon.cpp
_TEXT	SEGMENT
value$ = 8
?AuConsoleEarlyEnable@@YAX_N@Z PROC			; AuConsoleEarlyEnable

; 287  : void AuConsoleEarlyEnable(bool value) {

	mov	BYTE PTR [rsp+8], cl

; 288  : 	aucon->early_mode = value;

	mov	rax, QWORD PTR ?aucon@@3PEAU_aucon_@@EA	; aucon
	movzx	ecx, BYTE PTR value$[rsp]
	mov	BYTE PTR [rax+32], cl

; 289  : }

	ret	0
?AuConsoleEarlyEnable@@YAX_N@Z ENDP			; AuConsoleEarlyEnable
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\aucon.cpp
_TEXT	SEGMENT
c$1 = 32
args$ = 40
buf$2 = 48
buf$3 = 52
i$4 = 56
i$5 = 64
width$6 = 72
x$7 = 80
x$8 = 88
x$9 = 96
len$10 = 104
buffer$11 = 112
buffer$12 = 192
format$ = 288
AuTextOut PROC

; 192  : void AuTextOut(const char* format, ...) {

$LN26:
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	sub	rsp, 280				; 00000118H

; 193  : 
; 194  : 	if (early_) {

	movzx	eax, BYTE PTR ?early_@@3_NA		; early_
	test	eax, eax
	je	SHORT $LN23@AuTextOut

; 195  : 		_print_func(format);

	mov	rcx, QWORD PTR format$[rsp]
	call	QWORD PTR ?_print_func@@3P6AXPEBDZZEA	; _print_func

; 196  : 		return;

	jmp	$LN24@AuTextOut
$LN23@AuTextOut:

; 197  : 	}
; 198  : 
; 199  : 
; 200  : 	_va_list_ args;
; 201  : 	va_start(args, format);

	lea	rax, QWORD PTR format$[rsp+8]
	mov	QWORD PTR args$[rsp], rax
$LN22@AuTextOut:

; 202  : 
; 203  : 	while (*format)

	mov	rax, QWORD PTR format$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	$LN21@AuTextOut

; 204  : 	{
; 205  : 		if (*format == '%')

	mov	rax, QWORD PTR format$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 37					; 00000025H
	jne	$LN20@AuTextOut

; 206  : 		{
; 207  : 			++format;

	mov	rax, QWORD PTR format$[rsp]
	inc	rax
	mov	QWORD PTR format$[rsp], rax

; 208  : 			if (*format == 'd')

	mov	rax, QWORD PTR format$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 100				; 00000064H
	jne	$LN19@AuTextOut

; 209  : 			{
; 210  : 				size_t width = 0;

	mov	QWORD PTR width$6[rsp], 0

; 211  : 				if (format[1] == '.')

	mov	eax, 1
	imul	rax, rax, 1
	mov	rcx, QWORD PTR format$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 46					; 0000002eH
	jne	$LN18@AuTextOut

; 212  : 				{
; 213  : 					for (size_t i = 2; format[i] >= '0' && format[i] <= '9'; ++i)

	mov	QWORD PTR i$4[rsp], 2
	jmp	SHORT $LN17@AuTextOut
$LN16@AuTextOut:
	mov	rax, QWORD PTR i$4[rsp]
	inc	rax
	mov	QWORD PTR i$4[rsp], rax
$LN17@AuTextOut:
	mov	rax, QWORD PTR i$4[rsp]
	mov	rcx, QWORD PTR format$[rsp]
	add	rcx, rax
	mov	rax, rcx
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 48					; 00000030H
	jl	SHORT $LN15@AuTextOut
	mov	rax, QWORD PTR i$4[rsp]
	mov	rcx, QWORD PTR format$[rsp]
	add	rcx, rax
	mov	rax, rcx
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 57					; 00000039H
	jg	SHORT $LN15@AuTextOut

; 214  : 					{
; 215  : 						width *= 10;

	imul	rax, QWORD PTR width$6[rsp], 10
	mov	QWORD PTR width$6[rsp], rax

; 216  : 						width += format[i] - '0';

	mov	rax, QWORD PTR i$4[rsp]
	mov	rcx, QWORD PTR format$[rsp]
	add	rcx, rax
	mov	rax, rcx
	movsx	eax, BYTE PTR [rax]
	sub	eax, 48					; 00000030H
	cdqe
	mov	rcx, QWORD PTR width$6[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR width$6[rsp], rax

; 217  : 					}

	jmp	SHORT $LN16@AuTextOut
$LN15@AuTextOut:
$LN18@AuTextOut:

; 218  : 				}
; 219  : 				size_t i = va_arg(args, size_t);

	mov	rax, QWORD PTR args$[rsp]
	add	rax, 8
	mov	QWORD PTR args$[rsp], rax
	mov	rax, QWORD PTR args$[rsp]
	mov	rax, QWORD PTR [rax-8]
	mov	QWORD PTR i$5[rsp], rax

; 220  : 				char buffer[sizeof(size_t)* 8 + 1];
; 221  : 				//	size_t len
; 222  : 				if (i < 0) {

	cmp	QWORD PTR i$5[rsp], 0
	jae	SHORT $LN14@AuTextOut

; 223  : 					i = +i;

	mov	rax, QWORD PTR i$5[rsp]
	mov	QWORD PTR i$5[rsp], rax

; 224  : 					sztoa(i, buffer, 10);

	mov	r8d, 10
	lea	rdx, QWORD PTR buffer$11[rsp]
	mov	rcx, QWORD PTR i$5[rsp]
	call	?sztoa@@YAPEAD_KPEADH@Z			; sztoa

; 225  : 				}
; 226  : 				else {

	jmp	SHORT $LN13@AuTextOut
$LN14@AuTextOut:

; 227  : 					sztoa(i, buffer, 10);

	mov	r8d, 10
	lea	rdx, QWORD PTR buffer$11[rsp]
	mov	rcx, QWORD PTR i$5[rsp]
	call	?sztoa@@YAPEAD_KPEADH@Z			; sztoa

; 228  : 					size_t len = strlen(buffer);

	lea	rcx, QWORD PTR buffer$11[rsp]
	call	strlen
	mov	QWORD PTR len$10[rsp], rax
$LN13@AuTextOut:

; 229  : 				}
; 230  : 				/*	while (len++ < width)
; 231  : 				puts("0");*/
; 232  : 				AuPutS(buffer);

	lea	rcx, QWORD PTR buffer$11[rsp]
	call	?AuPutS@@YAXPEAD@Z			; AuPutS
	jmp	$LN12@AuTextOut
$LN19@AuTextOut:

; 233  : 			}
; 234  : 			else if (*format == 'c')

	mov	rax, QWORD PTR format$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 99					; 00000063H
	jne	SHORT $LN11@AuTextOut

; 235  : 			{
; 236  : 				char c = va_arg(args, char);

	mov	rax, QWORD PTR args$[rsp]
	add	rax, 4
	mov	QWORD PTR args$[rsp], rax
	mov	rax, QWORD PTR args$[rsp]
	movzx	eax, BYTE PTR [rax-4]
	mov	BYTE PTR c$1[rsp], al

; 237  : 				//char buffer[sizeof(size_t) * 8 + 1];
; 238  : 				//sztoa(c, buffer, 10);
; 239  : 				//puts(buffer);
; 240  : 				AuPutC(c);

	movzx	ecx, BYTE PTR c$1[rsp]
	call	?AuPutC@@YAXD@Z				; AuPutC
	jmp	$LN10@AuTextOut
$LN11@AuTextOut:

; 241  : 			}
; 242  : 			else if (*format == 'x')

	mov	rax, QWORD PTR format$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 120				; 00000078H
	jne	SHORT $LN9@AuTextOut

; 243  : 			{
; 244  : 				size_t x = va_arg(args, size_t);

	mov	rax, QWORD PTR args$[rsp]
	add	rax, 8
	mov	QWORD PTR args$[rsp], rax
	mov	rax, QWORD PTR args$[rsp]
	mov	rax, QWORD PTR [rax-8]
	mov	QWORD PTR x$9[rsp], rax

; 245  : 				char buffer[sizeof(size_t)* 8 + 1];
; 246  : 				sztoa(x, buffer, 16);

	mov	r8d, 16
	lea	rdx, QWORD PTR buffer$12[rsp]
	mov	rcx, QWORD PTR x$9[rsp]
	call	?sztoa@@YAPEAD_KPEADH@Z			; sztoa

; 247  : 				//puts("0x");
; 248  : 				AuPutS(buffer);

	lea	rcx, QWORD PTR buffer$12[rsp]
	call	?AuPutS@@YAXPEAD@Z			; AuPutS
	jmp	$LN8@AuTextOut
$LN9@AuTextOut:

; 249  : 			}
; 250  : 			else if (*format == 's')

	mov	rax, QWORD PTR format$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 115				; 00000073H
	jne	SHORT $LN7@AuTextOut

; 251  : 			{
; 252  : 				char* x = va_arg(args, char*);

	mov	rax, QWORD PTR args$[rsp]
	add	rax, 8
	mov	QWORD PTR args$[rsp], rax
	mov	rax, QWORD PTR args$[rsp]
	mov	rax, QWORD PTR [rax-8]
	mov	QWORD PTR x$8[rsp], rax

; 253  : 				AuPutS(x);

	mov	rcx, QWORD PTR x$8[rsp]
	call	?AuPutS@@YAXPEAD@Z			; AuPutS
	jmp	$LN6@AuTextOut
$LN7@AuTextOut:

; 254  : 			}
; 255  : 			else if (*format == 'f')

	mov	rax, QWORD PTR format$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 102				; 00000066H
	jne	SHORT $LN5@AuTextOut

; 256  : 			{
; 257  : 				double x = va_arg(args, double);

	mov	rax, QWORD PTR args$[rsp]
	add	rax, 8
	mov	QWORD PTR args$[rsp], rax
	mov	rax, QWORD PTR args$[rsp]
	movsdx	xmm0, QWORD PTR [rax-8]
	movsdx	QWORD PTR x$7[rsp], xmm0

; 258  : 				AuPutS(ftoa(x, 2));

	cvtsd2ss xmm0, QWORD PTR x$7[rsp]
	mov	dl, 2
	call	?ftoa@@YAPEADME@Z			; ftoa
	mov	rcx, rax
	call	?AuPutS@@YAXPEAD@Z			; AuPutS
	jmp	SHORT $LN4@AuTextOut
$LN5@AuTextOut:

; 259  : 			}
; 260  : 			else if (*format == '%')

	mov	rax, QWORD PTR format$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 37					; 00000025H
	jne	SHORT $LN3@AuTextOut

; 261  : 			{
; 262  : 				AuPutS(".");

	lea	rcx, OFFSET FLAT:$SG3015
	call	?AuPutS@@YAXPEAD@Z			; AuPutS

; 263  : 			}
; 264  : 			else

	jmp	SHORT $LN2@AuTextOut
$LN3@AuTextOut:

; 265  : 			{
; 266  : 				char buf[3];
; 267  : 				buf[0] = '%'; buf[1] = *format; buf[2] = '\0';

	mov	eax, 1
	imul	rax, rax, 0
	mov	BYTE PTR buf$3[rsp+rax], 37		; 00000025H
	mov	eax, 1
	imul	rax, rax, 1
	mov	rcx, QWORD PTR format$[rsp]
	movzx	ecx, BYTE PTR [rcx]
	mov	BYTE PTR buf$3[rsp+rax], cl
	mov	eax, 1
	imul	rax, rax, 2
	mov	BYTE PTR buf$3[rsp+rax], 0

; 268  : 				AuPutS(buf);

	lea	rcx, QWORD PTR buf$3[rsp]
	call	?AuPutS@@YAXPEAD@Z			; AuPutS
$LN2@AuTextOut:
$LN4@AuTextOut:
$LN6@AuTextOut:
$LN8@AuTextOut:
$LN10@AuTextOut:
$LN12@AuTextOut:

; 269  : 			}
; 270  : 		}
; 271  : 		else

	jmp	SHORT $LN1@AuTextOut
$LN20@AuTextOut:

; 272  : 		{
; 273  : 			char buf[2];
; 274  : 			buf[0] = *format; buf[1] = '\0';

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR format$[rsp]
	movzx	ecx, BYTE PTR [rcx]
	mov	BYTE PTR buf$2[rsp+rax], cl
	mov	eax, 1
	imul	rax, rax, 1
	mov	BYTE PTR buf$2[rsp+rax], 0

; 275  : 			AuPutS(buf);

	lea	rcx, QWORD PTR buf$2[rsp]
	call	?AuPutS@@YAXPEAD@Z			; AuPutS
$LN1@AuTextOut:

; 276  : 		}
; 277  : 		++format;

	mov	rax, QWORD PTR format$[rsp]
	inc	rax
	mov	QWORD PTR format$[rsp], rax

; 278  : 	}

	jmp	$LN22@AuTextOut
$LN21@AuTextOut:
$LN24@AuTextOut:

; 279  : 	va_end(args);
; 280  : }

	add	rsp, 280				; 00000118H
	ret	0
AuTextOut ENDP
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\aucon.cpp
_TEXT	SEGMENT
i$1 = 32
h$2 = 36
w$3 = 40
font_$ = 48
tv80 = 56
info$ = 80
?AuConsolePostInitialise@@YAXPEAU_KERNEL_BOOT_INFO_@@@Z PROC ; AuConsolePostInitialise

; 81   : void AuConsolePostInitialise(PKERNEL_BOOT_INFO info) {

$LN12:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 82   : 
; 83   : 	uint8_t* font_ = (uint8_t*)P2V((uint64_t)AuPmmngrAlloc());

	call	AuPmmngrAlloc
	mov	rcx, rax
	call	P2V
	mov	QWORD PTR font_$[rsp], rax

; 84   : 	memset(font_, 0, 4096);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR font_$[rsp]
	call	memset

; 85   : 	memcpy(font_, info->psf_font_data, 4096);

	mov	r8d, 4096				; 00001000H
	mov	rax, QWORD PTR info$[rsp]
	mov	rdx, QWORD PTR [rax+98]
	mov	rcx, QWORD PTR font_$[rsp]
	call	memcpy

; 86   : 	font_data = font_;

	mov	rax, QWORD PTR font_$[rsp]
	mov	QWORD PTR ?font_data@@3PEAEEA, rax	; font_data

; 87   : 
; 88   : 	aucon = (AuConsole*)kmalloc(sizeof(AuConsole));

	mov	ecx, 40					; 00000028H
	call	kmalloc
	mov	QWORD PTR ?aucon@@3PEAU_aucon_@@EA, rax	; aucon

; 89   : 	memset(aucon, 0, sizeof(AuConsole));

	mov	r8d, 40					; 00000028H
	xor	edx, edx
	mov	rcx, QWORD PTR ?aucon@@3PEAU_aucon_@@EA	; aucon
	call	memset

; 90   : 
; 91   : 	for (int i = 0; i < info->fb_size / PAGE_SIZE; i++)

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN9@AuConsoleP
$LN8@AuConsoleP:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN9@AuConsoleP:
	movsxd	rax, DWORD PTR i$1[rsp]
	mov	QWORD PTR tv80[rsp], rax
	xor	edx, edx
	mov	rcx, QWORD PTR info$[rsp]
	mov	rax, QWORD PTR [rcx+52]
	mov	ecx, 4096				; 00001000H
	div	rcx
	mov	rcx, QWORD PTR tv80[rsp]
	cmp	rcx, rax
	jae	SHORT $LN7@AuConsoleP

; 92   : 		AuMapPage((uint64_t)info->graphics_framebuffer + i * PAGE_SIZE, 0xFFFFD00000200000 + i * 4096, X86_64_PAGING_USER);

	imul	eax, DWORD PTR i$1[rsp], 4096		; 00001000H
	cdqe
	mov	rcx, 52776556036096			; 00002fffffe00000H
	sub	rax, rcx
	imul	ecx, DWORD PTR i$1[rsp], 4096		; 00001000H
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR info$[rsp]
	add	rcx, QWORD PTR [rdx+44]
	mov	r8b, 4
	mov	rdx, rax
	call	AuMapPage
	jmp	SHORT $LN8@AuConsoleP
$LN7@AuConsoleP:

; 93   : 
; 94   : 	early_ = false;

	mov	BYTE PTR ?early_@@3_NA, 0		; early_

; 95   : 	aucon->buffer = (uint32_t*)0xFFFFD00000200000;

	mov	rax, QWORD PTR ?aucon@@3PEAU_aucon_@@EA	; aucon
	mov	rcx, -52776556036096			; ffffd00000200000H
	mov	QWORD PTR [rax+8], rcx

; 96   : 	aucon->width = info->X_Resolution;

	mov	rax, QWORD PTR info$[rsp]
	movzx	eax, WORD PTR [rax+60]
	mov	rcx, QWORD PTR ?aucon@@3PEAU_aucon_@@EA	; aucon
	mov	DWORD PTR [rcx], eax

; 97   : 	aucon->height = info->Y_Resolution;

	mov	rax, QWORD PTR info$[rsp]
	movzx	eax, WORD PTR [rax+62]
	mov	rcx, QWORD PTR ?aucon@@3PEAU_aucon_@@EA	; aucon
	mov	DWORD PTR [rcx+4], eax

; 98   : 	aucon->bpp = 32;

	mov	rax, QWORD PTR ?aucon@@3PEAU_aucon_@@EA	; aucon
	mov	DWORD PTR [rax+16], 32			; 00000020H

; 99   : 	aucon->scanline = info->pixels_per_line;

	mov	rax, QWORD PTR ?aucon@@3PEAU_aucon_@@EA	; aucon
	mov	rcx, QWORD PTR info$[rsp]
	movzx	ecx, WORD PTR [rcx+64]
	mov	WORD PTR [rax+20], cx

; 100  : 	aucon->pitch = 4 * info->pixels_per_line;

	mov	rax, QWORD PTR info$[rsp]
	movzx	eax, WORD PTR [rax+64]
	shl	eax, 2
	mov	rcx, QWORD PTR ?aucon@@3PEAU_aucon_@@EA	; aucon
	mov	DWORD PTR [rcx+28], eax

; 101  : 	aucon->size = info->fb_size;

	mov	rax, QWORD PTR ?aucon@@3PEAU_aucon_@@EA	; aucon
	mov	rcx, QWORD PTR info$[rsp]
	mov	ecx, DWORD PTR [rcx+52]
	mov	DWORD PTR [rax+24], ecx

; 102  : 	aucon->early_mode = false;

	mov	rax, QWORD PTR ?aucon@@3PEAU_aucon_@@EA	; aucon
	mov	BYTE PTR [rax+32], 0

; 103  : 	console_x = console_y = 0;

	mov	DWORD PTR ?console_y@@3IA, 0		; console_y
	mov	eax, DWORD PTR ?console_y@@3IA		; console_y
	mov	DWORD PTR ?console_x@@3IA, eax		; console_x

; 104  : 
; 105  : 	for (int w = 0; w < info->X_Resolution; w++) {

	mov	DWORD PTR w$3[rsp], 0
	jmp	SHORT $LN6@AuConsoleP
$LN5@AuConsoleP:
	mov	eax, DWORD PTR w$3[rsp]
	inc	eax
	mov	DWORD PTR w$3[rsp], eax
$LN6@AuConsoleP:
	mov	rax, QWORD PTR info$[rsp]
	movzx	eax, WORD PTR [rax+60]
	cmp	DWORD PTR w$3[rsp], eax
	jge	SHORT $LN4@AuConsoleP

; 106  : 		for (int h = 0; h < info->Y_Resolution; h++) {

	mov	DWORD PTR h$2[rsp], 0
	jmp	SHORT $LN3@AuConsoleP
$LN2@AuConsoleP:
	mov	eax, DWORD PTR h$2[rsp]
	inc	eax
	mov	DWORD PTR h$2[rsp], eax
$LN3@AuConsoleP:
	mov	rax, QWORD PTR info$[rsp]
	movzx	eax, WORD PTR [rax+62]
	cmp	DWORD PTR h$2[rsp], eax
	jge	SHORT $LN1@AuConsoleP

; 107  : 			aucon->buffer[w + h * info->X_Resolution] = 0x00000000;

	mov	rax, QWORD PTR info$[rsp]
	movzx	eax, WORD PTR [rax+60]
	mov	ecx, DWORD PTR h$2[rsp]
	imul	ecx, eax
	mov	eax, ecx
	mov	ecx, DWORD PTR w$3[rsp]
	add	ecx, eax
	mov	eax, ecx
	cdqe
	mov	rcx, QWORD PTR ?aucon@@3PEAU_aucon_@@EA	; aucon
	mov	rcx, QWORD PTR [rcx+8]
	mov	DWORD PTR [rcx+rax*4], 0

; 108  : 		}

	jmp	SHORT $LN2@AuConsoleP
$LN1@AuConsoleP:

; 109  : 	}

	jmp	SHORT $LN5@AuConsoleP
$LN4@AuConsoleP:

; 110  : }

	add	rsp, 72					; 00000048H
	ret	0
?AuConsolePostInitialise@@YAXPEAU_KERNEL_BOOT_INFO_@@@Z ENDP ; AuConsolePostInitialise
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\aurora\kernel\aucon.cpp
_TEXT	SEGMENT
info$ = 8
early$ = 16
?AuConsoleInitialize@@YAXPEAU_KERNEL_BOOT_INFO_@@_N@Z PROC ; AuConsoleInitialize

; 69   : void AuConsoleInitialize(PKERNEL_BOOT_INFO info, bool early) {

	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx

; 70   : 	if (early) {

	movzx	eax, BYTE PTR early$[rsp]
	test	eax, eax
	je	SHORT $LN1@AuConsoleI

; 71   : 		_print_func = info->printf_gui;

	mov	rax, QWORD PTR info$[rsp]
	mov	rax, QWORD PTR [rax+106]
	mov	QWORD PTR ?_print_func@@3P6AXPEBDZZEA, rax ; _print_func

; 72   : 		early_ = early;

	movzx	eax, BYTE PTR early$[rsp]
	mov	BYTE PTR ?early_@@3_NA, al		; early_
$LN1@AuConsoleI:

; 73   : 	}
; 74   : 	aucon = NULL;

	mov	QWORD PTR ?aucon@@3PEAU_aucon_@@EA, 0	; aucon

; 75   : }

	ret	0
?AuConsoleInitialize@@YAXPEAU_KERNEL_BOOT_INFO_@@_N@Z ENDP ; AuConsoleInitialize
_TEXT	ENDS
END
