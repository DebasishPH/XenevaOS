; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30154.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?font_data@@3PEAEEA				; font_data
PUBLIC	?console_x@@3IA					; console_x
PUBLIC	?console_y@@3IA					; console_y
PUBLIC	?__framebuffer@@3PEAIEA				; __framebuffer
PUBLIC	?aucon@@3PEAU_aucon_@@EA			; aucon
PUBLIC	?early_@@3_NA					; early_
PUBLIC	?_print_func@@3P6AXPEBDZZEA			; _print_func
_BSS	SEGMENT
?font_data@@3PEAEEA DQ 01H DUP (?)			; font_data
?console_x@@3IA DD 01H DUP (?)				; console_x
?console_y@@3IA DD 01H DUP (?)				; console_y
?__framebuffer@@3PEAIEA DQ 01H DUP (?)			; __framebuffer
?aucon@@3PEAU_aucon_@@EA DQ 01H DUP (?)			; aucon
?early_@@3_NA DB 01H DUP (?)				; early_
	ALIGN	8

?_print_func@@3P6AXPEBDZZEA DQ 01H DUP (?)		; _print_func
_BSS	ENDS
msvcjmc	SEGMENT
__A69542EC_aucon@cpp DB 01H
msvcjmc	ENDS
PUBLIC	?AuConsoleInitialize@@YAXPEAU_KERNEL_BOOT_INFO_@@_N@Z ; AuConsoleInitialize
PUBLIC	?AuConsolePostInitialise@@YAXPEAU_KERNEL_BOOT_INFO_@@@Z ; AuConsolePostInitialise
PUBLIC	AuTextOut
PUBLIC	?AuConsoleEarlyEnable@@YAX_N@Z			; AuConsoleEarlyEnable
PUBLIC	?AuConsoleIoControl@@YAHPEAU__VFS_NODE__@@HPEAX@Z ; AuConsoleIoControl
PUBLIC	?AuPutC@@YAXD@Z					; AuPutC
PUBLIC	?AuPutS@@YAXPEAD@Z				; AuPutS
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_04PJHBAHNI@?1dev@				; `string'
PUBLIC	??_C@_05KCJBMLII@graph@				; `string'
PUBLIC	??_C@_01KMDKNFGN@?1@				; `string'
PUBLIC	??_C@_01JOAMLHOP@?9@				; `string'
PUBLIC	??_C@_01LFCBOECM@?4@				; `string'
EXTRN	AuMapPage:PROC
EXTRN	AuPmmngrAlloc:PROC
EXTRN	P2V:PROC
EXTRN	kmalloc:PROC
EXTRN	strcpy:PROC
EXTRN	strlen:PROC
EXTRN	memset:PROC
EXTRN	memcpy:PROC
EXTRN	?sztoa@@YAPEAD_KPEADH@Z:PROC			; sztoa
EXTRN	?ftoa@@YAPEADME@Z:PROC				; ftoa
EXTRN	AuVFSFind:PROC
EXTRN	AuDevFSAddFile:PROC
EXTRN	__CheckForDebuggerJustMyCode:PROC
EXTRN	__ImageBase:BYTE
EXTRN	_fltused:DWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuConsoleInitialize@@YAXPEAU_KERNEL_BOOT_INFO_@@_N@Z DD imagerel $LN4
	DD	imagerel $LN4+81
	DD	imagerel $unwind$?AuConsoleInitialize@@YAXPEAU_KERNEL_BOOT_INFO_@@_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuConsolePostInitialise@@YAXPEAU_KERNEL_BOOT_INFO_@@@Z DD imagerel $LN12
	DD	imagerel $LN12+709
	DD	imagerel $unwind$?AuConsolePostInitialise@@YAXPEAU_KERNEL_BOOT_INFO_@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AuTextOut DD imagerel $LN26
	DD	imagerel $LN26+884
	DD	imagerel $unwind$AuTextOut
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuConsoleEarlyEnable@@YAX_N@Z DD imagerel $LN3
	DD	imagerel $LN3+46
	DD	imagerel $unwind$?AuConsoleEarlyEnable@@YAX_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuConsoleIoControl@@YAHPEAU__VFS_NODE__@@HPEAX@Z DD imagerel $LN14
	DD	imagerel $LN14+344
	DD	imagerel $unwind$?AuConsoleIoControl@@YAHPEAU__VFS_NODE__@@HPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuPutC@@YAXD@Z DD imagerel $LN14
	DD	imagerel $LN14+517
	DD	imagerel $unwind$?AuPutC@@YAXD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AuPutS@@YAXPEAD@Z DD imagerel $LN21
	DD	imagerel $LN21+623
	DD	imagerel $unwind$?AuPutS@@YAXPEAD@Z
pdata	ENDS
;	COMDAT ??_C@_01LFCBOECM@?4@
CONST	SEGMENT
??_C@_01LFCBOECM@?4@ DB '.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01JOAMLHOP@?9@
CONST	SEGMENT
??_C@_01JOAMLHOP@?9@ DB '-', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01KMDKNFGN@?1@
CONST	SEGMENT
??_C@_01KMDKNFGN@?1@ DB '/', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05KCJBMLII@graph@
CONST	SEGMENT
??_C@_05KCJBMLII@graph@ DB 'graph', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04PJHBAHNI@?1dev@
CONST	SEGMENT
??_C@_04PJHBAHNI@?1dev@ DB '/dev', 00H			; `string'
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuPutS@@YAXPEAD@Z DD 025041201H
	DD	010d2312H
	DD	050060012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuPutC@@YAXD@Z DD 025041101H
	DD	010c2311H
	DD	050050014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuConsoleIoControl@@YAHPEAU__VFS_NODE__@@HPEAX@Z DD 025041b01H
	DD	0116231bH
	DD	0500f0014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuConsoleEarlyEnable@@YAX_N@Z DD 025030e01H
	DD	0b209230eH
	DD	05005H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AuTextOut DD 025042101H
	DD	011c2321H
	DD	05015002cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuConsolePostInitialise@@YAXPEAU_KERNEL_BOOT_INFO_@@@Z DD 025041201H
	DD	010d2312H
	DD	050060012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AuConsoleInitialize@@YAXPEAU_KERNEL_BOOT_INFO_@@_N@Z DD 025031301H
	DD	0b20e2313H
	DD	0500aH
xdata	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\aucon.cpp
;	COMDAT ?AuPutS@@YAXPEAD@Z
_TEXT	SEGMENT
font$ = 0
x$ = 8
y$ = 12
line$ = 16
mask$ = 20
offs$ = 24
bpl$ = 28
glyph$1 = 32
tv203 = 104
tv145 = 104
tv86 = 104
s$ = 128
?AuPutS@@YAXPEAD@Z PROC					; AuPutS, COMDAT

; 205  : void AuPutS(char *s){

$LN21:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 144				; 00000090H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__A69542EC_aucon@cpp
	call	__CheckForDebuggerJustMyCode

; 206  : 	if (font_data == NULL)

	cmp	QWORD PTR ?font_data@@3PEAEEA, 0	; font_data
	jne	SHORT $LN10@AuPutS

; 207  : 		return;

	jmp	$LN1@AuPutS
$LN10@AuPutS:

; 208  : 
; 209  : 	psf2_t *font = (psf2_t*)font_data;

	mov	rax, QWORD PTR ?font_data@@3PEAEEA	; font_data
	mov	QWORD PTR font$[rbp], rax

; 210  : 	int x, y, line, mask, offs;
; 211  : 	int bpl = (font->width + 7) / 8;

	mov	rax, QWORD PTR font$[rbp]
	mov	eax, DWORD PTR [rax+28]
	add	eax, 7
	xor	edx, edx
	mov	ecx, 8
	div	ecx
	mov	DWORD PTR bpl$[rbp], eax
$LN2@AuPutS:

; 212  : 	while (*s) {

	mov	rax, QWORD PTR s$[rbp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	$LN3@AuPutS

; 213  : 		if (*s == '\n') {

	mov	rax, QWORD PTR s$[rbp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 10
	jne	SHORT $LN11@AuPutS

; 214  : 
; 215  : 			console_y += 16;

	mov	eax, DWORD PTR ?console_y@@3IA		; console_y
	add	eax, 16
	mov	DWORD PTR ?console_y@@3IA, eax		; console_y

; 216  : 			console_x = 0;

	mov	DWORD PTR ?console_x@@3IA, 0		; console_x

; 217  : 			//!Scroll
; 218  : 			/*if (console_y >= aucon->height) {
; 219  : 				for (int line_y = 0; line_y < aucon->height - 16; line_y++) {
; 220  : 					for (int code_x = 0; code_x < aucon->width - 8; code_x++) {
; 221  : 						aucon->buffer[line_y * aucon->width + code_x] = aucon->buffer[(line_y + 16) * aucon->width + code_x];
; 222  : 					}
; 223  : 				}
; 224  : 				console_y -= 16;
; 225  : 			}*/
; 226  : 
; 227  : 		}

	jmp	$LN12@AuPutS
$LN11@AuPutS:

; 228  : 		else if (*s == '\b') {

	mov	rax, QWORD PTR s$[rbp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 8
	jne	SHORT $LN13@AuPutS

; 229  : 			if (console_x > 0) {

	cmp	DWORD PTR ?console_x@@3IA, 0		; console_x
	jbe	SHORT $LN15@AuPutS

; 230  : 				console_x--;

	mov	eax, DWORD PTR ?console_x@@3IA		; console_x
	dec	eax
	mov	DWORD PTR ?console_x@@3IA, eax		; console_x
$LN15@AuPutS:

; 231  : 			}
; 232  : 		}

	jmp	$LN14@AuPutS
$LN13@AuPutS:

; 233  : 		else {
; 234  : 			unsigned char *glyph = (unsigned char*)font_data + font->headersize +

	mov	rax, QWORD PTR s$[rbp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	jle	SHORT $LN17@AuPutS
	mov	rax, QWORD PTR s$[rbp]
	movsx	eax, BYTE PTR [rax]
	mov	rcx, QWORD PTR font$[rbp]
	cmp	eax, DWORD PTR [rcx+16]
	jae	SHORT $LN17@AuPutS
	mov	rax, QWORD PTR s$[rbp]
	movsx	eax, BYTE PTR [rax]
	mov	DWORD PTR tv86[rbp], eax
	jmp	SHORT $LN18@AuPutS
$LN17@AuPutS:
	mov	DWORD PTR tv86[rbp], 0
$LN18@AuPutS:
	mov	rax, QWORD PTR font$[rbp]
	mov	eax, DWORD PTR [rax+8]
	mov	rcx, QWORD PTR ?font_data@@3PEAEEA	; font_data
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR font$[rbp]
	mov	edx, DWORD PTR tv86[rbp]
	imul	edx, DWORD PTR [rcx+20]
	mov	ecx, edx
	mov	ecx, ecx
	add	rax, rcx
	mov	QWORD PTR glyph$1[rbp], rax

; 235  : 				(*s>0 && *s<font->numglyph ? *s : 0)*font->bytesperglyph;
; 236  : 			offs = console_x * (font->width + 1);// * 4);

	mov	rax, QWORD PTR font$[rbp]
	mov	eax, DWORD PTR [rax+28]
	inc	eax
	mov	ecx, DWORD PTR ?console_x@@3IA		; console_x
	imul	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR offs$[rbp], eax

; 237  : 			for (y = 0; y<font->height; y++) {

	mov	DWORD PTR y$[rbp], 0
	jmp	SHORT $LN6@AuPutS
$LN4@AuPutS:
	mov	eax, DWORD PTR y$[rbp]
	inc	eax
	mov	DWORD PTR y$[rbp], eax
$LN6@AuPutS:
	mov	rax, QWORD PTR font$[rbp]
	mov	eax, DWORD PTR [rax+24]
	cmp	DWORD PTR y$[rbp], eax
	jae	$LN5@AuPutS

; 238  : 				line = offs; mask = 1 << (font->width - 1);

	mov	eax, DWORD PTR offs$[rbp]
	mov	DWORD PTR line$[rbp], eax
	mov	rax, QWORD PTR font$[rbp]
	mov	eax, DWORD PTR [rax+28]
	dec	eax
	mov	ecx, 1
	mov	DWORD PTR tv203[rbp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv203[rbp]
	shl	eax, cl
	mov	DWORD PTR mask$[rbp], eax

; 239  : 				for (x = 0; x<font->width; x++) {

	mov	DWORD PTR x$[rbp], 0
	jmp	SHORT $LN9@AuPutS
$LN7@AuPutS:
	mov	eax, DWORD PTR x$[rbp]
	inc	eax
	mov	DWORD PTR x$[rbp], eax
$LN9@AuPutS:
	mov	rax, QWORD PTR font$[rbp]
	mov	eax, DWORD PTR [rax+28]
	cmp	DWORD PTR x$[rbp], eax
	jae	SHORT $LN8@AuPutS

; 240  : 					aucon->buffer[line + console_y * aucon->width] = ((int)*glyph) & (mask) ? 0xFFFFFF : 0;

	mov	rax, QWORD PTR glyph$1[rbp]
	movzx	eax, BYTE PTR [rax]
	and	eax, DWORD PTR mask$[rbp]
	test	eax, eax
	je	SHORT $LN19@AuPutS
	mov	DWORD PTR tv145[rbp], 16777215		; 00ffffffH
	jmp	SHORT $LN20@AuPutS
$LN19@AuPutS:
	mov	DWORD PTR tv145[rbp], 0
$LN20@AuPutS:
	mov	rax, QWORD PTR ?aucon@@3PEAU_aucon_@@EA	; aucon
	mov	ecx, DWORD PTR ?console_y@@3IA		; console_y
	imul	ecx, DWORD PTR [rax]
	mov	eax, ecx
	mov	ecx, DWORD PTR line$[rbp]
	add	ecx, eax
	mov	eax, ecx
	mov	eax, eax
	mov	rcx, QWORD PTR ?aucon@@3PEAU_aucon_@@EA	; aucon
	mov	rcx, QWORD PTR [rcx+8]
	mov	edx, DWORD PTR tv145[rbp]
	mov	DWORD PTR [rcx+rax*4], edx

; 241  : 					mask >>= 1; line += 1;

	mov	eax, DWORD PTR mask$[rbp]
	sar	eax, 1
	mov	DWORD PTR mask$[rbp], eax
	mov	eax, DWORD PTR line$[rbp]
	inc	eax
	mov	DWORD PTR line$[rbp], eax

; 242  : 				}

	jmp	SHORT $LN7@AuPutS
$LN8@AuPutS:

; 243  : 				aucon->buffer[line + console_y * aucon->width] = 0; glyph += bpl; offs += aucon->scanline;

	mov	rax, QWORD PTR ?aucon@@3PEAU_aucon_@@EA	; aucon
	mov	ecx, DWORD PTR ?console_y@@3IA		; console_y
	imul	ecx, DWORD PTR [rax]
	mov	eax, ecx
	mov	ecx, DWORD PTR line$[rbp]
	add	ecx, eax
	mov	eax, ecx
	mov	eax, eax
	mov	rcx, QWORD PTR ?aucon@@3PEAU_aucon_@@EA	; aucon
	mov	rcx, QWORD PTR [rcx+8]
	mov	DWORD PTR [rcx+rax*4], 0
	movsxd	rax, DWORD PTR bpl$[rbp]
	mov	rcx, QWORD PTR glyph$1[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR glyph$1[rbp], rax
	mov	rax, QWORD PTR ?aucon@@3PEAU_aucon_@@EA	; aucon
	movzx	eax, WORD PTR [rax+20]
	mov	ecx, DWORD PTR offs$[rbp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR offs$[rbp], eax

; 244  : 			}

	jmp	$LN4@AuPutS
$LN5@AuPutS:

; 245  : 			console_x++;

	mov	eax, DWORD PTR ?console_x@@3IA		; console_x
	inc	eax
	mov	DWORD PTR ?console_x@@3IA, eax		; console_x
$LN14@AuPutS:
$LN12@AuPutS:

; 246  : 		}
; 247  : 		s++;

	mov	rax, QWORD PTR s$[rbp]
	inc	rax
	mov	QWORD PTR s$[rbp], rax

; 248  : 	}

	jmp	$LN2@AuPutS
$LN3@AuPutS:
$LN1@AuPutS:

; 249  : 
; 250  : 
; 251  : }

	lea	rsp, QWORD PTR [rbp+112]
	pop	rbp
	ret	0
?AuPutS@@YAXPEAD@Z ENDP					; AuPutS
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\aucon.cpp
;	COMDAT ?AuPutC@@YAXD@Z
_TEXT	SEGMENT
font$ = 0
x$ = 8
y$ = 12
kx$ = 16
line$ = 20
mask$ = 24
offs$ = 28
bpl$ = 32
glyph$ = 40
tv190 = 112
tv137 = 112
tv77 = 112
c$ = 144
?AuPutC@@YAXD@Z PROC					; AuPutC, COMDAT

; 179  : void AuPutC(char c) {

$LN14:
	mov	BYTE PTR [rsp+8], cl
	push	rbp
	sub	rsp, 160				; 000000a0H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__A69542EC_aucon@cpp
	call	__CheckForDebuggerJustMyCode

; 180  : 	if (font_data == NULL)

	cmp	QWORD PTR ?font_data@@3PEAEEA, 0	; font_data
	jne	SHORT $LN8@AuPutC

; 181  : 		return;

	jmp	$LN1@AuPutC
$LN8@AuPutC:

; 182  : 
; 183  : 	psf2_t *font = (psf2_t*)font_data;

	mov	rax, QWORD PTR ?font_data@@3PEAEEA	; font_data
	mov	QWORD PTR font$[rbp], rax

; 184  : 	int x, y, kx = 0, line, mask, offs;

	mov	DWORD PTR kx$[rbp], 0

; 185  : 	int bpl = (font->width + 7) / 8;

	mov	rax, QWORD PTR font$[rbp]
	mov	eax, DWORD PTR [rax+28]
	add	eax, 7
	xor	edx, edx
	mov	ecx, 8
	div	ecx
	mov	DWORD PTR bpl$[rbp], eax

; 186  : 
; 187  : 
; 188  : 	unsigned char *glyph = (unsigned char*)font_data + font->headersize +

	movsx	eax, BYTE PTR c$[rbp]
	test	eax, eax
	jle	SHORT $LN10@AuPutC
	movsx	eax, BYTE PTR c$[rbp]
	mov	rcx, QWORD PTR font$[rbp]
	cmp	eax, DWORD PTR [rcx+16]
	jae	SHORT $LN10@AuPutC
	movsx	eax, BYTE PTR c$[rbp]
	mov	DWORD PTR tv77[rbp], eax
	jmp	SHORT $LN11@AuPutC
$LN10@AuPutC:
	mov	DWORD PTR tv77[rbp], 0
$LN11@AuPutC:
	mov	rax, QWORD PTR font$[rbp]
	mov	eax, DWORD PTR [rax+8]
	mov	rcx, QWORD PTR ?font_data@@3PEAEEA	; font_data
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR font$[rbp]
	mov	edx, DWORD PTR tv77[rbp]
	imul	edx, DWORD PTR [rcx+20]
	mov	ecx, edx
	mov	ecx, ecx
	add	rax, rcx
	mov	QWORD PTR glyph$[rbp], rax

; 189  : 		(c>0 && c<font->numglyph ? c : 0)*font->bytesperglyph;
; 190  : 	offs = kx * (font->width + 1);// * 4);

	mov	rax, QWORD PTR font$[rbp]
	mov	eax, DWORD PTR [rax+28]
	inc	eax
	mov	ecx, DWORD PTR kx$[rbp]
	imul	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR offs$[rbp], eax

; 191  : 	for (y = 0; y<font->height; y++) {

	mov	DWORD PTR y$[rbp], 0
	jmp	SHORT $LN4@AuPutC
$LN2@AuPutC:
	mov	eax, DWORD PTR y$[rbp]
	inc	eax
	mov	DWORD PTR y$[rbp], eax
$LN4@AuPutC:
	mov	rax, QWORD PTR font$[rbp]
	mov	eax, DWORD PTR [rax+24]
	cmp	DWORD PTR y$[rbp], eax
	jae	$LN3@AuPutC

; 192  : 		line = offs; mask = 1 << (font->width - 1);

	mov	eax, DWORD PTR offs$[rbp]
	mov	DWORD PTR line$[rbp], eax
	mov	rax, QWORD PTR font$[rbp]
	mov	eax, DWORD PTR [rax+28]
	dec	eax
	mov	ecx, 1
	mov	DWORD PTR tv190[rbp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv190[rbp]
	shl	eax, cl
	mov	DWORD PTR mask$[rbp], eax

; 193  : 		for (x = 0; x<font->width; x++) {

	mov	DWORD PTR x$[rbp], 0
	jmp	SHORT $LN7@AuPutC
$LN5@AuPutC:
	mov	eax, DWORD PTR x$[rbp]
	inc	eax
	mov	DWORD PTR x$[rbp], eax
$LN7@AuPutC:
	mov	rax, QWORD PTR font$[rbp]
	mov	eax, DWORD PTR [rax+28]
	cmp	DWORD PTR x$[rbp], eax
	jae	SHORT $LN6@AuPutC

; 194  : 			aucon->buffer[line + console_x + console_y * aucon->width] = ((int)*glyph) & (mask) ? 0xFFFFFF : 0;

	mov	rax, QWORD PTR glyph$[rbp]
	movzx	eax, BYTE PTR [rax]
	and	eax, DWORD PTR mask$[rbp]
	test	eax, eax
	je	SHORT $LN12@AuPutC
	mov	DWORD PTR tv137[rbp], 16777215		; 00ffffffH
	jmp	SHORT $LN13@AuPutC
$LN12@AuPutC:
	mov	DWORD PTR tv137[rbp], 0
$LN13@AuPutC:
	mov	eax, DWORD PTR ?console_x@@3IA		; console_x
	mov	ecx, DWORD PTR line$[rbp]
	add	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR ?aucon@@3PEAU_aucon_@@EA	; aucon
	mov	edx, DWORD PTR ?console_y@@3IA		; console_y
	imul	edx, DWORD PTR [rcx]
	mov	ecx, edx
	add	eax, ecx
	mov	eax, eax
	mov	rcx, QWORD PTR ?aucon@@3PEAU_aucon_@@EA	; aucon
	mov	rcx, QWORD PTR [rcx+8]
	mov	edx, DWORD PTR tv137[rbp]
	mov	DWORD PTR [rcx+rax*4], edx

; 195  : 			mask >>= 1; line += 1;

	mov	eax, DWORD PTR mask$[rbp]
	sar	eax, 1
	mov	DWORD PTR mask$[rbp], eax
	mov	eax, DWORD PTR line$[rbp]
	inc	eax
	mov	DWORD PTR line$[rbp], eax

; 196  : 		}

	jmp	SHORT $LN5@AuPutC
$LN6@AuPutC:

; 197  : 		aucon->buffer[line + console_x + console_y * aucon->width] = 0; glyph += bpl; offs += aucon->scanline;

	mov	eax, DWORD PTR ?console_x@@3IA		; console_x
	mov	ecx, DWORD PTR line$[rbp]
	add	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR ?aucon@@3PEAU_aucon_@@EA	; aucon
	mov	edx, DWORD PTR ?console_y@@3IA		; console_y
	imul	edx, DWORD PTR [rcx]
	mov	ecx, edx
	add	eax, ecx
	mov	eax, eax
	mov	rcx, QWORD PTR ?aucon@@3PEAU_aucon_@@EA	; aucon
	mov	rcx, QWORD PTR [rcx+8]
	mov	DWORD PTR [rcx+rax*4], 0
	movsxd	rax, DWORD PTR bpl$[rbp]
	mov	rcx, QWORD PTR glyph$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR glyph$[rbp], rax
	mov	rax, QWORD PTR ?aucon@@3PEAU_aucon_@@EA	; aucon
	movzx	eax, WORD PTR [rax+20]
	mov	ecx, DWORD PTR offs$[rbp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR offs$[rbp], eax

; 198  : 	}

	jmp	$LN2@AuPutC
$LN3@AuPutC:

; 199  : 	console_x += font->width + 1;

	mov	rax, QWORD PTR font$[rbp]
	mov	eax, DWORD PTR [rax+28]
	mov	ecx, DWORD PTR ?console_x@@3IA		; console_x
	lea	eax, DWORD PTR [rcx+rax+1]
	mov	DWORD PTR ?console_x@@3IA, eax		; console_x
$LN1@AuPutC:

; 200  : }

	lea	rsp, QWORD PTR [rbp+128]
	pop	rbp
	ret	0
?AuPutC@@YAXD@Z ENDP					; AuPutC
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\aucon.cpp
;	COMDAT ?AuConsoleIoControl@@YAHPEAU__VFS_NODE__@@HPEAX@Z
_TEXT	SEGMENT
ret$ = 0
ioctl$ = 8
width$1 = 16
height$2 = 20
bpp$3 = 24
scanline$4 = 28
pitch$5 = 32
buffaddr$6 = 40
tv65 = 112
node$ = 144
code$ = 152
args$ = 160
?AuConsoleIoControl@@YAHPEAU__VFS_NODE__@@HPEAX@Z PROC	; AuConsoleIoControl, COMDAT

; 83   : int AuConsoleIoControl(AuVFSNode* node, int code, void* args) {

$LN14:
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 160				; 000000a0H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__A69542EC_aucon@cpp
	call	__CheckForDebuggerJustMyCode

; 84   : 	int ret = 0;

	mov	DWORD PTR ret$[rbp], 0

; 85   : 	AuFileIOControl *ioctl = (AuFileIOControl*)args;

	mov	rax, QWORD PTR args$[rbp]
	mov	QWORD PTR ioctl$[rbp], rax

; 86   : 	/*if (ioctl->syscall_magic != AURORA_SYSCALL_MAGIC)
; 87   : 		return 0;*/
; 88   : 
; 89   : 	if (!aucon)

	cmp	QWORD PTR ?aucon@@3PEAU_aucon_@@EA, 0	; aucon
	jne	SHORT $LN4@AuConsoleI

; 90   : 		return 0;

	xor	eax, eax
	jmp	$LN1@AuConsoleI
$LN4@AuConsoleI:

; 91   : 	
; 92   : 	switch (code) {

	mov	eax, DWORD PTR code$[rbp]
	mov	DWORD PTR tv65[rbp], eax
	mov	eax, DWORD PTR tv65[rbp]
	sub	eax, 201				; 000000c9H
	mov	DWORD PTR tv65[rbp], eax
	cmp	DWORD PTR tv65[rbp], 8
	ja	$LN2@AuConsoleI
	movsxd	rax, DWORD PTR tv65[rbp]
	lea	rcx, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN13@AuConsoleI[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN5@AuConsoleI:

; 93   : 	case SCREEN_GETWIDTH:{
; 94   : 							 uint32_t width = aucon->width;

	mov	rax, QWORD PTR ?aucon@@3PEAU_aucon_@@EA	; aucon
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR width$1[rbp], eax

; 95   : 							 ioctl->uint_1 = width;

	mov	rax, QWORD PTR ioctl$[rbp]
	mov	ecx, DWORD PTR width$1[rbp]
	mov	DWORD PTR [rax+10], ecx

; 96   : 							 break;

	jmp	$LN2@AuConsoleI
$LN6@AuConsoleI:

; 97   : 	}
; 98   : 	case SCREEN_GETHEIGHT:{
; 99   : 							  uint32_t height = aucon->height;

	mov	rax, QWORD PTR ?aucon@@3PEAU_aucon_@@EA	; aucon
	mov	eax, DWORD PTR [rax+4]
	mov	DWORD PTR height$2[rbp], eax

; 100  : 							  ioctl->uint_1 = height;

	mov	rax, QWORD PTR ioctl$[rbp]
	mov	ecx, DWORD PTR height$2[rbp]
	mov	DWORD PTR [rax+10], ecx

; 101  : 							  break;

	jmp	SHORT $LN2@AuConsoleI
$LN7@AuConsoleI:

; 102  : 	}
; 103  : 	case SCREEN_GETBPP:{
; 104  : 						   uint32_t bpp = aucon->bpp;

	mov	rax, QWORD PTR ?aucon@@3PEAU_aucon_@@EA	; aucon
	mov	eax, DWORD PTR [rax+16]
	mov	DWORD PTR bpp$3[rbp], eax

; 105  : 						   ioctl->uint_1 = bpp;

	mov	rax, QWORD PTR ioctl$[rbp]
	mov	ecx, DWORD PTR bpp$3[rbp]
	mov	DWORD PTR [rax+10], ecx

; 106  : 						   break;

	jmp	SHORT $LN2@AuConsoleI
$LN8@AuConsoleI:

; 107  : 	}
; 108  : 	case SCREEN_GET_SCANLINE: {
; 109  : 								  uint16_t scanline = aucon->scanline;

	mov	rax, QWORD PTR ?aucon@@3PEAU_aucon_@@EA	; aucon
	movzx	eax, WORD PTR [rax+20]
	mov	WORD PTR scanline$4[rbp], ax

; 110  : 								  ioctl->ushort_1 = scanline;

	mov	rax, QWORD PTR ioctl$[rbp]
	movzx	ecx, WORD PTR scanline$4[rbp]
	mov	WORD PTR [rax+6], cx

; 111  : 								  break;

	jmp	SHORT $LN2@AuConsoleI
$LN9@AuConsoleI:

; 112  : 	}
; 113  : 	case SCREEN_GET_PITCH:{
; 114  : 							  uint32_t pitch = aucon->pitch;

	mov	rax, QWORD PTR ?aucon@@3PEAU_aucon_@@EA	; aucon
	mov	eax, DWORD PTR [rax+28]
	mov	DWORD PTR pitch$5[rbp], eax

; 115  : 							  ioctl->uint_1 = pitch;

	mov	rax, QWORD PTR ioctl$[rbp]
	mov	ecx, DWORD PTR pitch$5[rbp]
	mov	DWORD PTR [rax+10], ecx

; 116  : 							  break;

	jmp	SHORT $LN2@AuConsoleI
$LN10@AuConsoleI:

; 117  : 	}
; 118  : 	case SCREEN_GET_FB:{
; 119  : 						   uint64_t buffaddr = (uint64_t)aucon->buffer;

	mov	rax, QWORD PTR ?aucon@@3PEAU_aucon_@@EA	; aucon
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR buffaddr$6[rbp], rax

; 120  : 						   ioctl->ulong_1 = buffaddr;

	mov	rax, QWORD PTR ioctl$[rbp]
	mov	rcx, QWORD PTR buffaddr$6[rbp]
	mov	QWORD PTR [rax+18], rcx

; 121  : 						   break;

	jmp	SHORT $LN2@AuConsoleI
$LN11@AuConsoleI:

; 122  : 	}
; 123  : 
; 124  : 	case SCREEN_REG_MNGR:{
; 125  : 							 return 1;

	mov	eax, 1
	jmp	SHORT $LN1@AuConsoleI
$LN2@AuConsoleI:

; 126  : 							 break;
; 127  : 	}
; 128  : 	}
; 129  : 	return ret;

	mov	eax, DWORD PTR ret$[rbp]
$LN1@AuConsoleI:

; 130  : }

	lea	rsp, QWORD PTR [rbp+128]
	pop	rbp
	ret	0
	npad	2
$LN13@AuConsoleI:
	DD	$LN5@AuConsoleI
	DD	$LN6@AuConsoleI
	DD	$LN7@AuConsoleI
	DD	$LN2@AuConsoleI
	DD	$LN2@AuConsoleI
	DD	$LN8@AuConsoleI
	DD	$LN9@AuConsoleI
	DD	$LN11@AuConsoleI
	DD	$LN10@AuConsoleI
?AuConsoleIoControl@@YAHPEAU__VFS_NODE__@@HPEAX@Z ENDP	; AuConsoleIoControl
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\aucon.cpp
;	COMDAT ?AuConsoleEarlyEnable@@YAX_N@Z
_TEXT	SEGMENT
value$ = 80
?AuConsoleEarlyEnable@@YAX_N@Z PROC			; AuConsoleEarlyEnable, COMDAT

; 354  : void AuConsoleEarlyEnable(bool value) {

$LN3:
	mov	BYTE PTR [rsp+8], cl
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__A69542EC_aucon@cpp
	call	__CheckForDebuggerJustMyCode

; 355  : 	aucon->early_mode = value;

	mov	rax, QWORD PTR ?aucon@@3PEAU_aucon_@@EA	; aucon
	movzx	ecx, BYTE PTR value$[rbp]
	mov	BYTE PTR [rax+32], cl

; 356  : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
?AuConsoleEarlyEnable@@YAX_N@Z ENDP			; AuConsoleEarlyEnable
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\aucon.cpp
;	COMDAT AuTextOut
_TEXT	SEGMENT
args$ = 0
width$1 = 8
i$2 = 16
i$3 = 24
buffer$4 = 32
len$5 = 112
c$6 = 120
x$7 = 128
buffer$8 = 144
x$9 = 224
x$10 = 232
buf$11 = 240
buf$12 = 244
format$ = 336
AuTextOut PROC						; COMDAT

; 258  : void AuTextOut(const char* format, ...) {

$LN26:
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	push	rbp
	sub	rsp, 352				; 00000160H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__A69542EC_aucon@cpp
	call	__CheckForDebuggerJustMyCode

; 259  : 
; 260  : 	if (early_) {

	movzx	eax, BYTE PTR ?early_@@3_NA		; early_
	test	eax, eax
	je	SHORT $LN7@AuTextOut

; 261  : 		_print_func(format);

	mov	rcx, QWORD PTR format$[rbp]
	call	QWORD PTR ?_print_func@@3P6AXPEBDZZEA	; _print_func

; 262  : 		return;

	jmp	$LN1@AuTextOut
$LN7@AuTextOut:

; 263  : 	}
; 264  : 
; 265  : 
; 266  : 	_va_list_ args;
; 267  : 	va_start(args, format);

	lea	rax, QWORD PTR format$[rbp+8]
	mov	QWORD PTR args$[rbp], rax
$LN2@AuTextOut:

; 268  : 
; 269  : 	while (*format)

	mov	rax, QWORD PTR format$[rbp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	$LN3@AuTextOut

; 270  : 	{
; 271  : 		if (*format == '%')

	mov	rax, QWORD PTR format$[rbp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 37					; 00000025H
	jne	$LN8@AuTextOut

; 272  : 		{
; 273  : 			++format;

	mov	rax, QWORD PTR format$[rbp]
	inc	rax
	mov	QWORD PTR format$[rbp], rax

; 274  : 			if (*format == 'd')

	mov	rax, QWORD PTR format$[rbp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 100				; 00000064H
	jne	$LN10@AuTextOut

; 275  : 			{
; 276  : 				size_t width = 0;

	mov	QWORD PTR width$1[rbp], 0

; 277  : 				if (format[1] == '.')

	mov	eax, 1
	imul	rax, rax, 1
	mov	rcx, QWORD PTR format$[rbp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 46					; 0000002eH
	jne	SHORT $LN12@AuTextOut

; 278  : 				{
; 279  : 					for (size_t i = 2; format[i] >= '0' && format[i] <= '9'; ++i)

	mov	QWORD PTR i$2[rbp], 2
	jmp	SHORT $LN6@AuTextOut
$LN4@AuTextOut:
	mov	rax, QWORD PTR i$2[rbp]
	inc	rax
	mov	QWORD PTR i$2[rbp], rax
$LN6@AuTextOut:
	mov	rax, QWORD PTR i$2[rbp]
	mov	rcx, QWORD PTR format$[rbp]
	add	rcx, rax
	mov	rax, rcx
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 48					; 00000030H
	jl	SHORT $LN5@AuTextOut
	mov	rax, QWORD PTR i$2[rbp]
	mov	rcx, QWORD PTR format$[rbp]
	add	rcx, rax
	mov	rax, rcx
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 57					; 00000039H
	jg	SHORT $LN5@AuTextOut

; 280  : 					{
; 281  : 						width *= 10;

	imul	rax, QWORD PTR width$1[rbp], 10
	mov	QWORD PTR width$1[rbp], rax

; 282  : 						width += format[i] - '0';

	mov	rax, QWORD PTR i$2[rbp]
	mov	rcx, QWORD PTR format$[rbp]
	add	rcx, rax
	mov	rax, rcx
	movsx	eax, BYTE PTR [rax]
	sub	eax, 48					; 00000030H
	cdqe
	mov	rcx, QWORD PTR width$1[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR width$1[rbp], rax

; 283  : 					}

	jmp	SHORT $LN4@AuTextOut
$LN5@AuTextOut:
$LN12@AuTextOut:

; 284  : 				}
; 285  : 				size_t i = va_arg(args, size_t);

	mov	rax, QWORD PTR args$[rbp]
	add	rax, 8
	mov	QWORD PTR args$[rbp], rax
	mov	rax, QWORD PTR args$[rbp]
	mov	rax, QWORD PTR [rax-8]
	mov	QWORD PTR i$3[rbp], rax

; 286  : 				char buffer[sizeof(size_t)* 8 + 1];
; 287  : 				//	size_t len
; 288  : 				if ((int)i < 0) {

	cmp	DWORD PTR i$3[rbp], 0
	jge	SHORT $LN13@AuTextOut

; 289  : 					AuPutS("-");

	lea	rcx, OFFSET FLAT:??_C@_01JOAMLHOP@?9@
	call	?AuPutS@@YAXPEAD@Z			; AuPutS

; 290  : 					i = ((int)i * -1);

	imul	eax, DWORD PTR i$3[rbp], -1
	cdqe
	mov	QWORD PTR i$3[rbp], rax

; 291  : 					sztoa(i, buffer, 10);

	mov	r8d, 10
	lea	rdx, QWORD PTR buffer$4[rbp]
	mov	rcx, QWORD PTR i$3[rbp]
	call	?sztoa@@YAPEAD_KPEADH@Z			; sztoa

; 292  : 				}

	jmp	SHORT $LN14@AuTextOut
$LN13@AuTextOut:

; 293  : 				else {
; 294  : 					sztoa(i, buffer, 10);

	mov	r8d, 10
	lea	rdx, QWORD PTR buffer$4[rbp]
	mov	rcx, QWORD PTR i$3[rbp]
	call	?sztoa@@YAPEAD_KPEADH@Z			; sztoa

; 295  : 					size_t len = strlen(buffer);

	lea	rcx, QWORD PTR buffer$4[rbp]
	call	strlen
	mov	QWORD PTR len$5[rbp], rax
$LN14@AuTextOut:

; 296  : 				}
; 297  : 				/*	while (len++ < width)
; 298  : 				puts("0");*/
; 299  : 				AuPutS(buffer);

	lea	rcx, QWORD PTR buffer$4[rbp]
	call	?AuPutS@@YAXPEAD@Z			; AuPutS

; 300  : 			}

	jmp	$LN11@AuTextOut
$LN10@AuTextOut:

; 301  : 			else if (*format == 'c')

	mov	rax, QWORD PTR format$[rbp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 99					; 00000063H
	jne	SHORT $LN15@AuTextOut

; 302  : 			{
; 303  : 				char c = va_arg(args, char);

	mov	rax, QWORD PTR args$[rbp]
	add	rax, 8
	mov	QWORD PTR args$[rbp], rax
	mov	rax, QWORD PTR args$[rbp]
	movzx	eax, BYTE PTR [rax-8]
	mov	BYTE PTR c$6[rbp], al

; 304  : 				//char buffer[sizeof(size_t) * 8 + 1];
; 305  : 				//sztoa(c, buffer, 10);
; 306  : 				//puts(buffer);
; 307  : 				AuPutC(c);

	movzx	ecx, BYTE PTR c$6[rbp]
	call	?AuPutC@@YAXD@Z				; AuPutC

; 308  : 			}

	jmp	$LN16@AuTextOut
$LN15@AuTextOut:

; 309  : 			else if (*format == 'x')

	mov	rax, QWORD PTR format$[rbp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 120				; 00000078H
	jne	SHORT $LN17@AuTextOut

; 310  : 			{
; 311  : 				size_t x = va_arg(args, size_t);

	mov	rax, QWORD PTR args$[rbp]
	add	rax, 8
	mov	QWORD PTR args$[rbp], rax
	mov	rax, QWORD PTR args$[rbp]
	mov	rax, QWORD PTR [rax-8]
	mov	QWORD PTR x$7[rbp], rax

; 312  : 				char buffer[sizeof(size_t)* 8 + 1];
; 313  : 				sztoa(x, buffer, 16);

	mov	r8d, 16
	lea	rdx, QWORD PTR buffer$8[rbp]
	mov	rcx, QWORD PTR x$7[rbp]
	call	?sztoa@@YAPEAD_KPEADH@Z			; sztoa

; 314  : 				//puts("0x");
; 315  : 				AuPutS(buffer);

	lea	rcx, QWORD PTR buffer$8[rbp]
	call	?AuPutS@@YAXPEAD@Z			; AuPutS

; 316  : 			}

	jmp	$LN18@AuTextOut
$LN17@AuTextOut:

; 317  : 			else if (*format == 's')

	mov	rax, QWORD PTR format$[rbp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 115				; 00000073H
	jne	SHORT $LN19@AuTextOut

; 318  : 			{
; 319  : 				char* x = va_arg(args, char*);

	mov	rax, QWORD PTR args$[rbp]
	add	rax, 8
	mov	QWORD PTR args$[rbp], rax
	mov	rax, QWORD PTR args$[rbp]
	mov	rax, QWORD PTR [rax-8]
	mov	QWORD PTR x$9[rbp], rax

; 320  : 				AuPutS(x);

	mov	rcx, QWORD PTR x$9[rbp]
	call	?AuPutS@@YAXPEAD@Z			; AuPutS

; 321  : 			}

	jmp	$LN20@AuTextOut
$LN19@AuTextOut:

; 322  : 			else if (*format == 'f')

	mov	rax, QWORD PTR format$[rbp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 102				; 00000066H
	jne	SHORT $LN21@AuTextOut

; 323  : 			{
; 324  : 				double x = va_arg(args, double);

	mov	rax, QWORD PTR args$[rbp]
	add	rax, 8
	mov	QWORD PTR args$[rbp], rax
	mov	rax, QWORD PTR args$[rbp]
	movsd	xmm0, QWORD PTR [rax-8]
	movsd	QWORD PTR x$10[rbp], xmm0

; 325  : 				AuPutS(ftoa(x, 2));

	cvtsd2ss xmm0, QWORD PTR x$10[rbp]
	mov	dl, 2
	call	?ftoa@@YAPEADME@Z			; ftoa
	mov	rcx, rax
	call	?AuPutS@@YAXPEAD@Z			; AuPutS

; 326  : 			}

	jmp	SHORT $LN22@AuTextOut
$LN21@AuTextOut:

; 327  : 			else if (*format == '%')

	mov	rax, QWORD PTR format$[rbp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 37					; 00000025H
	jne	SHORT $LN23@AuTextOut

; 328  : 			{
; 329  : 				AuPutS(".");

	lea	rcx, OFFSET FLAT:??_C@_01LFCBOECM@?4@
	call	?AuPutS@@YAXPEAD@Z			; AuPutS

; 330  : 			}

	jmp	SHORT $LN24@AuTextOut
$LN23@AuTextOut:

; 331  : 			else
; 332  : 			{
; 333  : 				char buf[3];
; 334  : 				buf[0] = '%'; buf[1] = *format; buf[2] = '\0';

	mov	eax, 1
	imul	rax, rax, 0
	mov	BYTE PTR buf$11[rbp+rax], 37		; 00000025H
	mov	eax, 1
	imul	rax, rax, 1
	mov	rcx, QWORD PTR format$[rbp]
	movzx	ecx, BYTE PTR [rcx]
	mov	BYTE PTR buf$11[rbp+rax], cl
	mov	eax, 1
	imul	rax, rax, 2
	mov	BYTE PTR buf$11[rbp+rax], 0

; 335  : 				AuPutS(buf);

	lea	rcx, QWORD PTR buf$11[rbp]
	call	?AuPutS@@YAXPEAD@Z			; AuPutS
$LN24@AuTextOut:
$LN22@AuTextOut:
$LN20@AuTextOut:
$LN18@AuTextOut:
$LN16@AuTextOut:
$LN11@AuTextOut:

; 336  : 			}
; 337  : 		}

	jmp	SHORT $LN9@AuTextOut
$LN8@AuTextOut:

; 338  : 		else
; 339  : 		{
; 340  : 			char buf[2];
; 341  : 			buf[0] = *format; buf[1] = '\0';

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR format$[rbp]
	movzx	ecx, BYTE PTR [rcx]
	mov	BYTE PTR buf$12[rbp+rax], cl
	mov	eax, 1
	imul	rax, rax, 1
	mov	BYTE PTR buf$12[rbp+rax], 0

; 342  : 			AuPutS(buf);

	lea	rcx, QWORD PTR buf$12[rbp]
	call	?AuPutS@@YAXPEAD@Z			; AuPutS
$LN9@AuTextOut:

; 343  : 		}
; 344  : 		++format;

	mov	rax, QWORD PTR format$[rbp]
	inc	rax
	mov	QWORD PTR format$[rbp], rax

; 345  : 	}

	jmp	$LN2@AuTextOut
$LN3@AuTextOut:
$LN1@AuTextOut:

; 346  : 	va_end(args);
; 347  : }

	lea	rsp, QWORD PTR [rbp+320]
	pop	rbp
	ret	0
AuTextOut ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\aucon.cpp
;	COMDAT ?AuConsolePostInitialise@@YAXPEAU_KERNEL_BOOT_INFO_@@@Z
_TEXT	SEGMENT
font_$ = 0
i$1 = 8
w$2 = 12
h$3 = 16
fsys$ = 24
file$ = 32
tv80 = 104
info$ = 128
?AuConsolePostInitialise@@YAXPEAU_KERNEL_BOOT_INFO_@@@Z PROC ; AuConsolePostInitialise, COMDAT

; 136  : void AuConsolePostInitialise(PKERNEL_BOOT_INFO info) {

$LN12:
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 144				; 00000090H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__A69542EC_aucon@cpp
	call	__CheckForDebuggerJustMyCode

; 137  : 
; 138  : 	uint8_t* font_ = (uint8_t*)P2V((uint64_t)AuPmmngrAlloc());

	call	AuPmmngrAlloc
	mov	rcx, rax
	call	P2V
	mov	QWORD PTR font_$[rbp], rax

; 139  : 	memset(font_, 0, 4096);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR font_$[rbp]
	call	memset

; 140  : 	memcpy(font_, info->psf_font_data, 4096);

	mov	r8d, 4096				; 00001000H
	mov	rax, QWORD PTR info$[rbp]
	mov	rdx, QWORD PTR [rax+98]
	mov	rcx, QWORD PTR font_$[rbp]
	call	memcpy

; 141  : 	font_data = font_;

	mov	rax, QWORD PTR font_$[rbp]
	mov	QWORD PTR ?font_data@@3PEAEEA, rax	; font_data

; 142  : 
; 143  : 	aucon = (AuConsole*)kmalloc(sizeof(AuConsole));

	mov	ecx, 40					; 00000028H
	call	kmalloc
	mov	QWORD PTR ?aucon@@3PEAU_aucon_@@EA, rax	; aucon

; 144  : 	memset(aucon, 0, sizeof(AuConsole));

	mov	r8d, 40					; 00000028H
	xor	edx, edx
	mov	rcx, QWORD PTR ?aucon@@3PEAU_aucon_@@EA	; aucon
	call	memset

; 145  : 
; 146  : 	for (int i = 0; i < info->fb_size / PAGE_SIZE; i++)

	mov	DWORD PTR i$1[rbp], 0
	jmp	SHORT $LN4@AuConsoleP
$LN2@AuConsoleP:
	mov	eax, DWORD PTR i$1[rbp]
	inc	eax
	mov	DWORD PTR i$1[rbp], eax
$LN4@AuConsoleP:
	movsxd	rax, DWORD PTR i$1[rbp]
	mov	QWORD PTR tv80[rbp], rax
	xor	edx, edx
	mov	rcx, QWORD PTR info$[rbp]
	mov	rax, QWORD PTR [rcx+52]
	mov	ecx, 4096				; 00001000H
	div	rcx
	mov	rcx, QWORD PTR tv80[rbp]
	cmp	rcx, rax
	jae	SHORT $LN3@AuConsoleP

; 147  : 		AuMapPage((uint64_t)info->graphics_framebuffer + static_cast<uint64_t>(i) * PAGE_SIZE, 

	movsxd	rax, DWORD PTR i$1[rbp]
	imul	rax, rax, 4096				; 00001000H
	mov	rcx, 52776556036096			; 00002fffffe00000H
	sub	rax, rcx
	movsxd	rcx, DWORD PTR i$1[rbp]
	imul	rcx, rcx, 4096				; 00001000H
	mov	rdx, QWORD PTR info$[rbp]
	add	rcx, QWORD PTR [rdx+44]
	mov	r8b, 4
	mov	rdx, rax
	call	AuMapPage
	jmp	SHORT $LN2@AuConsoleP
$LN3@AuConsoleP:

; 148  : 			0xFFFFD00000200000 + static_cast<uint64_t>(i) * 4096, X86_64_PAGING_USER);
; 149  : 	early_ = false;

	mov	BYTE PTR ?early_@@3_NA, 0		; early_

; 150  : 	aucon->buffer = (uint32_t*)0xFFFFD00000200000;

	mov	rax, QWORD PTR ?aucon@@3PEAU_aucon_@@EA	; aucon
	mov	rcx, -52776556036096			; ffffd00000200000H
	mov	QWORD PTR [rax+8], rcx

; 151  : 	aucon->width = info->X_Resolution;

	mov	rax, QWORD PTR info$[rbp]
	movzx	eax, WORD PTR [rax+60]
	mov	rcx, QWORD PTR ?aucon@@3PEAU_aucon_@@EA	; aucon
	mov	DWORD PTR [rcx], eax

; 152  : 	aucon->height = info->Y_Resolution;

	mov	rax, QWORD PTR info$[rbp]
	movzx	eax, WORD PTR [rax+62]
	mov	rcx, QWORD PTR ?aucon@@3PEAU_aucon_@@EA	; aucon
	mov	DWORD PTR [rcx+4], eax

; 153  : 	aucon->bpp = 32;

	mov	rax, QWORD PTR ?aucon@@3PEAU_aucon_@@EA	; aucon
	mov	DWORD PTR [rax+16], 32			; 00000020H

; 154  : 	aucon->scanline = info->pixels_per_line;

	mov	rax, QWORD PTR ?aucon@@3PEAU_aucon_@@EA	; aucon
	mov	rcx, QWORD PTR info$[rbp]
	movzx	ecx, WORD PTR [rcx+64]
	mov	WORD PTR [rax+20], cx

; 155  : 	aucon->pitch = 4 * info->pixels_per_line;

	mov	rax, QWORD PTR info$[rbp]
	movzx	eax, WORD PTR [rax+64]
	shl	eax, 2
	mov	rcx, QWORD PTR ?aucon@@3PEAU_aucon_@@EA	; aucon
	mov	DWORD PTR [rcx+28], eax

; 156  : 	aucon->size = info->fb_size;

	mov	rax, QWORD PTR ?aucon@@3PEAU_aucon_@@EA	; aucon
	mov	rcx, QWORD PTR info$[rbp]
	mov	ecx, DWORD PTR [rcx+52]
	mov	DWORD PTR [rax+24], ecx

; 157  : 	aucon->early_mode = false;

	mov	rax, QWORD PTR ?aucon@@3PEAU_aucon_@@EA	; aucon
	mov	BYTE PTR [rax+32], 0

; 158  : 	console_x = console_y = 0;

	mov	DWORD PTR ?console_y@@3IA, 0		; console_y
	mov	eax, DWORD PTR ?console_y@@3IA		; console_y
	mov	DWORD PTR ?console_x@@3IA, eax		; console_x

; 159  : 
; 160  : 	for (int w = 0; w < info->X_Resolution; w++) {

	mov	DWORD PTR w$2[rbp], 0
	jmp	SHORT $LN7@AuConsoleP
$LN5@AuConsoleP:
	mov	eax, DWORD PTR w$2[rbp]
	inc	eax
	mov	DWORD PTR w$2[rbp], eax
$LN7@AuConsoleP:
	mov	rax, QWORD PTR info$[rbp]
	movzx	eax, WORD PTR [rax+60]
	cmp	DWORD PTR w$2[rbp], eax
	jge	SHORT $LN6@AuConsoleP

; 161  : 		for (int h = 0; h < info->Y_Resolution; h++) {

	mov	DWORD PTR h$3[rbp], 0
	jmp	SHORT $LN10@AuConsoleP
$LN8@AuConsoleP:
	mov	eax, DWORD PTR h$3[rbp]
	inc	eax
	mov	DWORD PTR h$3[rbp], eax
$LN10@AuConsoleP:
	mov	rax, QWORD PTR info$[rbp]
	movzx	eax, WORD PTR [rax+62]
	cmp	DWORD PTR h$3[rbp], eax
	jge	SHORT $LN9@AuConsoleP

; 162  : 			aucon->buffer[w + h * info->X_Resolution] = 0x00000000;

	mov	rax, QWORD PTR info$[rbp]
	movzx	eax, WORD PTR [rax+60]
	mov	ecx, DWORD PTR h$3[rbp]
	imul	ecx, eax
	mov	eax, ecx
	mov	ecx, DWORD PTR w$2[rbp]
	add	ecx, eax
	mov	eax, ecx
	cdqe
	mov	rcx, QWORD PTR ?aucon@@3PEAU_aucon_@@EA	; aucon
	mov	rcx, QWORD PTR [rcx+8]
	mov	DWORD PTR [rcx+rax*4], 0

; 163  : 		}

	jmp	SHORT $LN8@AuConsoleP
$LN9@AuConsoleP:

; 164  : 	}

	jmp	SHORT $LN5@AuConsoleP
$LN6@AuConsoleP:

; 165  : 
; 166  : 	AuVFSNode* fsys = AuVFSFind("/dev");

	lea	rcx, OFFSET FLAT:??_C@_04PJHBAHNI@?1dev@
	call	AuVFSFind
	mov	QWORD PTR fsys$[rbp], rax

; 167  : 	AuVFSNode* file = (AuVFSNode*)kmalloc(sizeof(AuVFSNode));

	mov	ecx, 178				; 000000b2H
	call	kmalloc
	mov	QWORD PTR file$[rbp], rax

; 168  : 	memset(file, 0, sizeof(AuVFSNode));

	mov	r8d, 178				; 000000b2H
	xor	edx, edx
	mov	rcx, QWORD PTR file$[rbp]
	call	memset

; 169  : 	strcpy(file->filename, "graph");

	mov	rax, QWORD PTR file$[rbp]
	lea	rdx, OFFSET FLAT:??_C@_05KCJBMLII@graph@
	mov	rcx, rax
	call	strcpy

; 170  : 	file->flags = FS_FLAG_DEVICE;

	mov	eax, 8
	mov	rcx, QWORD PTR file$[rbp]
	mov	WORD PTR [rcx+61], ax

; 171  : 	file->device = fsys;

	mov	rax, QWORD PTR file$[rbp]
	mov	rcx, QWORD PTR fsys$[rbp]
	mov	QWORD PTR [rax+64], rcx

; 172  : 	file->read = 0;

	mov	rax, QWORD PTR file$[rbp]
	mov	QWORD PTR [rax+90], 0

; 173  : 	file->write = 0;

	mov	rax, QWORD PTR file$[rbp]
	mov	QWORD PTR [rax+98], 0

; 174  : 	file->iocontrol = AuConsoleIoControl;

	mov	rax, QWORD PTR file$[rbp]
	lea	rcx, OFFSET FLAT:?AuConsoleIoControl@@YAHPEAU__VFS_NODE__@@HPEAX@Z ; AuConsoleIoControl
	mov	QWORD PTR [rax+170], rcx

; 175  : 	AuDevFSAddFile(fsys, "/", file);

	mov	r8, QWORD PTR file$[rbp]
	lea	rdx, OFFSET FLAT:??_C@_01KMDKNFGN@?1@
	mov	rcx, QWORD PTR fsys$[rbp]
	call	AuDevFSAddFile

; 176  : }

	lea	rsp, QWORD PTR [rbp+112]
	pop	rbp
	ret	0
?AuConsolePostInitialise@@YAXPEAU_KERNEL_BOOT_INFO_@@@Z ENDP ; AuConsolePostInitialise
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\aucon.cpp
;	COMDAT ?AuConsoleInitialize@@YAXPEAU_KERNEL_BOOT_INFO_@@_N@Z
_TEXT	SEGMENT
info$ = 80
early$ = 88
?AuConsoleInitialize@@YAXPEAU_KERNEL_BOOT_INFO_@@_N@Z PROC ; AuConsoleInitialize, COMDAT

; 72   : void AuConsoleInitialize(PKERNEL_BOOT_INFO info, bool early) {

$LN4:
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 96					; 00000060H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__A69542EC_aucon@cpp
	call	__CheckForDebuggerJustMyCode

; 73   : 	if (early) {

	movzx	eax, BYTE PTR early$[rbp]
	test	eax, eax
	je	SHORT $LN2@AuConsoleI

; 74   : 		_print_func = info->printf_gui;

	mov	rax, QWORD PTR info$[rbp]
	mov	rax, QWORD PTR [rax+106]
	mov	QWORD PTR ?_print_func@@3P6AXPEBDZZEA, rax ; _print_func

; 75   : 		early_ = early;

	movzx	eax, BYTE PTR early$[rbp]
	mov	BYTE PTR ?early_@@3_NA, al		; early_
$LN2@AuConsoleI:

; 76   : 	}
; 77   : 	aucon = NULL;

	mov	QWORD PTR ?aucon@@3PEAU_aucon_@@EA, 0	; aucon

; 78   : }

	lea	rsp, QWORD PTR [rbp+64]
	pop	rbp
	ret	0
?AuConsoleInitialize@@YAXPEAU_KERNEL_BOOT_INFO_@@_N@Z ENDP ; AuConsoleInitialize
_TEXT	ENDS
END
