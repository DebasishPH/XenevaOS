; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30154.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

msvcjmc	SEGMENT
__8431CB8A_list@cpp DB 01H
msvcjmc	ENDS
PUBLIC	initialize_list
PUBLIC	list_add
PUBLIC	list_remove
PUBLIC	list_get_at
PUBLIC	__JustMyCode_Default
EXTRN	kmalloc:PROC
EXTRN	kfree:PROC
EXTRN	__CheckForDebuggerJustMyCode:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$initialize_list DD imagerel $LN3
	DD	imagerel $LN3+69
	DD	imagerel $unwind$initialize_list
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$list_add DD imagerel $LN7
	DD	imagerel $LN7+184
	DD	imagerel $unwind$list_add
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$list_remove DD imagerel $LN12
	DD	imagerel $LN12+253
	DD	imagerel $unwind$list_remove
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$list_get_at DD imagerel $LN10
	DD	imagerel $LN10+154
	DD	imagerel $unwind$list_get_at
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$list_get_at DD 025031601H
	DD	0f2112316H
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$list_remove DD 025031601H
	DD	0f2112316H
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$list_add DD 025031401H
	DD	0d20f2314H
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$initialize_list DD 025030b01H
	DD	0d206230bH
	DD	05002H
xdata	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\list.cpp
;	COMDAT list_get_at
_TEXT	SEGMENT
current_node$ = 0
current_index$1 = 8
tv75 = 80
list$ = 112
index$ = 120
list_get_at PROC					; COMDAT

; 66   : void * list_get_at(list_t* list, unsigned int index) {

$LN10:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 128				; 00000080H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__8431CB8A_list@cpp
	call	__CheckForDebuggerJustMyCode

; 67   : 
; 68   : 	if (list->pointer == 0 || index >= list->pointer)

	mov	rax, QWORD PTR list$[rbp]
	cmp	DWORD PTR [rax], 0
	je	SHORT $LN6@list_get_a
	mov	rax, QWORD PTR list$[rbp]
	mov	eax, DWORD PTR [rax]
	cmp	DWORD PTR index$[rbp], eax
	jb	SHORT $LN5@list_get_a
$LN6@list_get_a:

; 69   : 		return nullptr;

	xor	eax, eax
	jmp	SHORT $LN1@list_get_a
$LN5@list_get_a:

; 70   : 
; 71   : 	dataentry * current_node = list->entry_current;

	mov	rax, QWORD PTR list$[rbp]
	mov	rax, QWORD PTR [rax+4]
	mov	QWORD PTR current_node$[rbp], rax

; 72   : 
; 73   : 	for (unsigned int current_index = 0; (current_index < index) && current_node; current_index++)

	mov	DWORD PTR current_index$1[rbp], 0
	jmp	SHORT $LN4@list_get_a
$LN2@list_get_a:
	mov	eax, DWORD PTR current_index$1[rbp]
	inc	eax
	mov	DWORD PTR current_index$1[rbp], eax
$LN4@list_get_a:
	mov	eax, DWORD PTR index$[rbp]
	cmp	DWORD PTR current_index$1[rbp], eax
	jae	SHORT $LN3@list_get_a
	cmp	QWORD PTR current_node$[rbp], 0
	je	SHORT $LN3@list_get_a

; 74   : 		current_node = current_node->next;

	mov	rax, QWORD PTR current_node$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR current_node$[rbp], rax
	jmp	SHORT $LN2@list_get_a
$LN3@list_get_a:

; 75   : 
; 76   : 	return current_node ? current_node->data : nullptr;

	cmp	QWORD PTR current_node$[rbp], 0
	je	SHORT $LN8@list_get_a
	mov	rax, QWORD PTR current_node$[rbp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR tv75[rbp], rax
	jmp	SHORT $LN9@list_get_a
$LN8@list_get_a:
	mov	QWORD PTR tv75[rbp], 0
$LN9@list_get_a:
	mov	rax, QWORD PTR tv75[rbp]
$LN1@list_get_a:

; 77   : }

	lea	rsp, QWORD PTR [rbp+96]
	pop	rbp
	ret	0
list_get_at ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\list.cpp
;	COMDAT list_remove
_TEXT	SEGMENT
payload$ = 0
current_node$ = 8
current_index$1 = 16
list$ = 112
index$ = 120
list_remove PROC					; COMDAT

; 79   : void* list_remove(list_t* list, unsigned int index) {

$LN12:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 128				; 00000080H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__8431CB8A_list@cpp
	call	__CheckForDebuggerJustMyCode

; 80   : 
; 81   : 	void* payload;
; 82   : 
; 83   : 	if (list->pointer == 0 || index >= list->pointer)

	mov	rax, QWORD PTR list$[rbp]
	cmp	DWORD PTR [rax], 0
	je	SHORT $LN6@list_remov
	mov	rax, QWORD PTR list$[rbp]
	mov	eax, DWORD PTR [rax]
	cmp	DWORD PTR index$[rbp], eax
	jb	SHORT $LN5@list_remov
$LN6@list_remov:

; 84   : 		return nullptr;

	xor	eax, eax
	jmp	$LN1@list_remov
$LN5@list_remov:

; 85   : 
; 86   : 	dataentry* current_node = list->entry_current;

	mov	rax, QWORD PTR list$[rbp]
	mov	rax, QWORD PTR [rax+4]
	mov	QWORD PTR current_node$[rbp], rax

; 87   : 
; 88   : 	for (unsigned int current_index = 0; (current_index < index) && current_node; current_index++)

	mov	DWORD PTR current_index$1[rbp], 0
	jmp	SHORT $LN4@list_remov
$LN2@list_remov:
	mov	eax, DWORD PTR current_index$1[rbp]
	inc	eax
	mov	DWORD PTR current_index$1[rbp], eax
$LN4@list_remov:
	mov	eax, DWORD PTR index$[rbp]
	cmp	DWORD PTR current_index$1[rbp], eax
	jae	SHORT $LN3@list_remov
	cmp	QWORD PTR current_node$[rbp], 0
	je	SHORT $LN3@list_remov

; 89   : 		current_node = current_node->next;

	mov	rax, QWORD PTR current_node$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR current_node$[rbp], rax
	jmp	SHORT $LN2@list_remov
$LN3@list_remov:

; 90   : 
; 91   : 	if (!current_node)

	cmp	QWORD PTR current_node$[rbp], 0
	jne	SHORT $LN7@list_remov

; 92   : 		return nullptr;

	xor	eax, eax
	jmp	SHORT $LN1@list_remov
$LN7@list_remov:

; 93   : 	payload = current_node->data;

	mov	rax, QWORD PTR current_node$[rbp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR payload$[rbp], rax

; 94   : 
; 95   : 	if (current_node->prev)

	mov	rax, QWORD PTR current_node$[rbp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN8@list_remov

; 96   : 		current_node->prev->next = current_node->next;

	mov	rax, QWORD PTR current_node$[rbp]
	mov	rax, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR current_node$[rbp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax], rcx
$LN8@list_remov:

; 97   : 
; 98   : 	if (current_node->next)

	mov	rax, QWORD PTR current_node$[rbp]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN9@list_remov

; 99   : 		current_node->next->prev = current_node->prev;

	mov	rax, QWORD PTR current_node$[rbp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR current_node$[rbp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	QWORD PTR [rax+8], rcx
$LN9@list_remov:

; 100  : 
; 101  : 	if (index == 0)

	cmp	DWORD PTR index$[rbp], 0
	jne	SHORT $LN10@list_remov

; 102  : 		list->entry_current = current_node->next;

	mov	rax, QWORD PTR list$[rbp]
	mov	rcx, QWORD PTR current_node$[rbp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax+4], rcx
$LN10@list_remov:

; 103  : 
; 104  : 	kfree(current_node);

	mov	rcx, QWORD PTR current_node$[rbp]
	call	kfree

; 105  : 
; 106  : 	list->pointer--;

	mov	rax, QWORD PTR list$[rbp]
	mov	eax, DWORD PTR [rax]
	dec	eax
	mov	rcx, QWORD PTR list$[rbp]
	mov	DWORD PTR [rcx], eax

; 107  : 
; 108  : 	return payload;

	mov	rax, QWORD PTR payload$[rbp]
$LN1@list_remov:

; 109  : }

	lea	rsp, QWORD PTR [rbp+96]
	pop	rbp
	ret	0
list_remove ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\list.cpp
;	COMDAT list_add
_TEXT	SEGMENT
current_data$ = 0
current_entry$1 = 8
list$ = 96
data$ = 104
list_add PROC						; COMDAT

; 43   : void list_add(list_t* list, void* data) {

$LN7:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__8431CB8A_list@cpp
	call	__CheckForDebuggerJustMyCode

; 44   : 	dataentry *current_data = (dataentry*)kmalloc(sizeof(dataentry));

	mov	ecx, 24
	call	kmalloc
	mov	QWORD PTR current_data$[rbp], rax

; 45   : 	current_data->next = nullptr;

	mov	rax, QWORD PTR current_data$[rbp]
	mov	QWORD PTR [rax], 0

; 46   : 	current_data->prev = nullptr;

	mov	rax, QWORD PTR current_data$[rbp]
	mov	QWORD PTR [rax+8], 0

; 47   : 	current_data->data = data;

	mov	rax, QWORD PTR current_data$[rbp]
	mov	rcx, QWORD PTR data$[rbp]
	mov	QWORD PTR [rax+16], rcx

; 48   : 
; 49   : 	
; 50   : 
; 51   : 	if (!list->entry_current) {

	mov	rax, QWORD PTR list$[rbp]
	cmp	QWORD PTR [rax+4], 0
	jne	SHORT $LN4@list_add

; 52   : 		list->entry_current = current_data;

	mov	rax, QWORD PTR list$[rbp]
	mov	rcx, QWORD PTR current_data$[rbp]
	mov	QWORD PTR [rax+4], rcx

; 53   : 	}

	jmp	SHORT $LN5@list_add
$LN4@list_add:

; 54   : 	else {
; 55   : 		dataentry * current_entry = list->entry_current;

	mov	rax, QWORD PTR list$[rbp]
	mov	rax, QWORD PTR [rax+4]
	mov	QWORD PTR current_entry$1[rbp], rax
$LN2@list_add:

; 56   : 		while (current_entry->next) {

	mov	rax, QWORD PTR current_entry$1[rbp]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN3@list_add

; 57   : 			current_entry = current_entry->next;

	mov	rax, QWORD PTR current_entry$1[rbp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR current_entry$1[rbp], rax

; 58   : 		}

	jmp	SHORT $LN2@list_add
$LN3@list_add:

; 59   : 		current_entry->next = current_data;

	mov	rax, QWORD PTR current_entry$1[rbp]
	mov	rcx, QWORD PTR current_data$[rbp]
	mov	QWORD PTR [rax], rcx

; 60   : 		current_data->prev = current_entry;

	mov	rax, QWORD PTR current_data$[rbp]
	mov	rcx, QWORD PTR current_entry$1[rbp]
	mov	QWORD PTR [rax+8], rcx
$LN5@list_add:

; 61   : 	}
; 62   : 
; 63   : 	list->pointer++;

	mov	rax, QWORD PTR list$[rbp]
	mov	eax, DWORD PTR [rax]
	inc	eax
	mov	rcx, QWORD PTR list$[rbp]
	mov	DWORD PTR [rcx], eax

; 64   : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
list_add ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File E:\Xeneva Project\Aurora\Kernel\list.cpp
;	COMDAT initialize_list
_TEXT	SEGMENT
list$ = 0
initialize_list PROC					; COMDAT

; 35   : list_t* initialize_list() {

$LN3:
	push	rbp
	sub	rsp, 112				; 00000070H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__8431CB8A_list@cpp
	call	__CheckForDebuggerJustMyCode

; 36   : 	list_t *list = (list_t*)kmalloc(sizeof(list_t));

	mov	ecx, 12
	call	kmalloc
	mov	QWORD PTR list$[rbp], rax

; 37   : 	list->entry_current = nullptr;

	mov	rax, QWORD PTR list$[rbp]
	mov	QWORD PTR [rax+4], 0

; 38   : 	list->pointer = 0;

	mov	rax, QWORD PTR list$[rbp]
	mov	DWORD PTR [rax], 0

; 39   : 	return list;

	mov	rax, QWORD PTR list$[rbp]

; 40   : }

	lea	rsp, QWORD PTR [rbp+80]
	pop	rbp
	ret	0
initialize_list ENDP
_TEXT	ENDS
END
